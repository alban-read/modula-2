/* "@(#)Generic.c Sep  1  9:37:55 2019" */
/* Generated by XDS Modula-2 to ANSI C v4.20 translator */

#define X2C_int32
#define X2C_index32
#ifndef X2C_H_
#include "X2C.h"
#endif
#define Generic_C_
#include "Windows.h"
#include "WinUser.h"
#include "WinDef.h"
#include "CommCtrl.h"
#ifndef WholeStr_H_
#include "WholeStr.h"
#endif
#ifndef Strings_H_
#include "Strings.h"
#endif

#define Generic_AppName "Generic"

#define Generic_Title "Generic Application 2"

#define Generic_IDM_NEW 100

#define Generic_IDM_OPEN 101

#define Generic_IDM_SAVE 102

#define Generic_IDM_SAVEAS 103

#define Generic_IDM_PRINT 104

#define Generic_IDM_PRINTSETUP 105

#define Generic_IDM_EXIT 106

#define Generic_IDM_UNDO 200

#define Generic_IDM_CUT 201

#define Generic_IDM_COPY 202

#define Generic_IDM_PASTE 203

#define Generic_IDM_LINK 204

#define Generic_IDM_LINKS 205

#define Generic_IDC_MAIN_STATUS 601

#define Generic_IDC_MAIN_TOOL 602

#define Generic_IDSTR_FILTER 1000

#define Generic_LineLength 132

#define Generic_ScreenLines 32

#define Generic_CharWidth 7

struct cursor;


struct cursor {
   long x;
   long y;
};

typedef char line[132];

typedef line lines[32];

static HGDIOBJ PlainFont;

static HGDIOBJ BoldFont;

static lines Screen;

static HWND hStatus;

static long iStatusHeight;

static HWND hTool;

static struct cursor csr;


static void EnableMenuItems(HWND hWnd)
{
   HMENU hMenu;
   hMenu = GetMenu(hWnd);
   EnableMenuItem(hMenu, 100u, 0u);
   EnableMenuItem(hMenu, 101u, 0u);
   EnableMenuItem(hMenu, 102u, 0u);
   EnableMenuItem(hMenu, 103u, 0u);
} /* end EnableMenuItems() */


static void FillScreen(char filler)
{
   long r;
   long c;
   for (r = 1l; r<=32l; r++) {
      for (c = 1l; c<=132l; c++) {
         Screen[X2C_CHKINX(r-1u,32u)][X2C_CHKINX(c-1u,132u)] = filler;
      } /* end for */
   } /* end for */
} /* end FillScreen() */


static void StatusMessage(long n, char text[], unsigned long text_len)
{
   X2C_ADDRESS tmp;
   X2C_PCOPY((void **)&text,text_len);
   SendMessageA(hStatus, 1025u, (unsigned)X2C_CHKL(n,0l,X2C_max_longint),
                *X2C_CAST((tmp = (char *)text,&tmp),X2C_ADDRESS,long,
                long *));
   X2C_PFREE(text);
} /* end StatusMessage() */


static void displayCursorInStatus(void)
{
   char xtext[10];
   char ytext[10];
   char xytext[21];
   xtext[0] = 0;
   ytext[0] = 0;
   xytext[0] = 0;
   WholeStr_IntToStr(csr.x, xtext, 10ul);
   WholeStr_IntToStr(csr.y, ytext, 10ul);
   Strings_Append(xtext, 10ul, xytext, 21ul);
   Strings_Append(".", 2ul, xytext, 21ul);
   Strings_Append(ytext, 10ul, xytext, 21ul);
   StatusMessage(0l, xytext, 21ul);
} /* end displayCursorInStatus() */

#define Generic_DefExt "*.TXT\\0"

#define Generic_Title0 "Select file to open"

#define Generic_Dir "s:\\projects\\modula-2\\samples"


static void OpenFile0(HWND owner)
{
   char filter[1001];
   OPENFILENAMEA of;
   char file[1001];
   char s[1101];
   memset((char *)filter,(char)0u,1001ul);
   LoadStringA(GetModuleHandleA(0), 1000u, filter, 1001l);
   file[0u] = 0;
   StatusMessage(4l, filter, 1001ul);
   memset((char *) &of,(char)0u,X2C_CHKUL(sizeof(OPENFILENAMEA),0u,
                X2C_max_longcard));
   of.lStructSize = X2C_CHKUL(sizeof(OPENFILENAMEA),0u,X2C_max_longcard);
   of.hwndOwner = owner;
   of.hInstance = GetModuleHandleA(0);
   of.lpstrFilter = filter;
   of.nFilterIndex = 1ul;
   of.lpstrDefExt = (PSTR)Generic_DefExt;
   of.lpstrFile = file;
   of.nMaxFile = 1001ul;
   of.lpstrTitle = (PSTR)Generic_Title0;
   of.lpstrInitialDir = (PSTR)Generic_Dir;
   if (GetOpenFileNameA(&of)) {
      wsprintfA(s, "File selected: %s", file);
      MessageBoxA(owner, s, (PSTR)"Open command", 0ul);
   }
} /* end OpenFile() */

#define Generic_DefExt0 "*.TXT\\0"

#define Generic_Title1 "Save File"

#define Generic_Dir0 "s:\\projects\\modula-2\\samples"


static void SaveFile(HWND owner, char filename[],
                unsigned long filename_len)
{
   char filter[1001];
   OPENFILENAMEA of;
   char file[1001];
   char s[1101];
   X2C_PCOPY((void **)&filename,filename_len);
   memset((char *)filter,(char)0u,1001ul);
   LoadStringA(GetModuleHandleA(0), 1000u, filter, 1001l);
   Strings_Assign(filename, filename_len, file, 1001ul);
   StatusMessage(4l, filter, 1001ul);
   memset((char *) &of,(char)0u,X2C_CHKUL(sizeof(OPENFILENAMEA),0u,
                X2C_max_longcard));
   of.lStructSize = X2C_CHKUL(sizeof(OPENFILENAMEA),0u,X2C_max_longcard);
   of.hwndOwner = owner;
   of.hInstance = GetModuleHandleA(0);
   of.lpstrFilter = filter;
   of.nFilterIndex = 1ul;
   of.lpstrDefExt = (PSTR)Generic_DefExt0;
   of.lpstrFile = file;
   of.nMaxFile = 1001ul;
   of.lpstrTitle = (PSTR)Generic_Title1;
   of.lpstrInitialDir = (PSTR)Generic_Dir0;
   if (GetSaveFileNameA(&of)) {
      wsprintfA(s, "File selected to save: %s", file);
      MessageBoxA(owner, s, (PSTR)"Save command", 0ul);
   }
   X2C_PFREE(filename);
} /* end SaveFile() */


static long Min(long a, long b)
{
   if (a<b) return a;
   return b;
} /* end Min() */


static void onPaintCursor(HWND hWnd, HDC hdc, long cline)
{
   RECT rect;
   RECT crect;
   HGDIOBJ hfOld;
   long maxDrop;
   long line0;
   hfOld = SelectObject(hdc, BoldFont);
   GetClientRect(hWnd, &rect);
   maxDrop = rect.bottom-iStatusHeight;
   SetTextColor(hdc, RGB(0u, 0u, 0u));
   line0 = csr.y;
   rect.top = Min(14l+line0*16l, maxDrop);
   rect.bottom = Min(28l+line0*20l, maxDrop);
   crect = rect;
   crect.left = (-7l)+csr.x*7l;
   crect.right = crect.left+7l;
   SelectObject(hdc, PlainFont);
   SetBkMode(hdc, TRANSPARENT);
   DrawTextA(hdc, (PSTR)"_", 1l, &crect, 0x20ul);
   SelectObject(hdc, hfOld);
} /* end onPaintCursor() */


static long Min0(long a, long b)
{
   if (a<b) return a;
   return b;
} /* end Min() */


static void onUnPaintCursor(HWND hWnd, HDC hdc, long cline)
{
   RECT rect;
   RECT crect;
   HGDIOBJ hfOld;
   long maxDrop;
   long line0;
   char cstring[4];
   StatusMessage(1l, "Paint Line", 11ul);
   hfOld = SelectObject(hdc, BoldFont);
   GetClientRect(hWnd, &rect);
   maxDrop = rect.bottom-iStatusHeight;
   SetTextColor(hdc, RGB(0u, 0u, 0u));
   line0 = csr.y;
   rect.top = Min0(14l+line0*16l, maxDrop);
   rect.bottom = Min0(28l+line0*20l, maxDrop);
   if ((line0&1)) SelectObject(hdc, BoldFont);
   else SelectObject(hdc, PlainFont);
   crect = rect;
   crect.left = (-7l)+csr.x*7l;
   crect.right = crect.left+7l;
   cstring[0u] = Screen[X2C_CHKINX(line0-1u,32u)][X2C_CHKINX(csr.x-1u,132u)];
   cstring[1u] = 0;
   SetBkMode(hdc, OPAQUE);
   DrawTextA(hdc, cstring, 1l, &crect, 0x20ul);
   SelectObject(hdc, hfOld);
} /* end onUnPaintCursor() */


static long Min1(long a, long b)
{
   if (a<b) return a;
   return b;
} /* end Min() */


static void onPaint(HWND hWnd, HDC hdc)
{
   RECT rect;
   HGDIOBJ hfOld;
   long maxDrop;
   long i;
   StatusMessage(1l, "Paint All lines", 16ul);
   hfOld = SelectObject(hdc, BoldFont);
   GetClientRect(hWnd, &rect);
   maxDrop = rect.bottom-iStatusHeight;
   SetTextColor(hdc, RGB(0u, 0u, 0u));
   SetBkMode(hdc, OPAQUE);
   for (i = 1l; i<=32l; i++) {
      rect.top = Min1(14l+i*16l, maxDrop);
      rect.bottom = Min1(28l+i*20l, maxDrop);
      if ((i&1)) SelectObject(hdc, BoldFont);
      else SelectObject(hdc, PlainFont);
      DrawTextA(hdc, Screen[X2C_CHKINX(i-1u,32u)], 132l, &rect, 0x20ul);
   } /* end for */
   SelectObject(hdc, hfOld);
} /* end onPaint() */


static void redisplayCursorOn(HWND hWnd, long line0)
{
   HDC hdc;
   hdc = GetDC(hWnd);
   onPaintCursor(hWnd, hdc, line0);
   SendMessageA(hStatus, 5u, 0u, 0l);
   ReleaseDC(hWnd, hdc);
   displayCursorInStatus();
} /* end redisplayCursorOn() */


static void redisplayCursorOff(HWND hWnd, long line0)
{
   HDC hdc;
   hdc = GetDC(hWnd);
   onUnPaintCursor(hWnd, hdc, line0);
   SendMessageA(hStatus, 5u, 0u, 0l);
   ReleaseDC(hWnd, hdc);
} /* end redisplayCursorOff() */


static void redisplay(HWND hWnd)
{
   HDC hdc;
   hdc = GetDC(hWnd);
   onPaint(hWnd, hdc);
   redisplayCursorOn(hWnd, csr.y);
   SendMessageA(hStatus, 5u, 0u, 0l);
   ReleaseDC(hWnd, hdc);
} /* end redisplay() */


static void moveCursor(HWND hWnd, unsigned wParam)
{
   if (wParam==37u) {
      redisplayCursorOff(hWnd, csr.y);
      csr.x = csr.x-1l;
      if (csr.x<=1l) csr.x = 1l;
      redisplayCursorOn(hWnd, csr.y);
   }
   if (wParam==39u) {
      redisplayCursorOff(hWnd, csr.y);
      csr.x = csr.x+1l;
      if (csr.x>132l) csr.x = 132l;
      redisplayCursorOn(hWnd, csr.y);
   }
   if (wParam==38u) {
      redisplayCursorOff(hWnd, csr.y);
      csr.y = csr.y-1l;
      if (csr.y<1l) csr.y = 1l;
      redisplayCursorOn(hWnd, csr.y);
   }
   if (wParam==40u) {
      redisplayCursorOff(hWnd, csr.y);
      csr.y = csr.y+1l;
      if (csr.y>32l) csr.y = 32l;
      redisplayCursorOn(hWnd, csr.y);
   }
   if (wParam==8u) {
      redisplayCursorOff(hWnd, csr.y);
      csr.x = csr.x-1l;
      if (csr.x<=1l) csr.x = 1l;
      if (csr.x<132l && csr.y<32l) {
         Screen[X2C_CHKINX(csr.y-1u,32u)][X2C_CHKINX(csr.x-1u,132u)] = ' ';
         redisplayCursorOff(hWnd, csr.y);
      }
      redisplayCursorOn(hWnd, csr.y);
   }
} /* end moveCursor() */


static void insertAtCursor(HWND hWnd, unsigned wParam)
{
   if (wParam<32u || wParam>127u) return;
   if (csr.x<132l && csr.y<32l) {
      Screen[X2C_CHKINX(csr.y-1u,32u)][X2C_CHKINX(csr.x-1u,
                132u)] = (char)wParam;
      redisplayCursorOff(hWnd, csr.y);
      csr.x = csr.x+1l;
      if (csr.x>132l) csr.x = 132l;
      redisplayCursorOn(hWnd, csr.y);
   }
} /* end insertAtCursor() */

static long X2C_STDCALL WndProc(HWND, unsigned, unsigned, long);


static long X2C_STDCALL WndProc(HWND hWnd, unsigned message, unsigned wParam,
                 long lParam)
{
   long wmId;
   POINT pnt;
   HMENU hMenu;
   RECT rect;
   RECT rcStatus;
   HDC hdc;
   PAINTSTRUCT ps;
   HGDIOBJ hBrush;
   switch (message) {
   case 1u:
      EnableMenuItems(hWnd);
      return 0l;
   case 258u:
      insertAtCursor(hWnd, wParam);
      break;
   case 256u:
      moveCursor(hWnd, wParam);
      break;
   case 5u:
      SendMessageA(hStatus, 5u, 0u, 0l);
      SendMessageA(hTool, 5u, 0u, 0l);
      GetWindowRect(hStatus, &rcStatus);
      iStatusHeight = rcStatus.bottom-rcStatus.top;
      break;
   case 273u:
      wmId = (long)LOWORD(wParam);
      switch (wmId) {
      case 106l:
         DestroyWindow(hWnd);
         break;
      case 100l:
         FillScreen(' ');
         redisplay(hWnd);
         break;
      case 101l:
         OpenFile0(hWnd);
         break;
      case 102l:
         SaveFile(hWnd, "filename.txt", 13ul);
         break;
      case 103l:
         SaveFile(hWnd, "filename.txt", 13ul);
         break;
      case 200l:
         break;
      case 201l:
         break;
      case 202l:
         break;
      case 203l:
         break;
      case 204l:
         break;
      case 205l:
         break;
      default:;
         return DefWindowProcA(hWnd, message, wParam, lParam);
      } /* end switch */
      break;
   case 516u:
      StatusMessage(1l, "POPUP MENU NEW", 15ul);
      pnt.x = (long)LOWORD((unsigned long)X2C_CHKL(lParam,0l,
                X2C_max_longint));
      pnt.y = (long)HIWORD((unsigned long)X2C_CHKL(lParam,0l,
                X2C_max_longint));
      ClientToScreen(hWnd, &pnt);
      hMenu = GetSubMenu(GetMenu(hWnd), 0l);
      if (hMenu) TrackPopupMenu(hMenu, 0u, pnt.x, pnt.y, 0l, hWnd, 0);
      else MessageBeep(0ul);
      break;
   case 15u:
      StatusMessage(1l, "PAINTING", 9ul);
      hdc = BeginPaint(hWnd, &ps);
      hBrush = CreateSolidBrush(RGB(100u, 100u, 100u));
      GetClientRect(hWnd, &rect);
      FillRect(hdc, &rect, hBrush);
      DeleteObject(hBrush);
      onPaint(hWnd, hdc);
      EndPaint(hWnd, &ps);
      break;
   case 2u:
      PostQuitMessage(0l);
      break;
   default:;
      return DefWindowProcA(hWnd, message, wParam, lParam);
   } /* end switch */
   return 0l;
} /* end WndProc() */


static char InitApplication(void)
{
   WNDCLASSEXA wc;
   InitCommonControls();
   csr.x = 10l;
   csr.y = 10l;
   wc.style = 0x3ul;
   wc.lpfnWndProc = WndProc;
   wc.cbClsExtra = 0l;
   wc.cbWndExtra = 0l;
   wc.hInstance = GetModuleHandleA(0);
   wc.hIcon = LoadIconA(wc.hInstance, (PSTR)Generic_AppName);
   wc.hCursor = LoadCursorA(0, (PSTR)32512u);
   wc.hbrBackground = 0;
   wc.lpszMenuName = (PSTR)Generic_AppName;
   wc.lpszClassName = (PSTR)Generic_AppName;
   wc.cbSize = X2C_CHKUL(sizeof(WNDCLASSEXA),0u,X2C_max_longcard);
   wc.hIconSm = LoadIconA(wc.hInstance, (PSTR)"SMALL");
   FillScreen('*');
   return (unsigned long)RegisterClassExA(&wc)!=0ul;
} /* end InitApplication() */

typedef long statusBarArray[5];

static statusBarArray Generic_statwidths = {100l,200l,300l,400l,-1l};


static void MakeStatusBar(RECT * rcStatus, HWND hWnd)
{
   X2C_ADDRESS tmp;
   hStatus = CreateWindowExA(0ul, (PSTR)STATUSCLASSNAME, (PSTR)"",
                (unsigned long)0x50000100ul, 0l, 0l, 0l, 0l, hWnd,
                (HMENU)601u, GetModuleHandleA(0), 0);
   SendMessageA(hStatus, 1028u, 5u,
                *X2C_CAST((tmp = (char *)Generic_statwidths,&tmp),
                X2C_ADDRESS,long,long *));
   SendMessageA(hStatus, 5u, 0u, 0l);
   GetWindowRect(hStatus, rcStatus);
   iStatusHeight = rcStatus->bottom-rcStatus->top;
} /* end MakeStatusBar() */


static void MakeToolBar(HWND hWnd)
{
   struct TBBUTTON tbb[4];
   struct TBADDBITMAP tbab;
   X2C_ADDRESS tmp;
   hTool = CreateWindowExA(0ul, (PSTR)TOOLBARCLASSNAME, (PSTR)"",
                0x50000000ul, 0l, 0l, 0l, 0l, hWnd, (HMENU)602u,
                GetModuleHandleA(0), 0);
   SendMessageA(hTool, 1054u, X2C_CHKUL(sizeof(struct TBBUTTON),0u,
                X2C_max_longcard), 0l);
   tbab.hInst = (HINSTANCE)-1u;
   tbab.nID = 0u;
   SendMessageA(hTool, 1043u, 0u, *X2C_CAST((tmp = (char *) &tbab,&tmp),
                X2C_ADDRESS,long,long *));
   tbb[0u].iBitmap = 6l;
   tbb[0u].iString = 0l;
   tbb[0u].fsState = 0x4u;
   tbb[0u].fsStyle = 0u;
   tbb[0u].idCommand = 100l;
   tbb[1u].iBitmap = 7l;
   tbb[1u].iString = 0l;
   tbb[1u].fsState = 0x4u;
   tbb[1u].fsStyle = 0u;
   tbb[1u].idCommand = 101l;
   tbb[2u].iBitmap = 8l;
   tbb[2u].iString = 0l;
   tbb[2u].fsState = 0x4u;
   tbb[2u].fsStyle = 0u;
   tbb[2u].idCommand = 102l;
   SendMessageA(hTool, 1044u, 3u, *X2C_CAST((tmp = (char *)tbb,&tmp),
                X2C_ADDRESS,long,long *));
} /* end MakeToolBar() */


static long MulDiv0(unsigned long a, unsigned long b, unsigned long c)
{
   long Result;
   Result = (long)X2C_CHKUL((a*b)/c,0ul,2147483647ul);
   return Result;
} /* end MulDiv() */


static char InitFonts(HWND hWnd)
{
   HDC hdc;
   HGDIOBJ hf;
   long lfHeight;
   hdc = GetDC(hWnd);
   lfHeight = -MulDiv0(11ul, (unsigned long)X2C_CHKL(GetDeviceCaps(hdc, 90l),
                0l,X2C_max_longint), 72ul);
   hf = CreateFontA(lfHeight, 0l, 0l, 0l, 400l, 0, 0, 0, 0u,
                OUT_DEFAULT_PRECIS, 0u, PROOF_QUALITY, 0x2u,
                (PSTR)"CONSOLAS");
   if (hf) PlainFont = hf;
   else {
      MessageBoxA(hWnd, "Plain Font creation failed!", (PSTR)"Error",
                0x30ul);
      return 0;
   }
   hf = CreateFontA(lfHeight, 0l, 0l, 0l, 700l, 0, 0, 0, 0u,
                OUT_DEFAULT_PRECIS, 0u, PROOF_QUALITY, 0x2u,
                (PSTR)"CONSOLAS");
   if (hf) BoldFont = hf;
   else {
      MessageBoxA(hWnd, "Bold Font creation failed!", (PSTR)"Error", 0x30ul);
      return 0;
   }
   return 1;
} /* end InitFonts() */


static char InitMainWindow(void)
{
   HWND hWnd;
   RECT rcStatus;
   hWnd = CreateWindowA((PSTR)Generic_AppName, (PSTR)Generic_Title,
                0xCF0000ul, X2C_min_longint, 0l, X2C_min_longint, 0l, 0, 0,
                GetModuleHandleA(0), 0);
   if (hWnd==0) return 0;
   if (!InitFonts(hWnd)) return 0;
   MakeStatusBar(&rcStatus, hWnd);
   MakeToolBar(hWnd);
   ShowWindow(hWnd, SW_SHOWDEFAULT);
   UpdateWindow(hWnd);
   return 1;
} /* end InitMainWindow() */

static MSG msg;


X2C_STACK_LIMIT(100000l)
extern int main(int argc, char **argv)
{
   X2C_BEGIN(&argc,argv,1,2000000l,256000000l);
   if (sizeof(line)!=132) X2C_ASSERT(0);
   if (sizeof(lines)!=4224) X2C_ASSERT(0);
   Strings_BEGIN();
   WholeStr_BEGIN();
   if (InitApplication() && InitMainWindow()) {
      while (GetMessageA(&msg, 0, 0u, 0u)) {
         TranslateMessage(&msg);
         DispatchMessageA(&msg);
      }
   }
   X2C_EXIT();
   return 0;
}

X2C_MAIN_DEFINITION
