/* "@(#)MandSet.c Aug 17 19:19:51 2019" */
/* Generated by XDS Modula-2 to ANSI C v4.20 translator */

#define X2C_int32
#define X2C_index32
#ifndef X2C_H_
#include "X2C.h"
#endif
#define MandSet_C_
#include "Windows.h"
#ifndef LongStr_H_
#include "LongStr.h"
#endif
#ifndef WholeStr_H_
#include "WholeStr.h"
#endif
#ifndef Strings_H_
#include "Strings.h"
#endif
#ifndef Storage_H_
#include "Storage.h"
#endif

static long wnd_count;

#define MandSet_MaxX 1600

#define MandSet_MaxY 1280

#define MandSet_ClassName "MANClass"

typedef unsigned char * PTR;

struct DATA;


struct DATA {
   HWND hwnd;
   double SX0;
   double SX1;
   double SY0;
   double SY1;
   double X0;
   double X1;
   double Y0;
   double Y1;
   double x00;
   double x10;
   double y00;
   double y10;
   long time0;
   char selected;
   long sx;
   long sy;
   PTR image;
   long image_sz;
};

typedef struct DATA * PDATA;

#define MandSet_MSG_RECALCULATE 2024

#define MandSet_MSG_EXPAND 2025

#define MandSet_RECALC_ITEM 1001

#define MandSet_EXPAND_ITEM 1002

#define MandSet_COPY_ITEM 1003

#define MandSet_EXIT_ITEM 1004

#define MandSet_START_X0 (-2.0)

#define MandSet_START_X1 1.0

#define MandSet_START_Y0 (-1.5)

#define MandSet_START_Y1 1.5

struct biType;


struct biType {
   BITMAPINFOHEADER h;
   RGBQUAD colors[256];
};

static struct biType bi;


static void setcolors(void)
{
   long i;
   for (i = 0l; i<=254l; i++) {
      bi.colors[i].rgbRed = (unsigned char)(X2C_DIV(i,64l)*64l);
      bi.colors[i].rgbGreen = (unsigned char)((X2C_DIV(i,8l)&7l)*32l);
      bi.colors[i].rgbBlue = (unsigned char)((i&7l)*32l);
      bi.colors[i].rgbReserved = 0u;
   } /* end for */
   bi.colors[255u].rgbRed = 0u;
   bi.colors[255u].rgbGreen = 0u;
   bi.colors[255u].rgbBlue = 0u;
   bi.colors[255u].rgbReserved = 0u;
} /* end setcolors() */


static void preparebi(void)
{
   bi.h.biSize = sizeof(BITMAPINFOHEADER);
   bi.h.biWidth = 0l;
   bi.h.biHeight = 0l;
   bi.h.biPlanes = 1u;
   bi.h.biBitCount = 8u;
   bi.h.biCompression = BI_RGB;
   bi.h.biSizeImage = 0ul;
   bi.h.biXPelsPerMeter = 0l;
   bi.h.biYPelsPerMeter = 0l;
   bi.h.biClrUsed = 0ul;
   bi.h.biClrImportant = 0ul;
} /* end preparebi() */


static void OutCoords(char s[], unsigned long s_len, double x0, double y00,
                double x1, double y1)
{
   char tmp[80];
   Strings_Append("(", 2ul, s, s_len);
   LongStr_RealToFloat(x0, 4ul, tmp, 80ul);
   Strings_Append(tmp, 80ul, s, s_len);
   Strings_Append(",", 2ul, s, s_len);
   LongStr_RealToFloat(y00, 4ul, tmp, 80ul);
   Strings_Append(tmp, 80ul, s, s_len);
   Strings_Append(")-(", 4ul, s, s_len);
   LongStr_RealToFloat(x1, 4ul, tmp, 80ul);
   Strings_Append(tmp, 80ul, s, s_len);
   Strings_Append(",", 2ul, s, s_len);
   LongStr_RealToFloat(y1, 4ul, tmp, 80ul);
   Strings_Append(tmp, 80ul, s, s_len);
   Strings_Append(")", 2ul, s, s_len);
} /* end OutCoords() */


static void draw_title(struct DATA * data)
{
   char tmp[256];
   char s[256];
   Strings_Assign("Time: ", 7ul, s, 256ul);
   WholeStr_IntToStr(data->time0, tmp, 256ul);
   Strings_Append(tmp, 256ul, s, 256ul);
   Strings_Append(". Set borders: ", 16ul, s, 256ul);
   OutCoords(s, 256ul, data->SX0, data->SY0, data->SX1, data->SY1);
   if (data->selected) {
      Strings_Append("; Selection: ", 14ul, s, 256ul);
      OutCoords(s, 256ul, data->x00, data->y00, data->x10, data->y10);
   }
   SetWindowTextA(data->hwnd, s);
} /* end draw_title() */


static double Max(double a, double b)
{
   if (a>=b) return a;
   else return b;
   return 0;
} /* end Max() */


static void DrawBitmap(struct DATA * data, HDC dc)
{
   if (data->image) {
      bi.h.biWidth = data->sx;
      bi.h.biHeight = data->sy;
      SetDIBitsToDevice(dc, 0l, 0l, data->sx, data->sy, 0l, 0l, 0u,
                (unsigned)data->sy, data->image, &bi.h, DIB_RGB_COLORS);
   }
} /* end DrawBitmap() */


static void DrawWin(struct DATA * data)
{
   HDC dc;
   dc = GetDC(data->hwnd);
   DrawBitmap(data, dc);
   ReleaseDC(data->hwnd, dc);
} /* end DrawWin() */


static void TitleCalculated(long perc, struct DATA * data)
{
   char tmp[80];
   char s[80];
   Strings_Assign("Calculated ", 12ul, s, 80ul);
   WholeStr_IntToStr(perc, tmp, 80ul);
   Strings_Append(tmp, 80ul, s, 80ul);
   Strings_Append("%", 2ul, s, 80ul);
   SetWindowTextA(data->hwnd, s);
} /* end TitleCalculated() */


static void CalcSet(struct DATA * data, long w, long h, double d)
{
   double y2;
   double x2;
   double y;
   double x;
   double y00;
   double x0;
   long perc;
   long n;
   long j;
   long i;
   long wb;
   long p;
   long tmp;
   long tmp0;
   p = 0l;
   wb = X2C_DIV(w+3l,4l)*4l;
   perc = 0l;
   tmp = h-1l;
   j = 0l;
   if (j<=tmp) for (;; j++) {
      y00 = (double)j*d+data->Y0;
      tmp0 = wb-1l;
      i = 0l;
      if (i<=tmp0) for (;; i++) {
         x0 = (double)i*d+data->X0;
         x = x0;
         y = y00;
         n = 0l;
         for (;;) {
            x2 = x*x;
            y2 = y*y;
            if (x2+y2>=4.0) break;
            ++n;
            if (n==255l) break;
            y = 2.0*x*y+y00;
            x = (x2-y2)+x0;
         }
         data->image[p] = (unsigned char)n;
         ++p;
         if (i==tmp0) break;
      } /* end for */
      n = X2C_QUO((j+1l)*100l,h);
      if (n!=perc && n!=100l) {
         perc = n;
         TitleCalculated(perc, data);
         if (X2C_MOD(perc,10l)==0l) DrawWin(data);
      }
      if (j==tmp) break;
   } /* end for */
} /* end CalcSet() */


static void BuildImage(struct DATA * data)
{
   RECT rc;
   long t1;
   long t0;
   long wb;
   long h;
   long w;
   double d;
   GetClientRect(data->hwnd, &rc);
   w = rc.right;
   h = rc.bottom;
   if (data->image) {
      Storage_DEALLOCATE((X2C_ADDRESS *) &data->image,
                (unsigned long)data->image_sz);
   }
   wb = X2C_DIV(w+3l,4l)*4l;
   data->image_sz = wb*h;
   Storage_ALLOCATE((X2C_ADDRESS *) &data->image,
                (unsigned long)data->image_sz);
   if (data->image==0) {
      SetWindowTextA(data->hwnd, "Sorry, no memory for a bitmap");
   }
   else {
      RtlFillMemory((PVOID)data->image, (unsigned long)(wb*h), 0u);
      d = Max(X2C_DIVL(data->SX1-data->SX0,(double)w),
                X2C_DIVL(data->SY1-data->SY0,(double)h));
      data->X0 = X2C_DIVL((data->SX0+data->SX1)-d*(double)w,2.0);
      data->X1 = data->X0+d*(double)w;
      data->Y0 = X2C_DIVL((data->SY0+data->SY1)-d*(double)h,2.0);
      data->Y1 = data->Y0+d*(double)h;
      data->sx = w;
      data->sy = h;
      t0 = (long)GetTickCount();
      CalcSet(data, w, h, d);
      t1 = (long)GetTickCount();
      data->time0 = t1-t0;
      draw_title(data);
   }
} /* end BuildImage() */


static void CopyBitmap(struct DATA * data)
{
   unsigned long l;
   X2C_ADDRESS p;
   HGLOBAL h;
   if (data->image) {
      l = (unsigned long)(X2C_DIV(data->sx+3l,4l)*4l*data->sy);
      h = GlobalAlloc(0x2002u, sizeof(struct biType)+l);
      if (h==0) return;
      p = (X2C_ADDRESS)GlobalLock(h);
      X2C_MOVE((char *) &bi,p,sizeof(struct biType));
      X2C_MOVE((X2C_ADDRESS)data->image,
                (X2C_ADDRESS)((char *)p+(long)sizeof(struct biType)),l);
      GlobalUnlock(h);
      if (OpenClipboard(data->hwnd)) {
         EmptyClipboard();
         SetClipboardData(8u, (HANDLE)h);
         CloseClipboard();
      }
      else GlobalFree(h);
   }
} /* end CopyBitmap() */

static char in_drag;

static char rect_drawn;

static long rx0;

static long ry0;

static long rx;

static long ry;


static void draw_rect(HWND hwnd)
{
   RECT rc;
   HDC dc;
   dc = GetDC(hwnd);
   rc.left = min(rx0, rx);
   rc.right = max(rx0, rx);
   rc.top = min(ry0, ry);
   rc.bottom = max(ry0, ry);
   DrawFocusRect(dc, &rc);
   ReleaseDC(hwnd, dc);
} /* end draw_rect() */


static void calc_borders(struct DATA * data)
{
   double DY;
   double DX;
   RECT rc;
   GetClientRect(data->hwnd, &rc);
   DX = data->X1-data->X0;
   DY = data->Y1-data->Y0;
   data->x00 = data->X0+(X2C_DIVL(DX,(double)data->sx))*(double)min(rx0, rx);
   data->x10 = data->X0+(X2C_DIVL(DX,(double)data->sx))*(double)max(rx0, rx);
   data->y00 = data->Y0+(X2C_DIVL(DY,
                (double)data->sy))*(double)min(rc.bottom-ry0, rc.bottom-ry);
   data->y10 = data->Y0+(X2C_DIVL(DY,
                (double)data->sy))*(double)max(rc.bottom-ry0, rc.bottom-ry);
   data->selected = 1;
   draw_title(data);
} /* end calc_borders() */


static void check(HWND hwnd, long * x, long * y)
{
   RECT rc;
   GetClientRect(hwnd, &rc);
   if (*x<0l) *x = 0l;
   else if (*x>rc.right) *x = rc.right;
   if (*y<0l) *y = 0l;
   else if (*y>rc.bottom) *y = rc.bottom;
} /* end check() */


static void StartDrag(struct DATA * data, long x, long y)
{
   if (data->image) {
      if (rect_drawn) draw_rect(data->hwnd);
      check(data->hwnd, &x, &y);
      rx0 = x;
      ry0 = y;
      rx = x;
      ry = y;
      in_drag = 1;
      rect_drawn = 0;
      SetCapture(data->hwnd);
   }
} /* end StartDrag() */


static void InDrag(struct DATA * data, long x, long y)
{
   if (in_drag) {
      if (rect_drawn) draw_rect(data->hwnd);
      check(data->hwnd, &x, &y);
      rx = x;
      ry = y;
      draw_rect(data->hwnd);
      rect_drawn = 1;
      calc_borders(data);
   }
} /* end InDrag() */


static void EndDrag(struct DATA * data, long x, long y)
{
   if (in_drag) {
      in_drag = 0;
      if (rect_drawn) draw_rect(data->hwnd);
      rect_drawn = 0;
      ReleaseCapture();
      check(data->hwnd, &x, &y);
      rx = x;
      ry = y;
      calc_borders(data);
   }
} /* end EndDrag() */


static void DeactivateDrag(struct DATA * data)
{
   if (in_drag) {
      in_drag = 0;
      if (rect_drawn) draw_rect(data->hwnd);
      rect_drawn = 0;
      ReleaseCapture();
   }
} /* end DeactivateDrag() */


static HWND create_view(double x0, double x1, double y00, double y1,
                char recalc)
{
   PDATA data;
   HWND wnd;
   unsigned long tmp;
   wnd = CreateWindowA((PSTR)MandSet_ClassName, (PSTR)"M-Set", 0x10CF0000ul,
                X2C_min_longint, X2C_min_longint, X2C_min_longint,
                X2C_min_longint, 0, 0, GetModuleHandleA(0), 0);
   if (wnd) {
      data = (PDATA)*X2C_CAST((tmp = GetWindowLongA(wnd, -21l),&tmp),
                unsigned long,X2C_ADDRESS,X2C_ADDRESS *);
      data->SX0 = x0;
      data->SY0 = y00;
      data->SX1 = x1;
      data->SY1 = y1;
      if (recalc) PostMessageA(wnd, 2024u, 0u, 0l);
   }
   return wnd;
} /* end create_view() */


static long ILOWORD(long lparam)
{
   return (long)(short)LOWORD((unsigned long)lparam);
} /* end ILOWORD() */


static long IHIWORD(long lparam)
{
   return (long)(short)HIWORD((unsigned long)lparam);
} /* end IHIWORD() */

static long X2C_STDCALL MainWinProc(HWND, unsigned, unsigned, long);


static long X2C_STDCALL MainWinProc(HWND hwnd, unsigned msg, unsigned wparam,
                 long lparam)
{
   HDC dc;
   HMENU menu;
   PAINTSTRUCT ps;
   PDATA data;
   unsigned long tmp;
   data = (PDATA)*X2C_CAST((tmp = GetWindowLongA(hwnd, -21l),&tmp),
                unsigned long,X2C_ADDRESS,X2C_ADDRESS *);
   switch (msg) {
   case 1u:
      Storage_ALLOCATE((X2C_ADDRESS *) &data, sizeof(struct DATA));
      if (data==0) return -1l;
      data->image = 0;
      data->image_sz = 0l;
      data->hwnd = hwnd;
      data->selected = 0;
      SetWindowLongA(hwnd, -21l, *X2C_CAST(&data,PDATA,unsigned long,
                unsigned long *));
      ++wnd_count;
      menu = GetSystemMenu(hwnd, 0);
      AppendMenuA(menu, 0u, 1001u, (PSTR)"&Refresh");
      AppendMenuA(menu, 0u, 1002u, (PSTR)"&Expand");
      AppendMenuA(menu, 0u, 1003u, (PSTR)"Cop&y");
      AppendMenuA(menu, 0u, 1004u, (PSTR)"E&xit");
      return 0l;
   case 15u:
      dc = BeginPaint(hwnd, &ps);
      DrawBitmap(data, dc);
      EndPaint(hwnd, &ps);
      return 0l;
   case 16u:
      if (data->image) {
         Storage_DEALLOCATE((X2C_ADDRESS *) &data->image,
                (unsigned long)data->image_sz);
      }
      Storage_DEALLOCATE((X2C_ADDRESS *) &data, sizeof(struct DATA));
      --wnd_count;
      if (wnd_count==0l) PostQuitMessage(0l);
      break;
   case 513u:
      StartDrag(data, ILOWORD(lparam), IHIWORD(lparam));
      return 0l;
   case 514u:
      EndDrag(data, ILOWORD(lparam), IHIWORD(lparam));
      return 0l;
   case 512u:
      InDrag(data, ILOWORD(lparam), IHIWORD(lparam));
      return 0l;
   case 6u:
      if ((unsigned long)LOWORD(wparam)==0ul) DeactivateDrag(data);
      break;
   case 516u:
      if (data->selected) SendMessageA(hwnd, 2025u, 0u, 0l);
      else SendMessageA(hwnd, 2024u, 0u, 0l);
      return 0l;
   case 2024u:
      BuildImage(data);
      DrawWin(data);
      return 0l;
   case 2025u:
      if (data->selected) {
         if (create_view(data->x00, data->x10, data->y00, data->y10, 1)==0) {
            MessageBoxA(0, "Couldn\'t create window", 0, 0x1010ul);
         }
         data->selected = 0;
         draw_title(data);
      }
      return 0l;
   case 278u:
      menu = GetSystemMenu(hwnd, 0);
      EnableMenuItem(menu, 1004u, 0u);
      EnableMenuItem(menu, 1001u, 0u);
      if (data->image) EnableMenuItem(menu, 1003u, 0u);
      else EnableMenuItem(menu, 1003u, 0x1u);
      if (data->selected) EnableMenuItem(menu, 1002u, 0u);
      else EnableMenuItem(menu, 1002u, 0x1u);
      return 0l;
   case 274u:
      switch (LOWORD(wparam)) {
      case 1001u:
         PostMessageA(hwnd, 2024u, 0u, 0l);
         return 0l;
      case 1002u:
         PostMessageA(hwnd, 2025u, 0u, 0l);
         return 0l;
      case 1003u:
         CopyBitmap(data);
         return 0l;
      case 1004u:
         PostQuitMessage(0l);
         return 0l;
      } /* end switch */
      break;
   } /* end switch */
   return DefWindowProcA(hwnd, msg, wparam, lparam);
} /* end MainWinProc() */

static WNDCLASSA wc;

static MSG msg;


X2C_STACK_LIMIT(100000l)
extern int main(int argc, char **argv)
{
   X2C_BEGIN(&argc,argv,1,2000000l,4000000l);
   Storage_BEGIN();
   Strings_BEGIN();
   WholeStr_BEGIN();
   LongStr_BEGIN();
   wc.style = 0x1020ul;
   wc.lpfnWndProc = MainWinProc;
   wc.cbClsExtra = 0l;
   wc.cbWndExtra = 0l;
   wc.hInstance = GetModuleHandleA(0);
   wc.hIcon = 0;
   wc.hCursor = LoadCursorA(0, (PSTR)32512u);
   wc.hbrBackground = CreateSolidBrush(RGB(0u, 0u, 0u));
   wc.lpszMenuName = 0;
   wc.lpszClassName = (PSTR)MandSet_ClassName;
   if ((unsigned long)RegisterClassA(&wc)==0ul) {
      MessageBoxA(0, "Couldn\'t register Class", 0, 0x1010ul);
      X2C_HALT(1ul);
   }
   setcolors();
   preparebi();
   in_drag = 0;
   rect_drawn = 0;
   if (create_view((-2.0), 1.0, (-1.5), 1.5, 1)==0) {
      MessageBoxA(0, "Couldn\'t create main window", 0, 0x1010ul);
      X2C_HALT(1ul);
   }
   while (GetMessageA(&msg, 0, 0u, 0u)) {
      TranslateMessage(&msg);
      DispatchMessageA(&msg);
   }
   X2C_EXIT();
   return 0;
}

X2C_MAIN_DEFINITION
