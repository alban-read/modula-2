(* ncurses\h2d_curses.def  Aug 28  14:46:8  2001 *)
(* Generated by H2D v1.31.0 from ncurses\curses.h. *)
<*+ M2ADDTYPES *>
<*+ M2EXTENSIONS *>
<*+ NOHEADER *> 
<* IF NOT DEFINED(GENTYPEDEF) THEN *> <* NEW GENTYPEDEF+ *> <* END *>
(* Merged headers: ncurses\curses.h, stdio.h, features.h, sys/cdefs.h, gnu/stubs.h, 
stddef.h, stdarg.h, bits/types.h, libio.h, _G_config.h, bits/stdio_lim.h, 
ncurses/unctrl.h, ncurses/curses.h *)

DEFINITION MODULE ["C"] h2d_curses;

IMPORT SYSTEM;
(* H2D:  Required IMPORT clause: 
IMPORT h2d_curses;
*)

(*   ***************************************************************************  *)
(*  * Copyright (c) 1998 Free Software Foundation, Inc.                        *  *)
(*  *                                                                          *  *)
(*  * Permission is hereby granted, free of charge, to any person obtaining a  *  *)
(*  * copy of this software and associated documentation files (the            *  *)
(*  * "Software"), to deal in the Software without restriction, including      *  *)
(*  * without limitation the rights to use, copy, modify, merge, publish,      *  *)
(*  * distribute, distribute with modifications, sublicense, and/or sell       *  *)
(*  * copies of the Software, and to permit persons to whom the Software is    *  *)
(*  * furnished to do so, subject to the following conditions:                 *  *)
(*  *                                                                          *  *)
(*  * The above copyright notice and this permission notice shall be included  *  *)
(*  * in all copies or substantial portions of the Software.                   *  *)
(*  *                                                                          *  *)
(*  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  *)
(*  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  *)
(*  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  *)
(*  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  *)
(*  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  *)
(*  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  *)
(*  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *)
(*  *                                                                          *  *)
(*  * Except as contained in this notice, the name(s) of the above copyright   *  *)
(*  * holders shall not be used in advertising or otherwise to promote the     *  *)
(*  * sale, use or other dealings in this Software without prior written       *  *)
(*  * authorization.                                                           *  *)
(*  ***************************************************************************   *)
(*   ***************************************************************************  *)
(*  *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *  *)
(*  *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *  *)
(*  ***************************************************************************   *)
(*  $Id: curses.h.in,v 1.78 1999/01/10 03:21:11 tom Exp $  *)
(* #define __NCURSES_H *)

<* IF  __GEN_C__ THEN *>

VAR 
  CURSES - : INTEGER;
  CURSES_H - : INTEGER;

<* ELSE *>

CONST 
  CURSES = 1;
  CURSES_H = 1;

<* END *>

(*    This should be defined for the enhanced functionality to be visible.          *)
(*  * However, none of the wide-character (enhanced) functionality is implemented.  *)
(*  * So we do not define it (yet).                                                 *)
(* #define _XOPEN_CURSES 1                                                          *)
(*                                                                                  *)
(*  These are defined only in curses.h, and are used for conditional compiles  *)

<* IF  __GEN_C__ THEN *>

VAR 
  NCURSES_VERSION_MAJOR - : INTEGER;
  NCURSES_VERSION_MINOR - : INTEGER;
  NCURSES_VERSION_PATCH - : INTEGER;

<* ELSE *>

CONST 
  NCURSES_VERSION_MAJOR = 4;
  NCURSES_VERSION_MINOR = 2;
  NCURSES_VERSION_PATCH = 990213;

<* END *>

(*  This is defined in more than one ncurses header, for identification  *)
(* #define NCURSES_ATTR_T int *)
(* #define NCURSES_CONST  *)

TYPE 
  chtype = LONGCARD;

(*  Define ISO C stdio on top of C++ iostreams.                                *)
(*  Copyright (C) 1991, 94, 95, 96, 97, 98, 99 Free Software Foundation, Inc.  *)
(*                                                                             *)
(*  The GNU C Library is free software; you can redistribute it and/or         *)
(*  modify it under the terms of the GNU Library General Public License as     *)
(*  published by the Free Software Foundation; either version 2 of the         *)
(*  License, or (at your option) any later version.                            *)
(*                                                                             *)
(*  The GNU C Library is distributed in the hope that it will be useful,       *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of             *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          *)
(*  Library General Public License for more details.                           *)
(*                                                                             *)
(*  You should have received a copy of the GNU Library General Public          *)
(*  License along with the GNU C Library; see the file COPYING.LIB.  If not,   *)
(*  write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,  *)
(*  Boston, MA 02111-1307, USA.                                                *)
(*                                                *)
(*  *	ISO C Standard: 4.9 INPUT/OUTPUT	<stdio.h>  *)
(*                                                *)

<* IF  __GEN_C__ THEN *>

VAR 
  _STDIO_H - : INTEGER;

<* ELSE *>

CONST 
  _STDIO_H = 1;

<* END *>

(*  Copyright (C) 1991, 92, 93, 95, 96, 97, 98 Free Software Foundation, Inc.  *)
(*  This file is part of the GNU C Library.                                    *)
(*                                                                             *)
(*  The GNU C Library is free software; you can redistribute it and/or         *)
(*  modify it under the terms of the GNU Library General Public License as     *)
(*  published by the Free Software Foundation; either version 2 of the         *)
(*  License, or (at your option) any later version.                            *)
(*                                                                             *)
(*  The GNU C Library is distributed in the hope that it will be useful,       *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of             *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          *)
(*  Library General Public License for more details.                           *)
(*                                                                             *)
(*  You should have received a copy of the GNU Library General Public          *)
(*  License along with the GNU C Library; see the file COPYING.LIB.  If not,   *)
(*  write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,  *)
(*  Boston, MA 02111-1307, USA.                                                *)

<* IF  __GEN_C__ THEN *>

VAR 
  _FEATURES_H - : INTEGER;

<* ELSE *>

CONST 
  _FEATURES_H = 1;

<* END *>

(*    These are defined by the user (or the compiler)                          *)
(*    to specify the desired environment:                                      *)
(*                                                                             *)
(*    __STRICT_ANSI__	ISO Standard C.                                          *)
(*    _ISOC9X_SOURCE	Extensions to ISO C 89 from ISO C 9x.                     *)
(*    _POSIX_SOURCE	IEEE Std 1003.1.                                           *)
(*    _POSIX_C_SOURCE	If ==1, like _POSIX_SOURCE; if >=2 add IEEE Std 1003.2;  *)
(* 			if >=199309L, add IEEE Std 1003.1b-1993;                                 *)
(* 			if >=199506L, add IEEE Std 1003.1c-1995                                  *)
(*    _XOPEN_SOURCE	Includes POSIX and XPG things.  Set to 500 if              *)
(* 			Single Unix conformance is wanted.                                       *)
(*    _XOPEN_SOURCE_EXTENDED XPG things and X/Open Unix extensions.            *)
(*    _LARGEFILE_SOURCE	Some more functions for correct standard I/O.          *)
(*    _LARGEFILE64_SOURCE	Additional functionality from LFS for large files.   *)
(*    _FILE_OFFSET_BITS=N	Select default filesystem interface.                 *)
(*    _BSD_SOURCE		ISO C, POSIX, and 4.3BSD things.                            *)
(*    _SVID_SOURCE		ISO C, POSIX, and SVID things.                             *)
(*    _GNU_SOURCE		All of the above, plus GNU extensions.                      *)
(*    _REENTRANT		Select additionally reentrant object.                        *)
(*    _THREAD_SAFE		Same as _REENTRANT, often used by other systems.           *)
(*                                                                             *)
(*    The `-ansi' switch to the GNU C compiler defines __STRICT_ANSI__.        *)
(*    If none of these are defined, the default is all but _GNU_SOURCE.        *)
(*    If more than one of these are defined, they accumulate.                  *)
(*    For example __STRICT_ANSI__, _POSIX_SOURCE and _POSIX_C_SOURCE           *)
(*    together give you ISO C, 1003.1, and 1003.2, but nothing else.           *)
(*                                                                             *)
(*    These are defined by this file and are used by the                       *)
(*    header files to decide what to declare or define:                        *)
(*                                                                             *)
(*    __USE_ISOC9X		Define ISO C 9X things.                                    *)
(*    __USE_POSIX		Define IEEE Std 1003.1 things.                              *)
(*    __USE_POSIX2		Define IEEE Std 1003.2 things.                             *)
(*    __USE_POSIX199309	Define IEEE Std 1003.1, and .1b things.                *)
(*    __USE_POSIX199506	Define IEEE Std 1003.1, .1b, .1c and .1i things.       *)
(*    __USE_XOPEN		Define XPG things.                                          *)
(*    __USE_XOPEN_EXTENDED	Define X/Open Unix things.                          *)
(*    __USE_UNIX98		Define Single Unix V2 things.                              *)
(*    __USE_LARGEFILE64	Define LFS things with separate names.                 *)
(*    __USE_FILE_OFFSET64	Define 64bit interface as default.                   *)
(*    __USE_BSD		Define 4.3BSD things.                                         *)
(*    __USE_SVID		Define SVID things.                                          *)
(*    __USE_MISC		Define things common to BSD and System V Unix.               *)
(*    __USE_GNU		Define GNU extensions.                                        *)
(*    __USE_REENTRANT	Define reentrant/thread-safe *_r functions.              *)
(*    __FAVOR_BSD		Favor 4.3BSD things in cases of conflict.                   *)
(*                                                                             *)
(*    The macros `__GNU_LIBRARY__', `__GLIBC__', and `__GLIBC_MINOR__' are     *)
(*    defined by this file unconditionally.  `__GNU_LIBRARY__' is provided     *)
(*    only for compatibility.  All new code should use the other symbols       *)
(*    to test for features.                                                    *)
(*                                                                             *)
(*    All macros listed above as possibly being defined by this file are       *)
(*    explicitly undefined if they are not explicitly defined.                 *)
(*    Feature-test macros that are not defined by the user or compiler         *)
(*    but are implied by the other feature-test macros defined (or by the      *)
(*    lack of any definitions) are defined by the file.                        *)
(*  Undefine everything, so we get a clean slate.   *)
(*  Suppress kernel-name space pollution unless user expressedly asks  *)
(*  for it.                                                            *)
(* # define __KERNEL_STRICT_NAMES *)
(*  Always use ISO C things.   *)

<* IF  __GEN_C__ THEN *>

VAR 
  __USE_ANSI - : INTEGER;

<* ELSE *>

CONST 
  __USE_ANSI = 1;

<* END *>

(*  If _BSD_SOURCE was defined by the user, favor BSD over POSIX.   *)
(*  If _GNU_SOURCE was defined by the user, turn on all the other features.   *)
(*  If nothing (other than _GNU_SOURCE) is defined,  *)
(*  define _BSD_SOURCE and _SVID_SOURCE.             *)

<* IF  __GEN_C__ THEN *>

VAR 
  _BSD_SOURCE - : INTEGER;
  _SVID_SOURCE - : INTEGER;

<* ELSE *>

CONST 
  _BSD_SOURCE = 1;
  _SVID_SOURCE = 1;

<* END *>

(*  This is to enable the ISO C 9x extension.  It will go away as soon  *)
(*  as this standard is officially released.                            *)
(*  If none of the ANSI/POSIX macros are defined, use POSIX.1 and POSIX.2  *)
(*  (and IEEE Std 1003.1b-1993 unless _XOPEN_SOURCE is defined).           *)

<* IF  __GEN_C__ THEN *>

VAR 
  _POSIX_SOURCE - : INTEGER;
  _POSIX_C_SOURCE - : INTEGER;
  __USE_POSIX - : INTEGER;
  __USE_POSIX2 - : INTEGER;
  __USE_POSIX199309 - : INTEGER;
  __USE_POSIX199506 - : INTEGER;
  __USE_MISC - : INTEGER;
  __USE_BSD - : INTEGER;
  __USE_SVID - : INTEGER;

<* ELSE *>

CONST 
  _POSIX_SOURCE = 1;
  _POSIX_C_SOURCE = 199506;
  __USE_POSIX = 1;
  __USE_POSIX2 = 1;
  __USE_POSIX199309 = 1;
  __USE_POSIX199506 = 1;
  __USE_MISC = 1;
  __USE_BSD = 1;
  __USE_SVID = 1;

<* END *>

(*  We do support the IEC 559 math functionality, real and complex.   *)

<* IF  __GEN_C__ THEN *>

VAR 
  __STDC_IEC_559__ - : INTEGER;
  __STDC_IEC_559_COMPLEX__ - : INTEGER;

<* ELSE *>

CONST 
  __STDC_IEC_559__ = 1;
  __STDC_IEC_559_COMPLEX__ = 1;

<* END *>

(*  This macro indicates that the installed library is the GNU C Library.  *)
(*  For historic reasons the value now is 6 and this will stay from now    *)
(*  on.  The use of this variable is deprecated.  Use __GLIBC__ and        *)
(*  __GLIBC_MINOR__ now (see below) when you want to test for a specific   *)
(*  GNU C library version and use the values in <gnu/lib-names.h> to get   *)
(*  the sonames of the shared libraries.                                   *)

<* IF  __GEN_C__ THEN *>

VAR 
  __GNU_LIBRARY__ - : INTEGER;

<* ELSE *>

CONST 
  __GNU_LIBRARY__ = 6;

<* END *>

(*  Major and minor version number of the GNU C library package.  Use  *)
(*  these macros to test for features in specific releases.            *)

<* IF  __GEN_C__ THEN *>

VAR 
  __GLIBC__ - : INTEGER;
  __GLIBC_MINOR__ - : INTEGER;

<* ELSE *>

CONST 
  __GLIBC__ = 2;
  __GLIBC_MINOR__ = 1;

<* END *>

(*  This is here only because every header file already includes this one.   *)
(*  Copyright (C) 1992,93,94,95,96,97,98,99 Free Software Foundation, Inc.     *)
(*  This file is part of the GNU C Library.                                    *)
(*                                                                             *)
(*  The GNU C Library is free software; you can redistribute it and/or         *)
(*  modify it under the terms of the GNU Library General Public License as     *)
(*  published by the Free Software Foundation; either version 2 of the         *)
(*  License, or (at your option) any later version.                            *)
(*                                                                             *)
(*  The GNU C Library is distributed in the hope that it will be useful,       *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of             *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          *)
(*  Library General Public License for more details.                           *)
(*                                                                             *)
(*  You should have received a copy of the GNU Library General Public          *)
(*  License along with the GNU C Library; see the file COPYING.LIB.  If not,   *)
(*  write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,  *)
(*  Boston, MA 02111-1307, USA.                                                *)

<* IF  __GEN_C__ THEN *>

VAR 
  _SYS_CDEFS_H - : INTEGER;

<* ELSE *>

CONST 
  _SYS_CDEFS_H = 1;

<* END *>

(*  We are almost always included from features.h.  *)
(*  Some user header file might have defined this before.   *)
(* # define __inline		/* No inline functions.  */ *)

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE __P ( args: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE __PMT ( args: ARRAY OF SYSTEM.BYTE );
<* END *>

(* #  define __const		/* No ANSI C keywords.  */ *)
(* #  define __signed *)
(* #  define __volatile *)
(* #  define __DOTS *)
(*  For these things, GCC behaves the ANSI way normally,  *)
(*  and the non-ANSI way under -traditional.              *)

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE __CONCAT ( x, y: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE __STRING ( x: ARRAY OF SYSTEM.BYTE );
<* END *>

(* # define __ptr_t char * *)
(* # define __long_double_t  long double *)
(*  The BSD header files use the ANSI keywords unmodified (this means that   *)
(*  old programs may lose if they use the new keywords as identifiers), but  *)
(*  those names are not available under -traditional.  We define them to     *)
(*  their __ versions, which are taken care of above.                        *)
(*  C++ needs to know that types and declarations are C, not C++.   *)
(* # define __BEGIN_DECLS *)
(* # define __END_DECLS *)
(*  __asm__ ("xyz") is used throughout the headers to rename functions    *)
(*  at the assembly language level.  This is wrapped by the __REDIRECT    *)
(*  macro, in order to support compilers that can do this some other      *)
(*  way.  When compilers don't support asm-names at all, we have to do    *)
(*  preprocessor tricks instead (which don't have exactly the right       *)
(*  semantics, but it's the best we can do).                              *)
(*                                                                        *)
(*  Example:                                                              *)
(*  int __REDIRECT(setpgrp, __P((__pid_t pid, __pid_t pgrp)), setpgid);   *)
(*  GCC has various useful declarations that can be made with the    *)
(*  `__attribute__' syntax.  All of the ways we use this do fine if  *)
(*  they are omitted for compilers that don't understand it.         *)

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE __attribute__ ( xyz: ARRAY OF SYSTEM.BYTE );
<* END *>

(*  It is possible to compile containing GCC extensions even if GCC is    *)
(*  run in pedantic mode if the uses are carefully marked using the       *)
(*  `__extension__' keyword.  But this is not generally available before  *)
(*  version 2.8.                                                          *)
(* # define __extension__		/* Ignore */ *)
(*  __restrict is known in EGCS 1.2 and above.  *)
(* # define __restrict	/* Ignore */ *)
(*  If we don't have __REDIRECT, prototypes will be missing if  *)
(*  __USE_FILE_OFFSET64 but not __USE_LARGEFILE[64].            *)
(*  Decide whether we can define 'extern inline' functions in headers.   *)
(*  This is here only because every header file already includes this one.   *)
(*  Get the definitions of all the appropriate `__stub_FUNCTION' symbols.     *)
(*  <gnu/stubs.h> contains `#define __stub_FUNCTION' when FUNCTION is a stub  *)
(*  which will always return failure (and set errno to ENOSYS).               *)
(*                                                                            *)
(*  We avoid including <gnu/stubs.h> when compiling the C library itself to   *)
(*  avoid a dependency loop.  stubs.h depends on every object file.  If       *)
(*  this #include were done for the library source code, then every object    *)
(*  file would depend on stubs.h.                                             *)
(*  This file is automatically generated.                    *)
(*  It defines a symbol `__stub_FUNCTION' for each function  *)
(*  in the C library which is a stub, meaning it will fail   *)
(*  every time called, usually setting errno to ENOSYS.      *)
(* #define __stub___kernel_cosl *)
(* #define __stub___kernel_sinl *)
(* #define __stub___kernel_tanl *)
(* #define __stub_chflags *)
(* #define __stub_erfcl *)
(* #define __stub_erfl *)
(* #define __stub_fattach *)
(* #define __stub_fchflags *)
(* #define __stub_fdetach *)
(* #define __stub_fexecve *)
(* #define __stub_getcontext *)
(* #define __stub_getmsg *)
(* #define __stub_getpmsg *)
(* #define __stub_gtty *)
(* #define __stub_j0l *)
(* #define __stub_j1l *)
(* #define __stub_jnl *)
(* #define __stub_lgammal *)
(* #define __stub_lgammal_r *)
(* #define __stub_madvise *)
(* #define __stub_makecontext *)
(* #define __stub_putmsg *)
(* #define __stub_putpmsg *)
(* #define __stub_revoke *)
(* #define __stub_setcontext *)
(* #define __stub_setlogin *)
(* #define __stub_sigreturn *)
(* #define __stub_sstk *)
(* #define __stub_stty *)
(* #define __stub_swapcontext *)
(* #define __stub_y0l *)
(* #define __stub_y1l *)
(* #define __stub_ynl *)
(* # define __need_size_t *)
(* # define __need_NULL *)
(*  Any one of these symbols __need_* means that GNU libc              *)
(*  wants us just to define one data type.  So don't define            *)
(*  the symbols that indicate this file's entire job has been done.    *)
(*  This avoids lossage on SunOS but only if stdtypes.h comes first.  *)
(*  There's no way to win with the other order!  Sun lossage.         *)
(*  On 4.3bsd-net2, make sure ansi.h is included, so we have  *)
(*  one less case to deal with in the following.              *)
(*  In 4.3bsd-net2, machine/ansi.h defines these symbols, which are  *)
(*  defined if the corresponding type is *not* defined.              *)
(*  FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_         *)
(*  Sequent's header files use _PTRDIFF_T_ in some conflicting way.  *)
(*  Just ignore it.                                                  *)
(*  On VxWorks, <type/vxTypesBase.h> may have defined macros like        *)
(*  _TYPE_size_t which will typedef size_t.  fixincludes patched the     *)
(*  vxTypesBase.h so that this macro is only defined if _GCC_SIZE_T is   *)
(*  not defined, and so that defining this macro defines _GCC_SIZE_T.    *)
(*  If we find that the macros are still defined at this point, we must  *)
(*  invoke them so that the type is defined as expected.                 *)
(*  In case nobody has defined these types, but we aren't running under  *)
(*  GCC 2.00, make sure that __PTRDIFF_TYPE__, __SIZE__TYPE__, and       *)
(*  __WCHAR_TYPE__ have reasonable values.  This can happen if the       *)
(*  parts of GCC is compiled by an older compiler, that actually         *)
(*  include gstddef.h, such as collect2.                                 *)
(*  Signed type of difference of two pointers.   *)
(*  Define this type if we are doing the whole job,  *)
(*  or if we want this type in particular.           *)
(*  Unsigned type of `sizeof' something.   *)
(*  Define this type if we are doing the whole job,  *)
(*  or if we want this type in particular.           *)
(* #define __size_t__	/* BeOS */ *)
(* #define _SIZE_T *)
(* #define _SYS_SIZE_T_H *)
(* #define _T_SIZE_ *)
(* #define _T_SIZE *)
(* #define __SIZE_T *)
(* #define _SIZE_T_ *)
(* #define _BSD_SIZE_T_ *)
(* #define _SIZE_T_DEFINED_ *)
(* #define _SIZE_T_DEFINED *)
(* #define ___int_size_t_h *)
(* #define _GCC_SIZE_T *)
(* #define _SIZET_ *)
(* #define __size_t *)
(* #define __SIZE_TYPE__ unsigned long int *)

TYPE 
  size_t = LONGCARD;

  _G_size_t = LONGCARD;

  _IO_size_t = LONGCARD;

(*  Wide character type.                                           *)
(*  Locale-writers should change this as necessary to              *)
(*  be big enough to hold unique values not between 0 and 127,     *)
(*  and not (wchar_t) -1, for each defined multibyte character.    *)
(*  Define this type if we are doing the whole job,  *)
(*  or if we want this type in particular.           *)
(*  In 4.3bsd-net2, leave these undefined to indicate that size_t, etc.  *)
(*  are already defined.                                                 *)
(*  BSD/OS 3.1 requires the MACHINE_ANSI_H check here.  FreeBSD 2.x apparently  *)
(*  does not, even though there is a check for MACHINE_ANSI_H above.            *)
(*  A null pointer constant.   *)
(* #define NULL ((void * )0) *)
(* #  define __need___va_list *)
(*  stdarg.h for GNU.                                           *)
(*  Note that the type used in va_arg is supposed to match the  *)
(*  actual type **after default promotions**.                   *)
(*  Thus, va_arg (..., short) is not valid.                     *)
(*  Define __gnuc_va_list.   *)
(* #define __GNUC_VA_LIST *)

  __gnuc_va_list = SYSTEM.ADDRESS;

  _G_va_list = SYSTEM.ADDRESS;

  _IO_va_list = SYSTEM.ADDRESS;

(*  Define the standard macros for the user,         *)
(*  if this invocation was from the user program.    *)
(*  Copyright (C) 1991, 92, 94, 95, 96, 97, 98 Free Software Foundation, Inc.  *)
(*  This file is part of the GNU C Library.                                    *)
(*                                                                             *)
(*  The GNU C Library is free software; you can redistribute it and/or         *)
(*  modify it under the terms of the GNU Library General Public License as     *)
(*  published by the Free Software Foundation; either version 2 of the         *)
(*  License, or (at your option) any later version.                            *)
(*                                                                             *)
(*  The GNU C Library is distributed in the hope that it will be useful,       *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of             *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          *)
(*  Library General Public License for more details.                           *)
(*                                                                             *)
(*  You should have received a copy of the GNU Library General Public          *)
(*  License along with the GNU C Library; see the file COPYING.LIB.  If not,   *)
(*  write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,  *)
(*  Boston, MA 02111-1307, USA.                                                *)
(*                                                                  *)
(*  * Never include this file directly; use <sys/types.h> instead.  *)
(*                                                                  *)

<* IF  __GEN_C__ THEN *>

VAR 
  _BITS_TYPES_H - : INTEGER;

<* ELSE *>

CONST 
  _BITS_TYPES_H = 1;

<* END *>

(* #define __need_size_t *)
(*  Convenience types.   *)

TYPE 
  __u_char = SHORTCARD;

  __u_short = SYSTEM.CARD16;

  __u_int = SYSTEM.unsigned;

  __u_long = LONGCARD;

  __quad_t = RECORD
    __val: ARRAY [0..2-1] OF LONGINT;
  END;

  __u_quad_t = RECORD
    __val: ARRAY [0..2-1] OF __u_long;
  END;

  __int8_t = CHAR;

  __uint8_t = SHORTCARD;

  __int16_t = SYSTEM.INT16;

  __uint16_t = SYSTEM.CARD16;

  __int32_t = SYSTEM.int;

  __uint32_t = SYSTEM.unsigned;

  __qaddr_t = POINTER TO __quad_t;

  __dev_t = __u_quad_t;   (*  Type of device numbers.   *)

  __uid_t = SYSTEM.unsigned;   (*  Type of user identifications.   *)

  _G_uid_t = SYSTEM.unsigned;

  _IO_uid_t = SYSTEM.unsigned;

  __gid_t = SYSTEM.unsigned;   (*  Type of group identifications.   *)

  __ino_t = LONGCARD;   (*  Type of file serial numbers.   *)

  __mode_t = SYSTEM.unsigned;   (*  Type of file attribute bitmasks.   *)

  __nlink_t = SYSTEM.unsigned;   (*  Type of file link counts.   *)

  __off_t = LONGINT;   (*  Type of file sizes and offsets.   *)

  _G_off_t = LONGINT;

  _IO_off_t = LONGINT;

  _G_fpos_t = LONGINT;

  _IO_pos_t = LONGINT;   (*  obsolete  *)

  _IO_fpos_t = LONGINT;

  __loff_t = __quad_t;   (*  Type of file sizes and offsets.   *)

  __pid_t = SYSTEM.int;   (*  Type of process identifications.   *)

  _G_pid_t = SYSTEM.int;

  _IO_pid_t = SYSTEM.int;

  __ssize_t = SYSTEM.int;   (*  Type of a byte count, or error.   *)

  _G_ssize_t = SYSTEM.int;

  _IO_ssize_t = SYSTEM.int;

  __rlim_t = LONGINT;   (*  Type of resource counts.   *)

  __rlim64_t = __quad_t;   (*  Type of resource counts (LFS).   *)

  __id_t = SYSTEM.unsigned;   (*  General type for ID.   *)

  __fsid_t = RECORD
    __val: ARRAY [0..2-1] OF SYSTEM.int;
  END;   (*  Type of file system IDs.   *)

(*  Everythin' else.   *)

  __daddr_t = SYSTEM.int;   (*  The type of a disk address.   *)

  __caddr_t = POINTER TO CHAR;

  __time_t = LONGINT;

  __swblk_t = LONGINT;   (*  Type of a swap block maybe?   *)

  __clock_t = LONGINT;

(*  One element in the file descriptor mask array.   *)

  __fd_mask = LONGCARD;

(*  Number of descriptors that can fit in an `fd_set'.   *)

<* IF  __GEN_C__ THEN *>

VAR 
  __FD_SETSIZE - : INTEGER;

<* ELSE *>

CONST 
  __FD_SETSIZE = 1024;

<* END *>

(*  It's easier to assume 8-bit bytes than to get CHAR_BIT.   *)
(* #define __NFDBITS	(8 * sizeof (__fd_mask)) *)

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE __FDELT ( d: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE __FDMASK ( d: ARRAY OF SYSTEM.BYTE );
<* END *>

(*  fd_set for select and pselect.   *)

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE __FDS_BITS ( set: ARRAY OF SYSTEM.BYTE );
<* END *>

TYPE 
  __fd_set = RECORD
    (*  XPG4.2 requires this member name.  Otherwise avoid the name  *)   (*  from the global namespace.                                   *)
    __fds_bits: ARRAY [0..32-1] OF __fd_mask;  (* [__FD_SETSIZE / __NFDBITS]; *)
  END;

  __key_t = SYSTEM.int;

(*  Used in `struct shmid_ds'.   *)

  __ipc_pid_t = SYSTEM.CARD16;

(*  Types from the Large File Support interface.   *)
(*  Type to count number os disk blocks.   *)

  __blkcnt_t = LONGCARD;

  __blkcnt64_t = __u_quad_t;

(*  Type to count file system blocks.   *)

  __fsblkcnt_t = LONGINT;

  __fsblkcnt64_t = __quad_t;

(*  Type to count file system inodes.   *)

  __fsfilcnt_t = LONGCARD;

  __fsfilcnt64_t = __u_quad_t;

(*  Type of file serial numbers.   *)

  __ino64_t = LONGCARD;

(*  Type of file sizes and offsets.   *)

  __off64_t = __loff_t;

  _G_off64_t = __off64_t;

  _IO_off64_t = _G_off64_t;

  _G_fpos64_t = __off64_t;

  _IO_fpos64_t = _G_fpos64_t;

(*  Used in XTI.   *)

  __t_scalar_t = SYSTEM.int;

  __t_uscalar_t = SYSTEM.unsigned;

(*  Duplicates info from stdint.h but this is used in unistd.h.   *)

  __intptr_t = SYSTEM.int;

(*  Now add the thread types.   *)
(*  The opaque type of streams.   *)

  H2D_PtrSChar = POINTER TO CHAR;

  H2D_Ptr_IO_marker = POINTER TO _IO_marker;

  H2D_Ptr_IO_FILE = POINTER TO _IO_FILE;

  _IO_FILE = RECORD
    _flags         : SYSTEM.int;                     (*  High-order word is _IO_MAGIC; rest is flags.  *)
    (*  The following pointers correspond to the C++ streambuf protocol.  *)
(*  Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly.  *)
    _IO_read_ptr   : H2D_PtrSChar;                   (*  Current read pointer  *)
    _IO_read_end   : H2D_PtrSChar;                   (*  End of get area.  *)
    _IO_read_base  : H2D_PtrSChar;                   (*  Start of putback+get area.  *)
    _IO_write_base : H2D_PtrSChar;                   (*  Start of put area.  *)
    _IO_write_ptr  : H2D_PtrSChar;                   (*  Current put pointer.  *)
    _IO_write_end  : H2D_PtrSChar;                   (*  End of put area.  *)
    _IO_buf_base   : H2D_PtrSChar;                   (*  Start of reserve area.  *)
    _IO_buf_end    : H2D_PtrSChar;                   (*  End of reserve area.  *)
    (*  The following fields are used to support backing up and undo.  *)
    _IO_save_base  : H2D_PtrSChar;                   (*  Pointer to start of non-current get area.  *)
    _IO_backup_base: H2D_PtrSChar;                   (*  Pointer to first valid character of backup area  *)
    _IO_save_end   : H2D_PtrSChar;                   (*  Pointer to end of non-current get area.  *)
    _markers       : H2D_Ptr_IO_marker;
    _chain         : H2D_Ptr_IO_FILE;
    _fileno        : SYSTEM.int;
    _blksize       : SYSTEM.int;
    _old_offset    : __off_t;                        (*  This used to be _offset but it's too small.   *)
    (*  1+column number of pbase(); 0 is unknown.  *)
    _cur_column    : SYSTEM.CARD16;
    _vtable_offset : CHAR;
    _shortbuf      : ARRAY [0..1-1] OF CHAR;
    (*   char* _save_gptr;  char* _save_egptr;  *)
    _lock          : SYSTEM.ADDRESS;
    _offset        : __off64_t;
    (*  Make sure we don't get into trouble again.   *)
    _unused2       : ARRAY [0..16-1] OF SYSTEM.int;
  END;

  FILE = _IO_FILE;

<* IF  __GEN_C__ THEN *>

VAR 
  __FILE_defined - : INTEGER;

<* ELSE *>

CONST 
  __FILE_defined = 1;

<* END *>

(* #define _STDIO_USES_IOSTREAM *)
(*  Copyright (C) 1991, 92, 93, 94, 95, 97, 98 Free Software Foundation, Inc.  *)
(*  This file is part of the GNU IO Library.                                   *)
(*  Written by Per Bothner <bothner@cygnus.com>.                               *)
(*                                                                             *)
(*  This library is free software; you can redistribute it and/or              *)
(*  modify it under the terms of the GNU General Public License as             *)
(*  published by the Free Software Foundation; either version 2, or (at        *)
(*  your option) any later version.                                            *)
(*                                                                             *)
(*  This library is distributed in the hope that it will be useful, but        *)
(*  WITHOUT ANY WARRANTY; without even the implied warranty of                 *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          *)
(*  General Public License for more details.                                   *)
(*                                                                             *)
(*  You should have received a copy of the GNU General Public License          *)
(*  along with this library; see the file COPYING.  If not, write to           *)
(*  the Free Software Foundation, 59 Temple Place - Suite 330, Boston,         *)
(*  MA 02111-1307, USA.                                                        *)
(*                                                                             *)
(*  As a special exception, if you link this library with files                *)
(*  compiled with a GNU compiler to produce an executable, this does           *)
(*  not cause the resulting executable to be covered by the GNU General        *)
(*  Public License.  This exception does not however invalidate any            *)
(*  other reasons why the executable file might be covered by the GNU          *)
(*  General Public License.                                                    *)
(* #define _IO_STDIO_H *)
(*  This file is needed by libio to define various configuration parameters.  *)
(*  These are always the same in the GNU C library.                           *)

<* IF  __GEN_C__ THEN *>

VAR 
  _G_config_h - : INTEGER;

<* ELSE *>

CONST 
  _G_config_h = 1;

<* END *>

(*  Define types for libio in terms of the standard internal type names.   *)
(* #define __need_size_t *)
(* #define __need_wchar_t *)
(* #define __need_wint_t *)
(* #define __need_NULL *)
(*  Integral type unchanged by default argument promotions that can     *)
(*  hold any value corresponding to members of the extended character   *)
(*  set, as well as at least one value that does not correspond to any  *)
(*  member of the extended character set.                               *)
(* # define _WINT_T *)

TYPE 
  wint_t = SYSTEM.unsigned;

  _G_wint_t = SYSTEM.unsigned;

  _G_int16_t = SYSTEM.int;

  _G_int32_t = SYSTEM.int;

  _G_uint16_t = SYSTEM.unsigned;

  _G_uint32_t = SYSTEM.unsigned;

<* IF  __GEN_C__ THEN *>

VAR 
  _G_HAVE_BOOL - : INTEGER;

<* ELSE *>

CONST 
  _G_HAVE_BOOL = 1;

<* END *>

(*  These library features are always available in the GNU C library.   *)

<* IF  __GEN_C__ THEN *>

VAR 
  _G_HAVE_ATEXIT - : INTEGER;
  _G_HAVE_SYS_CDEFS - : INTEGER;
  _G_HAVE_SYS_WAIT - : INTEGER;
  _G_NEED_STDARG_H - : INTEGER;
  _G_HAVE_PRINTF_FP - : INTEGER;
  _G_HAVE_MMAP - : INTEGER;
  _G_HAVE_LONG_DOUBLE_IO - : INTEGER;
  _G_HAVE_IO_FILE_OPEN - : INTEGER;
  _G_HAVE_IO_GETLINE_INFO - : INTEGER;
  _G_IO_IO_FILE_VERSION - : INTEGER;

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE _G_FSTAT64 ( fd, buf: ARRAY OF SYSTEM.BYTE );

<* ELSE *>

CONST 
  _G_HAVE_ATEXIT = 1;
  _G_HAVE_SYS_CDEFS = 1;
  _G_HAVE_SYS_WAIT = 1;
  _IO_HAVE_SYS_WAIT = _G_HAVE_SYS_WAIT;
  _G_NEED_STDARG_H = 1;
  _G_HAVE_PRINTF_FP = 1;
  _G_HAVE_MMAP = 1;
  _G_HAVE_LONG_DOUBLE_IO = 1;
  _G_HAVE_IO_FILE_OPEN = 1;
  _G_HAVE_IO_GETLINE_INFO = 1;
  _G_IO_IO_FILE_VERSION = 20001H;

<* END *>

(*  This is defined by <bits/stat.h> if `st_blksize' exists.   *)
(* #define _G_HAVE_ST_BLKSIZE defined (_STATBUF_ST_BLKSIZE) *)

<* IF  __GEN_C__ THEN *>

VAR 
  _G_BUFSIZ - : INTEGER;

<* ELSE *>

CONST 
  _G_BUFSIZ = 8192;
  _IO_BUFSIZ = _G_BUFSIZ;

<* END *>

(*  These are the vtbl details for ELF.   *)

<* IF  __GEN_C__ THEN *>

VAR 
  _G_NAMES_HAVE_UNDERSCORE - : INTEGER;
  _G_VTABLE_LABEL_HAS_LENGTH - : INTEGER;
  _G_USING_THUNKS - : INTEGER;
  _G_VTABLE_LABEL_PREFIX - : ARRAY [0..5] OF CHAR;

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE _G_ARGS ( ARGLIST: ARRAY OF SYSTEM.BYTE );

<* ELSE *>

CONST 
  _G_NAMES_HAVE_UNDERSCORE = 0;
  _G_VTABLE_LABEL_HAS_LENGTH = 1;
  _G_USING_THUNKS = 1;
  _G_VTABLE_LABEL_PREFIX = '__vt_';

<* END *>

(*  This define avoids name pollution if we're using GNU stdarg.h  *)
(* # define __need___va_list *)
(*  For backward compatibility  *)

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE _PARAMS ( protos: ARRAY OF SYSTEM.BYTE );
<* END *>

(* # ifndef const *)
(* #  define const *)
(* # endif *)

<* IF  __GEN_C__ THEN *>

VAR 
  _IO_UNIFIED_JUMPTABLES - : INTEGER;
  EOF - : INTEGER;
  _IOS_INPUT - : INTEGER;
  _IOS_OUTPUT - : INTEGER;
  _IOS_ATEND - : INTEGER;
  _IOS_APPEND - : INTEGER;
  _IOS_TRUNC - : INTEGER;
  _IOS_NOCREATE - : INTEGER;
  _IOS_NOREPLACE - : INTEGER;
  _IOS_BIN - : INTEGER;

<* ELSE *>

CONST 
  _IO_UNIFIED_JUMPTABLES = 1;
  EOF = -1;
  _IOS_INPUT = 1;
  _IOS_OUTPUT = 2;
  _IOS_ATEND = 4;
  _IOS_APPEND = 8;
  _IOS_TRUNC = 16;
  _IOS_NOCREATE = 32;
  _IOS_NOREPLACE = 64;
  _IOS_BIN = 128;

<* END *>

(*  Magic numbers and bits for the _flags field.           *)
(*  The magic numbers use the high-order bits of _flags;   *)
(*  the remaining bits are available for variable flags.   *)
(*  Note: The magic numbers must all be negative if stdio  *)
(*  emulation is desired.                                  *)

<* IF  __GEN_C__ THEN *>

VAR 
  _IO_MAGIC - : INTEGER;
  _OLD_STDIO_MAGIC - : INTEGER;
  _IO_MAGIC_MASK - : INTEGER;
  _IO_USER_BUF - : INTEGER;
  _IO_UNBUFFERED - : INTEGER;
  _IO_NO_READS - : INTEGER;
  _IO_NO_WRITES - : INTEGER;
  _IO_EOF_SEEN - : INTEGER;
  _IO_ERR_SEEN - : INTEGER;
  _IO_DELETE_DONT_CLOSE - : INTEGER;
  _IO_LINKED - : INTEGER;
  _IO_IN_BACKUP - : INTEGER;
  _IO_LINE_BUF - : INTEGER;
  _IO_TIED_PUT_GET - : INTEGER;
  _IO_CURRENTLY_PUTTING - : INTEGER;
  _IO_IS_APPENDING - : INTEGER;
  _IO_IS_FILEBUF - : INTEGER;
  _IO_BAD_SEEN - : INTEGER;

<* ELSE *>

CONST 
  _IO_MAGIC = 0FBAD0000H;   (*  Magic number  *)
  _OLD_STDIO_MAGIC = 0FABC0000H;   (*  Emulate old stdio.  *)
  _IO_MAGIC_MASK = 0FFFF0000H;
  _IO_USER_BUF = 1;   (*  User owns buffer; don't delete it on close.  *)
  _IO_UNBUFFERED = 2;
  _IO_NO_READS = 4;   (*  Reading not allowed  *)
  _IO_NO_WRITES = 8;   (*  Writing not allowd  *)
  _IO_EOF_SEEN = 10H;
  _IO_ERR_SEEN = 20H;
  _IO_DELETE_DONT_CLOSE = 40H;   (*  Don't call close(_fileno) on cleanup.  *)
  _IO_LINKED = 80H;   (*  Set if linked (using _chain) to streambuf::_list_all. *)
  _IO_IN_BACKUP = 100H;
  _IO_LINE_BUF = 200H;
  _IO_TIED_PUT_GET = 400H;   (*  Set if put and get pointer logicly tied.  *)
  _IO_CURRENTLY_PUTTING = 800H;
  _IO_IS_APPENDING = 1000H;
  _IO_IS_FILEBUF = 2000H;
  _IO_BAD_SEEN = 4000H;

<* END *>

(*  These are "formatting flags" matching the iostream fmtflags enum values.  *)

<* IF  __GEN_C__ THEN *>

VAR 
  _IO_SKIPWS - : INTEGER;
  _IO_LEFT - : INTEGER;
  _IO_RIGHT - : INTEGER;
  _IO_INTERNAL - : INTEGER;
  _IO_DEC - : INTEGER;
  _IO_OCT - : INTEGER;
  _IO_HEX - : INTEGER;
  _IO_SHOWBASE - : INTEGER;
  _IO_SHOWPOINT - : INTEGER;
  _IO_UPPERCASE - : INTEGER;
  _IO_SHOWPOS - : INTEGER;
  _IO_SCIENTIFIC - : INTEGER;
  _IO_FIXED - : INTEGER;
  _IO_UNITBUF - : INTEGER;
  _IO_STDIO - : INTEGER;
  _IO_DONT_CLOSE - : INTEGER;
  _IO_BOOLALPHA - : INTEGER;

<* ELSE *>

CONST 
  _IO_SKIPWS = 1;
  _IO_LEFT = 2;
  _IO_RIGHT = 4;
  _IO_INTERNAL = 8;
  _IO_DEC = 16;
  _IO_OCT = 32;
  _IO_HEX = 64;
  _IO_SHOWBASE = 128;
  _IO_SHOWPOINT = 256;
  _IO_UPPERCASE = 512;
  _IO_SHOWPOS = 1024;
  _IO_SCIENTIFIC = 2048;
  _IO_FIXED = 4096;
  _IO_UNITBUF = 8192;
  _IO_STDIO = 16384;
  _IO_DONT_CLOSE = 32768;
  _IO_BOOLALPHA = 65536;

<* END *>

TYPE 
  _IO_jump_t = RECORD
    (* Declaration without definition *)
  END;

(* struct _IO_FILE; *)
(*  Handle lock.   *)

  _IO_lock_t = SYSTEM.void;

(*  A streammarker remembers a position in a buffer.  *)

  _IO_marker = RECORD
    _next: H2D_Ptr_IO_marker;
    _sbuf: H2D_Ptr_IO_FILE;
    (*      If _pos >= 0                                 *)   (*  it points to _buf->Gbase()+_pos. FIXME comment   *)
    (*  if _pos < 0, it points to _buf->eBptr()+_pos. FIXME comment  *)
    _pos : SYSTEM.int;
  END;

(* #define __HAVE_COLUMN /* temporary */ *)

  _IO_FILE_plus = _IO_jump_t;

VAR 
  _IO_2_1_stdin_: _IO_FILE_plus;
  _IO_2_1_stdout_: _IO_FILE_plus;
  _IO_2_1_stderr_: _IO_FILE_plus;

(* #define _IO_stdin ((_IO_FILE* )(&_IO_2_1_stdin_)) *)
(* #define _IO_stdout ((_IO_FILE* )(&_IO_2_1_stdout_)) *)
(* #define _IO_stderr ((_IO_FILE* )(&_IO_2_1_stderr_)) *)

PROCEDURE __underflow ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

PROCEDURE __uflow ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

PROCEDURE __overflow ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE _IO_getc_unlocked ( _fp: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE _IO_peekc_unlocked ( _fp: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE _IO_putc_unlocked ( _ch, _fp: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE _IO_feof_unlocked ( __fp: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE _IO_ferror_unlocked ( __fp: ARRAY OF SYSTEM.BYTE );

<* END *>

PROCEDURE _IO_getc ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

PROCEDURE _IO_putc ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

PROCEDURE _IO_feof ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

PROCEDURE _IO_ferror ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

PROCEDURE _IO_peekc_locked ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  This one is for Emacs.  *)

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE _IO_PENDING_OUTPUT_COUNT ( _fp: ARRAY OF SYSTEM.BYTE );

<* END *>

PROCEDURE _IO_flockfile ( SEQ arg0: SYSTEM.BYTE );

PROCEDURE _IO_funlockfile ( SEQ arg0: SYSTEM.BYTE );

PROCEDURE _IO_ftrylockfile ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE _IO_peekc ( _fp: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE _IO_flockfile ( _fp: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE _IO_funlockfile ( _fp: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE _IO_ftrylockfile ( _fp: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE _IO_cleanup_region_start ( _fct, _fp: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE _IO_cleanup_region_end ( _Doit: ARRAY OF SYSTEM.BYTE );

<* END *>

PROCEDURE _IO_vfscanf ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

PROCEDURE _IO_vfprintf ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

PROCEDURE _IO_padn ( SEQ arg0: SYSTEM.BYTE ): __ssize_t;

PROCEDURE _IO_sgetn ( SEQ arg0: SYSTEM.BYTE ): size_t;

PROCEDURE _IO_seekoff ( SEQ arg0: SYSTEM.BYTE ): __off64_t;

PROCEDURE _IO_seekpos ( SEQ arg0: SYSTEM.BYTE ): __off64_t;

PROCEDURE _IO_free_backup_area ( SEQ arg0: SYSTEM.BYTE );

(*  The type of the second argument to `fgetpos' and `fsetpos'.   *)

TYPE 
  fpos_t = LONGINT;

(*  The possibilities for the third argument to `setvbuf'.   *)

<* IF  __GEN_C__ THEN *>

VAR 
  _IOFBF - : INTEGER;
  _IOLBF - : INTEGER;
  _IONBF - : INTEGER;

<* ELSE *>

CONST 
  _IOFBF = 0;   (*  Fully buffered.   *)
  _IOLBF = 1;   (*  Line buffered.   *)
  _IONBF = 2;   (*  No buffering.   *)

<* END *>

(*  Default buffer size.   *)
(*  End of file character.                                       *)
(*  Some things throughout the library rely on this being -1.    *)
(*  The possibilities for the third argument to `fseek'.  *)
(*  These values should not be changed.                   *)

<* IF  __GEN_C__ THEN *>

VAR 
  SEEK_SET - : INTEGER;
  SEEK_CUR - : INTEGER;
  SEEK_END - : INTEGER;

<* ELSE *>

CONST 
  SEEK_SET = 0;   (*  Seek from beginning of file.   *)
  SEEK_CUR = 1;   (*  Seek from current position.   *)
  SEEK_END = 2;   (*  Seek from end of file.   *)

<* END *>

(*  Default path prefix for `tempnam' and `tmpnam'.   *)

<* IF  __GEN_C__ THEN *>

VAR 
  P_tmpdir - : ARRAY [0..4] OF CHAR;

<* ELSE *>

CONST 
  P_tmpdir = '/tmp';

<* END *>

(*    Get the values:                                                        *)
(*    L_tmpnam	How long an array of chars must be to be passed to `tmpnam'.  *)
(*    TMP_MAX	The minimum number of unique filenames generated by tmpnam     *)
(*    		(and tempnam when it uses tmpnam's name space),                      *)
(* 		or tempnam (the two are separate).                                      *)
(*    L_ctermid	How long an array to pass to `ctermid'.                      *)
(*    L_cuserid	How long an array to pass to `cuserid'.                      *)
(*    FOPEN_MAX	Minimum number of files that can be open at once.            *)
(*    FILENAME_MAX	Maximum length of a filename.                             *)
(*  Copyright (C) 1994, 1997, 1998 Free Software Foundation, Inc.              *)
(*  This file is part of the GNU C Library.                                    *)
(*                                                                             *)
(*  The GNU C Library is free software; you can redistribute it and/or         *)
(*  modify it under the terms of the GNU Library General Public License as     *)
(*  published by the Free Software Foundation; either version 2 of the         *)
(*  License, or (at your option) any later version.                            *)
(*                                                                             *)
(*  The GNU C Library is distributed in the hope that it will be useful,       *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of             *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU          *)
(*  Library General Public License for more details.                           *)
(*                                                                             *)
(*  You should have received a copy of the GNU Library General Public          *)
(*  License along with the GNU C Library; see the file COPYING.LIB.  If not,   *)
(*  write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,  *)
(*  Boston, MA 02111-1307, USA.                                                *)

<* IF  __GEN_C__ THEN *>

VAR 
  L_tmpnam - : INTEGER;
  TMP_MAX - : INTEGER;
  FILENAME_MAX - : INTEGER;
  L_ctermid - : INTEGER;
  L_cuserid - : INTEGER;
  FOPEN_MAX - : INTEGER;

<* ELSE *>

CONST 
  L_tmpnam = 20;
  TMP_MAX = 238328;
  FILENAME_MAX = 4095;
  L_ctermid = 9;
  L_cuserid = 9;
  FOPEN_MAX = 256;

<* END *>

(*  Standard streams.   *)

VAR 
  stdin: H2D_Ptr_IO_FILE;   (*  Standard input stream.   *)
  stdout: H2D_Ptr_IO_FILE;   (*  Standard output stream.   *)
  stderr: H2D_Ptr_IO_FILE;   (*  Standard error output stream.   *)

(*  Remove file FILENAME.   *)

PROCEDURE remove ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Rename file OLD to NEW.   *)

PROCEDURE rename ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Create a temporary file and open it read/write.   *)

PROCEDURE tmpfile ( SEQ arg0: SYSTEM.BYTE ): H2D_Ptr_IO_FILE;

(*  Generate a temporary filename.   *)

PROCEDURE tmpnam ( SEQ arg0: SYSTEM.BYTE ): H2D_PtrSChar;

(*  This is the reentrant variant of `tmpnam'.  The only difference is  *)
(*  that it does not allow S to be NULL.                                *)

PROCEDURE tmpnam_r ( SEQ arg0: SYSTEM.BYTE ): H2D_PtrSChar;

(*  Generate a unique temporary filename using up to five characters of PFX   *)
(*  if it is not NULL.  The directory to put this file in is searched for     *)
(*  as follows: First the environment variable "TMPDIR" is checked.           *)
(*  If it contains the name of a writable directory, that directory is used.  *)
(*  If not and if DIR is not NULL, that value is checked.  If that fails,     *)
(*  P_tmpdir is tried and finally "/tmp".  The storage for the filename       *)
(*  is allocated by `malloc'.                                                 *)

PROCEDURE tempnam ( SEQ arg0: SYSTEM.BYTE ): H2D_PtrSChar;

(*  Close STREAM.   *)

PROCEDURE fclose ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Flush STREAM, or all streams if STREAM is NULL.   *)

PROCEDURE fflush ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Faster versions when locking is not required.   *)

PROCEDURE fflush_unlocked ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Open a file and create a new stream for it.   *)

PROCEDURE fopen ( SEQ arg0: SYSTEM.BYTE ): H2D_Ptr_IO_FILE;

(*  Open a file, replacing an existing stream with it.  *)

PROCEDURE freopen ( SEQ arg0: SYSTEM.BYTE ): H2D_Ptr_IO_FILE;

(*  Create a new stream that refers to an existing system file descriptor.   *)

PROCEDURE fdopen ( SEQ arg0: SYSTEM.BYTE ): H2D_Ptr_IO_FILE;

(*  If BUF is NULL, make STREAM unbuffered.         *)
(*  Else make it use buffer BUF, of size BUFSIZ.    *)

PROCEDURE setbuf ( SEQ arg0: SYSTEM.BYTE );

(*  Make STREAM use buffering mode MODE.                  *)
(*  If BUF is not NULL, use N bytes of it for buffering;  *)
(*  else allocate an internal buffer N bytes long.        *)

PROCEDURE setvbuf ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  If BUF is NULL, make STREAM unbuffered.              *)
(*  Else make it use SIZE bytes of BUF for buffering.    *)

PROCEDURE setbuffer ( SEQ arg0: SYSTEM.BYTE );

(*  Make STREAM line-buffered.   *)

PROCEDURE setlinebuf ( SEQ arg0: SYSTEM.BYTE );

(*  Write formatted output to STREAM.   *)

PROCEDURE fprintf ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Write formatted output to stdout.   *)

PROCEDURE printf ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Write formatted output to S.   *)

PROCEDURE sprintf ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Write formatted output to S from argument list ARG.   *)

PROCEDURE vfprintf ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Write formatted output to stdout from argument list ARG.   *)

PROCEDURE vprintf ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Write formatted output to S from argument list ARG.   *)

PROCEDURE vsprintf ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Maximum chars of output to write in MAXLEN.   *)

PROCEDURE snprintf ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

PROCEDURE __vsnprintf ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

PROCEDURE vsnprintf ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Read formatted input from STREAM.   *)

PROCEDURE fscanf ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Read formatted input from stdin.   *)

PROCEDURE scanf ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Read formatted input from S.   *)

PROCEDURE sscanf ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Read a character from STREAM.   *)

PROCEDURE fgetc ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

PROCEDURE getc ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Read a character from stdin.   *)

PROCEDURE getchar ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  The C standard explicitly says this is a macro, so we always do the  *)
(*  optimization for it.                                                 *)

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE getc ( _fp: ARRAY OF SYSTEM.BYTE );
*)
<* END *>

(*  These are defined in POSIX.1:1996.   *)

PROCEDURE getc_unlocked ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

PROCEDURE getchar_unlocked ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Faster version when locking is not necessary.   *)

PROCEDURE fgetc_unlocked ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Write a character to STREAM.   *)

PROCEDURE fputc ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

PROCEDURE putc ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Write a character to stdout.   *)

PROCEDURE putchar ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  The C standard explicitly says this can be a macro,  *)
(*  so we always do the optimization for it.             *)

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE putc ( _ch, _fp: ARRAY OF SYSTEM.BYTE );
*)
<* END *>

(*  Faster version when locking is not necessary.   *)

PROCEDURE fputc_unlocked ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  These are defined in POSIX.1:1996.   *)

PROCEDURE putc_unlocked ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

PROCEDURE putchar_unlocked ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Get a word (int) from STREAM.   *)

PROCEDURE getw ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Write a word (int) to STREAM.   *)

PROCEDURE putw ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Get a newline-terminated string of finite length from STREAM.   *)

PROCEDURE fgets ( SEQ arg0: SYSTEM.BYTE ): H2D_PtrSChar;

(*  Get a newline-terminated string from stdin, removing the newline.          *)
(*  DO NOT USE THIS FUNCTION!!  There is no limit on how much it will read.    *)

PROCEDURE gets ( SEQ arg0: SYSTEM.BYTE ): H2D_PtrSChar;

(*  Write a string to STREAM.   *)

PROCEDURE fputs ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Write a string, followed by a newline, to stdout.   *)

PROCEDURE puts ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Push a character back onto the input buffer of STREAM.   *)

PROCEDURE ungetc ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Read chunks of generic data from STREAM.   *)

PROCEDURE fread ( SEQ arg0: SYSTEM.BYTE ): size_t;

(*  Write chunks of generic data to STREAM.   *)

PROCEDURE fwrite ( SEQ arg0: SYSTEM.BYTE ): size_t;

(*  Faster versions when locking is not necessary.   *)

PROCEDURE fread_unlocked ( SEQ arg0: SYSTEM.BYTE ): size_t;

PROCEDURE fwrite_unlocked ( SEQ arg0: SYSTEM.BYTE ): size_t;

(*  Seek to a certain position on STREAM.   *)

PROCEDURE fseek ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Return the current position of STREAM.   *)

PROCEDURE ftell ( SEQ arg0: SYSTEM.BYTE ): LONGINT;

(*  Rewind to the beginning of STREAM.   *)

PROCEDURE rewind ( SEQ arg0: SYSTEM.BYTE );

(*  The Single Unix Specification, Version 2, specifies an alternative,  *)
(*  more adequate interface for the two functions above which deal with  *)
(*  file offset.  `long int' is not the right type.  These definitions   *)
(*  are originally defined in the Large File Support API.                *)
(*  Types needed in these functions.   *)
(*                               *)
(* #ifndef off_t                 *)
(* # ifndef __USE_FILE_OFFSET64  *)
(* typedef __off_t off_t;        *)
(* # else                        *)
(* typedef __off64_t off_t;      *)
(* # endif                       *)
(* # define off_t off_t          *)
(* #endif                        *)
(*                               *)
(*  Get STREAM's position.   *)

PROCEDURE fgetpos ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Set STREAM's position.   *)

PROCEDURE fsetpos ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Clear the error and EOF indicators for STREAM.   *)

PROCEDURE clearerr ( SEQ arg0: SYSTEM.BYTE );

(*  Return the EOF indicator for STREAM.   *)

PROCEDURE feof ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Return the error indicator for STREAM.   *)

PROCEDURE ferror ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Faster versions when locking is not required.   *)

PROCEDURE clearerr_unlocked ( SEQ arg0: SYSTEM.BYTE );

PROCEDURE feof_unlocked ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

PROCEDURE ferror_unlocked ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Print a message describing the meaning of the value of errno.   *)

PROCEDURE perror ( SEQ arg0: SYSTEM.BYTE );

(*  These variables normally should not be used directly.  The `strerror'  *)
(*  function provides all the needed functionality.                        *)

VAR 
  sys_nerr: SYSTEM.int;

TYPE 
  H2D_PtrPtrSChar = POINTER TO H2D_PtrSChar;

  H2D_OpenArrayPtrSChar = H2D_PtrPtrSChar;

VAR 
  sys_errlist: H2D_OpenArrayPtrSChar;

(*  Return the system file descriptor for STREAM.   *)

PROCEDURE fileno ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Faster version when locking is not required.   *)

PROCEDURE fileno_unlocked ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Create a new stream connected to a pipe running the given command.   *)

PROCEDURE popen ( SEQ arg0: SYSTEM.BYTE ): H2D_Ptr_IO_FILE;

(*  Close a stream opened by popen and return the status of its child.   *)

PROCEDURE pclose ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Return the name of the controlling terminal.   *)

PROCEDURE ctermid ( SEQ arg0: SYSTEM.BYTE ): H2D_PtrSChar;

(*  These are defined in POSIX.1:1996.   *)
(*  Acquire ownership of STREAM.   *)

PROCEDURE flockfile ( SEQ arg0: SYSTEM.BYTE );

(*  Try to acquire ownership of STREAM but do not block if it is not  *)
(*  possible.                                                         *)

PROCEDURE ftrylockfile ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Relinquish the ownership granted for STREAM.   *)

PROCEDURE funlockfile ( SEQ arg0: SYSTEM.BYTE );

(*  If we are compiling with optimizing read this file.  It contains  *)
(*  several optizing inline functions and macros.                     *)
(*   ***************************************************************************  *)
(*  * Copyright (c) 1998 Free Software Foundation, Inc.                        *  *)
(*  *                                                                          *  *)
(*  * Permission is hereby granted, free of charge, to any person obtaining a  *  *)
(*  * copy of this software and associated documentation files (the            *  *)
(*  * "Software"), to deal in the Software without restriction, including      *  *)
(*  * without limitation the rights to use, copy, modify, merge, publish,      *  *)
(*  * distribute, distribute with modifications, sublicense, and/or sell       *  *)
(*  * copies of the Software, and to permit persons to whom the Software is    *  *)
(*  * furnished to do so, subject to the following conditions:                 *  *)
(*  *                                                                          *  *)
(*  * The above copyright notice and this permission notice shall be included  *  *)
(*  * in all copies or substantial portions of the Software.                   *  *)
(*  *                                                                          *  *)
(*  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  *)
(*  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  *)
(*  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  *)
(*  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  *)
(*  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  *)
(*  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  *)
(*  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *)
(*  *                                                                          *  *)
(*  * Except as contained in this notice, the name(s) of the above copyright   *  *)
(*  * holders shall not be used in advertising or otherwise to promote the     *  *)
(*  * sale, use or other dealings in this Software without prior written       *  *)
(*  * authorization.                                                           *  *)
(*  ***************************************************************************   *)
(*   ***************************************************************************  *)
(*  *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *  *)
(*  *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *  *)
(*  ***************************************************************************   *)
(*                                                                                  *)
(*  * unctrl.h                                                                      *)
(*  *                                                                               *)
(*  * Display a printable version of a control character.                           *)
(*  * Control characters are displayed in caret notation (^x), DELETE is displayed  *)
(*  * as ^?. Printable characters are displayed as is.                              *)
(*                                                                                  *)
(*  $Id: unctrl.h.in,v 1.8 1998/02/11 12:13:45 tom Exp $  *)

<* IF  __GEN_C__ THEN *>

VAR 
  _UNCTRL_H - : INTEGER;
  NCURSES_VERSION - : ARRAY [0..3] OF CHAR;

<* ELSE *>

CONST 
  _UNCTRL_H = 1;
  NCURSES_VERSION = '4.2';

<* END *>

(*   ***************************************************************************  *)
(*  * Copyright (c) 1998 Free Software Foundation, Inc.                        *  *)
(*  *                                                                          *  *)
(*  * Permission is hereby granted, free of charge, to any person obtaining a  *  *)
(*  * copy of this software and associated documentation files (the            *  *)
(*  * "Software"), to deal in the Software without restriction, including      *  *)
(*  * without limitation the rights to use, copy, modify, merge, publish,      *  *)
(*  * distribute, distribute with modifications, sublicense, and/or sell       *  *)
(*  * copies of the Software, and to permit persons to whom the Software is    *  *)
(*  * furnished to do so, subject to the following conditions:                 *  *)
(*  *                                                                          *  *)
(*  * The above copyright notice and this permission notice shall be included  *  *)
(*  * in all copies or substantial portions of the Software.                   *  *)
(*  *                                                                          *  *)
(*  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  *)
(*  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  *)
(*  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  *)
(*  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  *)
(*  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  *)
(*  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  *)
(*  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *)
(*  *                                                                          *  *)
(*  * Except as contained in this notice, the name(s) of the above copyright   *  *)
(*  * holders shall not be used in advertising or otherwise to promote the     *  *)
(*  * sale, use or other dealings in this Software without prior written       *  *)
(*  * authorization.                                                           *  *)
(*  ***************************************************************************   *)
(*   ***************************************************************************  *)
(*  *  Author: Zeyd M. Ben-Halim <zmbenhal@netcom.com> 1992,1995               *  *)
(*  *     and: Eric S. Raymond <esr@snark.thyrsus.com>                         *  *)
(*  ***************************************************************************   *)
(*  $Id: curses.h.in,v 1.78 1999/01/10 03:21:11 tom Exp $  *)

PROCEDURE unctrl ( arg0: chtype ): H2D_PtrSChar;

(*    XSI and SVr4 specify that curses implements 'bool'.  However, C++ may also    *)
(*  * implement it.  If so, we must use the C++ compiler's type to avoid conflict   *)
(*  * with other interfaces.                                                        *)
(*  *                                                                               *)
(*  * To simplify use with/without the configuration script, we define the symbols  *)
(*  * CXX_BUILTIN_BOOL and CXX_TYPE_OF_BOOL; they're edited by the configure        *)
(*  * script.                                                                       *)
(*                                                                                  *)

TYPE 
  bool = SYSTEM.int;

<* IF  __GEN_C__ THEN *>

VAR 
  H2D_Const_TRUE - : INTEGER;
  H2D_Const_FALSE - : INTEGER;

<* ELSE *>

CONST 
  H2D_Const_TRUE = 1;
  H2D_Const_FALSE = 0;

<* END *>

(*                                                                               *)
(*  * XSI attributes.  In the ncurses implementation, they are identical to the  *)
(*  * A_ attributes.                                                             *)
(*                                                                               *)
(*  colors  *)

VAR 
  COLORS: SYSTEM.int;
  COLOR_PAIRS: SYSTEM.int;

<* IF  __GEN_C__ THEN *>

VAR 
  COLOR_BLACK - : INTEGER;
  COLOR_RED - : INTEGER;
  COLOR_GREEN - : INTEGER;
  COLOR_YELLOW - : INTEGER;
  COLOR_BLUE - : INTEGER;
  COLOR_MAGENTA - : INTEGER;
  COLOR_CYAN - : INTEGER;
  COLOR_WHITE - : INTEGER;

<* ELSE *>

CONST 
  COLOR_BLACK = 0;
  COLOR_RED = 1;
  COLOR_GREEN = 2;
  COLOR_YELLOW = 3;
  COLOR_BLUE = 4;
  COLOR_MAGENTA = 5;
  COLOR_CYAN = 6;
  COLOR_WHITE = 7;

<* END *>

(*  line graphics  *)

TYPE 
  H2D_Ptrchtype = POINTER TO chtype;

  H2D_OpenArraychtype = H2D_Ptrchtype;

VAR 
  acs_map: H2D_OpenArraychtype;

(*  VT100 symbols begin here  *)
(* #define ACS_ULCORNER	(acs_map['l'])	/* upper left corner */ *)
(* #define ACS_LLCORNER	(acs_map['m'])	/* lower left corner */ *)
(* #define ACS_URCORNER	(acs_map['k'])	/* upper right corner */ *)
(* #define ACS_LRCORNER	(acs_map['j'])	/* lower right corner */ *)
(* #define ACS_LTEE	(acs_map['t'])	/* tee pointing right */ *)
(* #define ACS_RTEE	(acs_map['u'])	/* tee pointing left */ *)
(* #define ACS_BTEE	(acs_map['v'])	/* tee pointing up */ *)
(* #define ACS_TTEE	(acs_map['w'])	/* tee pointing down */ *)
(* #define ACS_HLINE	(acs_map['q'])	/* horizontal line */ *)
(* #define ACS_VLINE	(acs_map['x'])	/* vertical line */ *)
(* #define ACS_PLUS	(acs_map['n'])	/* large plus or crossover */ *)
(* #define ACS_S1		(acs_map['o'])	/* scan line 1 */ *)
(* #define ACS_S9		(acs_map['s'])	/* scan line 9 */ *)
(* #define ACS_DIAMOND	(acs_map['`'])	/* diamond */ *)
(* #define ACS_CKBOARD	(acs_map['a'])	/* checker board (stipple) */ *)
(* #define ACS_DEGREE	(acs_map['f'])	/* degree symbol */ *)
(* #define ACS_PLMINUS	(acs_map['g'])	/* plus/minus */ *)
(* #define ACS_BULLET	(acs_map['~'])	/* bullet */ *)
(*  Teletype 5410v1 symbols begin here  *)
(* #define ACS_LARROW	(acs_map[','])	/* arrow pointing left */ *)
(* #define ACS_RARROW	(acs_map['+'])	/* arrow pointing right */ *)
(* #define ACS_DARROW	(acs_map['.'])	/* arrow pointing down */ *)
(* #define ACS_UARROW	(acs_map['-'])	/* arrow pointing up */ *)
(* #define ACS_BOARD	(acs_map['h'])	/* board of squares */ *)
(* #define ACS_LANTERN	(acs_map['i'])	/* lantern symbol */ *)
(* #define ACS_BLOCK	(acs_map['0'])	/* solid square block */ *)
(*                                                                      *)
(*  * These aren't documented, but a lot of System Vs have them anyway  *)
(*  * (you can spot pprryyzz{{||}} in a lot of AT&T terminfo strings).  *)
(*  * The ACS_names may not match AT&T's, our source didn't know them.  *)
(*                                                                      *)
(* #define ACS_S3		(acs_map['p'])	/* scan line 3 */ *)
(* #define ACS_S7		(acs_map['r'])	/* scan line 7 */ *)
(* #define ACS_LEQUAL	(acs_map['y'])	/* less/equal */ *)
(* #define ACS_GEQUAL	(acs_map['z'])	/* greater/equal */ *)
(* #define ACS_PI		(acs_map['{'])	/* Pi */ *)
(* #define ACS_NEQUAL	(acs_map['|'])	/* not equal */ *)
(* #define ACS_STERLING	(acs_map['}'])	/* UK pound sign */ *)
(*                                                                             *)
(*  * Line drawing ACS names are of the form ACS_trbl, where t is the top, r   *)
(*  * is the right, b is the bottom, and l is the left.  t, r, b, and l might  *)
(*  * be B (blank), S (single), D (double), or T (thick).  The subset defined  *)
(*  * here only uses B and S.                                                  *)
(*                                                                             *)

<* IF  __GEN_C__ THEN *>

VAR 
  ERR - : INTEGER;
  OK - : INTEGER;

<* ELSE *>

CONST 
  ERR = -1;
  OK = 0;

<* END *>

(*  values for the _flags member  *)

<* IF  __GEN_C__ THEN *>

VAR 
  _SUBWIN - : INTEGER;
  _ENDLINE - : INTEGER;
  _FULLWIN - : INTEGER;
  _SCROLLWIN - : INTEGER;
  _ISPAD - : INTEGER;
  _HASMOVED - : INTEGER;
  _WRAPPED - : INTEGER;

<* ELSE *>

CONST 
  _SUBWIN = 1H;   (*  is this a sub-window?  *)
  _ENDLINE = 2H;   (*  is the window flush right?  *)
  _FULLWIN = 4H;   (*  is the window full-screen?  *)
  _SCROLLWIN = 8H;   (*  bottom edge is at screen bottom?  *)
  _ISPAD = 10H;   (*  is this window a pad?  *)
  _HASMOVED = 20H;   (*  has cursor moved since last refresh?  *)
  _WRAPPED = 40H;   (*  cursor was just wrappped  *)

<* END *>

(*                                                                     *)
(*  * this value is used in the firstchar and lastchar fields to mark  *)
(*  * unchanged lines                                                  *)
(*                                                                     *)

<* IF  __GEN_C__ THEN *>

VAR 
  _NOCHANGE - : INTEGER;

<* ELSE *>

CONST 
  _NOCHANGE = -1;

<* END *>

(*                                                                                  *)
(*  * this value is used in the oldindex field to mark lines created by insertions  *)
(*  * and scrolls.                                                                  *)
(*                                                                                  *)

<* IF  __GEN_C__ THEN *>

VAR 
  _NEWINDEX - : INTEGER;

<* ELSE *>

CONST 
  _NEWINDEX = -1;

<* END *>

TYPE 
  screen = _IO_jump_t;

  SCREEN = _IO_jump_t;

  attr_t = LONGCARD;

  H2D_Ptrldat = POINTER TO ldat;

  H2D_PtrWINDOW = POINTER TO WINDOW;

  pdat = RECORD
    _pad_y     : SYSTEM.INT16;
    _pad_x     : SYSTEM.INT16;
    _pad_top   : SYSTEM.INT16;
    _pad_left  : SYSTEM.INT16;
    _pad_bottom: SYSTEM.INT16;
    _pad_right : SYSTEM.INT16;
  END;

  _win_st = RECORD
    _cury      : SYSTEM.INT16;
    _curx      : SYSTEM.INT16;   (*  current cursor position  *)
    (*  window location and size  *)
    _maxy      : SYSTEM.INT16;
    _maxx      : SYSTEM.INT16;   (*  maximums of x and y, NOT window size  *)
    _begy      : SYSTEM.INT16;
    _begx      : SYSTEM.INT16;   (*  screen coords of upper-left-hand corner  *)
    _flags     : SYSTEM.INT16;   (*  window state flags  *)
    (*  attribute tracking  *)
    _attrs     : attr_t;         (*  current attribute for non-space character  *)
    _bkgd      : chtype;         (*  current background char/attribute pair  *)
    (*  option values set by user  *)
    _notimeout : bool;           (*  no time out on function-key entry?  *)
    _clear     : bool;           (*  consider all data in the window invalid?  *)
    _leaveok   : bool;           (*  OK to not reset cursor on exit?  *)
    _scroll    : bool;           (*  OK to scroll this window?  *)
    _idlok     : bool;           (*  OK to use insert/delete line?  *)
    _idcok     : bool;           (*  OK to use insert/delete char?  *)
    _immed     : bool;           (*  window in immed mode? (not yet used)  *)
    _sync      : bool;           (*  window in sync mode?  *)
    _use_keypad: bool;           (*  process function keys into KEY_ symbols?  *)
    _delay     : SYSTEM.int;     (*  0 = nodelay, <0 = blocking, >0 = delay  *)
    _line      : H2D_Ptrldat;    (*  the actual line data  *)
    (*  global screen state  *)
    _regtop    : SYSTEM.INT16;   (*  top line of scrolling region  *)
    _regbottom : SYSTEM.INT16;   (*  bottom line of scrolling region  *)
    (*  these are used only if this is a sub-window  *)
    _parx      : SYSTEM.int;     (*  x coordinate of this window in parent  *)
    _pary      : SYSTEM.int;     (*  y coordinate of this window in parent  *)
    _parent    : H2D_PtrWINDOW;  (*  pointer to parent if a sub-window  *)
    (*  these are used only if this is a pad  *)
    _pad       : pdat;
    _yoffset   : SYSTEM.INT16;   (*  real begy is _begy + _yoffset  *)
  END;

  WINDOW = _win_st;

(* Type 'attr_t' was declared here in the source file *)

(*  ...must be at least as wide as chtype  *)

  ldat = RECORD
    text     : H2D_Ptrchtype;  (*  text of the line  *)
    firstchar: SYSTEM.INT16;   (*  first changed character in the line  *)
    lastchar : SYSTEM.INT16;   (*  last changed character in the line  *)
    oldindex : SYSTEM.INT16;   (*  index of the line at last update  *)
  END;

(* Type 'pdat' was declared here in the source file *)

VAR 
  stdscr: H2D_PtrWINDOW;
  curscr: H2D_PtrWINDOW;
  newscr: H2D_PtrWINDOW;
  LINES: SYSTEM.int;
  COLS: SYSTEM.int;
  TABSIZE: SYSTEM.int;

(*                                                               *)
(*  * This global was an undocumented feature under AIX curses.  *)
(*                                                               *)
  ESCDELAY: SYSTEM.int;   (*  ESC expire time in milliseconds  *)

PROCEDURE define_key ( arg0: H2D_PtrSChar; arg1: SYSTEM.int ): SYSTEM.int;

PROCEDURE keyok ( arg0: SYSTEM.int; arg1: bool ): SYSTEM.int;

PROCEDURE resizeterm ( arg0: SYSTEM.int; arg1: SYSTEM.int ): SYSTEM.int;

PROCEDURE use_default_colors (  ): SYSTEM.int;

PROCEDURE wresize ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int;
                    arg2: SYSTEM.int ): SYSTEM.int;

TYPE 
  H2D_OpenArraySChar = H2D_PtrSChar;

VAR 
  ttytype: H2D_OpenArraySChar;   (*  needed for backward compatibility  *)

(*                                                                                *)
(*  * GCC (and some other compilers) define '__attribute__'; we're using this     *)
(*  * macro to alert the compiler to flag inconsistencies in printf/scanf-like    *)
(*  * function calls.  Just in case '__attribute__' isn't defined, make a dummy.  *)
(*  * G++ doesn't accept it anyway.                                               *)
(*                                                                                *)
(*                                                                                  *)
(*  * We cannot define these in ncurses_cfg.h, since they require parameters to be  *)
(*  * passed (that's non-portable).                                                 *)
(*                                                                                  *)

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE GCC_PRINTFLIKE ( fmt, var: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE GCC_SCANFLIKE ( fmt, var: ARRAY OF SYSTEM.BYTE );
<* END *>

(* #define	GCC_NORETURN /* nothing */ *)
(* #define	GCC_UNUSED /* nothing */ *)
(*                                                                               *)
(*  * Function prototypes.  This is the complete XSI Curses list of required     *)
(*  * functions.  Those marked `generated' will have sources generated from the  *)
(*  * macro definitions later in this file, in order to satisfy XPG4.2           *)
(*  * requirements.                                                              *)
(*                                                                               *)

PROCEDURE addch ( arg0: chtype ): SYSTEM.int;

(*  generated  *)

PROCEDURE addchnstr ( arg0: H2D_Ptrchtype; arg1: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE addchstr ( arg0: H2D_Ptrchtype ): SYSTEM.int;

(*  generated  *)

PROCEDURE addnstr ( arg0: H2D_PtrSChar; arg1: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE addstr ( arg0: H2D_PtrSChar ): SYSTEM.int;

(*  generated  *)

PROCEDURE attroff ( arg0: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE attron ( arg0: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE attrset ( arg0: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

TYPE 
  H2D_PtrSShInt = POINTER TO SYSTEM.INT16;

PROCEDURE attr_get ( arg0: H2D_Ptrchtype; arg1: H2D_PtrSShInt;
                     arg2: SYSTEM.ADDRESS ): SYSTEM.int;

(*  generated  *)

PROCEDURE attr_off ( arg0: attr_t; arg1: SYSTEM.ADDRESS ): SYSTEM.int;

(*  generated  *)

PROCEDURE attr_on ( arg0: attr_t; arg1: SYSTEM.ADDRESS ): SYSTEM.int;

(*  generated  *)

PROCEDURE attr_set ( arg0: attr_t; arg1: SYSTEM.INT16;
                     arg2: SYSTEM.ADDRESS ): SYSTEM.int;

(*  generated  *)

PROCEDURE baudrate (  ): SYSTEM.int;

(*  implemented  *)

PROCEDURE beep (  ): SYSTEM.int;

(*  implemented  *)

PROCEDURE bkgd ( arg0: chtype ): SYSTEM.int;

(*  generated  *)

PROCEDURE bkgdset ( arg0: chtype );

(*  generated  *)

PROCEDURE border ( arg0: chtype; arg1: chtype; arg2: chtype; arg3: chtype;
                   arg4: chtype; arg5: chtype; arg6: chtype;
                   arg7: chtype ): SYSTEM.int;

(*  generated  *)

PROCEDURE box ( arg0: H2D_PtrWINDOW; arg1: chtype; arg2: chtype ): SYSTEM.int;

(*  generated  *)

PROCEDURE can_change_color (  ): bool;

(*  implemented  *)

PROCEDURE cbreak (  ): SYSTEM.int;

(*  implemented  *)

PROCEDURE chgat ( arg0: SYSTEM.int; arg1: attr_t; arg2: SYSTEM.INT16;
                  arg3: SYSTEM.ADDRESS ): SYSTEM.int;

(*  generated  *)

PROCEDURE clear (  ): SYSTEM.int;

(*  generated  *)

PROCEDURE clearok ( arg0: H2D_PtrWINDOW; arg1: bool ): SYSTEM.int;

(*  implemented  *)

PROCEDURE clrtobot (  ): SYSTEM.int;

(*  generated  *)

PROCEDURE clrtoeol (  ): SYSTEM.int;

(*  generated  *)

PROCEDURE color_content ( arg0: SYSTEM.INT16; arg1: H2D_PtrSShInt;
                          arg2: H2D_PtrSShInt; arg3: H2D_PtrSShInt ): SYSTEM.int;

(*  implemented  *)

PROCEDURE color_set ( arg0: SYSTEM.INT16; arg1: SYSTEM.ADDRESS ): SYSTEM.int;

(*  generated  *)

PROCEDURE COLOR_PAIR ( arg0: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE copywin ( arg0: H2D_PtrWINDOW; arg1: H2D_PtrWINDOW; arg2: SYSTEM.int;
                    arg3: SYSTEM.int; arg4: SYSTEM.int; arg5: SYSTEM.int;
                    arg6: SYSTEM.int; arg7: SYSTEM.int;
                    arg8: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE curs_set ( arg0: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE def_prog_mode (  ): SYSTEM.int;

(*  implemented  *)

PROCEDURE def_shell_mode (  ): SYSTEM.int;

(*  implemented  *)

PROCEDURE delay_output ( arg0: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE delch (  ): SYSTEM.int;

(*  generated  *)

TYPE 
  H2D_PtrSCREEN = POINTER TO SCREEN;

PROCEDURE delscreen ( arg0: H2D_PtrSCREEN );

(*  implemented  *)

PROCEDURE delwin ( arg0: H2D_PtrWINDOW ): SYSTEM.int;

(*  implemented  *)

PROCEDURE deleteln (  ): SYSTEM.int;

(*  generated  *)

PROCEDURE derwin ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                   arg3: SYSTEM.int; arg4: SYSTEM.int ): H2D_PtrWINDOW;

(*  implemented  *)

PROCEDURE doupdate (  ): SYSTEM.int;

(*  implemented  *)

PROCEDURE dupwin ( arg0: H2D_PtrWINDOW ): H2D_PtrWINDOW;

(*  implemented  *)

PROCEDURE echo (  ): SYSTEM.int;

(*  implemented  *)

PROCEDURE echochar ( arg0: chtype ): SYSTEM.int;

(*  generated  *)

PROCEDURE endwin (  ): SYSTEM.int;

(*  implemented  *)

PROCEDURE erasechar (  ): CHAR;

(*  implemented  *)

PROCEDURE filter (  );

(*  implemented  *)

PROCEDURE flash (  ): SYSTEM.int;

(*  implemented  *)

PROCEDURE flushinp (  ): SYSTEM.int;

(*  implemented  *)

PROCEDURE getbkgd ( arg0: H2D_PtrWINDOW ): chtype;

(*  generated  *)

PROCEDURE getch (  ): SYSTEM.int;

(*  generated  *)

PROCEDURE getnstr ( arg0: H2D_PtrSChar; arg1: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE getstr ( arg0: H2D_PtrSChar ): SYSTEM.int;

(*  generated  *)

PROCEDURE getwin ( arg0: H2D_Ptr_IO_FILE ): H2D_PtrWINDOW;

(*  implemented  *)

PROCEDURE halfdelay ( arg0: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE has_colors (  ): bool;

(*  implemented  *)

PROCEDURE has_ic (  ): bool;

(*  implemented  *)

PROCEDURE has_il (  ): bool;

(*  implemented  *)

PROCEDURE hline ( arg0: chtype; arg1: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE idcok ( arg0: H2D_PtrWINDOW; arg1: bool );

(*  implemented  *)

PROCEDURE idlok ( arg0: H2D_PtrWINDOW; arg1: bool ): SYSTEM.int;

(*  implemented  *)

PROCEDURE immedok ( arg0: H2D_PtrWINDOW; arg1: bool );

(*  implemented  *)

PROCEDURE inch (  ): chtype;

(*  generated  *)

PROCEDURE inchnstr ( arg0: H2D_Ptrchtype; arg1: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE inchstr ( arg0: H2D_Ptrchtype ): SYSTEM.int;

(*  generated  *)

PROCEDURE initscr (  ): H2D_PtrWINDOW;

(*  implemented  *)

PROCEDURE init_color ( arg0: SYSTEM.INT16; arg1: SYSTEM.INT16; arg2: SYSTEM.INT16;
                       arg3: SYSTEM.INT16 ): SYSTEM.int;

(*  implemented  *)

PROCEDURE init_pair ( arg0: SYSTEM.INT16; arg1: SYSTEM.INT16;
                      arg2: SYSTEM.INT16 ): SYSTEM.int;

(*  implemented  *)

PROCEDURE innstr ( arg0: H2D_PtrSChar; arg1: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE insch ( arg0: chtype ): SYSTEM.int;

(*  generated  *)

PROCEDURE insdelln ( arg0: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE insertln (  ): SYSTEM.int;

(*  generated  *)

PROCEDURE insnstr ( arg0: H2D_PtrSChar; arg1: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE insstr ( arg0: H2D_PtrSChar ): SYSTEM.int;

(*  generated  *)

PROCEDURE instr ( arg0: H2D_PtrSChar ): SYSTEM.int;

(*  generated  *)

PROCEDURE intrflush ( arg0: H2D_PtrWINDOW; arg1: bool ): SYSTEM.int;

(*  implemented  *)

PROCEDURE isendwin (  ): bool;

(*  implemented  *)

PROCEDURE is_linetouched ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int ): bool;

(*  implemented  *)

PROCEDURE is_wintouched ( arg0: H2D_PtrWINDOW ): bool;

(*  implemented  *)

PROCEDURE keyname ( arg0: SYSTEM.int ): H2D_PtrSChar;

(*  implemented  *)

PROCEDURE keypad ( arg0: H2D_PtrWINDOW; arg1: bool ): SYSTEM.int;

(*  implemented  *)

PROCEDURE killchar (  ): CHAR;

(*  implemented  *)

PROCEDURE leaveok ( arg0: H2D_PtrWINDOW; arg1: bool ): SYSTEM.int;

(*  implemented  *)

PROCEDURE longname (  ): H2D_PtrSChar;

(*  implemented  *)

PROCEDURE meta ( arg0: H2D_PtrWINDOW; arg1: bool ): SYSTEM.int;

(*  implemented  *)

PROCEDURE move ( arg0: SYSTEM.int; arg1: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvaddch ( arg0: SYSTEM.int; arg1: SYSTEM.int; arg2: chtype ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvaddchnstr ( arg0: SYSTEM.int; arg1: SYSTEM.int; arg2: H2D_Ptrchtype;
                        arg3: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvaddchstr ( arg0: SYSTEM.int; arg1: SYSTEM.int;
                       arg2: H2D_Ptrchtype ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvaddnstr ( arg0: SYSTEM.int; arg1: SYSTEM.int; arg2: H2D_PtrSChar;
                      arg3: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvaddstr ( arg0: SYSTEM.int; arg1: SYSTEM.int;
                     arg2: H2D_PtrSChar ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvchgat ( arg0: SYSTEM.int; arg1: SYSTEM.int; arg2: SYSTEM.int;
                    arg3: attr_t; arg4: SYSTEM.INT16;
                    arg5: SYSTEM.ADDRESS ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvcur ( arg0: SYSTEM.int; arg1: SYSTEM.int; arg2: SYSTEM.int;
                  arg3: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE mvdelch ( arg0: SYSTEM.int; arg1: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvderwin ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int;
                     arg2: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE mvgetch ( arg0: SYSTEM.int; arg1: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvgetnstr ( arg0: SYSTEM.int; arg1: SYSTEM.int; arg2: H2D_PtrSChar;
                      arg3: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvgetstr ( arg0: SYSTEM.int; arg1: SYSTEM.int;
                     arg2: H2D_PtrSChar ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvhline ( arg0: SYSTEM.int; arg1: SYSTEM.int; arg2: chtype;
                    arg3: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvinch ( arg0: SYSTEM.int; arg1: SYSTEM.int ): chtype;

(*  generated  *)

PROCEDURE mvinchnstr ( arg0: SYSTEM.int; arg1: SYSTEM.int; arg2: H2D_Ptrchtype;
                       arg3: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvinchstr ( arg0: SYSTEM.int; arg1: SYSTEM.int;
                      arg2: H2D_Ptrchtype ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvinnstr ( arg0: SYSTEM.int; arg1: SYSTEM.int; arg2: H2D_PtrSChar;
                     arg3: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvinsch ( arg0: SYSTEM.int; arg1: SYSTEM.int; arg2: chtype ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvinsnstr ( arg0: SYSTEM.int; arg1: SYSTEM.int; arg2: H2D_PtrSChar;
                      arg3: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvinsstr ( arg0: SYSTEM.int; arg1: SYSTEM.int;
                     arg2: H2D_PtrSChar ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvinstr ( arg0: SYSTEM.int; arg1: SYSTEM.int;
                    arg2: H2D_PtrSChar ): SYSTEM.int;

(*  generated  *)
(*  implemented  *)

PROCEDURE mvprintw ( arg0: SYSTEM.int; arg1: SYSTEM.int; arg2: H2D_PtrSChar;
                     SEQ arg3: SYSTEM.BYTE ): SYSTEM.int;

(*  implemented  *)

PROCEDURE mvscanw ( arg0: SYSTEM.int; arg1: SYSTEM.int; arg2: H2D_PtrSChar;
                    SEQ arg3: SYSTEM.BYTE ): SYSTEM.int;

PROCEDURE mvvline ( arg0: SYSTEM.int; arg1: SYSTEM.int; arg2: chtype;
                    arg3: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvwaddch ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                     arg3: chtype ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvwaddchnstr ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                         arg3: H2D_Ptrchtype; arg4: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvwaddchstr ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                        arg3: H2D_Ptrchtype ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvwaddnstr ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                       arg3: H2D_PtrSChar; arg4: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvwaddstr ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                      arg3: H2D_PtrSChar ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvwchgat ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                     arg3: SYSTEM.int; arg4: attr_t; arg5: SYSTEM.INT16;
                     arg6: SYSTEM.ADDRESS ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvwdelch ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int;
                     arg2: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvwgetch ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int;
                     arg2: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvwgetnstr ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                       arg3: H2D_PtrSChar; arg4: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvwgetstr ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                      arg3: H2D_PtrSChar ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvwhline ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                     arg3: chtype; arg4: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvwin ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int;
                  arg2: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE mvwinch ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int ): chtype;

(*  generated  *)

PROCEDURE mvwinchnstr ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                        arg3: H2D_Ptrchtype; arg4: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvwinchstr ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                       arg3: H2D_Ptrchtype ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvwinnstr ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                      arg3: H2D_PtrSChar; arg4: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvwinsch ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                     arg3: chtype ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvwinsnstr ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                       arg3: H2D_PtrSChar; arg4: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvwinsstr ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                      arg3: H2D_PtrSChar ): SYSTEM.int;

(*  generated  *)

PROCEDURE mvwinstr ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                     arg3: H2D_PtrSChar ): SYSTEM.int;

(*  generated  *)
(*  implemented  *)

PROCEDURE mvwprintw ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                      arg3: H2D_PtrSChar; SEQ arg4: SYSTEM.BYTE ): SYSTEM.int;

(*  implemented  *)

PROCEDURE mvwscanw ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                     arg3: H2D_PtrSChar; SEQ arg4: SYSTEM.BYTE ): SYSTEM.int;

PROCEDURE mvwvline ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                     arg3: chtype; arg4: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE napms ( arg0: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE newpad ( arg0: SYSTEM.int; arg1: SYSTEM.int ): H2D_PtrWINDOW;

(*  implemented  *)

PROCEDURE newterm ( arg0: H2D_PtrSChar; arg1: H2D_Ptr_IO_FILE;
                    arg2: H2D_Ptr_IO_FILE ): H2D_PtrSCREEN;

(*  implemented  *)

PROCEDURE newwin ( arg0: SYSTEM.int; arg1: SYSTEM.int; arg2: SYSTEM.int;
                   arg3: SYSTEM.int ): H2D_PtrWINDOW;

(*  implemented  *)

PROCEDURE nl (  ): SYSTEM.int;

(*  implemented  *)

PROCEDURE nocbreak (  ): SYSTEM.int;

(*  implemented  *)

PROCEDURE nodelay ( arg0: H2D_PtrWINDOW; arg1: bool ): SYSTEM.int;

(*  implemented  *)

PROCEDURE noecho (  ): SYSTEM.int;

(*  implemented  *)

PROCEDURE nonl (  ): SYSTEM.int;

(*  implemented  *)

PROCEDURE noqiflush (  );

(*  implemented  *)

PROCEDURE noraw (  ): SYSTEM.int;

(*  implemented  *)

PROCEDURE notimeout ( arg0: H2D_PtrWINDOW; arg1: bool ): SYSTEM.int;

(*  implemented  *)

PROCEDURE overlay ( arg0: H2D_PtrWINDOW; arg1: H2D_PtrWINDOW ): SYSTEM.int;

(*  implemented  *)

PROCEDURE overwrite ( arg0: H2D_PtrWINDOW; arg1: H2D_PtrWINDOW ): SYSTEM.int;

(*  implemented  *)

PROCEDURE pair_content ( arg0: SYSTEM.INT16; arg1: H2D_PtrSShInt;
                         arg2: H2D_PtrSShInt ): SYSTEM.int;

(*  implemented  *)

PROCEDURE PAIR_NUMBER ( arg0: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE pechochar ( arg0: H2D_PtrWINDOW; arg1: chtype ): SYSTEM.int;

(*  implemented  *)

PROCEDURE pnoutrefresh ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                         arg3: SYSTEM.int; arg4: SYSTEM.int; arg5: SYSTEM.int;
                         arg6: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE prefresh ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                     arg3: SYSTEM.int; arg4: SYSTEM.int; arg5: SYSTEM.int;
                     arg6: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)
(*  implemented  *)

PROCEDURE printw ( arg0: H2D_PtrSChar; SEQ arg1: SYSTEM.BYTE ): SYSTEM.int;

PROCEDURE putp ( arg0: H2D_PtrSChar ): SYSTEM.int;

(*  implemented  *)

PROCEDURE putwin ( arg0: H2D_PtrWINDOW; arg1: H2D_Ptr_IO_FILE ): SYSTEM.int;

(*  implemented  *)

PROCEDURE qiflush (  );

(*  implemented  *)

PROCEDURE raw (  ): SYSTEM.int;

(*  implemented  *)

PROCEDURE redrawwin ( arg0: H2D_PtrWINDOW ): SYSTEM.int;

(*  generated  *)

PROCEDURE refresh (  ): SYSTEM.int;

(*  generated  *)

PROCEDURE resetty (  ): SYSTEM.int;

(*  implemented  *)

PROCEDURE reset_prog_mode (  ): SYSTEM.int;

(*  implemented  *)

PROCEDURE reset_shell_mode (  ): SYSTEM.int;

(*  implemented  *)

TYPE 
  H2D_PtrProc = PROCEDURE ( H2D_PtrWINDOW, SYSTEM.int ): SYSTEM.int;

PROCEDURE ripoffline ( arg0: SYSTEM.int; init: H2D_PtrProc ): SYSTEM.int;

(*  implemented  *)

PROCEDURE savetty (  ): SYSTEM.int;

(*  implemented  *)
(*  implemented  *)

PROCEDURE scanw ( arg0: H2D_PtrSChar; SEQ arg1: SYSTEM.BYTE ): SYSTEM.int;

PROCEDURE scr_dump ( arg0: H2D_PtrSChar ): SYSTEM.int;

(*  implemented  *)

PROCEDURE scr_init ( arg0: H2D_PtrSChar ): SYSTEM.int;

(*  implemented  *)

PROCEDURE scrl ( arg0: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE scroll ( arg0: H2D_PtrWINDOW ): SYSTEM.int;

(*  generated  *)

PROCEDURE scrollok ( arg0: H2D_PtrWINDOW; arg1: bool ): SYSTEM.int;

(*  implemented  *)

PROCEDURE scr_restore ( arg0: H2D_PtrSChar ): SYSTEM.int;

(*  implemented  *)

PROCEDURE scr_set ( arg0: H2D_PtrSChar ): SYSTEM.int;

(*  implemented  *)

PROCEDURE setscrreg ( arg0: SYSTEM.int; arg1: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE set_term ( arg0: H2D_PtrSCREEN ): H2D_PtrSCREEN;

(*  implemented  *)

PROCEDURE slk_attroff ( arg0: chtype ): SYSTEM.int;

(*  implemented  *)

PROCEDURE slk_attr_off ( arg0: attr_t; arg1: SYSTEM.ADDRESS ): SYSTEM.int;

(*  generated:WIDEC  *)

PROCEDURE slk_attron ( arg0: chtype ): SYSTEM.int;

(*  implemented  *)

PROCEDURE slk_attr_on ( arg0: attr_t; arg1: SYSTEM.ADDRESS ): SYSTEM.int;

(*  generated:WIDEC  *)

PROCEDURE slk_attrset ( arg0: chtype ): SYSTEM.int;

(*  implemented  *)

PROCEDURE slk_attr (  ): attr_t;

(*  implemented  *)

PROCEDURE slk_attr_set ( arg0: attr_t; arg1: SYSTEM.INT16;
                         arg2: SYSTEM.ADDRESS ): SYSTEM.int;

(*  implemented  *)

PROCEDURE slk_clear (  ): SYSTEM.int;

(*  implemented  *)

PROCEDURE slk_color ( arg0: SYSTEM.INT16 ): SYSTEM.int;

(*  implemented  *)

PROCEDURE slk_init ( arg0: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE slk_label ( arg0: SYSTEM.int ): H2D_PtrSChar;

(*  implemented  *)

PROCEDURE slk_noutrefresh (  ): SYSTEM.int;

(*  implemented  *)

PROCEDURE slk_refresh (  ): SYSTEM.int;

(*  implemented  *)

PROCEDURE slk_restore (  ): SYSTEM.int;

(*  implemented  *)

PROCEDURE slk_set ( arg0: SYSTEM.int; arg1: H2D_PtrSChar;
                    arg2: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE slk_touch (  ): SYSTEM.int;

(*  implemented  *)

PROCEDURE standout (  ): SYSTEM.int;

(*  generated  *)

PROCEDURE standend (  ): SYSTEM.int;

(*  generated  *)

PROCEDURE start_color (  ): SYSTEM.int;

(*  implemented  *)

PROCEDURE subpad ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                   arg3: SYSTEM.int; arg4: SYSTEM.int ): H2D_PtrWINDOW;

(*  implemented  *)

PROCEDURE subwin ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                   arg3: SYSTEM.int; arg4: SYSTEM.int ): H2D_PtrWINDOW;

(*  implemented  *)

PROCEDURE syncok ( arg0: H2D_PtrWINDOW; arg1: bool ): SYSTEM.int;

(*  implemented  *)

PROCEDURE termattrs (  ): chtype;

(*  implemented  *)

PROCEDURE term_attrs (  ): attr_t;

(*  missing  *)

PROCEDURE termname (  ): H2D_PtrSChar;

(*  implemented  *)

PROCEDURE tigetflag ( arg0: H2D_PtrSChar ): SYSTEM.int;

(*  implemented  *)

PROCEDURE tigetnum ( arg0: H2D_PtrSChar ): SYSTEM.int;

(*  implemented  *)

PROCEDURE tigetstr ( arg0: H2D_PtrSChar ): H2D_PtrSChar;

(*  implemented  *)

PROCEDURE timeout ( arg0: SYSTEM.int );

(*  generated  *)

PROCEDURE tparm ( arg0: H2D_PtrSChar; SEQ arg1: SYSTEM.BYTE ): H2D_PtrSChar;

(*  implemented  *)

PROCEDURE typeahead ( arg0: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE ungetch ( arg0: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE untouchwin ( arg0: H2D_PtrWINDOW ): SYSTEM.int;

(*  generated  *)

PROCEDURE use_env ( arg0: bool );

(*  implemented  *)

PROCEDURE vidattr ( arg0: chtype ): SYSTEM.int;

(*  implemented  *)

PROCEDURE vid_attr ( arg0: attr_t; arg1: SYSTEM.INT16;
                     arg2: SYSTEM.ADDRESS ): SYSTEM.int;

(*  generated:WIDEC  *)

TYPE 
  H2D_PtrProc0 = PROCEDURE ( SYSTEM.int ): SYSTEM.int;

PROCEDURE vidputs ( arg0: chtype; arg1: H2D_PtrProc0 ): SYSTEM.int;

(*  implemented  *)

PROCEDURE vline ( arg0: chtype; arg1: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE vwprintw ( arg0: H2D_PtrWINDOW; arg1: H2D_PtrSChar;
                     va_list: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

--CONST 
--  vw_printw = vwprintw;

PROCEDURE vw_printw ( arg0: H2D_PtrWINDOW; arg1: H2D_PtrSChar;
                      va_list: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE vwscanw ( arg0: H2D_PtrWINDOW; arg1: H2D_PtrSChar;
                    va_list: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

--CONST 
--  vw_scanw = vwscanw;

PROCEDURE vw_scanw ( arg0: H2D_PtrWINDOW; arg1: H2D_PtrSChar;
                     va_list: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE waddch ( arg0: H2D_PtrWINDOW; arg1: chtype ): SYSTEM.int;

(*  implemented  *)

PROCEDURE waddchnstr ( arg0: H2D_PtrWINDOW; arg1: H2D_Ptrchtype;
                       arg2: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE waddchstr ( arg0: H2D_PtrWINDOW; arg1: H2D_Ptrchtype ): SYSTEM.int;

(*  generated  *)

PROCEDURE waddnstr ( arg0: H2D_PtrWINDOW; arg1: H2D_PtrSChar;
                     arg2: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE waddstr ( arg0: H2D_PtrWINDOW; arg1: H2D_PtrSChar ): SYSTEM.int;

(*  generated  *)

PROCEDURE wattron ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE wattroff ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE wattrset ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int ): SYSTEM.int;

(*  generated  *)

PROCEDURE wattr_get ( arg0: H2D_PtrWINDOW; arg1: H2D_Ptrchtype; arg2: H2D_PtrSShInt;
                      arg3: SYSTEM.ADDRESS ): SYSTEM.int;

(*  generated  *)

PROCEDURE wattr_on ( arg0: H2D_PtrWINDOW; arg1: attr_t;
                     arg2: SYSTEM.ADDRESS ): SYSTEM.int;

(*  implemented  *)

PROCEDURE wattr_off ( arg0: H2D_PtrWINDOW; arg1: attr_t;
                      arg2: SYSTEM.ADDRESS ): SYSTEM.int;

(*  implemented  *)

PROCEDURE wattr_set ( arg0: H2D_PtrWINDOW; arg1: attr_t; arg2: SYSTEM.INT16;
                      arg3: SYSTEM.ADDRESS ): SYSTEM.int;

(*  generated  *)

PROCEDURE wbkgd ( arg0: H2D_PtrWINDOW; arg1: chtype ): SYSTEM.int;

(*  implemented  *)

PROCEDURE wbkgdset ( arg0: H2D_PtrWINDOW; arg1: chtype );

(*  implemented  *)

PROCEDURE wborder ( arg0: H2D_PtrWINDOW; arg1: chtype; arg2: chtype; arg3: chtype;
                    arg4: chtype; arg5: chtype; arg6: chtype; arg7: chtype;
                    arg8: chtype ): SYSTEM.int;

(*  implemented  *)

PROCEDURE wchgat ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: attr_t;
                   arg3: SYSTEM.INT16; arg4: SYSTEM.ADDRESS ): SYSTEM.int;

(*  implemented  *)

PROCEDURE wclear ( arg0: H2D_PtrWINDOW ): SYSTEM.int;

(*  implemented  *)

PROCEDURE wclrtobot ( arg0: H2D_PtrWINDOW ): SYSTEM.int;

(*  implemented  *)

PROCEDURE wclrtoeol ( arg0: H2D_PtrWINDOW ): SYSTEM.int;

(*  implemented  *)

PROCEDURE wcolor_set ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.INT16;
                       arg2: SYSTEM.ADDRESS ): SYSTEM.int;

(*  implemented  *)

PROCEDURE wcursyncup ( arg0: H2D_PtrWINDOW );

(*  implemented  *)

PROCEDURE wdelch ( arg0: H2D_PtrWINDOW ): SYSTEM.int;

(*  implemented  *)

PROCEDURE wdeleteln ( arg0: H2D_PtrWINDOW ): SYSTEM.int;

(*  generated  *)

PROCEDURE wechochar ( arg0: H2D_PtrWINDOW; arg1: chtype ): SYSTEM.int;

(*  implemented  *)

PROCEDURE werase ( arg0: H2D_PtrWINDOW ): SYSTEM.int;

(*  implemented  *)

PROCEDURE wgetch ( arg0: H2D_PtrWINDOW ): SYSTEM.int;

(*  implemented  *)

PROCEDURE wgetnstr ( arg0: H2D_PtrWINDOW; arg1: H2D_PtrSChar;
                     arg2: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE wgetstr ( arg0: H2D_PtrWINDOW; arg1: H2D_PtrSChar ): SYSTEM.int;

(*  generated  *)

PROCEDURE whline ( arg0: H2D_PtrWINDOW; arg1: chtype; arg2: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE winch ( arg0: H2D_PtrWINDOW ): chtype;

(*  implemented  *)

PROCEDURE winchnstr ( arg0: H2D_PtrWINDOW; arg1: H2D_Ptrchtype;
                      arg2: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE winchstr ( arg0: H2D_PtrWINDOW; arg1: H2D_Ptrchtype ): SYSTEM.int;

(*  generated  *)

PROCEDURE winnstr ( arg0: H2D_PtrWINDOW; arg1: H2D_PtrSChar;
                    arg2: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE winsch ( arg0: H2D_PtrWINDOW; arg1: chtype ): SYSTEM.int;

(*  implemented  *)

PROCEDURE winsdelln ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE winsertln ( arg0: H2D_PtrWINDOW ): SYSTEM.int;

(*  generated  *)

PROCEDURE winsnstr ( arg0: H2D_PtrWINDOW; arg1: H2D_PtrSChar;
                     arg2: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE winsstr ( arg0: H2D_PtrWINDOW; arg1: H2D_PtrSChar ): SYSTEM.int;

(*  generated  *)

PROCEDURE winstr ( arg0: H2D_PtrWINDOW; arg1: H2D_PtrSChar ): SYSTEM.int;

(*  generated  *)

PROCEDURE wmove ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int;
                  arg2: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE wnoutrefresh ( arg0: H2D_PtrWINDOW ): SYSTEM.int;

(*  implemented  *)
(*  implemented  *)

PROCEDURE wprintw ( arg0: H2D_PtrWINDOW; arg1: H2D_PtrSChar;
                    SEQ arg2: SYSTEM.BYTE ): SYSTEM.int;

PROCEDURE wredrawln ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int;
                      arg2: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE wrefresh ( arg0: H2D_PtrWINDOW ): SYSTEM.int;

(*  implemented  *)
(*  implemented  *)

PROCEDURE wscanw ( arg0: H2D_PtrWINDOW; arg1: H2D_PtrSChar;
                   SEQ arg2: SYSTEM.BYTE ): SYSTEM.int;

PROCEDURE wscrl ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE wsetscrreg ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int;
                       arg2: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE wstandout ( arg0: H2D_PtrWINDOW ): SYSTEM.int;

(*  generated  *)

PROCEDURE wstandend ( arg0: H2D_PtrWINDOW ): SYSTEM.int;

(*  generated  *)

PROCEDURE wsyncdown ( arg0: H2D_PtrWINDOW );

(*  implemented  *)

PROCEDURE wsyncup ( arg0: H2D_PtrWINDOW );

(*  implemented  *)

PROCEDURE wtimeout ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int );

(*  implemented  *)

PROCEDURE wtouchln ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int;
                     arg3: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

PROCEDURE wvline ( arg0: H2D_PtrWINDOW; arg1: chtype; arg2: SYSTEM.int ): SYSTEM.int;

(*  implemented  *)

TYPE 
  H2D_PtrSInt = POINTER TO SYSTEM.int;

PROCEDURE mouse_trafo ( arg0: H2D_PtrSInt; arg1: H2D_PtrSInt; arg2: bool ): bool;

(*  generated  *)
(*  attributes  *)

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE NCURSES_BITS ( mask, shift: ARRAY OF SYSTEM.BYTE );

VAR 
  A_NORMAL - : INTEGER;

<* ELSE *>

CONST 
  A_NORMAL = 0;
  WA_NORMAL = A_NORMAL;

<* END *>

(* #define A_ATTRIBUTES	NCURSES_BITS(~(1UL - 1UL),0) *)
(* #define A_CHARTEXT	(NCURSES_BITS(1UL,0) - 1UL) *)
(* #define A_COLOR		NCURSES_BITS(((1UL) << 8) - 1UL,0) *)
(* #define A_STANDOUT	NCURSES_BITS(1UL,8) *)
(* #define A_UNDERLINE	NCURSES_BITS(1UL,9) *)
(* #define A_REVERSE	NCURSES_BITS(1UL,10) *)
(* #define A_BLINK		NCURSES_BITS(1UL,11) *)
(* #define A_DIM		NCURSES_BITS(1UL,12) *)
(* #define A_BOLD		NCURSES_BITS(1UL,13) *)
(* #define A_ALTCHARSET	NCURSES_BITS(1UL,14) *)
(* #define A_INVIS		NCURSES_BITS(1UL,15) *)
(*    Tradeoff on 32-bit machines ('protect' vs widec).  The others (e.g., left  *)
(*  * highlight are not implemented in any terminal descriptions, anyway.        *)
(*                                                                               *)
(* #define A_PROTECT	NCURSES_BITS(1UL,16) *)
(* #define A_HORIZONTAL	NCURSES_BITS(1UL,17) *)
(* #define A_LEFT		NCURSES_BITS(1UL,18) *)
(* #define A_LOW		NCURSES_BITS(1UL,19) *)
(* #define A_RIGHT		NCURSES_BITS(1UL,20) *)
(* #define A_TOP		NCURSES_BITS(1UL,21) *)
(* #define A_VERTICAL	NCURSES_BITS(1UL,22) *)

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE COLOR_PAIR ( n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE PAIR_NUMBER ( a: ARRAY OF SYSTEM.BYTE );
*)
<* END *>

(*                      *)
(*  * pseudo functions  *)
(*                      *)

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE wgetstr ( w, s: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE getnstr ( s, n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE setterm ( term: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE fixterm ( );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE resetterm ( );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE saveterm ( );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE crmode ( );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE nocrmode ( );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE gettmode ( );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE getyx ( win, y, x: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE getbegyx ( win, y, x: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE getmaxyx ( win, y, x: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE getparyx ( win, y, x: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE getsyx ( y, x: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE setsyx ( y, x: ARRAY OF SYSTEM.BYTE );
<* END *>

(*  It seems older SYSV curses versions define these  *)

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE getattrs ( win: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE getcurx ( win: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE getcury ( win: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE getbegx ( win: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE getbegy ( win: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE getmaxx ( win: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE getmaxy ( win: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE getparx ( win: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE getpary ( win: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE wstandout ( win: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE wstandend ( win: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE wattr_set ( win, a, p, opts: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE wattron ( win, at: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE wattroff ( win, at: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE wattrset ( win, at: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE scroll ( win: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE touchwin ( win: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE touchline ( win, s, c: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE untouchwin ( win: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE box ( win, v, h: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE border ( ls, rs, ts, bs, tl, tr, bl, br: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE hline ( ch, n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE vline ( ch, n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE winstr ( w, s: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE winchstr ( w, s: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE winsstr ( w, s: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE redrawwin ( w: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE waddstr ( win, str: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE waddchstr ( win, str: ARRAY OF SYSTEM.BYTE );
*)
<* END *>

(*                                          *)
(*  * pseudo functions for standard screen  *)
(*                                          *)

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE addch ( ch: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE addchnstr ( str, n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE addchstr ( str: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE addnstr ( str, n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE addstr ( str: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE attroff ( at: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE attron ( at: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE attrset ( at: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE bkgd ( ch: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE bkgdset ( ch: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE clear ( );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE clrtobot ( );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE clrtoeol ( );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE color_set ( c, o: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE delch ( );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE deleteln ( );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE echochar ( c: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE erase ( );

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE getch ( );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE getstr ( str: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE inch ( );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE inchnstr ( s, n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE inchstr ( s: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE innstr ( s, n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE insch ( c: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE insdelln ( n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE insertln ( );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE insnstr ( s, n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE insstr ( s: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE instr ( s: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE move ( y, x: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE refresh ( );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE scrl ( n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE setscrreg ( t, b: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE standend ( );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE standout ( );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE timeout ( delay: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE wdeleteln ( win: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE winsertln ( win: ARRAY OF SYSTEM.BYTE );
*)
<* END *>

(*                  *)
(*  * mv functions  *)
(*                  *)

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvwaddch ( win, y, x, ch: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvwaddchnstr ( win, y, x, str, n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvwaddchstr ( win, y, x, str: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvwaddnstr ( win, y, x, str, n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvwaddstr ( win, y, x, str: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvwdelch ( win, y, x: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvwgetch ( win, y, x: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvwgetnstr ( win, y, x, str, n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvwgetstr ( win, y, x, str: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvwhline ( win, y, x, c, n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvwinch ( win, y, x: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvwinchnstr ( win, y, x, s, n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvwinchstr ( win, y, x, s: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvwinnstr ( win, y, x, s, n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvwinsch ( win, y, x, c: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvwinsnstr ( win, y, x, s, n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvwinsstr ( win, y, x, s: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvwinstr ( win, y, x, s: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvwvline ( win, y, x, c, n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvaddch ( y, x, ch: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvaddchnstr ( y, x, str, n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvaddchstr ( y, x, str: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvaddnstr ( y, x, str, n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvaddstr ( y, x, str: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvdelch ( y, x: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvgetch ( y, x: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvgetnstr ( y, x, str, n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvgetstr ( y, x, str: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvhline ( y, x, c, n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvinch ( y, x: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvinchnstr ( y, x, s, n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvinchstr ( y, x, s: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvinnstr ( y, x, s, n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvinsch ( y, x, c: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvinsnstr ( y, x, s, n: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvinsstr ( y, x, s: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvinstr ( y, x, s: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvvline ( y, x, c, n: ARRAY OF SYSTEM.BYTE );
*)
<* END *>

(*                                                                                *)
(*  * XSI curses macros for XPG4 conformance.                                     *)
(*  * The underlying functions needed to make these work are:                     *)
(*  * waddnwstr(), waddchnwstr(), wadd_wch(), wborder_set(), wchgat(),            *)
(*  * wecho_wchar(), wgetn_wstr(), wget_wch(), whline_set(), vhline_set(),        *)
(*  * winnwstr(), wins_nwstr(), wins_wch(), win_wch(), win_wchnstr().             *)
(*  * Except for wchgat(), these are not yet implemented.  They will be someday.  *)
(*                                                                                *)

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE add_wch ( c: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE addnwstr ( wstr, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE addwstr ( wstr, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE attr_get ( a, pair, opts: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE attr_off ( a, opts: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE attr_on ( a, opts: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE attr_set ( a, pair, opts: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE box_set ( w, v, h: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE chgat ( n, a, c, o: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE echo_wchar ( c: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE getbkgd ( win: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE get_wch ( c: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE get_wstr ( t: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE getn_wstr ( t, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE hline_set ( c, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE in_wch ( c: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE in_wchnstr ( c, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE in_wchstr ( c: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE innwstr ( c, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE ins_nwstr ( t, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE ins_wch ( c: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE ins_wstr ( t: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE inwstr ( c: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvadd_wch ( y, x, c: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvaddnwstr ( y, x, wstr, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvaddwstr ( y, x, wstr, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvchgat ( y, x, n, a, c, o: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvget_wch ( y, x, c: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvget_wstr ( y, x, t: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvgetn_wstr ( y, x, t, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvhline_set ( y, x, c, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvin_wch ( y, x, c: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvin_wchnstr ( y, x, c, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvin_wchstr ( y, x, c: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvinnwstr ( y, x, c, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvins_nwstr ( y, x, t, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvins_wch ( y, x, c: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvins_wstr ( y, x, t: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvinwstr ( y, x, c: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvvline_set ( y, x, c, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvwadd_wch ( win, y, x, c: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvwaddnwstr ( win, y, x, wstr, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvwaddwstr ( win, y, x, wstr, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mvwchgat ( win, y, x, n, a, c, o: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvwget_wch ( win, y, x, c: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvwget_wstr ( win, y, x, t: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvwgetn_wstr ( win, y, x, t, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvwhline_set ( win, y, x, c, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvwin_wch ( win, y, x, c: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvwin_wchnstr ( win, y, x, c, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvwin_wchstr ( win, y, x, c: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvwinnwstr ( win, y, x, c, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvwins_nwstr ( win, y, x, t, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvwins_wch ( win, y, x, c: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvwins_wstr ( win, y, x, t: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvwinwstr ( win, y, x, c: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE mvwvline_set ( win, y, x, c, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE slk_attr_off ( a, v: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE slk_attr_on ( a, v: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE vid_attr ( a, pair, opts: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE vline_set ( c, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE waddwstr ( win, wstr, n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE wattr_get ( win, a, p, opts: ARRAY OF SYSTEM.BYTE );
*)

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE wget_wstr ( w, t: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE win_wchstr ( w, c: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE wins_wstr ( w, t: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE winwstr ( w, c: ARRAY OF SYSTEM.BYTE );
<* END *>

(*                                                                             *)
(*  * XSI curses deprecates SVr4 vwprintw/vwscanw, which are supposed to use   *)
(*  * varargs.h.  It adds new calls vw_printw/vw_scanw, which are supposed to  *)
(*  * use POSIX stdarg.h.  The ncurses versions of vwprintw/vwscanw already    *)
(*  * use stdarg.h, so...                                                      *)
(*                                                                             *)
(*                                                                                *)
(*  * Pseudo-character tokens outside ASCII range.  The curses wgetch() function  *)
(*  * will return any given one of these only if the corresponding k- capability  *)
(*  * is defined in your terminal's terminfo entry.                               *)
(*                                                                                *)

<* IF  __GEN_C__ THEN *>

VAR 
  KEY_CODE_YES - : INTEGER;
  KEY_MIN - : INTEGER;
  KEY_BREAK - : INTEGER;
  KEY_DOWN - : INTEGER;
  KEY_UP - : INTEGER;
  KEY_LEFT - : INTEGER;
  KEY_RIGHT - : INTEGER;
  KEY_HOME - : INTEGER;
  KEY_BACKSPACE - : INTEGER;
  KEY_F0 - : INTEGER;

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE KEY_F ( n: ARRAY OF SYSTEM.BYTE );

VAR 
  KEY_DL - : INTEGER;
  KEY_IL - : INTEGER;
  KEY_DC - : INTEGER;
  KEY_IC - : INTEGER;
  KEY_EIC - : INTEGER;
  KEY_CLEAR - : INTEGER;
  KEY_EOS - : INTEGER;
  KEY_EOL - : INTEGER;
  KEY_SF - : INTEGER;
  KEY_SR - : INTEGER;
  KEY_NPAGE - : INTEGER;
  KEY_PPAGE - : INTEGER;
  KEY_STAB - : INTEGER;
  KEY_CTAB - : INTEGER;
  KEY_CATAB - : INTEGER;
  KEY_ENTER - : INTEGER;
  KEY_SRESET - : INTEGER;
  KEY_RESET - : INTEGER;
  KEY_PRINT - : INTEGER;
  KEY_LL - : INTEGER;

<* ELSE *>

CONST 
  KEY_CODE_YES = 256;   (*  A wchar_t contains a key code  *)
  KEY_MIN = 257;   (*  Minimum curses key  *)
  KEY_BREAK = 257;   (*  Break key (unreliable)  *)
  KEY_DOWN = 258;   (*  Down-arrow  *)
  KEY_UP = 259;   (*  Up-arrow  *)
  KEY_LEFT = 260;   (*  Left-arrow  *)
  KEY_RIGHT = 261;   (*  Right-arrow  *)
  KEY_HOME = 262;   (*  Home key (upward+left arrow)  *)
  KEY_BACKSPACE = 263;   (*  Backspace (unreliable)  *)
  KEY_F0 = 264;   (*  Function keys.  Space for 64  *)
  KEY_DL = 328;   (*  Delete line  *)
  KEY_IL = 329;   (*  Insert line  *)
  KEY_DC = 330;   (*  Delete character  *)
  KEY_IC = 331;   (*  Insert char or enter insert mode  *)
  KEY_EIC = 332;   (*  Exit insert char mode  *)
  KEY_CLEAR = 333;   (*  Clear screen  *)
  KEY_EOS = 334;   (*  Clear to end of screen  *)
  KEY_EOL = 335;   (*  Clear to end of line  *)
  KEY_SF = 336;   (*  Scroll 1 line forward  *)
  KEY_SR = 337;   (*  Scroll 1 line backward (reverse)  *)
  KEY_NPAGE = 338;   (*  Next page  *)
  KEY_PPAGE = 339;   (*  Previous page  *)
  KEY_STAB = 340;   (*  Set tab  *)
  KEY_CTAB = 341;   (*  Clear tab  *)
  KEY_CATAB = 342;   (*  Clear all tabs  *)
  KEY_ENTER = 343;   (*  Enter or send (unreliable)  *)
  KEY_SRESET = 344;   (*  Soft (partial) reset (unreliable)  *)
  KEY_RESET = 345;   (*  Reset or hard reset (unreliable)  *)
  KEY_PRINT = 346;   (*  Print  *)
  KEY_LL = 347;   (*  Home down or bottom (lower left)  *)

<* END *>

(*  The keypad is arranged like this:  *)
(*  a1    up    a3    *)
(*  left   b2  right   *)
(*  c1   down   c3    *)

<* IF  __GEN_C__ THEN *>

VAR 
  KEY_A1 - : INTEGER;
  KEY_A3 - : INTEGER;
  KEY_B2 - : INTEGER;
  KEY_C1 - : INTEGER;
  KEY_C3 - : INTEGER;
  KEY_BTAB - : INTEGER;
  KEY_BEG - : INTEGER;
  KEY_CANCEL - : INTEGER;
  KEY_CLOSE - : INTEGER;
  KEY_COMMAND - : INTEGER;
  KEY_COPY - : INTEGER;
  KEY_CREATE - : INTEGER;
  KEY_END - : INTEGER;
  KEY_EXIT - : INTEGER;
  KEY_FIND - : INTEGER;
  KEY_HELP - : INTEGER;
  KEY_MARK - : INTEGER;
  KEY_MESSAGE - : INTEGER;
  KEY_MOVE - : INTEGER;
  KEY_NEXT - : INTEGER;
  KEY_OPEN - : INTEGER;
  KEY_OPTIONS - : INTEGER;
  KEY_PREVIOUS - : INTEGER;
  KEY_REDO - : INTEGER;
  KEY_REFERENCE - : INTEGER;
  KEY_REFRESH - : INTEGER;
  KEY_REPLACE - : INTEGER;
  KEY_RESTART - : INTEGER;
  KEY_RESUME - : INTEGER;
  KEY_SAVE - : INTEGER;
  KEY_SBEG - : INTEGER;
  KEY_SCANCEL - : INTEGER;
  KEY_SCOMMAND - : INTEGER;
  KEY_SCOPY - : INTEGER;
  KEY_SCREATE - : INTEGER;
  KEY_SDC - : INTEGER;
  KEY_SDL - : INTEGER;
  KEY_SELECT - : INTEGER;
  KEY_SEND - : INTEGER;
  KEY_SEOL - : INTEGER;
  KEY_SEXIT - : INTEGER;
  KEY_SFIND - : INTEGER;
  KEY_SHELP - : INTEGER;
  KEY_SHOME - : INTEGER;
  KEY_SIC - : INTEGER;
  KEY_SLEFT - : INTEGER;
  KEY_SMESSAGE - : INTEGER;
  KEY_SMOVE - : INTEGER;
  KEY_SNEXT - : INTEGER;
  KEY_SOPTIONS - : INTEGER;
  KEY_SPREVIOUS - : INTEGER;
  KEY_SPRINT - : INTEGER;
  KEY_SREDO - : INTEGER;
  KEY_SREPLACE - : INTEGER;
  KEY_SRIGHT - : INTEGER;
  KEY_SRSUME - : INTEGER;
  KEY_SSAVE - : INTEGER;
  KEY_SSUSPEND - : INTEGER;
  KEY_SUNDO - : INTEGER;
  KEY_SUSPEND - : INTEGER;
  KEY_UNDO - : INTEGER;
  KEY_MOUSE - : INTEGER;
  KEY_RESIZE - : INTEGER;
  KEY_MAX - : INTEGER;

<* ELSE *>

CONST 
  KEY_A1 = 348;   (*  Upper left of keypad  *)
  KEY_A3 = 349;   (*  Upper right of keypad  *)
  KEY_B2 = 350;   (*  Center of keypad  *)
  KEY_C1 = 351;   (*  Lower left of keypad  *)
  KEY_C3 = 352;   (*  Lower right of keypad  *)
  KEY_BTAB = 353;   (*  Back tab  *)
  KEY_BEG = 354;   (*  Beg (beginning)  *)
  KEY_CANCEL = 355;   (*  Cancel  *)
  KEY_CLOSE = 356;   (*  Close  *)
  KEY_COMMAND = 357;   (*  Cmd (command)  *)
  KEY_COPY = 358;   (*  Copy  *)
  KEY_CREATE = 359;   (*  Create  *)
  KEY_END = 360;   (*  End  *)
  KEY_EXIT = 361;   (*  Exit  *)
  KEY_FIND = 362;   (*  Find  *)
  KEY_HELP = 363;   (*  Help  *)
  KEY_MARK = 364;   (*  Mark  *)
  KEY_MESSAGE = 365;   (*  Message  *)
  KEY_MOVE = 366;   (*  Move  *)
  KEY_NEXT = 367;   (*  Next  *)
  KEY_OPEN = 368;   (*  Open  *)
  KEY_OPTIONS = 369;   (*  Options  *)
  KEY_PREVIOUS = 370;   (*  Prev (previous)  *)
  KEY_REDO = 371;   (*  Redo  *)
  KEY_REFERENCE = 372;   (*  Ref (reference)  *)
  KEY_REFRESH = 373;   (*  Refresh  *)
  KEY_REPLACE = 374;   (*  Replace  *)
  KEY_RESTART = 375;   (*  Restart  *)
  KEY_RESUME = 376;   (*  Resume  *)
  KEY_SAVE = 377;   (*  Save  *)
  KEY_SBEG = 378;   (*  Shifted Beg (beginning)  *)
  KEY_SCANCEL = 379;   (*  Shifted Cancel  *)
  KEY_SCOMMAND = 380;   (*  Shifted Command  *)
  KEY_SCOPY = 381;   (*  Shifted Copy  *)
  KEY_SCREATE = 382;   (*  Shifted Create  *)
  KEY_SDC = 383;   (*  Shifted Delete char  *)
  KEY_SDL = 384;   (*  Shifted Delete line  *)
  KEY_SELECT = 385;   (*  Select  *)
  KEY_SEND = 386;   (*  Shifted End  *)
  KEY_SEOL = 387;   (*  Shifted Clear line  *)
  KEY_SEXIT = 388;   (*  Shifted Dxit  *)
  KEY_SFIND = 389;   (*  Shifted Find  *)
  KEY_SHELP = 390;   (*  Shifted Help  *)
  KEY_SHOME = 391;   (*  Shifted Home  *)
  KEY_SIC = 392;   (*  Shifted Input  *)
  KEY_SLEFT = 393;   (*  Shifted Left arrow  *)
  KEY_SMESSAGE = 394;   (*  Shifted Message  *)
  KEY_SMOVE = 395;   (*  Shifted Move  *)
  KEY_SNEXT = 396;   (*  Shifted Next  *)
  KEY_SOPTIONS = 397;   (*  Shifted Options  *)
  KEY_SPREVIOUS = 398;   (*  Shifted Prev  *)
  KEY_SPRINT = 399;   (*  Shifted Print  *)
  KEY_SREDO = 400;   (*  Shifted Redo  *)
  KEY_SREPLACE = 401;   (*  Shifted Replace  *)
  KEY_SRIGHT = 402;   (*  Shifted Right arrow  *)
  KEY_SRSUME = 403;   (*  Shifted Resume  *)
  KEY_SSAVE = 404;   (*  Shifted Save  *)
  KEY_SSUSPEND = 405;   (*  Shifted Suspend  *)
  KEY_SUNDO = 406;   (*  Shifted Undo  *)
  KEY_SUSPEND = 407;   (*  Suspend  *)
  KEY_UNDO = 408;   (*  Undo  *)
  KEY_MOUSE = 409;   (*  Mouse event has occurred  *)
  KEY_RESIZE = 410;   (*  Terminal resize event  *)
  KEY_MAX = 511;   (*  Maximum key value  *)

<* END *>

(*  mouse interface  *)

<* IF  __GEN_C__ THEN *>

VAR 
  NCURSES_MOUSE_VERSION - : INTEGER;

<* ELSE *>

CONST 
  NCURSES_MOUSE_VERSION = 1;

<* END *>

(*  event masks  *)

<* IF  __GEN_C__ THEN *>

VAR 
  BUTTON1_RELEASED - : INTEGER;
  BUTTON1_PRESSED - : INTEGER;
  BUTTON1_CLICKED - : INTEGER;
  BUTTON1_DOUBLE_CLICKED - : INTEGER;
  BUTTON1_TRIPLE_CLICKED - : INTEGER;
  BUTTON1_RESERVED_EVENT - : INTEGER;
  BUTTON2_RELEASED - : INTEGER;
  BUTTON2_PRESSED - : INTEGER;
  BUTTON2_CLICKED - : INTEGER;
  BUTTON2_DOUBLE_CLICKED - : INTEGER;
  BUTTON2_TRIPLE_CLICKED - : INTEGER;
  BUTTON2_RESERVED_EVENT - : INTEGER;
  BUTTON3_RELEASED - : INTEGER;
  BUTTON3_PRESSED - : INTEGER;
  BUTTON3_CLICKED - : INTEGER;
  BUTTON3_DOUBLE_CLICKED - : INTEGER;
  BUTTON3_TRIPLE_CLICKED - : INTEGER;
  BUTTON3_RESERVED_EVENT - : INTEGER;
  BUTTON4_RELEASED - : INTEGER;
  BUTTON4_PRESSED - : INTEGER;
  BUTTON4_CLICKED - : INTEGER;
  BUTTON4_DOUBLE_CLICKED - : INTEGER;
  BUTTON4_TRIPLE_CLICKED - : INTEGER;
  BUTTON4_RESERVED_EVENT - : INTEGER;
  BUTTON_CTRL - : INTEGER;
  BUTTON_SHIFT - : INTEGER;
  BUTTON_ALT - : INTEGER;
  ALL_MOUSE_EVENTS - : INTEGER;
  REPORT_MOUSE_POSITION - : INTEGER;

<* ELSE *>

CONST 
  BUTTON1_RELEASED = 1;
  BUTTON1_PRESSED = 2;
  BUTTON1_CLICKED = 4;
  BUTTON1_DOUBLE_CLICKED = 8;
  BUTTON1_TRIPLE_CLICKED = 16;
  BUTTON1_RESERVED_EVENT = 32;
  BUTTON2_RELEASED = 64;
  BUTTON2_PRESSED = 128;
  BUTTON2_CLICKED = 256;
  BUTTON2_DOUBLE_CLICKED = 512;
  BUTTON2_TRIPLE_CLICKED = 1024;
  BUTTON2_RESERVED_EVENT = 2048;
  BUTTON3_RELEASED = 4096;
  BUTTON3_PRESSED = 8192;
  BUTTON3_CLICKED = 16384;
  BUTTON3_DOUBLE_CLICKED = 32768;
  BUTTON3_TRIPLE_CLICKED = 65536;
  BUTTON3_RESERVED_EVENT = 131072;
  BUTTON4_RELEASED = 262144;
  BUTTON4_PRESSED = 524288;
  BUTTON4_CLICKED = 1048576;
  BUTTON4_DOUBLE_CLICKED = 2097152;
  BUTTON4_TRIPLE_CLICKED = 4194304;
  BUTTON4_RESERVED_EVENT = 8388608;
  BUTTON_CTRL = 16777216;
  BUTTON_SHIFT = 33554432;
  BUTTON_ALT = 67108864;
  ALL_MOUSE_EVENTS = 134217727;
  REPORT_MOUSE_POSITION = 134217728;

<* END *>

(*  macros to extract single event-bits from masks  *)

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE BUTTON_RELEASE ( e, x: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE BUTTON_PRESS ( e, x: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE BUTTON_CLICK ( e, x: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE BUTTON_DOUBLE_CLICK ( e, x: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE BUTTON_TRIPLE_CLICK ( e, x: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE BUTTON_RESERVED_EVENT ( e, x: ARRAY OF SYSTEM.BYTE );
<* END *>

TYPE 
  mmask_t = LONGCARD;

  MEVENT = RECORD
    id    : SYSTEM.INT16;  (*  ID to distinguish multiple devices  *)
    x     : SYSTEM.int;
    y     : SYSTEM.int;
    z     : SYSTEM.int;    (*  event coordinates (character-cell)  *)
    bstate: mmask_t;       (*  button state bits  *)
  END;

  H2D_PtrMEVENT = POINTER TO MEVENT;

PROCEDURE getmouse ( arg0: H2D_PtrMEVENT ): SYSTEM.int;

PROCEDURE ungetmouse ( arg0: H2D_PtrMEVENT ): SYSTEM.int;

PROCEDURE mousemask ( arg0: mmask_t; arg1: H2D_Ptrchtype ): mmask_t;

PROCEDURE wenclose ( arg0: H2D_PtrWINDOW; arg1: SYSTEM.int; arg2: SYSTEM.int ): bool;

PROCEDURE mouseinterval ( arg0: SYSTEM.int ): SYSTEM.int;

PROCEDURE wmouse_trafo ( win: H2D_PtrWINDOW; y: H2D_PtrSInt; x: H2D_PtrSInt;
                         to_screen: bool ): bool;

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. 
   H2D: name already exists.
PROCEDURE mouse_trafo ( y, x, to_screen: ARRAY OF SYSTEM.BYTE );
*)
<* END *>

(*  other non-XSI functions  *)

PROCEDURE mcprint ( arg0: H2D_PtrSChar; arg1: SYSTEM.int ): SYSTEM.int;

(*  direct data to printer  *)

PROCEDURE has_key ( arg0: SYSTEM.int ): SYSTEM.int;

(*  do we have given key?  *)
(*  Debugging : use with libncurses_g.a  *)

PROCEDURE _tracef ( arg0: H2D_PtrSChar; SEQ arg1: SYSTEM.BYTE );

PROCEDURE _tracedump ( arg0: H2D_PtrSChar; arg1: H2D_PtrWINDOW );

PROCEDURE _traceattr ( arg0: attr_t ): H2D_PtrSChar;

PROCEDURE _traceattr2 ( arg0: SYSTEM.int; arg1: chtype ): H2D_PtrSChar;

PROCEDURE _nc_tracebits (  ): H2D_PtrSChar;

PROCEDURE _tracechar ( arg0: SHORTCARD ): H2D_PtrSChar;

PROCEDURE _tracechtype ( arg0: chtype ): H2D_PtrSChar;

PROCEDURE _tracechtype2 ( arg0: SYSTEM.int; arg1: chtype ): H2D_PtrSChar;

PROCEDURE _tracemouse ( arg0: H2D_PtrMEVENT ): H2D_PtrSChar;

PROCEDURE trace ( arg0: SYSTEM.unsigned );

(*  trace masks  *)

<* IF  __GEN_C__ THEN *>

VAR 
  TRACE_DISABLE - : INTEGER;
  TRACE_TIMES - : INTEGER;
  TRACE_TPUTS - : INTEGER;
  TRACE_UPDATE - : INTEGER;
  TRACE_MOVE - : INTEGER;
  TRACE_CHARPUT - : INTEGER;
  TRACE_ORDINARY - : INTEGER;
  TRACE_CALLS - : INTEGER;
  TRACE_VIRTPUT - : INTEGER;
  TRACE_IEVENT - : INTEGER;
  TRACE_BITS - : INTEGER;
  TRACE_ICALLS - : INTEGER;
  TRACE_CCALLS - : INTEGER;
  TRACE_MAXIMUM - : INTEGER;

<* ELSE *>

CONST 
  TRACE_DISABLE = 0H;   (*  turn off tracing  *)
  TRACE_TIMES = 1H;   (*  trace user and system times of updates  *)
  TRACE_TPUTS = 2H;   (*  trace tputs calls  *)
  TRACE_UPDATE = 4H;   (*  trace update actions, old & new screens  *)
  TRACE_MOVE = 8H;   (*  trace cursor moves and scrolls  *)
  TRACE_CHARPUT = 10H;   (*  trace all character outputs  *)
  TRACE_ORDINARY = 1FH;   (*  trace all update actions  *)
  TRACE_CALLS = 20H;   (*  trace all curses calls  *)
  TRACE_VIRTPUT = 40H;   (*  trace virtual character puts  *)
  TRACE_IEVENT = 80H;   (*  trace low-level input processing  *)
  TRACE_BITS = 100H;   (*  trace state of TTY control bits  *)
  TRACE_ICALLS = 200H;   (*  trace internal/nested calls  *)
  TRACE_CCALLS = 400H;   (*  trace per-character calls  *)
  TRACE_MAXIMUM = 0FFFFH;   (*  maximum trace level  *)

<* END *>

END h2d_curses.
