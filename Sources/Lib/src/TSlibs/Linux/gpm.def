(* h2d_gpm.def  Nov 13  10:16:43  1999 *)
(* Generated by H2D v1.31.1 from gpm.h. *)
<*+ M2ADDTYPES *>
<*+ M2EXTENSIONS *>
<*+ NOHEADER *> 
<* IF NOT DEFINED(GENTYPEDEF) THEN *> <* NEW GENTYPEDEF+ *> <* END *>
(* Merged headers: gpm.h *)

DEFINITION MODULE ["C"] gpm;

IMPORT SYSTEM;
(* H2D:  Required IMPORT clause: 
IMPORT h2d_gpm;
*)

(* #define _GPM_H_ *)
(*  $Id: gpm.h,v 1.6 1998/09/13 06:24:35 itz Exp $  *)
(* #include <paths.h>              /* _PATH_VARRUN etc. */ *)
(* ....................................... Xtermish stuff  *)
(* #define GPM_XTERM_ON \  printf("%c[?1001s",27), fflush(stdout), /* save old hilit tracking */ \  printf("%c[?1000h",27), fflush(stdout) /* enable mouse tracking */ *)
(* #define GPM_XTERM_OFF \  printf("%c[?1000l",27), fflush(stdout), /* disable mouse tracking */ \  printf("%c[?1001r",27), fflush(stdout) /* restore old hilittracking */ *)
(* ....................................... Cfg pathnames  *)
(*  Provide trailing slash, since mostly used for building pathnames.  *)

<* IF  __GEN_C__ THEN *>

VAR 
  _PATH_VARRUN - : ARRAY [0..9] OF CHAR;
  _PATH_DEV - : ARRAY [0..5] OF CHAR;

<* ELSE *>

CONST 
  _PATH_VARRUN = '/var/run/';
  GPM_NODE_DIR = _PATH_VARRUN;
  _PATH_DEV = '/dev/';

<* END *>

(*  itz Wed Jul  1 11:56:46 PDT 1998 this definitely ought not to be  *)
(*  world-writable; umask doesn't apply either, as gpm is most often  *)
(*  run from init                                                     *)

<* IF  __GEN_C__ THEN *>

VAR 
  GPM_NODE_DIR_MODE - : INTEGER;

<* ELSE *>

CONST 
  GPM_NODE_DIR_MODE = 509;

<* END *>

(* #define GPM_NODE_PID      GPM_NODE_DIR	"gpm.pid" *)
(* #define GPM_NODE_DEV      _PATH_DEV	"gpmctl" *)
(*  itz Wed Jul 1 12:09:29 PDT 1998 let's simplify this by placing the  *)
(*  file always in /dev whether it's a device or socket.  It doesn't    *)
(*  really belong to /var/run anyway.                                   *)
(* #define GPM_NODE_FIFO     _PATH_DEV	"gpmdata" *)
(* ....................................... Cfg buttons  *)

<* IF  __GEN_C__ THEN *>

VAR 
  GPM_B_LEFT - : INTEGER;
  GPM_B_MIDDLE - : INTEGER;
  GPM_B_RIGHT - : INTEGER;

<* ELSE *>

CONST 
  GPM_B_LEFT = 4;
  GPM_B_MIDDLE = 2;
  GPM_B_RIGHT = 1;

<* END *>

(* ....................................... The event types  *)

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE GPM_BARE_EVENTS ( type: ARRAY OF SYSTEM.BYTE );
(* H2D: Enumeration: Gpm_Etype *)

VAR 
  GPM_MOVE - : INTEGER;
  GPM_DRAG - : INTEGER;
  GPM_DOWN - : INTEGER;
  GPM_UP - : INTEGER;
  GPM_SINGLE - : INTEGER;
  GPM_DOUBLE - : INTEGER;
  GPM_TRIPLE - : INTEGER;
  GPM_MFLAG - : INTEGER;
  GPM_HARD - : INTEGER;
  GPM_ENTER - : INTEGER;
  GPM_LEAVE - : INTEGER;

<* ELSE *>

CONST 
  GPM_MOVE = 1;
  GPM_DRAG = 2;   (*  exactly one of the bare ones is active at a time  *)
  GPM_DOWN = 4;
  GPM_UP = 8;
  GPM_SINGLE = 16;   (*  at most one in three is set  *)
  GPM_DOUBLE = 32;
  GPM_TRIPLE = 64;   (*  WARNING: I depend on the values  *)
  GPM_MFLAG = 128;   (*  motion during click?  *)
  GPM_HARD = 256;   (*              if set in the defaultMask, force an already  *)
                    (*  used event to pass over to another handler               *)
  GPM_ENTER = 512;   (*  enter event, user in Roi's  *)
  GPM_LEAVE = 1024;   (*  leave event, used in Roi's  *)

<* END *>

TYPE 
  Gpm_Etype = SYSTEM.int;
(* H2D: End of enumeration: Gpm_Etype *)

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE Gpm_StrictSingle ( type: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE Gpm_AnySingle ( type: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE Gpm_StrictDouble ( type: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE Gpm_AnyDouble ( type: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE Gpm_StrictTriple ( type: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE Gpm_AnyTriple ( type: ARRAY OF SYSTEM.BYTE );
<* END *>

(* ....................................... The event data structure  *)
(* H2D: Enumeration: Gpm_Margin *)

<* IF  __GEN_C__ THEN *>

VAR 
  GPM_TOP - : INTEGER;
  GPM_BOT - : INTEGER;
  GPM_LFT - : INTEGER;
  GPM_RGT - : INTEGER;

<* ELSE *>

CONST 
  GPM_TOP = 1;
  GPM_BOT = 2;
  GPM_LFT = 4;
  GPM_RGT = 8;

<* END *>

TYPE 
  Gpm_Margin = SYSTEM.int;
(* H2D: End of enumeration: Gpm_Margin *)

(* ....................................... The reported event  *)

  Gpm_Event = RECORD
    buttons  : SHORTCARD;
    modifiers: SHORTCARD;      (*  try to be a multiple of 4  *)
    vc       : SYSTEM.CARD16;
    dx       : SYSTEM.INT16;
    dy       : SYSTEM.INT16;
    x        : SYSTEM.INT16;
    y        : SYSTEM.INT16;
    type     : Gpm_Etype;
    clicks   : SYSTEM.int;
    margin   : Gpm_Margin;
  END;

(* ....................................... The handling function  *)

(* ....................................... The connection data structure  *)

<* IF  __GEN_C__ THEN *>

VAR 
  GPM_MAGIC - : INTEGER;

<* ELSE *>

CONST 
  GPM_MAGIC = 47706D4CH;   (*  "GpmL"  *)

<* END *>

TYPE 
  Gpm_Connect = RECORD
    eventMask  : SYSTEM.CARD16;
    defaultMask: SYSTEM.CARD16;
    minMod     : SYSTEM.CARD16;
    maxMod     : SYSTEM.CARD16;
    pid        : SYSTEM.int;
    vc         : SYSTEM.int;
  END;

(* ....................................... The region of Interest  *)

  H2D_PtrGpm_Event = POINTER TO Gpm_Event;

  H2D_PtrGpm_Handler = PROCEDURE ( (* event *) H2D_PtrGpm_Event, (* clientdata *) 
                                 SYSTEM.ADDRESS ): SYSTEM.int;

  H2D_PtrGpm_Roi = POINTER TO Gpm_Roi;

  Gpm_Roi = RECORD
    xMin      : SYSTEM.INT16;
    xMax      : SYSTEM.INT16;
    yMin      : SYSTEM.INT16;
    yMax      : SYSTEM.INT16;
    minMod    : SYSTEM.CARD16;
    maxMod    : SYSTEM.CARD16;
    eventMask : SYSTEM.CARD16;
    owned     : SYSTEM.CARD16;
    handler   : H2D_PtrGpm_Handler;
    clientdata: SYSTEM.ADDRESS;
    prev      : H2D_PtrGpm_Roi;
    next      : H2D_PtrGpm_Roi;
  END;

(* ....................................... Global variables for the client  *)

VAR 
  gpm_flag: SYSTEM.int;
  gpm_ctlfd: SYSTEM.int;
  gpm_fd: SYSTEM.int;
  gpm_hflag: SYSTEM.int;
  gpm_morekeys: SYSTEM.int;
  gpm_zerobased: SYSTEM.int;
  gpm_visiblepointer: SYSTEM.int;
  gpm_mx: SYSTEM.int;
  gpm_my: SYSTEM.int;   (*  max x and y to fit margins  *)

TYPE 
  timeval = RECORD
    (* Declaration without definition *)
  END;

VAR 
  gpm_timeout: timeval;

TYPE 
  H2D_PtrUChar = POINTER TO SHORTCARD;

  H2D_PtrUShInt = ARRAY [0..4] OF SYSTEM.CARD8;
  H2D_PtrUShInt1 = POINTER TO ARRAY [0..4] OF SYSTEM.CARD16;

VAR 
  _gpm_buf: H2D_PtrUShInt;

VAR 
  _gpm_arg: H2D_PtrUShInt1;
  gpm_handler: H2D_PtrGpm_Handler;
  gpm_data: SYSTEM.ADDRESS;
  gpm_roi_handler: H2D_PtrGpm_Handler;
  gpm_roi_data: SYSTEM.ADDRESS;
  gpm_roi: H2D_PtrGpm_Roi;
  gpm_current_roi: H2D_PtrGpm_Roi;

(* ....................................... Prototypes for the client        *)
(*                                           all of them return 0 or errno  *)
(* #include <stdio.h>      /* needed to get FILE */ *)
(* #include <sys/ioctl.h>  /* to get the prototype for ioctl() */ *)
(*  liblow.c  *)

TYPE 
  H2D_PtrGpm_Connect = POINTER TO Gpm_Connect;

PROCEDURE Gpm_Open ( arg0: H2D_PtrGpm_Connect; arg1: SYSTEM.int ): SYSTEM.int;

PROCEDURE Gpm_Close (  ): SYSTEM.int;

PROCEDURE Gpm_GetEvent ( arg0: H2D_PtrGpm_Event ): SYSTEM.int;

(* extern int Gpm_Getc(FILE * ); *)

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE Gpm_Getchar ( );

<* END *>

PROCEDURE Gpm_Repeat ( millisec: SYSTEM.int ): SYSTEM.int;

TYPE 
  H2D_PtrSInt = POINTER TO SYSTEM.int;

PROCEDURE Gpm_FitValuesM ( x: H2D_PtrSInt; y: H2D_PtrSInt;
                           margin: SYSTEM.int ): SYSTEM.int;

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE Gpm_FitValues ( x, y: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE Gpm_FitEvent ( ePtr: ARRAY OF SYSTEM.BYTE );
<* END *>

PROCEDURE Gpm_DrawPointer ( x, y: SYSTEM.CARD16; fd: SYSTEM.int );

(*  the following is a heavy thing ...  *)

VAR 
  gpm_consolefd: SYSTEM.int;   (*  liblow.c  *)

(*    #define GPM_DRAWPOINTER(event) \                                              *)
(*  *                      ((gpm_consolefd=open("/dev/console",O_RDWR))>=0 && \     *)
(*  *                      Gpm_DrawPointer((event)->x,(event)->y,gpm_consolefd), \  *)
(*  *                      close(gpm_consolefd))                                    *)
(*                                                                                  *)

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE GPM_DRAWPOINTER ( ePtr: ARRAY OF SYSTEM.BYTE );
<* END *>

(*  libhigh.c  *)

PROCEDURE Gpm_HandleRoi ( event: H2D_PtrGpm_Event;
                          clientdata: SYSTEM.ADDRESS ): SYSTEM.int;

PROCEDURE Gpm_PushRoi ( x: SYSTEM.int; y: SYSTEM.int; X: SYSTEM.int; Y: SYSTEM.int;
                        mask: SYSTEM.int; fun: H2D_PtrGpm_Handler;
                        xtradata: SYSTEM.ADDRESS ): H2D_PtrGpm_Roi;

PROCEDURE Gpm_PopRoi ( which: H2D_PtrGpm_Roi ): H2D_PtrGpm_Roi;

PROCEDURE Gpm_RaiseRoi ( which: H2D_PtrGpm_Roi;
                         before: H2D_PtrGpm_Roi ): H2D_PtrGpm_Roi;

PROCEDURE Gpm_LowerRoi ( which: H2D_PtrGpm_Roi;
                         after: H2D_PtrGpm_Roi ): H2D_PtrGpm_Roi;

(*  libcurses.c  *)
(*  #include <curses.h>  Hmm... seems risky  *)

PROCEDURE Gpm_Wgetch ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE Gpm_Getch ( );
<* END *>

(*  libxtra.c  *)

TYPE 
  H2D_PtrSChar = POINTER TO CHAR;

PROCEDURE Gpm_GetLibVersion ( where: H2D_PtrSInt ): H2D_PtrSChar;

PROCEDURE Gpm_GetServerVersion ( where: H2D_PtrSInt ): H2D_PtrSChar;

PROCEDURE Gpm_GetSnapshot ( ePtr: H2D_PtrGpm_Event ): SYSTEM.int;

CONST 
  TIOCLINUX = 0541CH;

PROCEDURE / ioctl( fd :INTEGER; __request :SYSTEM.CARD32;  par :SYSTEM.ADDRESS);

END gpm.
