\chapter{Mapping to C}\label{maptoc}
\index{mapping to C}

Almost all features of \mt{} and \ot{} have direct equivalents in
ANSI C. If some construct is not directly available in C, the
most simple and effective solution preserving the language
semantics is used.

Many features are implemented in the run-time system. The file
{\tt X2C.h}\index{X2C.h} is a C header file of the run-time
support library. It contains a set of type definitions, macros
and  functions  necessary for compilation and execution of
a translated code.

{\bf Note:} In the examples of a generated C code throughout this
appendix some unimportant details may be omitted for simplicity.

\section{Layout of a generated code}\label{maptoc:layout}
\index{mapping to C!code layout}

The compiler generates the header files and C code files (See also
\ref{usage:genfiles}). A generated header file has the
following general layout:
\begin{enumerate}
\item   a user defined copyright statement (See the \OERef{COPYRIGHT}
        equation)

\item   two header lines, including time of compilation,
        the name of the file, a version of the \xds{} compiler.

\item   \verb+#ifdef <module_name>_H_+

\item   a set of "include" directives (always contains "include" directive
        for the run-time header file {\tt X2C.h} or the file defined by 
        the \OERef{ALWAYS\_INCLUDE} equation).

\item   external declarations

\item   \verb+#endif+

\end{enumerate}

{\bf  Note:}  External declarations may contain implicitly
exported identifiers. E.g. a structure always contains
non-exported fields.

For a sample definition module:
\begin{verbatim}
DEFINITION MODULE MyLib;

PROCEDURE Foo;

END MyLib.
\end{verbatim}
the following header file will be produced under on assumption
that the {\bf COPYRIGHT} equation is properly set):
{\small
\begin{verbatim}
/* (c) 1994 Widget Databases Ltd */
/* "@(#)MyLib.h Sep 15 12:50:16 1995" */
/* Generated by XDS Modula-2 to ANSI C v3.14 translator */

#ifndef MyLib_H_
#define MyLib_H_
#ifndef X2C_H_
#include "X2C.h"
#endif

extern void X2C_PROCLASS MyLib_Foo(void);

extern void X2C_PROCLASS MyLib_BEGIN(void);

#endif /* MyLib_H_ */
\end{verbatim}
}

\noindent
A generated C code file  has  the
following general layout:
\begin{enumerate}
\item   a user defined copyright statement (See the \OERef{COPYRIGHT}
        equation)

\item   two header lines, including time of compilation
        (See the option \OERef{GENDATE}),
        the name of the file, a version of the \xds{} compiler.

\item   definitions of the pre-processor symbols corresponding
        to the settings of some options (See \ref{maptoc:opt:config})

\item   a set of include directives (for program module it contains
        "include" directive for the run-time header file {\tt X2C.h}).

\item   the generated source text

\end{enumerate}

\noindent
For the implementation module:
\begin{verbatim}
IMPLEMENTATION MODULE MyLib;

IMPORT  InOut;

VAR count: INTEGER;

PROCEDURE Foo;
BEGIN
  INC(count);
  InOut.WriteInt(count,0);
  InOut.WriteLn;
END Foo;

BEGIN
  count:=0;
END MyLib.
\end{verbatim}
the following code file will be produced:
{\small
\begin{verbatim}
/* (c) 1994 Widget Databases Ltd */
/* "@(#)MyLib.c Jan 12 12:50:36 1995" */
/* Generated by XDS Modula-2 to ANSI C v3.12 translator */

#define X2C_int32
#define X2C_index32
#ifndef InOut_H_
#include "InOut.h"
#endif
#include "MyLib.h"

static X2C_INT32 count;

extern  void X2C_PROCLASS MyLib_Foo(void)
{
  count += 1l;
  InOut_WriteInt(count,0ul);
  InOut_WriteLn();
} /* END Foo */

extern void X2C_PROCLASS MyLib_BEGIN(void)
{
  static int MyLib_init=0;
  if (MyLib_init) return;
  MyLib_init=1;
  InOut_BEGIN();
  count=0ul;
}
\end{verbatim}
}
{\bf Note:} for an Oberon module both the header and code files are
generated.

\section{Identifiers}\label{maptoc:idents}
\index{mapping to C!identifiers}

The compiler tries to copy identifiers from the source text to
the C code without modifications. In some cases it can be
necessary to expand an identifier or to reduce it (See also the {\bf
GENIDLEN} equation).

{\bf Note:} The compiler does not change identifiers which are
marked as C identifiers via the direct language specification
facility. See \ref{multilang:direct}.

All exported identifiers\footnote{Identifiers that are declared
in a definition module, or marked as exported in an oberon module.} are
prefixed by the module name.

If an identifier to be declared is already defined in the C text
it is postfixed with a number. It can occur for a various
reasons:
\begin{enumerate}

\item an identifier coincides with the C keyword or
standard identifier.
\begin{verbatim}
  VAR char: CHAR;
\end{verbatim}
translates to:
\begin{verbatim}
  X2C_CHAR char1;
\end{verbatim}
The compiler uses postfixing for all identifiers listed in the
{\tt \kwd} file. The file provided by the distribution contains a
list of all ANSI C/C++ keywords and some identifiers from the C
standard libraries.

One can extend the file with other identifiers. For example, if
you program contains (non-exported) identifier {\tt pi} and
imports a standard C {\tt math} library, it is necessary to include
{\tt pi} into the {\tt \kwd} file.

\item a local identifier coincides with the global one.
\begin{verbatim}
VAR i: INTEGER;

PROCEDURE Foo;
  VAR i: INTEGER;
BEGIN
  i:=1;
END Foo;
\end{verbatim}
translates to:
\begin{verbatim}
static X2C_INT32 i;

static void Foo(void)
{
  X2C_INT32 i1;
  i1 = 1;
}
\end{verbatim}

\item an identifier is exported/imported to/from the context, where
such an identifier is already defined. E.g.
\begin{verbatim}
PROCEDURE Foo; END Foo;

MODULE Local;

EXPORT QUALIFIED Foo;

PROCEDURE Foo; END Foo;

END Local;
\end{verbatim}
The compiler does not extend identifiers defined in the local modules
with the module name. It will use postfixing
to distinguish between two {\tt Foo} procedures.
\begin{verbatim}
static void Foo(void)
{
}

static void Foo1(void) /* Local.Foo */
{
}
\end{verbatim}

\end{enumerate}

If  the length of a generated  identifier  length  is greater than the limit
defined  by the {\bf GENIDLEN} equation, the compiler will reduce
the identifier.
Let us consider the definition module:
\begin{verbatim}
DEFINITION MODULE MyModule;

VAR int: INTEGER;

PROCEDURE proc;

END MyModule.
\end{verbatim}

If the limit is large enough (in our case greater than 13),
the following declarations will be generated in the header file:
\begin{verbatim}
extern X2C_INT32 MyModule_int;
extern void X2C_PROCLASS MyModule_proc(void);
\end{verbatim}

If the {\bf GENIDLEN} equation is set to 6, all identifiers
will be reduced:
\begin{verbatim}
extern X2C_INT32 MyModu;
extern void X2C_PROCLASS MyMod1(void);
\end{verbatim}

This feature can be used for satisfying the obsolete C compilers or
linkers, which imposes strong restrictions on the length of
identifiers.

A special naming scheme is used for the identifiers of the
functions corresponding to the initialization parts of
compilation units (module bodies). If the option {\bf VERSIONKEY}
is off, the compiler generates a function identifier of the form:
\begin{verbatim}
<module_name>_BEGIN
\end{verbatim}

For the above example, the initialization part will be declared as
\begin{verbatim}
extern void X2C_PROCLASS MyModule_BEGIN(void);
\end{verbatim}
or, if {\tt GENIDLEN=6}, as
\begin{verbatim}
extern void X2C_PROCLASS MyMod2(void);
\end{verbatim}

If the option is on, the compiler generates the name of
a module body as a composition of
\begin{itemize}
\item a module name
\item a string \verb+"_BEGIN_"+
\item a time stamp
\item values of options {\bf TARGET16}, {\bf INDEX16} and {\bf
      DIFADR16} in the packed form.
      All modules constituting the project
      should be compiled with the same values of these options.
\end{itemize}

If the definition (or Oberon) module imported by different
compilation units has the same version, the same name will be
generated for each call of the module body. In all other cases
unresolved references will occur at a link time.

\Example
\begin{verbatim}
extern void X2C_PROCLASS MyModule_BEGIN_A0FE6691B(void);
\end{verbatim}
or, if {\tt GENIDLEN=6}, as
\begin{verbatim}
extern void X2C_PROCLASS MyMod2_A0FE6691B(void);
\end{verbatim}

We recommend to switch ON the option {\bf VERSIONKEY} whenever
possible.

%----------------------------------------------------------------

\section{Data types}\label{maproc:types}
\index{mapping to C!data types}

\subsection{Basic types}

The correspondence between \mt{}/\ot{} basic types and C types is described
in the tables \ref{table:m2:C} and \ref{table:o2:C}.
A representation of system types is described
in the table \ref{table:SYSTEM:C}.
{\bf Note:} Subrange types are represented by their host types.

If the option {\bf GENCTYPES} is off, the compiler uses
identifiers defined the in run-time module {\tt X2C.h} for all basic
types; see the last column of the tables. If the option is on,
the compiler generates C type identifiers.
\begin{verbatim}
VAR ch: CHAR;
\end{verbatim}
translates to ({\bf GENCTYPES} is off):
\begin{verbatim}
X2C_CHAR ch;
\end{verbatim}
or, if the option is on, to:
\begin{verbatim}
char ch;
\end{verbatim}

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|l|c|l|l|} \hline
\bf Basic type & \bf Bits  &\bf C type  & \bf X2C type \\ \hline
\tt SHORTINT   & 8     & signed char    & \verb+X2C_INT8+ \\
\tt INTEGER    & 16    & short          & \verb+X2C_INT16+ \\
\tt INTEGER    & 32    & long           & \verb+X2C_INT32+ \\
\tt LONGINT    & 32    & long           & \verb+X2C_INT32+ \\
\tt SHORTCARD  & 8     & unsigned char  & \verb+X2C_CARD8+ \\
\tt CARDINAL   & 16    & unsigned short & \verb+X2C_CARD16+ \\
\tt CARDINAL   & 32    & unsigned long  & \verb+X2C_CARD32+ \\
\tt LONGCARD   & 32    & long           & \verb+X2C_CARD32+ \\
\tt REAL       & 32    & float          & \verb+X2C_REAL+ \\
\tt LONGREAL   & 64    & double         & \verb+X2C_LONGREAL+ \\
\tt CHAR       & 8     & unsigned char  & \verb+X2C_CHAR+ \\
\tt BOOLEAN    & 8     & unsigned char  & \verb+X2C_BOOLEAN+ \\
\tt BITSET     & 16    & unsigned short & \verb+X2C_SET16+ \\
\tt BITSET     & 32    & unsigned long  & \verb+X2C_SET32+ \\
\hline
\end{tabular}
\end{center}
\caption{Representation of Modula-2 basic types}\label{table:m2:C}
\end{table}

In \mt{}, the size of {\tt INTEGER}, {\tt CARDINAL} and {\tt BITSET}
types is controlled via the option {\bf M2BASE16}. If the option
is set, {\tt INTEGER} is equal to {\tt SYSTEM.INT16}, {\tt
CARDINAL} is equal to {\tt SYSTEM.CARD16} and
{\tt  BITSET}  is  defined as \verb+PACKEDSET OF [0..15]+.
Otherwise, all these types are 32-bits wide.

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|l|c|l|l|} \hline
\bf Basic type &\bf Bits  &\bf C type  & \bf X2C type \\ \hline
\tt SHORTINT   & 8     & signed char   & \verb+X2C_INT8+ \\
\tt INTEGER    & 16    & short int     & \verb+X2C_INT16+ \\
\tt LONGINT    & 32    & long int      & \verb+X2C_INT32+ \\
\tt REAL       & 32    & float         & \verb+X2C_REAL+ \\
\tt LONGREAL   & 64    & double        & \verb+X2C_LONGREAL+ \\
\tt CHAR       & 8     & unsigned char & \verb+X2C_CHAR+ \\
\tt BOOLEAN    & 8     & unsigned char & \verb+X2C_BOOLEAN+ \\
\tt SET        & 32    & unsigned long & \verb+X2C_SET32+ \\
\hline
\end{tabular}
\end{center}
\caption{Representation of Oberon-2 basic types}\label{table:o2:C}
\end{table}

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|l|c|l|l|} \hline
\bf System type & \bf Bits  &\bf C type  & \bf X2C type \\ \hline
\tt INT8        & 8     & signed char    & \verb+X2C_INT8+ \\
\tt INT16       & 16    & short int      & \verb+X2C_INT16+ \\
\tt INT32       & 32    & long           & \verb+X2C_INT32+ \\
\tt CARD8       & 8     & unsigned char  & \verb+X2C_CARD8+ \\
\tt CARD16      & 16    & unsigned short & \verb+X2C_CARD16+ \\
\tt CARD32      & 32    & unsigned long  & \verb+X2C_CARD32+ \\
\tt LOC         & 8     & char           & \verb+X2C_LOC+ \\
\tt BYTE        & 8     & char           & \verb+X2C_LOC+ \\
\tt WORD        & 32    & array of LOC   & \verb+X2C_WORD+ \\
\tt ADDRESS     & 32    & pointer to LOC & \verb+X2C_ADDRESS+ \\
\hline
\end{tabular}
\end{center}
\caption{Representation of SYSTEM types}\label{table:SYSTEM:C}
\end{table}

\subsection{Special system types}

The module SYSTEM provides special types {\tt int}, {\tt
unsigned}, \verb|size_t| and {\tt void}. A characteristic feature
of these types is that they are generated exactly as
the corresponding C types, i.e.
\begin{verbatim}
VAR
  x: SYSTEM.size_t;
  y: SYSTEM.int;
  z: POINTER TO SYSTEM.void;
\end{verbatim}
translates to
\begin{verbatim}
  size_t x;
  int y;
  void * z;
\end{verbatim}
The types should be used in the foreign definition modules
(See \ref{multilang:C}).

\subsection{Modula-2 enumeration types}

An enumeration type is translated to the C {\tt enum} declaration.
\begin{verbatim}
TYPE color = (red,green,blue);
\end{verbatim}
translates to:
\begin{verbatim}
enum color {red,green,blue};
\end{verbatim}
or, if the option {\bf GENTYPEDEF} is set to:
\begin{verbatim}
enum color {red,green,blue};
typedef enum color color;
\end{verbatim}

\subsection{Modula-2 set types}

Modula-2 sets which have not more than 32 elements are represented
as unsigned types of appropriate length. Large sets are declared
as array of words.
\begin{verbatim}
TYPE
  SmallSet = SET OF [-1..1];
  Set16    = SET OF [0..15];
  LongSet  = SET OF [-1..32];
\end{verbatim}
translates to:
\begin{verbatim}
  typedef X2C_SET8 SmallSet;
  typedef X2C_SET16 Set16;
  typedef X2C_CARD32 Long[2];
\end{verbatim}

\subsection{Record types}\label{maptoc:types:rec}

A record is translated into a C struct.
\begin{verbatim}
TYPE
  R = RECORD
    b: BOOLEAN;
    c: CHAR;
  END;
\end{verbatim}
translates to:
\begin{verbatim}
  struct R {
    X2C_BOOLEAN b;
    X2C_CHAR c;
  };
\end{verbatim}

If the option {\bf GENTYPEDEF} is set, the compiler will generate
the {\tt typedef} declaration including both {\em tag name} and {\em
type name}.
\begin{verbatim}
  struct R;
  typedef struct R R;
  struct R {
    X2C_BOOLEAN b;
    X2C_CHAR c;
  };
\end{verbatim}
The tag names are needed for the recursive structure
declarations (See the next section).

A dummy field is generated for an empty record, since the C compilers
treat an empty structure as an error:
\begin{verbatim}
  struct R {
    X2C_INT32 _dummy_;
  }
\end{verbatim}
A  variant  part  is translated to a C {\tt union}.
\begin{verbatim}
  R = RECORD
    CASE tag: BOOLEAN OF
    |TRUE : c: CHAR;
    |FALSE: b: BOOLEAN;
    END;
    set: BITSET;
  END;
\end{verbatim}
is translated to:
\begin{verbatim}
  struct R {
    X2C_BOOLEAN tag;
    union {
      struct {
        X2C_CHAR c;
      } _1;
      struct {
        X2C_BOOLEAN b;
      } _2;
    } _;
    X2C_SET32 set;
  };
\end{verbatim}

An access to a field of a variant part ($r$ is of type $R$)
\begin{verbatim}
  r.c:='a';
\end{verbatim}
is translated to:
\begin{verbatim}
  r._._1.c:='a';
\end{verbatim}

\subsection{Pointer types}

A pointer type is mapped to the corresponding C type.
\begin{verbatim}
  P = POINTER TO R;
  R = RECORD
    next: P;
  END;
\end{verbatim}
is translated to:
\begin{verbatim}
  struct R;
  typedef struct R *P;
  struct R {
    P next;
  };
\end{verbatim}

Pointer types are often used in a declaration of recursive data
structures. In C, a recursive data structure must contain at
least one {\tt struct} declaration. The compiler reports an error
if detects a recursive data type without at least one record type, e.g.:
\begin{verbatim}
  T = POINTER TO T;
\end{verbatim}

This limitation should not cause any problems since data
structures that constitutes of pointers only are quite artificial.

A special case is a pointer to an open array (See
\ref{maptoc:dynarr}).

\subsection{Dynamic arrays}\label{maptoc:dynarr}

A dynamic array type\footnote{Pointer to a (multidimensional) open
array.} is represented as a pointer to a descriptor of an open array.
For an $N$-dimensional open array, the descriptor
contains:
\begin{itemize}
\item a pointer to the array body;
\item for each of $N-1$ higher dimensions:
  \begin{itemize}
  \item a length of an array in this dimension;
  \item a size of array element in this dimension;
  \end{itemize}
\item an array length of the last dimension.
\end{itemize}

\Example
\begin{verbatim}
TYPE
  String = POINTER TO ARRAY OF CHAR;
  Matrix = POINTER TO ARRAY OF ARRAY OF REAL;
\end{verbatim}
is translated to:
\begin{verbatim}
  struct _0;
  typedef struct _0 * String;

  struct _0 {
    X2C_CHAR * Adr; /* pointer to an array body */
    X2C_INDEX Len0;
  };

  struct _1;
  typedef struct _1 * Matrix;

  struct _1 {
    X2C_REAL * Adr;  /* pointer to an array body */
    X2C_INDEX Len0;  /* length of the 1st dimension */
    X2C_INDEX Size1;
    X2C_INDEX Len1;  /* length of the 2nd dimension */
  };
\end{verbatim}

If $m$ is of type {\tt Matrix} then the call {\tt NEW(m,3,5)}
will set the following values:
\begin{flushleft}
\begin{tabular}{lll}
\tt Len0  & 5 & a length of the inner dimension \\
\tt Len1  & 3 & a length of the outer dimension \\
\tt Size1 & 20 & $5\times4$, if {\tt sizeof(REAL)=4} \\
\end{tabular}
\end{flushleft}

\section{Procedure declarations}\label{maptoc:proc}
\index{mapping to C!procedure declaration}

A \mt{}/\ot{} procedure is translated to a C function. A special case
is translation of a nested procedure (See \ref{maptoc:proc:nested}).  A
generated function prototype includes call of the \verb|X2C_PROCLASS|
macro, if the \OERef{GENPROCLASS} option is ON.

Regardless of the \OERef{GENPROCLASS} setting, function prototypes
corresponding to foreign procedures contains the following macro
call:

\begin{flushleft}
\begin{tabular}{l|l}
\bf DLS string & \bf Macro name   \\
\hline
\tt "C"        & none             \\
\tt "Pascal"   & \tt X2C\_PASCAL  \\
\tt "StdCall"  & \tt X2C\_STDCALL \\
\tt "SysCall"  & \tt X2C\_SYSCALL
\end{tabular}
\end{flushleft}

A list of parameters is generated according to the value of the
\OERef{GENKRC} option (See \ref{maptoc:opt:gen}).
If \OERef{GENKRC} is ON, the compiler generates
parameter names only, otherwise the compiler generates full function
prototype.

\subsection{Parameters}

The parameter passing convention conforms, whenever possible, to
the rules of the C language. Variable parameters are
declared as pointers to the formal parameter type. Exceptions are
parameters of array and large set types which are always passed by
reference.

The procedure header
\begin{verbatim}
PROCEDURE Foo(a: INTEGER;
          VAR b: INTEGER;
              c: Array;
          VAR d: Array);
\end{verbatim}
is translated to:
\begin{verbatim}
void X2C_PROCLASS Foo(X2C_INT32 a,
                      X2C_INT32 *b,
                      Array c,
                      Array d)
\end{verbatim}

In the case of value arrays and long sets, the procedure called is
responsible for making a local copy.
\begin{verbatim}
TYPE Vector = ARRAY [0..2] OF REAL;

PROCEDURE Foo(v: Vector);
BEGIN
  <statements>
END Foo;
\end{verbatim}
is translated to:
\begin{verbatim}
typedef X2C_REAL Vector[3];

static void X2C_PROCLASS Foo(Vector v)
{
  V tmp;
  v = (X2C_REAL *)memcpy(tmp,v2,sizeof(V));
  <statments>
} /* END Foo */
\end{verbatim}

A special case is a character array parameter of a
fixed size. A string literal can be passed as an actual parameter
for a such formal parameter. A string literal can be shorter than
the formal parameter and a special care must be taken not to
access memory location beyond the end of the actual parameter.
The compiler copies a string literal to a temporary variable in the
caller procedure. Then in the callee procedure, the parameter will
be copied again according to the standard rules. {\bf Note:} in
some cases this double copying may be prevented by marking the
parameter as read-only (See \ref{m2:ext:RO_param}).
\begin{verbatim}

TYPE Str = ARRAY [0..7] OF CHAR;

PROCEDURE Foo(s: Str);
END Foo;

PROCEDURE Callee;
BEGIN
  Foo("hello");
END Callee;
\end{verbatim}
is translated to:
\begin{verbatim}
typedef X2C_CHAR Str[8];

static void X2C_PROCLASS Foo(Str s)
{
  A tmp;
  s=(X2C_CHAR *)memcpy(tmp,s,8u);
} /* END Foo */

static void X2C_PROCLASS Callee(void)
{
  Str tmp;
  Foo(*(Str *)memcpy(&tmp,"hello",6u));
} /* END Callee */
\end{verbatim}

\subsection{Open arrays}

Parameters of an open array are generated  according to the following
rules:
\begin{itemize}
\item   for a $N$-dimensional open array $N$ additional parameters
        (a length of each dimension) are passed.
\item   if the parameter is a value parameter, the space necessary
        for the local copy is allocated at a run-time. The allocated
        memory is free before the function termination.
\end{itemize}

\begin{verbatim}
PROCEDURE Foo(s: ARRAY OF ARRAY OF CHAR);
BEGIN
  <statements>
END Foo;

PROCEDURE Callee;
  VAR x: ARRAY [0..1],[0..1] OF CHAR;
BEGIN
  Foo(x);
END Callee;
\end{verbatim}
is translated to:
\begin{verbatim}
static void X2C_PROCLASS Foo(X2C_CHAR s[],
                             X2C_CARD32 s_len,
                             X2C_CARD32 s_len1)
{
  X2C_PCOPY((void **)&s,s_len*s_len1);
  <statements>
  X2C_PFREE(s,s_len*s_len1);
} /* END Foo */

static void X2C_PROCLASS Callee(void)
{
  X2C_CHAR x[2][2];
  Foo((X2C_CHAR *)x, 2u, 2u);
} /* END Callee */
\end{verbatim}

\subsection{Oberon-2 variable vecord parameters}\label{maptoc:procdcl:varrec}

For a variable record parameter in \ot{} an additional
parameter ({\em type tag}) is passed. This parameter is
needed for the dynamic type tests and for calling the type-bound
procedures (See also \ref{maptoc:o2}).
\begin{verbatim}
PROCEDURE Foo(VAR r: Rec);
\end{verbatim}
is translated to:
\begin{verbatim}
static void proc(struct Rec * r, X2C_TD r_type);
\end{verbatim}

\subsection{Sequence parameters}\label{maptoc:procdcl:seqrep}

For the sequence parameters, the compiler forms the
byte  array  explicitly  as a dynamic  aggregate, according to the
rules specified in \ref{m2:SEQ:param}.
\begin{verbatim}
PROCEDURE write(SEQ x: SYSTEM.BYTE);
END write;

PROCEDURE Foo;
  VAR
    i: INTEGER;
    c: CHAR;
    r: REAL;
    a: ARRAY [0..7] OF CHAR;
BEGIN
  write(i,c,r,a);
END Foo;
\end{verbatim}
is translated to:
\begin{verbatim}
static void X2C_PROCLASS write(X2C_LOC x[],
                               X2C_CARD32 x_len)
{
} /* END write */

static void X2C_PROCLASS Foo(void)
  X2C_INT32 i;
  X2C_CHAR c;
  X2C_REAL r;
  X2C_CHAR a[8];
  X2C_SEQ tmp[7];
  write(
    (tmp[0].val=i,
     tmp[1].val=(X2C_CARD32)c,
     *(X2C_LONGREAL*)&tmp[2]=(X2C_LONGREAL)r,
     tmp[4].adr=a,
     tmp[5].val=0,
     tmp[6].val=7,
     (X2C_LOC *)tmp),
     28u);
} /* END Foo */
\end{verbatim}

For this call, the actual array passed to {\tt write} will contain:
\begin{itemize}
\item  4 bytes of a sign-extended value of {\tt i}
\item  4 bytes of a zero-extended value of {\tt c}
\item  8 bytes of a LONGREAL value  {\tt r}
\item  12 bytes of an array descriptor
\begin{itemize}
    \item 4 bytes containing the address of {\tt a}
    \item 4 bytes containing the value 0
    \item 4 bytes containing the value 7 ({\tt SIZE(a)-1})
\end{itemize}
\end{itemize}

\subsection{Function results}

\xds{} supports arbitrary return types for functions.  If a
function  returns an array or a large set type, an additional parameter
is  declared.  It  is  used  as  a  pointer to a temporary variable
receiving the result of function.
\begin{verbatim}
TYPE A = ARRAY [0..1] OF REAL;

PROCEDURE Foo(): A;
  VAR a: A;
BEGIN
  RETURN a
END Foo;

PROCEDURE Callee;
  VAR x: A;
BEGIN
  x:=Foo();
END Callee;
\end{verbatim}
is translated to:
\begin{verbatim}
typedef X2C_REAL A[2];

static X2C_REAL * X2C_PROCLASS Foo(A Foo_ret)
{
  A a1;
  memcpy(Foo_ret,a1,sizeof(A));
  return Foo_ret;
} /* END Foo */

static void X2C_PROCLASS Callee(void)
{
  A x;
  A tmp;
  memcpy(x,Foo(tmp),sizeof(A));
} /* END Callee */
\end{verbatim}

\subsection{Procedure body}

In most cases the translation of a procedure body is transparent.
Most  statements  of the source  languages have direct analog in C.
However,  in  some cases a special care must be taken to preserve
the language semantics.

The  following  example  illustrates  the  situation  where  {\tt
return}  statements  are  replaced  with  {\tt  goto} to free the
memory allocated for a parameter.
\begin{verbatim}
PROCEDURE Length(s: ARRAY OF CHAR): CARDINAL;
  VAR i: CARDINAL;
BEGIN
  i:=0;
  WHILE i<HIGH(s) DO
    IF s[i]=0C THEN RETURN i END;
    INC(i)
  END;
  RETURN i
END Length;
\end{verbatim}
is translated to:
\begin{verbatim}
static X2C_CARD32 Length(X2C_CHAR s[],
                         X2C_CARD32 s_len)
{
  X2C_CARD32 i;
  X2C_CARD32 Length_ret;
  X2C_PCOPY((void **)&s,s_len);
  i = 0;
  while (i<s_len-1) {
    if (s[i]=='\0') {
      Length_ret=i;
      goto label;
    }
    i += 1;
  } /* END WHILE */
  Length_ret=i;
  label:;
  X2C_PFREE(s,s_len);
  return Length_ret;
} /* END Length */
\end{verbatim}

If a procedure contains local modules, its initialization and
finalization  parts  (See  \ref{m2:ISO:final}) are inserted into the
appropriate places:
\begin{verbatim}
VAR Foo_in_operation: BOOLEAN;

PROCEDURE Foo(): INTEGER;
  MODULE M;
    IMPORT Foo_in_operation;
  BEGIN
    Foo_in_operation:=TRUE;
  FINALLY
    Foo_in_operation:=FALSE;
  END M;
BEGIN
  RETURN 1
END Foo;
\end{verbatim}
is translated to:
\begin{verbatim}
static X2C_BOOLEAN Foo_in_operation;

static X2C_INT32 Foo(void)
{
  X2C_INT32 Foo_ret;
  Foo_in_operation=1; /* M initialization */
  Foo_ret=0x01l;
  Foo_in_operation=0; /* M finalization */
  return Foo_ret;
} /* END Foo */
\end{verbatim}

If  a procedure contains an exceptional part (See \ref{m2:ISO:exc}),
the  procedure body is generated as {\tt if} statement, where one
branch  corresponds  to  a normal  part, and another to an exceptional
part.  The  calls  of run-time functions are generated to provide
all  necessary actions. The finalization statements (if any) are
generated after the {\tt if} statement.
\begin{verbatim}
PROCEDURE Div(a,b: INTEGER): INTEGER;
BEGIN
  RETURN a DIV b
EXCEPT
  RETURN MAX(INTEGER)
END Div;
\end{verbatim}
is translated to:
\begin{verbatim}
static X2C_INT32 Div(X2C_INT32 a, X2C_INT32 b)
{
  X2C_XHandler_STR tmp;
  X2C_INT32 Div_ret;
  if (X2C_XTRY(&tmp)) {
    Div_ret = X2C_DIV(a,b);
    X2C_XOFF();
  }
  else {
    Div_ret=X2C_max_longcard;
  }
  X2C_XREMOVE();
  return Div_ret;
} /* END Div */
\end{verbatim}


\subsection{Procedure Prologue / Epilogue}

Prologues and epilogues allow arbitrary text to be inserted into 
the C output either immediately before or immediately after a procedure
implementation in a similar fashion that the System procedure 
\See{CODE}{}{m2:system_procs}
statement allows text to be inserted within a procedure definition.

Prologues and Epilogues are defined by using an extension of 
the special feature provided to help interface to foreign programming languages.

Between the keyword {\tt PROCEDURE} and the name of the procedure being
defined a list of strings may be supplied within enclosing brackets.

Syntax:

\begin{verbatim}
String  = "'" { character } "'" | '"' { character } '"'
ProcAttribute  = "[" String | number {"," String } "]"
ProcDefinition = "PROCEDURE" [ ProcAttribute ] ProcedureName
\end{verbatim}

Where String is a Modula-2 string delimited by either a single quote
(') or double quote (") pair.

The string can either be one of the language keywords listed in
section \ref{multilang:direct} or an arbitrary string commencing with either
of the placement keywords {\tt Prologue} or {\tt Epilogue}.

Text following the white space delimiter following the {\tt Prologue} or
{\tt Epilogue} placement keyword is passed through to the C output either
before the procedures declaration in the case of Prologue or after
the declaration in the case of Epilogue.

Each string causes a single line of text to be inserted. Multiple
lines can be inserted by additional strings being supplied; each
proceeded by a placement keyword.

{\bf Example:}
\begin{verbatim}
  PROCEDURE ['Epilogue #pragma section Startup ".startup" RX'
            ,'Epilogue #pragma use_section Startup Handler'          
            ] Handler;
\end{verbatim}

Causes the two C {\tt \#pragma} directives to be placed immediately
following the procedure's implementation.

\begin{verbatim}
  static void Handler(void){
      ...
  } /* end Handler() */
  #pragma section Startup ".startup" RX
  #pragma use_section Startup  Handler
\end{verbatim}

{\bf Another example:}

\begin{verbatim}
  PROCEDURE ["Prologue #pragma inline SendChar"          
            ] SendChar (TheChar : CHAR);
  BEGIN
    ...
  END SendChar;
\end{verbatim}

is translated to: 

\begin{verbatim}
  #pragma inline SendChar 
  void SendChar(X2C_CHAR TheChar){
      ...
  } /* end SendChar() */
\end{verbatim}


\subsection{Nested procedures}\label{maptoc:proc:nested}
\index{mapping to C!nested procedures}

There is no equivalent for \mt{}/\ot{} nested procedures in C.  The
compiler appends additional parameters to make an access to the local
variables (and parameters) of an outer procedure(s).

\Example
\begin{verbatim}
PROCEDURE proc(a: INTEGER);
  VAR b,c,d: INTEGER;

  PROCEDURE loc1(a: INTEGER);
  BEGIN
    b:=a;
  END loc1;

  PROCEDURE loc2;
  BEGIN
    loc1(d+a);
  END loc2;

BEGIN
  c:=1;
  loc2;
END proc;
\end{verbatim}
is translated to:
\begin{verbatim}
static void loc1(X2C_INT32 * b, X2C_INT32 a)
{
  *b=a;
} /* END loc1 */

static void loc2(X2C_INT32 * b,
                 X2C_INT32 * a,
                 X2C_INT32 * d)
{
  loc1(b, *d+*a);
} /* END loc2 */

static void X2C_PROCLASS proc(X2C_INT32 a)
{
  X2C_INT32 c;
  X2C_INT32 b;
  X2C_INT32 d;
  c=0x01l;
  loc2(&b, &a, &d);
} /* END proc */
\end{verbatim}

{\bf  Note:}  Only  the  used  variables are passed as additional
parameters (e.g. the variable {\tt c} is not used and not passed).


%----------------------------------------------------------------

\section{Module initialization and finalization}
\index{mapping to C!module body}

For   each   compilation   unit   the   compiler   generates  the
initialization  function  which contains the necessary initialization
statements and statements constituting  the  module  body.
Initialization  statements  include  the  call  of initialization
functions  of  all  imported  modules.  Two  forms of an ideintifier
of an initialization function are  controlled  by  the  {\bf  VERSIONKEY}
option.

If    the   module   body   contains a finalization   part   (See
\ref{m2:ISO:final})   this   part  is  generated  as  a  separate
procedure, and the  run-time support procedure is called
to register it.

\Example
\begin{verbatim}
IMPLEMENTATION MODULE M;

IMPORT  A, B;

BEGIN
  A.Foo();
FINALLY
  B.Foo();
END M.
\end{verbatim}
is translated to ({\bf VERSIONKEY} is OFF; the module header is omitted):
\begin{verbatim}
static void final(void)
/* finalization part */
{
  B_Foo();
} /* END */

void M_BEGIN(void)
{
  static int M_init=0;
  if (M_init) return;
  M_init=1;
  A_BEGIN();           /* initialize A */
  B_BEGIN();           /* initialize B */
  X2C_FINALLY(final);  /* register FINALLY */
  A_Foo();             /* M initialization */
}
\end{verbatim}

Each module initialization is executed only once (See the first
three lines in \verb+M_BEGIN+). Imported compilation units
are initialized before the body of the module.

For  a program module (or an \ot{} module marked with the {\bf MAIN}
option)  the  compiler  uses the identifier {\tt main} as the name of
module  body,  and the {\tt main} function contains a call of
\verb+X2C_INIT+ to initialize run-time system.

%----------------------------------------------------------------

\section{Oberon-2 object-oriented features}\label{maptoc:o2}
\index{mapping to C!Oberon-2 features}

The compiler uses the standard scheme to implement
object-oriented  features  in \ot{}. A dynamic type of records is
needed for type tests and a table of type-bound procedures (methods
or  virtual  functions)  is  needed  to call  them.  A type
descriptor  containing all necessary information
is   created   for   an   \ot{}   record   (See
\ref{maptoc:runtimedata}).

A  C structure corresponding to an \ot{} record does not contain any
additional  fields\footnote{Unlike  the previous \xds{} release.}
since, for variables of a record type, the dynamic type is statically
known to the compiler.  A  dynamic type of an object $v$ may differ
from a static  one  only  if $v$ is a variable parameter of a record
type or $v$ is a pointer. For a variable parameter of a record type
an  additional  parameter  ({\em  type  tag}  or  a pointer to type
descriptor) is passed (See \ref{maptoc:procdcl:varrec}).

For a dynamically allocated record, a type tag (and possibly some
other information) is stored before the actual record data and is
invisible to a programmer.

An extended record directly contains the fields of all the base types.
\begin{verbatim}
TYPE
  Node = POINTER TO NodeDesc;
  NodeDesc = RECORD
    next: Node;
  END;
  IntNodeDesc = RECORD (NodeDesc)
    val: INTEGER;
  END;
\end{verbatim}
is translated to:
\begin{verbatim}
struct NodeDesc;
typedef struct NodeDesc * Node;

struct x_NodeDesc {
  Node next;
};

struct x_IntNodeDesc {
  Node next;
  X2C_INT16 val;
};
\end{verbatim}

A   type-bound  procedure  is  translated  to  a  function  which
prototype  includes  both a receiver  parameter (two parameters if
receiver is a variable record parameter) and normal parameters.
\begin{verbatim}
PROCEDURE (n: Node) Print;
END Print;
\end{verbatim}
is translated to a function declaration and the corresponding function type:
\begin{verbatim}
typedef void (X2C_PROCLASS *Print_)(Node);

static  void X2C_PROCLASS Print(Node n)
{
} /* END Print */
\end{verbatim}

The call of type-bound procedure is made via a table of methods
({\tt node} is of type {\tt Node}).
\begin{verbatim}
  node.Print;
\end{verbatim}
is translated to the call of run-time macro:
\begin{verbatim}
  X2C_CALL(Print_,X2C_GET_TD(node),0)(node);
\end{verbatim}
\verb+X2C_CALL+ macro evaluates a procedure to call;
\verb+X2C_GET_TD+ function returns type tag;
\verb+Print_+ is the function type and {\tt 0} is the ordinal number
of the {\tt Print} method.

\section{Oberon-2 run-time data structures}\label{maptoc:runtimedata}

Certain  information  about an \ot{}  module must be available at
run-time.  This  information  is  provided  in  the  form of type
descriptors (for each record type) and a module descriptor.

A type descriptor contains an information necessary for:
\begin{itemize}
\item dynamic type tests and type guards (type descriptors
        of all base records);
\item calling type-bound procedures (a method table);
\item garbage collection (location of pointers in records and arrays).
\end{itemize}

The  run-time  system  provides a set of pre-defined descriptors,
that are used for dynamically allocated arrays (including dynamic
arrays).

A module descriptor contains an information necessary for garbage
collection (the locations of all global pointers)  and
meta-language programming.

\Example
\begin{verbatim}
MODULE x;

TYPE
  Node = POINTER TO NodeDesc;
  NodeDesc = RECORD
    next: Node;
  END;
  IntNode = POINTER TO IntNodeDesc;
  IntNodeDesc = RECORD (NodeDesc)
    val: INTEGER;
  END;

VAR root: Node; (* global pointer *)

PROCEDURE (n: Node) Print;
END Print;

PROCEDURE (n: IntNode) Print;
END Print;

PROCEDURE (n: IntNode) Foo;
END Foo;

END x.
\end{verbatim}

The following data structure will be created for the above example
(type descriptor of {\tt NodeDesc} and some details
are omitted, comments are added by hand):
\begin{verbatim}
/* Module descriptor: */
static void * x_offs[]={ &root,X2C_OFS_END };
static X2C_MD_REC x_desc={
  0,"x",x_offs
};

/* IntNodeDesc type descriptor: */

/* location of pointers (IntNodeDesc): */
static void * x_IntNodeDesc_offs[]= {
        X2C_OFS(struct x_IntNodeDesc,next),
        X2C_OFS_END };

/* method table: */
static X2C_PROC x_IntNodeDesc_proc[]= {
        (X2C_PROC) Print1
        (X2C_PROC) Foo };

/* IntNodeDesc type descriptor: */
extern X2C_TD_REC x_IntNodeDesc_desc={
  sizeof(struct x_IntNodeDesc),
  "IntNodeDesc",
  &x_desc,
  0,1,1,
  /* base type descriptors */
  { &x_NodeDesc_desc, &x_IntNodeDesc_desc,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
  },
  x_IntNodeDesc_proc, /* method table */
  x_IntNodeDesc_offs  /* pointer locations */
};
\end{verbatim}

%----------------------------------------------------------------

\section{Options}
\index{mapping to C!code generation options}

This sections describes the options that affect the generated
C code. Some of the options must remain the same for all modules
that belongs to the same program (See \ref{maptoc:opt:config}).

\subsection{Describing platform}\label{maptoc:opt:config}

The \xds{}  compilers  generate a highly  portable  ANSI  C  code.
However,  to  get  correct program one must appropriately describe
target  platform  configuration  (or  a  C  compiler) by using the
following options (all options are OFF by default):
\begin{description}
\item[TARGET16] \index{TARGET16@{\bf TARGET16}} \mbox{}

        The option must be set for 16-bit platform.
        If the option is ON, the compiler will assume the C {\tt int}
        type is 16 bits wide.
        {\bf Note:} different settings may be required for
        different C compilers; consult your C compiler manual.

\item[INDEX16]  \index{INDEX16@{\bf INDEX16}}  \mbox{}

        The option defines a size of an index and the maximum size of
        an array or structure on the target platform.
        If the option is ON, the compiler will assume that
        an index is 16 bits wide, otherwise 32 bits wide.

\item[DIFADR16] \index{DIFADR16@{\bf DIFADR16}} \mbox{}

        The option defines a difference between addresses
        on the target  platform.
        If the option is ON, the compiler assumes that the difference
        is a 16-bit integer value, otherwise a 32-bit integer value.

        The correct setting of the option is required to
        implement {\tt ADDADR}, {\tt SUBADR} and {\tt DIFADR}
        system functions.
\end{description}

These options must have the same settings for all the modules
of a program. {\bf Note:} the compiler inserts a definition of
the corresponding macros in the C code file.
\begin{verbatim}
#define X2C_int32     /* target 32 */
#define X2C_index32   /* index  32 */
\end{verbatim}

If the {\tt VERSIONKEY} option is set, an identifier of
an initialization function contains settings of these options
in a packed form.

\subsection{Code generation}\label{maptoc:opt:gen}

\subsubsection{Improving readability}

By default the compiler performs a set of optimizations, including
constant expression evaluation, constant propagation, etc.
In the expressions it generates constant values, not constant names.

If you are using \XDS{} as a translator, we recommend to set the option
\OERef{NOOPTIMIZE} ON. In this case, the
compiler generates constant names whenever possible.

\subsubsection{Generate C types}

The   \OERef{GENCTYPES}  option
forces the compiler  to  use  C  type  identifiers instead of the identifiers,
defined  in  {\tt  X2C.h}, see tables \ref{table:m2:C}, \ref{table:o2:C}
and \ref{table:SYSTEM:C}\ifonline\else{} on page \pageref{table:m2:C}\fi.

{\bf Note:}
\mt{}  {\tt  INTEGER},  {\tt CARDINAL} and {\tt BITSET} types are
translated according to the value of the {\bf M2BASE16} option.
In spite of the option setting, the compiler generates the identifiers
from {\tt X2C.h} for the following types:
\begin{center}
\begin{tabular}{|l|l|} \hline
\bf Source type & \bf X2C type   \\ \hline
WORD            & \verb+X2C_WORD+              \\
ADDRESS         & \verb+X2C_ADDRESS+           \\
PROC            & \verb+X2C_PROC+              \\
COMPLEX         & \verb+X2C_COMPLEX+           \\
LONGCOMPLEX     & \verb+X2C_LONGCOMPLEX+       \\
\hline
\end{tabular}
\end{center}

\subsubsection{Debug mode}

The \OERef{GENDEBUG} option should be set
to compile your program in the debug mode. If your program is compiled
in this mode, the run-time system will print a stack of procedure calls
(a file name and a line number) on abnormal termination of your program.

\Example
\begin{verbatim}
<*+ GENDEBUG *>
MODULE test;

PROCEDURE Div(a,b: INTEGER): INTEGER;
BEGIN
  RETURN a DIV b
END Div;

PROCEDURE Try;
  VAR res: INTEGER;
BEGIN
  res:=Div(1,0);
END Try;

BEGIN
  Try;
END test.
\end{verbatim}

\noindent
When this program is running, the exception is raised and the
run-time system prints the exception location and a stack of
procedure calls.  If the option {\bf LINENO} is ON, all information
will be reported in terms of original (\ot{}/\mt{}) source files:
\begin{verbatim}
#RTS: No exception handler #6: zero or negative divisor.
test.mod              6
test.mod             12
test.mod             16
\end{verbatim}
The exception was raised in line 6 of {\tt test.mod},
the {\tt Div} procedure was called from line 12,
while the {\tt Try} procedure was called from line 16
(module body).

If the option {\bf LINENO} is OFF, all information will be reported in
terms of generated C files:
\begin{verbatim}
#RTS: No exception handler #6: zero or negative divisor.
test.c               17
test.c               27
test.c               36
\end{verbatim}

In the debug mode the compiler inserts additional calls in the generated
C code (some parts of code unimportant for this example are omitted):
\begin{verbatim}
#define X2C_DEBUG

static  long X2C_PROCLASS Div(long a, long b)
{
  long Div_ret;
  X2C_PROC_INP();
  Div_ret=X2C_DIV(a,b);
  X2C_PROC_OUT();
  return Div_ret;
} /* END Div */

static  void X2C_PROCLASS Try(void)
{
  long res;
  X2C_PROC_INP();
  res = (X2C_SET_HINFO() Div(1l, 0l));
  X2C_PROC_OUT();
} /* END Try */
\end{verbatim}
As can be seen from the above example, the compiler
\begin{enumerate}
\item
        inserts the \verb|#define X2C_DEBUG| line in the module header.
        This definition switches all macros,
        defined in {\tt X2C.h} run-time library, into the debug mode.

\item
        generates calls of \verb|X2C_PROC_INP| and \verb|X2C_PROC_OUT|
        into each procedure declaration.

\item
        inserts \verb|X2C_SET_HINFO| macro (set history information)
        into each procedure call.

\end{enumerate}

{\bf Important notes:}
\begin{itemize}
\item
        If not all modules of the program are compiled in the
        debug mode, the stack of procedure calls may be
        incomplete. The \xds{} distribution contains libraries
        compiled in the debug mode. We recommend to use
        these libraries when debugging your program.

\item
        The \xds{} run-time system supports 64 levels of procedure
        calls. If this limit is exceeded, \xds{} will show only the first
        64 procedure calls.

\item
        Switching the option ON will significantly increase
        the size of your program and slow it down.
\end{itemize}

\subsubsection{Profile mode}

If the option \OERef{GENPROFILE} is
set ON, the compiler generates additional code to provide a profile of
the program. At the end of a program execution the run-time system will
print the profile of the program to standard output. For each procedure
in the program the output includes:
\begin{itemize}
\item  the name of procedure;
\item  the number of calls;
\item  the time of procedure execution, including all internal calls;
\item  the time of procedure execution, excluding all calls.
\end{itemize}

The option may be not implemented for all platfomrs.
See your on-line documentation.

\subsubsection{Generate K\&R C}

The option \OERef{GENKRC}
forces the compiler to generate K\&R C instead of ANSI C.
If the option is ON, the procedure declaration
\begin{verbatim}
PROCEDURE Foo(a,b: INTEGER);
BEGIN
  ...
END Foo.
\end{verbatim}
is translated to:
\begin{verbatim}
static void X2C_PROCLASS Foo(a, b)
  X2C_INT32 a;
  X2C_INT32 b;
{
 ...
} /* END Foo */
\end{verbatim}
By default the option is OFF and \xds{} generates the ANSI C code.

\subsubsection{Generate C++}

The option \OERef{GENCPP} forces the compiler
to generate C++ instead of ANSI C. In the current release there are
only few differences between generated ANSI C and C++ code. In the
future versions we will use specific C++ features to improve
readability and efficiency of generated code.

\subsubsection{Procedure class specification}

The option \OERef{GENPROCLASS}
forces the compiler to insert special macro \verb|X2C_PROCLASS|
into all function prototypes.

This macro can be used as a specifier of a function class, e.g. it can be set
to {\tt pascal} to change parameter passing convention.  For many
platforms, this macro cannot be used in a meaningful way. In such
cases, we recommend to set the option OFF to make the generated code
more readable.

\subsubsection{Generate {\tt typedef}}

The option \OERef{GENTYPEDEF}
specifies  the  generation  of a record,  enumerations and dynamic
arrays. If the option is OFF, the compiler generates only tag names
in the corresponding C constructs.
\begin{verbatim}
  struct Rec {...};
  enum Color {...};
\end{verbatim}
If the option is ON, the compiler generates both tag names
and type names, using {\tt typedef}.
\begin{verbatim}
  struct Rec {...};
  typedef struct Rec Rec;
  enum Color {...};
  typedef enum Color Color;
\end{verbatim}

The  option  is essential in the development of an interface to a foreign
library. An inline usage of the option is recommended in such cases.
The following examples (from {\tt stdio.h} and {\tt time.h}
illustrate inline usage.

From the interface to {\tt stdio.h}:
\begin{verbatim}
TYPE
<* PUSH *> <* GENTYPEDEF+ *>
  FILE = RECORD END;
<* POP *>
\end{verbatim}
The option shall be ON, since {\tt FILE} is usually defined as
\begin{verbatim}
typedef struct {...} FILE;
\end{verbatim}

Vice versa, we have to switch the option OFF,
when defining the interface to {\tt time.h}:
\begin{verbatim}
TYPE
<* PUSH *> <* GENTYPEDEF- *>
  tm = RECORD
    ...
  END;
<* POP *>
\end{verbatim}
since it is defined as
\begin{verbatim}
struct tm {...};
\end{verbatim}

\subsubsection{Version key}

The \OERef{VERSIONKEY} option
specifies the generation of an identifier for an initialization function.
The option is introduced to perform version checks
at a link time. If the symbol file (corresponding to a definition
or Oberon module) has the same version, the same names will be
generated for the calls of initialization functions.
If the name of an actual initialization function and the name
of the called function does not match the linker will report
the unresolved reference error. It means that the program
must be recompiled in the right order using MAKE or
PROJECT operation mode (See Chapter \ref{usage}).

{\bf Note:} the option should be set when
a definition or an Oberon module is compiled. See also \ref{maptoc:idents}
for further details.

\subsubsection{The length of identifiers}

The  \OERef{GENIDLEN} sets the
maximum  length  of an identifier in the generated code. {\bf Note:}
the identifier's length cannot be less than 6 characters. The small
value  leads  to  more  compact  but  non-readable text. See also
\ref{maptoc:idents}.

\subsection{Evaluating size of types}\label{maptoc:opt:sizeof}

The  programmers  are  used  to  the fact that the sizes of types are
known at the compilation time, i.e. one can write
\begin{verbatim}
TYPE Rec = RECORD ... END;

CONST Size = SIZE(Rec);
\end{verbatim}
The  portable  nature  of \xds{} compilers makes an evaluation of
sizes at constant times somewhat tricky. Different C compilers on
different  platforms  may use various alignment algorithms, not
mentioning that the base types may have different sizes.

To  generate  a  portable  code, the \xds{} compilers do not allow (in
default  mode) the  call  of {\tt SIZE} and {\tt TSIZE}
functions to be used in constant expressions. E.g. one can write
\begin{verbatim}
  size:=SIZE(Rec);
\end{verbatim}
but not
\begin{verbatim}
CONST Size = SIZE(Rec);
\end{verbatim}

In most cases, it is not an essential restriction, since
\begin{itemize}
\item   a use of the size of a type is rare in high-level programming;
\item   if a constant like {\tt Size} is not used itself in a constant
        expression it can be replaced by a variable initialized
        in the module body.
\end{itemize}
However,  both \mt{} and \ot{} languages can be used in the low-level
programming  and  it can be desirable to know a size of a type in
compilation  time,  in  spite  of a potential non-portability  of a
program.

If the \OERef{GENSIZE} option is set ON,
the compiler will calculate sizes of types using the value
of the \OERef{ALIGNMENT} equation.

You have to consult with your C compiler guide to set the proper
value of the equation. To prevent that inappropriate setting,        % ??? What exaclty is meant here?
the compiler generates checks in the module
initialization function.
\begin{verbatim}
  if (sizeof(Rec) != 4) X2C_TRAP(X2C_ASSERT_TRAP);
\end{verbatim}
An exception will be reported at a run-time\footnote{During the program
initialization.} if the size evaluated by the \xds{} compiler
is not equal to those evaluated by the C compiler.

\subsection{Foreign language interface}\label{maptoc:opt:foreign}

Certain options are introduced to specify an interface to foreign
languages,   namely  {\bf  NOHEADER},  {\bf  NOEXTERN}  and  {\bf
CSTDLIB}.     See    also    the    {\bf    GENTYPEDEF}    option
(\ref{maptoc:opt:gen})  which  is often used for providing a correct
foreign language interface.

\subsubsection{Disable header file}

The \OERef{NOHEADER} option disables
the  generation of a header file. The option is usually specified
in  the  foreign definition module to force the C compiler to use
the original header files (See also \ref{multilang:C}).

\subsubsection{Disable function prototype}

In  some  cases  it  may  be  desirable  not  to  write a foreign
definition module but to use a few C functions directly.
The \xds{} compilers allow a C function to be declared as external:
\begin{verbatim}
PROCEDURE [2] / putchar(c: CHAR);
\end{verbatim}
The symbol \verb|"/"| marks a procedure as external. Only
procedure header must be specified for an external procedure.
After the declaration the external procedure can be used
as usual:
\begin{verbatim}
  putchar('a');
\end{verbatim}
A  function  defined  as external can be implemented as macro, or
have  some  additional  specifications in its prototype. The \OERef{NOEXTERN}
option  prevents the compiler from generating  a function's prototype.
In this case, a C compiler will use an original prototype (if available).

\subsubsection{Mark C interface library}

The \OERef{CSTDLIB}
option must be set when compiling a foreign definition
module, otherwise the option is ignored.
For the foreign definition marked as {\bf CSTDLIB},
the compiler will use angle brackets \verb+<>+
in the \verb|#include| directive.
Otherwise the compiler will use quotes.
\Example
\begin{verbatim}
<*+ CSTDLIB *> <*+ NOHEADER *>
DEFINITION MODULE stdio;
...
END stdio.

MODULE Test;

IMPORT  stdio, MyLib;

END Test.
\end{verbatim}
The import section of the module {\tt Test} is translated to:
\begin{verbatim}
#include <stdio.h>
#include "MyLib.h"
\end{verbatim}

\subsection{Code presentation}\label{maptoc:opt:rep}

In  this  section  we  describe options that do not affect the
program execution, but the C code representation.

\subsubsection{Insert line numbers}

The \OERef{LINENO} option forces the
compiler  to a insert line number information into the generated C
code in the form of \verb+#line+ directives.
\Example
\begin{verbatim}
PROCEDURE Foo(i: INTEGER): INTEGER;
BEGIN
  i:=i*i;
  i:=i+i;
  RETURN i
END Foo;
\end{verbatim}
translate to:
\begin{verbatim}
#line 2
static X2C_INT32 X2C_PROCLASS Foo(X2C_INT32 i)
{
  #line 4
  i=i*i;
  #line 5
  i=i+i;
  #line 6
  return i;
} /* END Foo */
\end{verbatim}

\subsubsection{Copy comments}

The \OERef{COMMENT} option forces the
compiler  to copy the original file comments into the generated C
code.

If the option is ON, the compiler copies comments to an appropriate
place in the  generated  C  code.  Comments from an \ot{} module are
only inserted into the C code file and not into the header file.

%!!! example -- ask Sem

\subsubsection{Insert copyright message}

The \OERef{COPYRIGHT} equation can be
used  for inserting a single line comment to the very beginning of
the generated code or header file. E.g., including the line
\begin{verbatim}
-copyright = (c) 1995 Widget Databases Ltd
\end{verbatim}
to {\bf \cfg} will cause the following line to appear
at the head of the generated C text
\begin{verbatim}
/* (c) 1995 Widget Databases Ltd */
\end{verbatim}

See also an example in \ref{maptoc:layout}.

\subsubsection{Convert header file names}

The \OERef{CONVHDRNAME} option
forces the compiler   to  use a file  name  in  the  \verb|#include|
directive,  according  to  the  given  file system. Otherwise the
compiler  will  generate a module name postfixed by the header file
extension.   E.g.,  the  include  directive  for  the  module  {\tt
MyLibrary} will be generated under OS/2 as
\begin{verbatim}
#include "MYLIBRAR.H"
\end{verbatim}
The  option may be necessary if source text resides on a FAT partition.

\subsubsection{Set line width}

The \OERef{GENWIDTH} equation
sets  the  length  of a line in the generated code
(by default it is equal to 78).
{\bf  Note:} the compiler splits a line in an appropriate place,
when its length exceedes the limit.
