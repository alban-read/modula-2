\chapter{Run-time support}\label{rts}
\index{Run-Time support}\index{RTS}

Some language features are implemented in the run-time library,
including:
\begin{itemize}
\ifgenc
\item   run-time checks
\fi
\item   exceptions and finalization
\item   coroutines
\item   memory management
\item   garbage collection
\item   postmortem history
\end{itemize}
\xds{} provides an integrated \mt{} and \ot{} run-time library, taking
into account the possibility that modules written in both languages are
used in one project. As a rule, if you do not use a particular feature,
the part of RTS that implements that feature will not be added to your
executable program. For example, if your program is written entirely
in \mt{}, the \ot{} part of RTS (garbage collector, meta-language
facilities) will not included.

The integrated memory manager is described
in \ref{rts:mm}. The section \ref{rts:oberonRTS} describes
an interface to the \ot{} run-time support.

\section{Memory management}\label{rts:mm}
\index{memory management}
\index{garbage collection}

The \xds{} integrated memory manager implements
\begin{itemize}
\item   default memory allocation and deallocation procedures for \mt{}
        (See the option \OERef{STORAGE});
\item   memory allocation procedures for \ot{};
\item   system memory allocation procedures for \ot{}
        (See \ref{o2:system:new});
\item   the garbage collector.
\end{itemize}

The compiler provides the option \OERef{GCAUTO} and the equation
\OERef{HEAPLIMIT} to control the memory management. They should be set
when the top-level module of the program is compiled\footnote{
We recommend to set them in the configuration file or a project file.}.
The compiler uses their values when generating
the RTS initialization call.

The equation \OERef{HEAPLIMIT} specifies the maximum size of the heap
in bytes. If that equation is set to zero, the run-time system automatically
determines heap size at startup and dynamically adjusts it according to
application's memory use and system load.

The option \OERef{GCAUTO} allows the garbage collector to be called
implicitly.
If the option is not set the garbage collector
must be called explicitly (See \ref{rts:oberonRTS}).
The garbage collector is called implicitly by the memory
allocation procedure in the following cases:
\begin{itemize}
\item
        a memory block of the requested length cannot be allocated;
\item
        the amount of busy memory exceeds the limit
        specified by the \OERef{HEAPLIMIT} equation (or the limit
        chosen by the run-ime system if \OERef{HEAPLIMIT} was set to zero
        during compilation);
\item
        the amount of busy memory exceeds some limit set
        internally by the memory manager for optimum performance.
\end{itemize}
If the memory block still cannot be allocated
after the call to the garbage collector, the exception
\verb'XEXCEPTIONS.noMemoryException' will be raised
by the \ot{} memory allocation procedure\footnote{In \mt{}
it has to return {\tt NIL} if failed to allocate a memory block.}.

{\bf Note:} In a pure \mt{} program, the garbage collector
is never invoked, so you may set the \OERef{HEAPLIMIT} equation
to a very large value.

\section{Postmortem history}\label{rts:history}

If the option \OERef{GENHISTORY} was
set ON when your program was compiled, the run-time system
\ifgenc prints a stack
of procedure calls on abnormal termination of your program, including
\else
dumps a procedure call stack into a file called \verb'errinfo.$$$', which
may then be read by the HIS utility to print each item with
\fi
\begin{itemize}
\item a file name
\item a line number
\item a program counter value
\item a procedure name (sometimes)
\end{itemize}
{\bf Note:} all modules constituting your program should be compiled with
the option \OERef{LINENO} set ON.

\ifgencode
To print the history, RTS scans the stack of the coroutine
that caused an exception and tries to find procedure calls. This is
not a trivial task because of the highly optimized code generated by the
compiler. For example, not all procedures have a stack frame.

For each pointer to the code segment on the stack RTS checks the
previous command. If this command is a call command, it assumes that
this is a procedure call. It is unlikely that RTS misses a procedure
call, but it can be cheated by something that looks like a procedure
call. As a rule, it is caused by uninitialized local variables, especially
character arrays.

The first line of the history is always correct. For each line, except
the first one, we recommend to check that the procedure shown in the
previous line is called from the given line.

From the other hand, if you turn the \OERef{GENFRAME} option on,
the code will be a bit slower, but RTS will scan stack frames of the
procedures and the history will show {\em absolutely} correct addresses
and line numbers. Procedure names are almost always valid except the case
of lack of debug information in some modules - probably
compiled by foreign compilers or by \XDS{} with not all debug flags set.
So you should not rely on procedure names hard.

Turning the \OERef{GENHISTORY} option ON does {\em not} slow down your code,
as it only adds an extra call to the initialization routine.
\else % genc
{\bf Note:} Turning the \OERef{GENHISTORY} option ON slows down your code,
cause the translator inserts extra RTS calls into every generated function.
\fi
It should be done when you compile the main module of your program, in
its header, compiler command line, or project (we recommend the last approach).

The following example shows a sketch of a program and the procedure
stack:
\begin{verbatim}
    PROCEDURE P1;
      (* uninitialized variable: *)
      VAR x: ARRAY [0..50] OF INTEGER;
    BEGIN
      i:=i DIV j;   (* line 50 *)
    END P1;

    PROCEDURE P2;
    BEGIN
      i:=i DIV j;   (* line 100 *)
    END P2;

    PROCEDURE P3;
    BEGIN
      P1;           (* line 150 *)
    END P3;
\end{verbatim}

\begin{verbatim}
#RTS: No exception handler #6: zero or negative divisor
------------------------------------------------------------
Source file                        LINE  OFFSET  PROCEDURE
------------------------------------------------------------
"test.mod"                           50 000000DE
"test.mod"                          100 0000024C
"test.mod"                          150 0000051D
\end{verbatim}
It is obvious from the source text that the procedure \verb'P1' cannot be
called from \verb'P2'. The second line is superfluous.

\section{The oberonRTS module}\label{rts:oberonRTS}
\index{Oberon run-time support}

The run-time support (RTS) is an integral part of the \ot{}
language implementation. It includes command activation,
memory allocation, garbage collection and
meta-language facilities.
The module {\bf oberonRTS} (written in \mt{})
provides an interface to these features.
\lindex{oberonRTS}

\subsection{Types and variables}
\begin{verbatim}
    TYPE
      Module;  (* run-time data structure for a module *)
      Type;    (* run-time data structure for a data type *)
      Command = PROC; (* parameterless procedure *)
      CARDINAL = SYSTEM.CARD32;
\end{verbatim}

\begin{verbatim}
    VAR
      nullModule: Module; (* Null value of type Module *)
      nullType: Type;     (* Null value of type Type *)
\end{verbatim}

\subsection{Garbage collection}

\Frame{Collect}{Garbage Collector}

\verb'    PROCEDURE Collect;'

Invokes the garbage collector.

\Frame{GetInfo}{Get Memory Information}

\verb'    PROCEDURE GetInfo(VAR objects, busymem: CARDINAL);'

Returns the number of allocated objects and the total size
of the allocated memory.

\subsection{Object finalization}

A system with garbage collection has some specific features. Its
main difference from systems without garbage collection
is that deallocation of any system resource must be postponed
until garbage collection. For example, let some data structure
contain descriptors of open files. To  close  a  file  (i.e.
to destroy its descriptor), one needs to know that there are
no references to that file. This information becomes known
only in the course of garbage collection.  The  same  argument
also holds for other kinds of resources.

One  immediate  implication  is  that  there  must  be  some {\em
finalization}   mechanism:   the ability  to  perform  certain
operations  with  an  object when there are no more references to it.

\XDS{} allows a finalization procedure to be attached to any
dynamically allocated object.

\Frame{Finalizer}{Type of a finalization procedure}

\verb'    TYPE Finalizer = PROCEDURE (SYSTEM.ADDRESS);'

\Frame{InstallFinalizer}{Set a finalizer to an object}

\verb'    PROCEDURE InstallFinalizer(f: Finalizer;'\\
\verb'                               obj: SYSTEM.ADDRESS);'

The procedure sets the finalization procedure \verb'f' for the object
\verb'obj'.
That procedure will be called when the object becomes unreachable.

{\bf Note}: a finalizer is called on the GC stack (stack size is limited).

\Example
\begin{verbatim}
    TYPE
      Obj = POINTER TO ObjDesc;
      ObjDesc = RECORD
        file: File; (* file handler *)
      END;

    PROCEDURE Final(x: SYSTEM.ADDRESS);
      VAR o: Obj;
    BEGIN
      o:=SYSTEM.CAST(Obj,x);
      IF o.file # NIL THEN Close(file) END;
    END Final;

    PROCEDURE Create(): Obj;
      VAR o: Obj;
    BEGIN
      NEW(o);
      o.file:=NIL;
      oberonRTS.InstallFinalizer(Final,o);
      TryOpen(o.file);
    END Create;
\end{verbatim}

\subsection{Meta-language facilities}

The meta-programming operations can be used to retrieve the type of an
object, to create an object of the given type, to get the name of a
type and a type by its name, etc.

\Frame{Search}{Search a Module by its Name}

\verb'    PROCEDURE Search(name: ARRAY OF CHAR): Module;'

Returns a module by its \verb'name' or {\tt nullModule}.

\Frame{NameOfModule}{Name of Module}

\verb'    PROCEDURE NameOfModule(m: Module;'\\
\verb'                    VAR name: ARRAY OF CHAR);'

Returns the \verb'name' of the \verb'Module'.

\Frame{ThisCommand}{Get Command by its Name}
\begin{verbatim}
    PROCEDURE ThisCommand(m: Module;
                       name: ARRAY OF CHAR;
                         ): Command;
\end{verbatim}
Returns the command (parameterless procedure) named "\verb'name'" in
the module {\tt m} or \verb'NIL', if the command does not exist.

\Frame{ThisType}{Get Type by its Name}
\begin{verbatim}
    PROCEDURE ThisType(m: Module;
                    name: ARRAY OF CHAR): Type;
\end{verbatim}
Returns the type named "\verb'name'" declared in the module
{\tt m} or {\tt nullType}, if there is no such type.

\Frame{SizeOf}{Size of Type}

\verb'    PROCEDURE SizeOf(t: Type): INTEGER;'

Returns the size (in bytes) of an object of the type {\tt t}.

\Frame{BaseOf}{Base of Type}

\verb'    PROCEDURE BaseOf(t: Type; level: INTEGER): Type;'

Returns the {\em level}-th base type of {\tt t}.

\Frame{LevelOf}{Level of Type Extension}

\verb'    PROCEDURE LevelOf(t: Type): INTEGER;'

Returns a level of the type extension.

\Frame{ModuleOf}{Module of Type}

\verb'    PROCEDURE ModuleOf(t: Type): Module;'

Returns the module in which the type {\tt t} was declared.

\Frame{NameOfType}{Name of Type}

\verb'    PROCEDURE NameOfType(t: Type; VAR name: ARRAY OF CHAR);'

Returns the \verb'name' of the record type \verb't'.

\Frame{TypeOf}{Type of Object}

\verb'    PROCEDURE TypeOf(obj: SYSTEM.ADDRESS): Type;'

Returns the type of the object \verb'obj'.

\Frame{NewObj}{Create Object}

\verb'    PROCEDURE NewObj(type: Type): SYSTEM.ADDRESS;'

Creates a new object of the type {\tt type}.

\subsection{Module iterators}

The module \verb'oberonRTS'
provides procedures which can be used to iterate all loaded
modules, all commands, and all object types (i.e., exported record
types).

\Frame{NameIterator}{Iterator Type}
\begin{verbatim}
    TYPE
      NameIterator = PROCEDURE (
                       (*context:*) SYSTEM.ADDRESS,
                       (*name:*) ARRAY OF CHAR
                     ): BOOLEAN;
\end{verbatim}
A procedure of type {\tt NameIterator} is called by
an iterator on each iterated item. An iterator passes
the name of the item along with the so-called {\em context} word.
This allows some context information to be passed to the
user-defined procedure (e.g., a file handler).
If the procedure returns FALSE, the iteration is terminated.

\Frame{IterModules}{Iterate all Modules}
\begin{verbatim}
    PROCEDURE IterModules(context: SYSTEM.ADDRESS;
                             iter: NameIterator);
\end{verbatim}
The procedure iterates all \ot{} modules.

\Frame{IterCommands}{Iterate Commands}
\begin{verbatim}
    PROCEDURE IterCommands(mod: Module;
                       context: SYSTEM.ADDRESS;
                          iter: NameIterator);
\end{verbatim}
Iterates all commands implemented in the module {\tt mod}.

\Frame{IterTypes}{Iterate Record Types}
\begin{verbatim}
     PROCEDURE IterTypes(mod: Module;
                     context: SYSTEM.WORD;
                        iter: NameIterator);
\end{verbatim}
Iterates all record types declared in the module {\tt mod}.


% examples !!!
