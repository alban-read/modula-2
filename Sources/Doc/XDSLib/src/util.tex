\chapter{Utility libraries}\label{lib:util}
\index{utility libraries}\index{libraries!utility}

Starting from \xds{} v2.0 the general purpose modules used in
\xds{} compilers and utilities, which are portable between all
versions of \xds{} on all platforms, are included in the utility
library. If you use the ISO library only, your program may be portable to
any ISO compliant \mt{} compiler. However, there are some essential
features which are omitted in the ISO library. The utility library 
covers some of those omissions.

{\bf Note:} Some library modules are written in \ot{}, others in \mt{}.
In general, any library can be used from both languages. However, do
not forget that Oberon modules use implicit memory
deallocation scheme and require garbage collection.
Refer to the {\em Multilangauge programming} Chapter of the
{\em XDS User's Guide}.

The following modules are provided in the utility library
(implementation language is pointed out in parentheses):
\begin{flushleft}
\begin{tabular}{lll}
\IdRef{FileName} & (M2) & Creating and parsing file names           \\
\IdRef{FileSys}  & (M2) & Common file operations                    \\
\IdRef{FormOut}  & (M2) & Generic module for formatting output      \\
\IdRef{FormStr}  & (M2) & Formatting output to strings              \\
\IdRef{Printf}   & (M2) & C style formatting output precedures      \\
\IdRef{ProgEnv}  & (M2) & Access to program environment             \\
\IdRef{TimeConv} & (M2) & Operations on time and date values        \\
\IdRef{DStrings} & (O2) & Dynamic strings                           \\
\IdRef{FilePath} & (O2) & File search operations                    \\
\IdRef{RegComp}  & (O2) & Regular expressions                       \\
\end{tabular}
\end{flushleft}

\section{FileName module}
\renewcommand{\ModuleI}{FileName}
\OneModule

The module provides operations for parsing and constructing file
names. A file name consists of three parts: the directory, name and
extension.

All the procedures that construct a string value ({\tt Get}, {\tt
GetDir},  {\tt GetName}, {\tt GetExt}, {\tt Convert}, {\tt
Create}), have the common behaviour: if the length of a constructed
string value exceeds capacity of a variable parameter, a
truncated value is assigned. If the length of a
constructed string value is less than the capacity of a
variable parameter, a string terminator is appended.

{\samepage
\Frame{Format}{File name format record}
\begin{verbatim}
TYPE
  Format = RECORD
    ok: BOOLEAN;
    (* directory position and length: *)
    dirPos, dirLen : CARDINAL;
    (* name position and length: *)
    namePos,nameLen: CARDINAL;
    (* extension position and length: *)
    extPos, extLen : CARDINAL;
  END;
\end{verbatim}
}
\ModuleList

{\samepage
\Frame{GetFormat}{Get file name format}
\begin{verbatim}
PROCEDURE GetFormat(str: ARRAY OF CHAR; VAR f: Format);
\end{verbatim}
}
\ModuleList
The {\tt GetFormat} procedure writes the position and
length of file name parts to a \IdQualRef{Format} type
record passed in \verb'f'. If \verb|f.ok = FALSE|,
vaues of all other fields are undefined.

{\samepage
\Frame{Get*}{Get file name parts}
\begin{verbatim}
PROCEDURE GetDir (fname: ARRAY OF CHAR;
                VAR dir: ARRAY OF CHAR);
PROCEDURE GetName(fname: ARRAY OF CHAR;
               VAR name: ARRAY OF CHAR);
PROCEDURE GetExt (fname: ARRAY OF CHAR;
                VAR ext: ARRAY OF CHAR);
PROCEDURE Get(fname: ARRAY OF CHAR;
   VAR dir,name,ext: ARRAY OF CHAR);
\end{verbatim}
}
\ModuleList
These procedures return corresponding file name parts.

{\samepage
\Frame{Convert}{Convert String to File Name}
\begin{verbatim}
PROCEDURE Convert(str: ARRAY OF CHAR;
            VAR fname: ARRAY OF CHAR);
\end{verbatim}
}
\ModuleList
Converts a string to a file name according to the conventions of the
underlying file system.

{\samepage
\Frame{ConvertExt}{Convert File Name Extension}
\begin{verbatim}
PROCEDURE ConvertExt(VAR ext: ARRAY OF CHAR);
\end{verbatim}
}
\ModuleList
Converts an extension according to the conventions of
the underlying file system.

{\samepage
\Frame{Length}{Calculate File Name Length}
\begin{verbatim}
PROCEDURE Length(dir,name,ext: CARDINAL): CARDINAL;
\end{verbatim}
}
\ModuleList
Using the lengths of the directory, name and extension returns
an estimated file name length which is greater than or equal to
the length of the name generated by the {\tt Create} procedure call.

{\samepage
\Frame{Create}{Create File Name}
\begin{verbatim}
PROCEDURE Create(dir,name,ext: ARRAY OF CHAR;
                    VAR fname: ARRAY OF CHAR);
\end{verbatim}
}
\ModuleList
Creates a file name from its parts.

\subsection{Example}

The following procedure can be used to change file name
extension:
\begin{verbatim}
PROCEDURE ChangeExt(VAR fname: ARRAY OF CHAR;
                       newext: ARRAY OF CHAR);
  CONST Len = 64;
  VAR
    dir,name: ARRAY [0..Len-1] OF CHAR;
    f: FileName.Format;
    len: CARDINAL;
BEGIN
  FileName.GetFormat(fname,f);
  IF NOT f.ok THEN Error("wrong format")
  ELSIF (f.dirLen > Len) OR (f.nameLen > Len) THEN
    Error("too long part");
  ELSE
    len:=FileName.Length(f.dirLen,f.nameLen,LENGTH(newext));
    IF len-1 > HIGH(fname) THEN
      Error("cannot create file name")
    ELSE
      FileName.Create(dir,name,newext,fname);
    END;
  END;
END ChangeExt;
\end{verbatim}

When programming in \ot{} dynamic strings can be used to
create strings of a required length:
\begin{verbatim}
PROCEDURE ChangeExt(VAR fname: ARRAY OF CHAR;
                       newext: ARRAY OF CHAR);
  VAR
    dir,name: DStrings.String;
    f: FileName.Format;
BEGIN
  FileName.GetFormat(fname,f);
  IF NOT f.ok THEN Error("wrong format")
  ELSE
    NEW(dir,f.dirLen+1);
    NEW(name,f.nameLen+1);
    ...
    END;
  END;
END ChangeExt;
\end{verbatim}

%--------------------------------------------------------

\section{FileSys module}
\renewcommand{\ModuleI}{FileSys}
\OneModule

The module provides file common operations.

{\samepage
\Frame{Exists}{Is File Exist}
\begin{verbatim}
PROCEDURE Exists(fname: ARRAY OF CHAR): BOOLEAN;
\end{verbatim}
}
\ModuleList
Returns \verb'TRUE', if file {\tt fname} exists.

{\samepage
\Frame{ModifyTime}{Return Modify Time}
\begin{verbatim}
PROCEDURE ModifyTime(fname: ARRAY OF CHAR;
                  VAR time: LONGCARD;
                VAR exists: BOOLEAN);
\end{verbatim}
}
\ModuleList
Returns a file modification time; {\tt time} is valid
only if \verb|exists=TRUE|.

{\samepage
\Frame{Rename}{Rename File}
\begin{verbatim}
PROCEDURE Rename(fname,newname: ARRAY OF CHAR;
                      VAR done: BOOLEAN);
\end{verbatim}
}
\ModuleList
Renames the file {\tt fname} to {\tt newname}.

{\samepage
\Frame{Remove}{Remove File}
\begin{verbatim}
PROCEDURE Remove(fname: ARRAY OF CHAR;
              VAR done: BOOLEAN);
\end{verbatim}
}
\ModuleList
Removes a file.

%--------------------------------------------------------

\section{FormOut module}
\renewcommand{\ModuleI}{FormOut}
\OneModule

The {\tt FormOut} module implements a generic formatted output
procedure which outputs its arguments according to the format parameter.
The syntax of a format string is similar to one used by
the {\tt printf} family of C functions;
some useful extensions are provided as well.

\begin{verbatim}
  Format = { character | Specifier }.
  Specifier = "%" Modifier Width
            [ "." Precision [ "." Start ] ] Base.
  Modifier = "+" | "-" | "|" | "0" | "$" | "#".
  Width = [ unsigned number | "*" ].
  Precision = [ unsigned number | "*" ].
  Start = [ unsigned number | "*" ].
  Base = "c" | "d" | "i" | "u" | "o" | "x" | "X" |
         "e" | "f" | "g" |
         "s" | "{}"
\end{verbatim}

The following pairs of symbols starting from the backslash
are recognized in \verb'Format' string (but {\em not} in strings
printed using "\verb|%s|" specifier):
\begin{flushleft}
\begin{tabular}{c|l}
\bf Input & \bf Output \\
\hline
\verb'\n' & the line separator \\
\verb'\r' & CR  (15C)          \\
\verb'\f' & FF  (14C)          \\
\verb'\t' & TAB (11C)          \\
\verb'\\' & backslash          \\
\end{tabular}
\end{flushleft}

{\tt Base} characters and their meanings are listed in the following table:

\begin{flushleft}
\begin{tabular}{c|l|l}
\bf Base             & \bf Argument & \bf Output format \\
\hline
\verb"c"             & CHAR    & single character             \\
\verb"d", \verb"i"   & integer & signed decimal integer       \\
\verb"u"             & integer & unsigned decimal integer     \\
\verb"o"             & integer & unsigned octal integer       \\
\verb"X", \verb"x"   & integer & unsigned hexadecimal integer \\
\verb"E", \verb"e"   & real    & floating-point real          \\
\verb"f",            & real    & fixed-point real             \\
\verb"G", \verb"g"   & real    & either as "f" or "e"         \\
\verb"s"             & string  & string                         \\
\verb"{}"            & BITSET  & bitset, e.g. \verb|{1,3..5}| \\
\end{tabular}
\end{flushleft}

{\tt Modifier} meanings are as follows:

\begin{flushleft}
\begin{tabular}{c|l|l}
\bf Modifier & \bf Meaning                     & \bf Default \\
\hline
 \verb'"+"' & always print a sign for numbers  & only for negative    \\
 \verb'"-"' & justify the result to the left   & right-justify        \\
 \verb'"|"' & center the result                &                      \\
 \verb'"0"' & print leading zeroes for numbers & spaces               \\
 \verb'"$"' & the same as "0"                  &                      \\
 \verb'"#"' & print a base character ("H" or "B") & no base character \\
            & for "o", "x" and "X" bases only  &
\end{tabular}
\end{flushleft}

{\tt Width} is used to specify the minimum number of characters in
the output value. Shorter values are padded with blanks or zeroes
to the left and/or to the right, depending on whether a \verb'"-"',
\verb'"|"', \verb'"0"', or \verb'"$"' modifier is present.
Specifying {\tt Width} never causes longer values to be truncated;
if it is not given or is less than the number of characters in the
output value, all characters will be output. In some cases,
{\tt Precision} may be used for truncation.

If {\tt Width} is set to an asterisk (\verb'"*"'), its actual value will be
retrieved from the argument list. It has to be specified before the value
being formatted.

{\tt Precision} specifies the number of characters to output or the number
of decimal places. Unlike {\tt Width}, it may cause the output value
to be truncated or rounded.

If {\tt Precision} is set to an asterisk (\verb'"*"'), its actual value will
be taken from the argument list. It has to be specified before the value being
formatted, but after the actual value for {\tt Width}, if the latter is also set
to "*".

{\tt Precision} value is interpreted depending upon the {\tt Base},
and specifies:

\begin{description}
\item[{\bf i d u o x X}] \mbox{} \\
    The minimum number of digits to output. Shorter values are padded on
    the left with blanks; longer values are not truncated. Default is 1.
\item[{\bf f F e E}] \mbox{} \\
    The number of positions after the decimal point. The last digit output
    is rounded. If {\tt Precision} is 0, decimal point is not printed.
    Default is 6.
\item[{\bf g G}] \mbox{} \\
    The maximum number of significant digits to output. By default,
    all significant digits are printed.
\item[{\bf c}] \mbox{} \\
    The number of times the character is to output, default is 1.
\item[{\bf s}] \mbox{} \\
    The maximum number of characters to output. By default, characters
    are output until \verb'0C' is reached.
\item[{\bf \{\}}] \mbox{} \\
    Has no effect.
\end{description}

{\tt Start} may be used with the \verb'"s"' (string) base only
and specifies an initial offset in the string being formatted.
If {\tt Start} is set to an asterisk (\verb'"*"'), the actual value will
be taken from the argument list. It has to be specified before the value being
formatted, but after the actual values for {\tt Width} and/or {\tt Precision},
if either of them is also set to "*".

{\bf Notes:}

\begin{itemize}
\item  neither the compiler nor the library checks the correctness
       of actual arguments against format specifications.
       However, all specifiers, for which no arguments are passed,
       are ignored, while C {\tt printf}-like functions may
       produce unpredictable results in such case.
\item  the ISO conversion library (See \ref{lib:ISO:conv})
       is used to convert numbers to strings, therefore the results may
       differ from produced by C functions.
\end{itemize}

{\samepage
\Frame{writeProc}{Write Procedure Type}
\begin{verbatim}
TYPE
  writeProc = PROCEDURE(
                (*handle:*) SYSTEM.ADDRESS,
                (*string:*) ARRAY OF CHAR,
                (*length:*) INTEGER
              );
\end{verbatim}
}
\ModuleList
A procedure of this type is passed to the \IdQualRef{format} procedure
which uses that procedure to perform output.

{\samepage
\Frame{format}{Generic Formatting Procedure}
\begin{verbatim}
PROCEDURE format(handle : SYSTEM.ADDRESS;
                 write  : writeProc;
                 fmt    : ARRAY OF CHAR;
                 linesep: CHAR;
                 args   : SYSTEM.ADDRESS;
                 size   : CARDINAL);
\end{verbatim}
}
\ModuleList
The {\tt format} procedure forms a string and outputs it via the
{\tt write} procedure parameter. The {\tt handle} parameter is
passed to the procedure {\tt write} and provides a useful method
to pass any information between the caller and the {\tt
write} procedure (e.g. output channel or something like it).
The ({\tt args}, {\tt size}) pair denotes the address and
size of the parameter block.
The {\tt linesep} parameter determines the line separator character
sequence corresponding to "\verb|\n|". Several standard values of the
parameter are defined in the definition module:
\begin{flushleft}
\begin{tabular}{ll}
{\tt default} & default line separator for binary files \\
{\tt text}    & default line separator for text files   \\
{\tt crlf}    & CR LF character sequence                \\
\end{tabular}
\end{flushleft}
If the {\tt linesep} is not equal to any of the values above,
its value will be used as a line separator.

{\samepage
\Frame{LineSeparator}{Set Line Separator}
\begin{verbatim}
PROCEDURE LineSeparator(nl: ARRAY OF CHAR);
\end{verbatim}
}
\ModuleList
Sets the default line separator for binary files.
The correct value for the given platform is set in the module
initializaion.

{\samepage
\Frame{TextSeparator}{Set Line Separator}
\begin{verbatim}
PROCEDURE TextSeparator(nl: ARRAY OF CHAR);
\end{verbatim}
}
\ModuleList
Sets the default line separator for text files.
The correct value for the given platform is set in the module
initializaion.

\subsection{Examples}

The following example shows the implementation of a procedure which
produces a format output to an ISO channel.
\begin{verbatim}
PROCEDURE ChanWrite(handle: SYSTEM.ADDRESS;
                    str: ARRAY OF CHAR;
                    len: INTEGER);
  VAR chan: IOChan.ChanId; pos: INTEGER;
BEGIN
  chan:=SYSTEM.CAST(IOChan.ChanId,handle);
  pos:=0;
  WHILE len > 0 DO
    IF str[pos] = ASCII.LF THEN IOChan.WriteLn
    ELSE IOChan.TextWrite(chan,SYSTEM.ADR(str[pos]),1)
    END;
    INC(pos); DEC(len);
  END;
END ChanWrite;

PROCEDURE Print(chan: IOChan.ChanId;
              format: ARRAY OF CHAR;
            SEQ args: SYSTEM.BYTE);
BEGIN
  FormOut.format(chan,ChanWrite,format,FormOut.text,
                 SYSTEM.ADR(args),SIZE(args));
END Print;
\end{verbatim}

\noindent
The procedure {\tt printf} prints to the standard output channel:
\begin{verbatim}
PROCEDURE printf(f: ARRAY OF CHAR; SEQ x: SYSTEM.BYTE);
BEGIN
  Print(StdChans.StdOutChan(),f,x);
END printf;
\end{verbatim}

The  procedure  {\tt  printf}  can  be used in the
conventional for C programmers way, e.g. the call
\begin{verbatim}
  printf("%d! = %d\n",5,Factorial(5));
\end{verbatim}
will produce the line
\footnote{Provided that the implementation of the procedure {\tt Factorial}
corresponds to its name.}
\begin{verbatim}
  5! = 120
\end{verbatim}

The \IdRef{Printf} module implements C-like procedures {\tt printf},
{\tt sprintf}, and {\tt fprintf}.

\subsubsection{Examples:}
\begin{center}
\begin{tabular}{l|l}
\bf Call                & \bf Output \\ \hline
\verb|printf("%5.3s","abcdef")|    & \verb*|  abc| \\
\verb|printf("%-5.3s","abcdef")|   & \verb*|abc  | \\
\verb+printf("%|5.3s","abcdef")+   & \verb*| abc | \\
\verb|printf("%..3s","abcdef")|    & \verb*|def| \\
\verb|printf("pos=%3d",13)|        & \verb*|pos= 13| \\
\verb|printf("%$3o",13)|           & \verb*|015| \\
\verb|printf("%04X",33C)|          & \verb*|001B| \\
\verb|printf("%{}",13)|            & \verb*|{0,2..3}| \\
\end{tabular}
\end{center}

%---------------------------------------------------------------

\section{FormStr module}
\renewcommand{\ModuleI}{FormStr}
\OneModule

\extlib{}

A string is an array of characters of an arbitrary length. The
procedures \IdQualRef{print}, \IdQualRef{append} and \IdQualRef{image}
guarantee the presence of the string terminator ({\tt 0C}) in the
resulting string. See the \IdRef{FormOut} module overview for the format
string syntax.

{\samepage
\Frame{print}{Print to string}
\begin{verbatim}
PROCEDURE print(VAR str: ARRAY OF CHAR;
                 format: ARRAY OF CHAR;
               SEQ args: SYSTEM.BYTE);
\end{verbatim}
}
\ModuleList
Constructs a string specified by the pair ({\tt format},{\tt args})
and places it into {\tt str}.

{\samepage
\Frame{append}{Append to the end of string}
\begin{verbatim}
PROCEDURE append( VAR str: ARRAY OF CHAR;
                   format: ARRAY OF CHAR;
                 SEQ args: SYSTEM.BYTE);
\end{verbatim}
}
\ModuleList
Appends a string specified by the pair (\verb|format|,\verb|args|)
to the end of the string \verb|str|.

{\samepage
\Frame{image}{Print from the given position}
\begin{verbatim}
PROCEDURE image( VAR str: ARRAY OF CHAR;
                 VAR pos: LONGINT;
                  format: ARRAY OF CHAR;
                SEQ args: SYSTEM.BYTE);
\end{verbatim}
}
\ModuleList
Places a string specified by the pair (\verb|format|,\verb|args|)
in the string {\tt str}
starting from the position {\tt pos}.
After the procedure call, {\tt pos} points to
the {\tt 0C} or to the position next to the end of the string.

{\samepage
\Frame{iscan}{Read integer in Modula-2 format}
\begin{verbatim}
PROCEDURE iscan( VAR num: INTEGER;
                     str: ARRAY OF CHAR;
                 VAR pos: CARDINAL;
                VAR done: BOOLEAN);
\end{verbatim}
}
\ModuleList
Reads an integer value from the string \verb|str|
starting from the position \verb|pos|.
After the procedure call:
\begin{description}
\item[{\tt done}] becomes TRUE, if the attempt was successful;
\item[{\tt pos }] is the index of the first not scanned character;
\item[{\tt num }] is the read value when \verb'done=TRUE'.
\end{description}

The number may be represented in any form permitted in
Modula-2. In case of an integer overflow {\tt done=FALSE}.

\section{Printf module}
\renewcommand{\ModuleI}{Printf}
\OneModule

The {\tt Printf} module provides C-like formatted output procedures
\IdQualRef{fprintf}, \IdQualRef{printf}, and \IdQualRef{sprintf},

This module is based on the \IdRef{FormOut} module and is provided
for convenience.

{\samepage
\Frame{ChanId}{I/O channel identity}
\begin{verbatim}
TYPE ChanId = IOChan.ChanId;
\end{verbatim}
}
The type {\tt IOChan.ChanId}, which is used in ISO Modula-2 library
to identify I/O channels, is reexported.

{\samepage
\Frame{fprintf}{Write formatted data to channel}
\begin{verbatim}
PROCEDURE fprintf(file     : ChanId;
                  format   : ARRAY OF CHAR;
                  SEQ args : SYSTEM.BYTE);
\end{verbatim}
}
\ModuleList

The procedure {\tt fprintf} formats and outputs a series of characters and
values to the channel identified by {\tt file}. Each argument in {\tt args}
is converted and written to {\tt file} according to the corresponding format
specification in {\tt format}.

See \ref{FormOut} for a description of the format specification and the
argument list.


{\samepage
\Frame{printf}{Print formatted data}
\begin{verbatim}
PROCEDURE printf(format   : ARRAY OF CHAR;
                 SEQ args : SYSTEM.BYTE);
\end{verbatim}
}
\ModuleList

The procedure {\tt printf} formats and outputs a series of characters and
values to the current standard output channel. Each argument in {\tt args}
is converted and written to the standard output according to the corresponding
format specification in {\tt format}.

See \ref{FormOut} for a description of the format specification and the
argument list.

{\samepage
\Frame{sprintf}{Put formatted data to buffer}
\begin{verbatim}
PROCEDURE sprintf(VAR buf  : ARRAY OF CHAR;
                  format   : ARRAY OF CHAR;
                  SEQ args : SYSTEM.BYTE);
\end{verbatim}
}
\ModuleList

The procedure {\tt sprintf} formats and stores a series of characters and
values in the array {\tt buf}. Each argument in {\tt args}
is converted and put out according to the corresponding format
specification in {\tt format}.

See \ref{FormOut} for a description of the format specification and the
argument list.

\section{ProgEnv module}
\renewcommand{\ModuleI}{ProgEnv}
\OneModule

The {\tt ProgEnv} module provides access to the program
name, arguments, and environment strings.

{\samepage
\Frame{ArgNumber}{Return the number of arguments}
\begin{verbatim}
PROCEDURE ArgNumber(): CARDINAL;
\end{verbatim}
}
\ModuleList
Returns the number of arguments (0 if there is no arguments).

{\samepage
\Frame{GetArg}{Get argument}
\begin{verbatim}
PROCEDURE GetArg(n: CARDINAL; VAR arg: ARRAY OF CHAR);
\end{verbatim}
}
\ModuleList
Copies \verb'n'-th argument (\verb'n >= 0') to {\tt arg}, or empties it
if \verb|n >= ArgNumber()|.

{\samepage
\Frame{ArgLength}{Return length of argument}
\begin{verbatim}
PROCEDURE ArgLength(n: CARDINAL): CARDINAL;
\end{verbatim}
}
\ModuleList
Returns the length of the \verb'n'-th argument, or
0 if \verb|n>=ArgNumber()|.

{\samepage
\Frame{ProgramName}{Get program name}
\begin{verbatim}
PROCEDURE ProgramName(VAR name: ARRAY OF CHAR);
\end{verbatim}
}
\ModuleList
Copies a program name to {\tt name}.

{\samepage
\Frame{ProgramNameLength}{Length of program name}
\begin{verbatim}
PROCEDURE ProgramNameLength(): CARDINAL;
\end{verbatim}
}
\ModuleList
Returns the length of the program name.

{\samepage
\Frame{String}{Get environment string}
\begin{verbatim}
PROCEDURE String(name: ARRAY OF CHAR;
              VAR str: ARRAY OF CHAR);
\end{verbatim}
}
\ModuleList
Copies a value of the environment variable {\tt name} to {\tt str}
(empty string if the variable is undefined).

{\samepage
\Frame{StringLength}{Return environment string length}
\begin{verbatim}
PROCEDURE StringLength(name: ARRAY OF CHAR): CARDINAL;
\end{verbatim}
}
\ModuleList
Returns the length of the environment variable {\tt name}
(0 if the variable is undefined).

\subsection{Example}

The following procedure (in \ot{}) prints all program arguments:
\begin{verbatim}
PROCEDURE ShowArgs;
  VAR
    str: POINTER TO ARRAY OF CHAR;
    i,args: LONGINT;
BEGIN
  i:=0;
  args:=ProgEnv.ArgNumber();
  FOR i:=0 TO args-1 DO
    NEW(str,ProgEnv.ArgLength(i)+1);
    ProgEnv.GetArg(i,str^);
    STextIO.WriteString(str^); STextIO.WriteLn;
  END;
END ShowArgs;
\end{verbatim}

\section{TimeConv module}
\renewcommand{\ModuleI}{TimeConv}
\OneModule

The \mt{} module {\bf TimeConv} provides operations on
values of type \verb'SysClock.DateTime'. % !!! ref

{\samepage
\Frame{DateTime}{Date and Time Type}
\begin{verbatim}
TYPE DateTime = SysClock.DateTime;
\end{verbatim}
}
\ModuleList
The \verb'SysClock.DateTime' type is re-exported for convenience.

{\samepage
\Frame{Compare}{Compare two clock values}
\begin{verbatim}
PROCEDURE Compare(dl,dr: DateTime): INTEGER;
\end{verbatim}
}
\ModuleList
The function procedure \verb'Compare' returns:
\begin{itemize}
\item zero, if \verb'dl' represents the same moment as \verb'dr'
\item value less than zero, if \verb'dl' is before \verb'dr'
\item value greater than zero, if \verb'dl' is after \verb'dr'
\end{itemize}

{\bf Note:} If either \verb'dl' or \verb'dr' is invalid, zero is returned.

{\samepage
\Frame{SubDateDays}{Date difference in days}
\begin{verbatim}
PROCEDURE SubDateDays(dl,dr: DateTime): CARDINAL;
\end{verbatim}
}
\ModuleList
The function procedure \verb'SubDateDays' returns the number of days
passed from \verb'dr' to \verb'dl'.

{\bf Note:} If one of the parameters is invalid or if \verb'dl' is before
\verb'dr', zero is returned.

{\samepage
\Frame{SubDateSecs}{Time difference in seconds}
\begin{verbatim}
PROCEDURE SubDateSecs(dl,dr: DateTime): CARDINAL;
\end{verbatim}
}
\ModuleList
The function procedure \verb'SubDateSecs' returns the number of seconds
passed from \verb'dr' to \verb'dl'.

{\bf Note:} If one of the parameters is invalid or if \verb'dl' is before
\verb'dr', zero is returned.

{\samepage
\Frame{AddDateDays}{Add whole number of days to date}
\begin{verbatim}
PROCEDURE AddDateDays(d: DateTime;
                      days: CARDINAL;
                      VAR res: DateTime);
\end{verbatim}
}
\ModuleList
The procedure \verb'AddDateDays' adds \verb'days' days to date \verb'd'
and assigns the resulting date to \verb'res'.

{\bf Note:} If "d" is invalid, "res" is assigned the first valid date.

{\samepage
\Frame{AddDateSecs}{Add seconds to date}
\begin{verbatim}
PROCEDURE AddDateSecs(d: DateTime;
                      secs: CARDINAL;
                      VAR res: DateTime);
\end{verbatim}
}
\ModuleList
The procedure \verb'AddDateSecs' adds \verb'secs' seconds to date \verb'd'
and assigns the resulting date to \verb'res'.

{\bf Note:} If "d" is invalid, "res" is assigned the first valid date.

{\samepage
\Frame{TheDayNumber}{Ordinal day number}
\begin{verbatim}
PROCEDURE TheDayNumber(d: DateTime): CARDINAL;
\end{verbatim}
}
\ModuleList
The function procedure \verb'TheDayNumber' returns the ordinal number of
the day for the date \verb'd'.

{\bf Note:} If \verb'd' is invalid, zero is returned.

{\samepage
\Frame{TheFractionNumber}{Number of fractions passed from midnight}
\begin{verbatim}
PROCEDURE TheFractionNumber(d: DateTime): CARDINAL;
\end{verbatim}
}
\ModuleList
The function procedure \verb'TheFractionNumber' returns the number
of fractions passed from time 0:00:00.00 of the day for the date
\verb'd'.

{\bf Note:} If \verb'd' is invalid, zero is returned.

{\samepage
\Frame{WeekDay}{Determine day of the week}
\begin{verbatim}
PROCEDURE WeekDay(d: DateTime): CARDINAL;
\end{verbatim}
}
\ModuleList
The function procedure \verb'WeekDay' returns day of the week
for the date \verb'd'. 0 represents Sunday, 1 - Monday, etc.

{\bf Note:} If \verb'd' is invalid, zero is returned.

{\samepage
\Frame{millisecs}{Milliseconds passed from midnight}
\begin{verbatim}
PROCEDURE millisecs(): CARDINAL;
\end{verbatim}
}
\ModuleList
The function procedure \verb'millisecs' returns the number of
milliseconds passed from the time 0:00:00.00 of current date
as known to the system.

{\bf Note:} This procedure is system-dependent.

{\samepage
\Frame{time}{System time in seconds}
\begin{verbatim}
PROCEDURE time(): CARDINAL;
\end{verbatim}
}
\ModuleList
The function procedure \verb'time' returns the number of seconds
passed from the time 0:00:00.00 at first valid date for the system.

{\bf Note:} This procedure is system-dependent.

{\samepage
\Frame{unpack}{Unpack system time}
\begin{verbatim}
PROCEDURE unpack(VAR d: DateTime; secs: CARDINAL);
\end{verbatim}
}
\ModuleList
The procedure \verb'unpack' assigns to \verb'd' the value
corresponding to date/time which is \verb'secs' seconds later than
the first valid time/date for the system.

This procedure can be used to examine the first system time/date
as follows:

\verb'    unpack(firstDateTime,0);'

{\bf Note:} This procedure is system-dependent.

{\samepage
\Frame{pack}{Pack system time}
\begin{verbatim}
PROCEDURE pack(d: DateTime; VAR secs: CARDINAL);
\end{verbatim}
}
\ModuleList
The procedure \verb'pack' assigns to \verb'secs' the number of
seconds passed from a first valid system date/time to \verb'd'.
Its effect is opposite to the \verb'pack' procedure. % !!! ref

{\bf Note:} This procedure is system-dependent.

{\samepage
\Frame{weekday}{Determine day of the week for system time}
\begin{verbatim}
PROCEDURE weekday(t: CARDINAL): CARDINAL;
\end{verbatim}
}
\ModuleList
The function procedure \verb'weekday' behaves exactly the same as if it
contains the following code:

\verb'    unpack(tmpDateTime,t); RETURN WeekDay(tmpDateTime);'

% !!! ref

{\bf Note:} This procedure is system-dependent.

\section{DStrings module}
\renewcommand{\ModuleI}{DStrings}
\OneModule

The module {\bf DStrings} (written in \ot{}) defines
a dynamic string type and provides some conventional operations.

{\samepage
\Frame{String}{Dynamic String Type}
\begin{verbatim}
TYPE String* = POINTER TO ARRAY OF CHAR;
\end{verbatim}
}
\ModuleList

{\samepage
\Frame{Assign}{Create and Initialize String}
\begin{verbatim}
PROCEDURE Assign*(s: ARRAY OF CHAR; VAR d: String);
\end{verbatim}
}
\ModuleList
Allocates a new dynamic string and copies string {\tt s} to it.
The resulting string always contains a terminator character (0C).

{\samepage
\Frame{Append}{Append to Dynamic String}
\begin{verbatim}
PROCEDURE Append*(s: ARRAY OF CHAR; VAR d: String);
\end{verbatim}
}
\ModuleList
Appends the string {\tt s} to {\tt d}. {\tt d} is extended if necessary.
The resulting string always contains the string terminator (0C).

%-----------------------------------------------------------------

\section{FilePath module}
\renewcommand{\ModuleI}{FilePath}
\OneModule

The {\tt FilePath} module (written in \ot{}) provides directory
search facilities. In the following procedures {\tt path} is a
list of directories separated by semicolons, e.g.
\begin{verbatim}
  .\SYM;C:\LIB\SYM;C:\XDS\LIB\SYM;.        (Windows)
  ./sym;~/lib/sym;/usr/bin/xds/sym;.       (Unix)
\end{verbatim}

{\samepage
\Frame{IsSimpleName}{Is just a File Name}
\begin{verbatim}
PROCEDURE IsSimpleName*(name: ARRAY OF CHAR): BOOLEAN;
\end{verbatim}
}
\ModuleList
Returns \verb'TRUE', if {\tt name} contains a file name only
(without directories).

{\samepage
\Frame{Lookup}{Look up File}
\begin{verbatim}
PROCEDURE Lookup*(path,name: ARRAY OF CHAR;
                  VAR fname: DStrings.String;
                  VAR n: INTEGER);
\end{verbatim}
}
\ModuleList
Builds a filename using the search path. After a call:
\begin{center}
\begin{tabular}{ll}
\tt n = -1 & if {\tt name} is not simple ({\tt fname = name}) \\
\tt n =  0 & file is not found (the first directory is used)  \\
\tt n >  0 & file is found in the \verb'n'-th directory       \\
\end{tabular}
\end{center}

{\samepage
\Frame{UseFirst}{Use First Directory}
\begin{verbatim}
PROCEDURE UseFirst*(path,name: ARRAY OF CHAR;
                    VAR fname: DStrings.String);
\end{verbatim}
}
\ModuleList
Builds a filename using the first directory from
the search path.

%--------------------------------------------------------------

\section{RegComp module}
\renewcommand{\ModuleI}{RegComp}
\OneModule
\index{regular expressions}

This  module (written in \ot{}) implements a comparison of a string with
regular expression.

\subsection{Regular expressions}

A regular expression is a string which may contain certain special symbols:

\begin{center}
\begin{tabular}{cl}
\bf Sequence & \bf Denotes \\
\hline
\verb+*+      & an arbitrary sequence of any characters, possibly empty \\
              & (equivalent to \verb|{\000-\377}| expression) \\
\verb+?+      & any single character \\
              & (equivalent  to \verb|[\000-\377]| expression) \\
\verb+[...]+  & one of the listed characters \\
\verb+{...}+  & an arbitrary sequence of the listed characters, possibly empty \\
\verb+\nnn+   & the ASCII character with octal code \verb|nnn|, where n is \verb|[0-7]| \\
\verb+&+      & the logical operation AND \\
\verb+|+      & the logical operation OR  \\
\verb+^+      & the logical operation NOT \\
\verb+(...)+  & the priority of operations \\
\verb+$digit+ & subexpression number (see below)
\end{tabular}
\end{center}

A  sequence of the  form \verb|a-b|  used  within  either
\verb|[]| or \verb|{}| brackets denotes all characters from
\verb|a| to \verb|b|.

\verb'$digit' may follow \verb|*|, \verb|?|, \verb|[]|, \verb|{}|, or
\verb|()| subexpression. For a string matching a regular expression,
it represents the corresponding substring.

If you need to use any special symbol as an ordinary symbol, you should
precede it with a backslash (\verb|\|), which suppresses interpretation of
the following symbol.

\subsection{Examples of regular expressions}

\indent
\verb|{0-9A-F}| defines set of hexadecimal numbers

\verb|[a-zA-z_]| defines a single small or capital letter or an underscore
character.

\verb'(({0-9A-Fa-f})$1|({a-zA-Z_})$2))$3' matches
both hexadecimal numbers and Modula-2 identifiers. After a
successful match, a program may access the
hexadecimal number by the \verb|$1| reference,
the identifier by the \verb|$2|  reference  and
either of them by the \verb|$3| reference.

\verb|\\\$\{\}\[\]\*\?| represents the string \verb|\${}[]*?|.

{\samepage
\Frame{Expr}{Regular expression}
\begin{verbatim}
TYPE
  Expr*    = POINTER TO ExprDesc;
  ExprDesc = RECORD END;
\end{verbatim}
}
\ModuleList

{\samepage
\Frame{Compile}{Compile regular expression}
\begin{verbatim}
PROCEDURE Compile*(expr: ARRAY OF CHAR;
                VAR reg: Expr;
                VAR res: LONGINT);
\end{verbatim}
}
\ModuleList
Compiles a regular expression to an internal form.
\begin{flushleft}
\begin{tabular}{l|l}
Value of {\tt res} & Meaning \\ \hline
  {\tt res}$\leq 0$ & error in position ABS(res) \\
  {\tt res}$ > 0$   & done                       \\
\end{tabular}
\end{flushleft}

{\samepage
\Frame{Const}{Is constant expression}
\begin{verbatim}
PROCEDURE Const*(re: Expr): BOOLEAN;
\end{verbatim}
}
\ModuleList
Returns \verb'TRUE', if the expression does not contain wildcards.

{\samepage
\Frame{Match}{Compare string with expression}
\begin{verbatim}
PROCEDURE Match*(re: Expr;
                  s: ARRAY OF CHAR;
                pos: LONGINT): BOOLEAN;
\end{verbatim}
}
\ModuleList
Returns \verb'TRUE', if the expression matches the string {\tt s} starting
from the position {\tt pos}.

{\samepage
\Frame{Len}{Length of substring}
\begin{verbatim}
PROCEDURE Len*(re: Expr; n: INTEGER): LONGINT;
\end{verbatim}
}
\ModuleList
Returns the length of the substring which corresponds to \verb|$n|
in the last call of the {\tt Match} procedure with the parameter {\tt re}.

{\samepage
\Frame{Pos}{Position of substring}
\begin{verbatim}
PROCEDURE Pos*(re: Expr; n: INTEGER): LONGINT;
\end{verbatim}
}
\ModuleList
Returns the position of the substring which
corresponds to \verb|$n| in the last call of
the {\tt Match} procedure with the parameter {\tt re}.

{\samepage
\Frame{Substitute}{Substitute substrings}
\begin{verbatim}
PROCEDURE Substitute*(re: Expr;
                     s,m: ARRAY OF CHAR;
                   VAR d: ARRAY OF CHAR);
\end{verbatim}
}
\ModuleList
The substrings of {\tt s} which matched {\tt re}
are substituted instead of \verb|$digit| into {\tt m} and
the result string is copied into {\tt d}.

{\bf Note:} The {\tt Match(re,s,0)} call should be issued
and tested for success prior to a call to {\tt Substitute}.

\subsubsection{Example}

After the following sequence of calls
\begin{verbatim}
  Compile("{a-z}$1{0-9}$2",re,res);
  IF Match(re,"abcdef153",0) THEN
    Substitute(re,"abcdef153","tail: $2 head: $1",dest);
  END;
\end{verbatim}

the {\tt dest} string will contain
\begin{verbatim}
  "tail: 153 head: abcdef"
\end{verbatim}


