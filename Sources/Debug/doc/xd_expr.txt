XD debugger expression 
----------------------

XD debugger позволяет использовать разнообразные выражения в процессе отладки.
Выражение - сочетание операций, операндов, стандартных функций, др., т.е.
выражение имеет обычный смысл. В качестве операндов можно использовать числовые,
в том числе, вещественные, и символьные константы, специальные обьекты, такие
как регистры, а также, конечно, обьекты из отлаживаемой программы - переменные
и процедуры.

Выражение может быть использовано для самых разнообразных целей в различных
контекстах, например, для слежения за значением заданого выражение, вычисления
адреса или размера переменной, др.; в пакетном отладчике использование
выражений является основным способом модификации и контроля переменных, памяти,
а также управления выполнением пакета.



Типы результата вычисления выражения
------------------------------------

Выражения, используемые в XD debugger, по возможности приближены к выражению
языка Modula-2. Результат вычисления синтаксически правильного определенного
выражения может иметь один из следующих типов (в дальнейшем - тип выражения):

"I" - целый.
"F" - вещественный.
"B" - булевский.
"C" - литерный.
"A" - адресный.
"V" - переменная.
"R" - регистр.

В зависимости от контекста, требуются разные типы выражения. Например, для
услоного оператора или для условной точки необходимо задавать выражение 
булевского типа. Для задания начального адреса дампа памяти необходимо
определить выражение адресного типа. Для контроля и модификации переменных
в Examine variable необходимо задавать выражение типа переменная. Выражение
типа регистр используется только в пакетном отладчике для модификации
значений регистров.

В выражении можно использовать обьекты программы, глобальные обьекты модулей
и локальные обьекты только текущего блока видимости.



Имена обьектов программы
------------------------

Основную информацию об обьектах программы отладчик получает из отладочной
информации о программе. Таким образом, только те обьекты программы, информация
о которых была обнаружены в отладочной информации, могут быть использованы в
выражении. 

Имя в выражении может обозначать модуль, глобальную переменную или процедуру,
локальную переменную или процедуру, тип, имя элемента перечислимого типа,
public, а также alias.

Синтаксис имени такой:

1. [ Module '.' ] ( Variable | Type | Procedure { [ '::' ] Local } )
2. Public
3. Alias
        
Программа может состоять из нескольких модулей, но только один из них является
текущим - это тот модуль, адресное пространство которго содержит текущее
значение IP. Точно так же, модуль может состоять из нескольких процедур,
одна из них является текущей, а именно та, адресное пространство которой
содержит текущее значение IP. Для диалоговаого отладчика текущими являются
модуль и процедура, отвечающие положению пользовательского курсора, информация
о которых отображается в верхней строке главного окна. 

Идентификация обьекта, соответсвующего имени, выполняется в следующей
последовательности: alias, модуль, переменная, процедура, локальный обьект,
тип, public, имя элемента перечислимого тип. 

Example:

KrnExec
result
feefawfum
sunday
PCHAR
CalcSumm
InOut_WriteString

Если обьект неопределен в текущей области видимости, его можно квалифицировать
именем обьемлющего блока.

Example:

KrnExec.LoadProgram
DlgBreak.AddBreak::BreakPos


Note

Информация об обьектах программы генерируется компилятором, для этого ему
необходимо задать соответствующие опции; более подробную информацию об этом
можно получить в соответствующих разделах описания компилятора и отладчика. 



Constants 
---------

Константы могут быть числовыми (целыми разных типов и вещественными),
булевскими, символьными и адресными. Константы можно использовать во всяком
выражении в соответствии с требуемым типом выражения и применяемых операций.



Целые константы 
---------------

Константа целого типа записывается последовательностью символов '0'..'9' и
'a'..'f' или 'A'..'F'. Для указания базы можно использовать следующие
обозначения:

'0x' { digit} - база 16
'0X' { digit} - база 16
{ digit} H    - база 16

Example:

0x05074
13H
1342

Длина целой константы - 4 байта. Максимальное значение для целых
констант - 0xffffffff.



Real Constants 
--------------

Вещественная константа записывается в виде:

ДесятичКонстанта '.' [ ДесятичКонстанта ] ['e'|'E' ['+'|'-'] ДесятичКонстанта ]

Т.е. признаком вещественной константы является символ '.' после записи
десятичной константы.

Все вещественные константы хранятся в отладчике как LONGLONGREAL и занимают,
соответственно, 10 байт.



Complex Constant 
----------------

Не поддерживаются в выражении (сейчас, по крайней мере).



Character Constant
------------------

Литерная константа состоит из символа ', затем идет литера, и завершатся
вновь '. Длина литерной константы - 1 байт.

Examples:
     
'!'
'''
'X'



Character String Constant
-------------------------

Не поддерживаются в выражении (сейчас, по крайней мере).



Memory References Constant
--------------------------

Для указания явного адреса, например, при открытии окна дампа памяти,
в выражении используется следующая нотация;

'A:' ШестнадцатиричнаяЦифра { ШестнадцатиричнаяЦифра }.

Тип такой константы, очевидно, - адресный.

Examples:

A:1267
A:afbfcfdf



Служебные имена
---------------

В отладчике определен некоторый набор специальных имен, таких как имена
общих регистров, регистра флагов, др..

Для получения значений этих имен необходимо предварить имя символом '@'. В этом
случае их можно использовать в любом выражении, так же как константы целого типа.

Для обозначения сущности имени его необходимо предварить символом '&'. В этом
случае тип выражения будет зависит от типа имени, и может быть, например,
регистр. Такие выражения можно использовать в левой части оператора
присваивания. Длина регистра - 4 байта. Этот способ ссылки на сущность имени
используется только в пакетном отладчике.

Регистры общего назначения:

EAX, AX, AL, AH, EBX, BX, BL, BH, ECX, CX, CL, CH, EDX, DX, DL, DH

Индексные регистры:

ESI, SI, EDI, DI

Базовые рагистры:

ESP, SP, EBP, BP

Счетчик инструкций:

EIP

Сегментные регистры:

CS, SS, DS, ES, GS, FS

Регистр флагов:

EFL


Examples:

@AX
@EFL
&EBP


Операций отношения
------------------

В выражении можно использовать операции логических отношения. Они имеют два
операнда, а результат выражения - булевский.

┌─────────────┬───────────────────┐
│ Обозначение │    Действие       │
├─────────────┼───────────────────┤
│   <         │ меньше            │
│   <=        │ меньше либо равно │
│   >         │ больше            │
│   >=        │ больше либо равно │
│   =         │ равно             │
│   # или <>  │ не равно          │
└─────────────┴───────────────────┘


Операции
--------

        Унарные операции.

Арифмектические: аргумент - числового типа, результат - числового типа;

"+"   - плюс.
"-"   - минус.
"NOT" - инверсия.


Логические: аргумент - булевского типа, результат - булевского типа;

"NOT" - отрицание.


Прочие:

ADR(designator) - address of a memory object, аргумент - типа переменная,
результат - адресного типа.

Examples:

ADR(ArrayRecord)
ADR(ArrayRecord[6])
ADR(ArrayRecord[6].FirstField)



[ TYPE ] '<' address '>' - получить типизировонное косвенное значение, аргумент
- адресного типа, результат - при заданом TYPE - в соответсвии с TYPE, иначе
целого типа. В качестве аргумента можно использовать любое адресное выражение,
например, результат операции взятия адреса.

Операцию получения типизированного косвенного значения надо понимать так:
рассмотреть N (N=длина в байтах типа TYPE или N=1, при его отсутствии) ячеек
памяти, начиная с указанного адреса, как обьект типа TYPE.

В операции для задания типа можно использовать все те типы, которые компилятор
положил в отладочную информацию (т.е. типы действительно используемых обьектов).
Как было сказано выше, тип можно квалифицировать именем модуля.

Определены следующие стандартные типы:

BYTE8        - целый беззнаковой, 1 байт
BYTE16       - целый беззнаковой, 2 байта
BYTE32       - целый беззнаковой, 4 байта
INT8         - целый знаковой, 1 байт
INT16        - целый знаковой, 2 байта
INT32        - целый знаковой, 4 байта
CARD8        - целый беззнаковой, 1 байт
CARD16       - целый беззнаковой, 2 байта
CARD32       - целый беззнаковой, 4 байта
REAL         - вещественный, 4 байт
LONGREAL     - вещественный, 8 байт
LONGLONGREAL - вещественный, 10 байт
COMPLEX      - комплексный, 8 байт
LONGCOMPLEX  - комплексный, 16 байт
BOOL8        - булевский, 1 байт
BOOL16       - булевский, 2 байта
BOOL32       - булевский, 4 байта
CHAR8        - литерный, 1 байт
CHAR16       - литерный, 2 байта
CHAR32       - литерный, 4 байта
ADDRESS      - адресный, 4 байта


Examples:

ADDRESS<ADR(result)>
DataBase.ArrayCardinal<ADR(Array2DimInteger[3])>



SIZE(designator) - size of a memory object, аргумент - типа переменная,
результат - целого типа.

Examples:

SIZE(ArrayRecord)
SIZE(ArrayRecord[6])
SIZE(ArrayRecord[6].FirstField)



LOW(array) - low index of an array, аргумент - типа переменная, причем тип
типа переменной должен быть ARRAY, результат - нижний индеск массива.

Examples:

LOW(ArrayRecord)


HIGH(array) - high index of an array, аргумент - типа переменная, причем тип
типа переменной должен быть ARRAY, результат - верхний индеск массива.

Examples:

HIGH(ArrayRecord)



        Бинарные операции.

Арифмектические: аргумент - числового типа, результат - числового типа;

"+"   - сложение.
"-"   - вычитание.
"*"   - умножение.
"/"   - деление.
"%"   - остаток.
"AND" - побитовое умножение.
"OR"  - побитовое сложение.


Логические: аргумент - булевского типа, результат - булевского типа;

"AND" - умножение.
"OR"  - сложение.



Операнды и тип результата операции.
-----------------------------------

        Унарные операции.

           ┌───────────────────────────┐
           │       О п е р а н д       │
           ├───┬───┬───┬───┬───┬───┬───┤
           │ I │ F │ B │ C │ A │ V │ R │
┌───┬──────┼───┼───┼───┼───┼───┼───┼───┤
│ О │  +   │ I │ F │   │   │   │   │   │
│ п ├──────┼───┼───┼───┼───┼───┼───┼───┤
│ е │  -   │ I │ F │   │   │   │   │   │
│ р ├──────┼───┼───┼───┼───┼───┼───┼───┤
│ а │ NOT  │ I │   │ B │   │   │   │   │
│ ц ├──────┼───┼───┼───┼───┼───┼───┼───┤
│ и │ T<>  │   │   │   │   │ V │   │   │   
│ я ├──────┼───┼───┼───┼───┼───┼───┼───┤
│   │ ADR  │   │   │   │   │   │ A │   │
│   ├──────┼───┼───┼───┼───┼───┼───┼───┤
│   │ SIZE │   │   │   │   │   │ A │   │
│   ├──────┼───┼───┼───┼───┼───┼───┼───┤
│   │ LOW  │   │   │   │   │   │ V │   │
│   ├──────┼───┼───┼───┼───┼───┼───┼───┤
│   │ HIGH │   │   │   │   │   │ V │   │
└───┴──────┴───┴───┴───┴───┴───┴───┴───┘


        Бинарные.

            ┌───────────┐       ┌───────────┐       ┌───────────┐
            │ Л е в ы й │       │ Л е в ы й │       │ Л е в ы й │
            │  операнд  │       │  операнд  │       │  операнд  │
            ├─┬─┬─┬─┬─┬─┤       ├─┬─┬─┬─┬─┬─┤       ├─┬─┬─┬─┬─┬─┤
            │I│F│B│A│V│R│       │I│F│B│A│V│R│       │I│F│B│A│V│R│
┌───┬───┬───┼─┼─┼─┼─┼─┼─┼───┬───┼─┼─┼─┼─┼─┼─┼───┬───┼─┼─┼─┼─┼─┼─┤
│   │   │ + │I│F│ │ │ │ │   │ + │F│F│ │ │ │ │   │ + │ │ │ │ │ │ │
│ П │ Ц │ - │I│F│ │ │ │ │ В │ - │F│F│ │ │ │ │ Б │ - │ │ │ │ │ │ │
│   │ е │ * │I│F│ │ │ │ │ е │ * │F│F│ │ │ │ │ у │ * │ │ │ │ │ │ │
│ р │ л │ / │I│F│ │ │ │ │ щ │ / │F│F│ │ │ │ │ л │ / │ │ │ │ │ │ │
│   │ ы │ % │I│ │ │ │ │ │ е │ % │ │ │ │ │ │ │ е │ % │ │ │ │ │ │ │
│ а │ й ├───┼─┼─┼─┼─┼─┼─┤ с ├───┼─┼─┼─┼─┼─┼─┤ в ├───┼─┼─┼─┼─┼─┼─┤
│   │   │ = │B│B│ │B│ │ │ т │ = │B│B│ │ │ │ │ с │ = │ │ │B│ │ │ │
│ в │   │ # │B│B│ │B│ │ │ в │ # │B│B│ │ │ │ │ к │ # │ │ │B│ │ │ │
│   │   │ > │B│B│ │B│ │ │ е │ > │B│B│ │ │ │ │ и │ > │ │ │ │ │ │ │
│ ы │   │ >=│B│B│ │B│ │ │ н │ >=│B│B│ │ │ │ │ й │ >=│ │ │ │ │ │ │
│   │   │ < │B│B│ │B│ │ │ н │ < │B│B│ │ │ │ │   │ < │ │ │ │ │ │ │
│ й │   │ <=│B│B│ │B│ │ │ ы │ <=│B│B│ │ │ │ │   │ <=│ │ │ │ │ │ │
│   │   ├───┼─┼─┼─┼─┼─┼─┤ й ├───┼─┼─┼─┼─┼─┼─┤   ├───┼─┼─┼─┼─┼─┼─┤
│   │   │AND│I│ │ │ │ │ │   │AND│ │ │ │ │ │ │   │AND│ │ │B│ │ │ │
│   │   │ OR│I│ │ │ │ │ │   │ OR│ │ │ │ │ │ │   │ OR│ │ │B│ │ │ │
│   ├───┼───┼─┼─┼─┼─┼─┼─┼───┼───┼─┼─┼─┼─┼─┴─┼───┼───┼─┼─┼─┼─┼─┼─┤
│   │   │ + │A│ │ │ │ │ │   │ + │ │ │ │ │ │ │   │ + │ │ │ │ │ │ │
│ о │ Б │ - │A│ │ │ │ │ │ П │ - │ │ │ │ │ │ │ Р │ - │ │ │ │ │ │ │
│   │ о │ * │ │ │ │ │ │ │ е │ * │ │ │ │ │ │ │ е │ * │ │ │ │ │ │ │
│ п │ р │ / │ │ │ │ │ │ │ р │ / │ │ │ │ │ │ │ г │ / │ │ │ │ │ │ │
│   │ т │ % │ │ │ │ │ │ │ е │ % │ │ │ │ │ │ │ и │ % │ │ │ │ │ │ │
│ е │ о ├───┼─┼─┼─┼─┼─┼─┤ м ├───┼─┼─┼─┼─┼─┼─┤ с ├───┼─┼─┼─┼─┼─┼─┤
│   │ в │ = │B│ │ │B│ │ │ е │ = │ │ │ │ │ │ │ т │ = │ │ │ │ │ │ │
│ р │ о │ # │B│ │ │B│ │ │ н │ # │ │ │ │ │ │ │ р │ # │ │ │ │ │ │ │
│   │ й │ > │B│ │ │B│ │ │ н │ > │ │ │ │ │ │ │   │ > │ │ │ │ │ │ │
│ а │   │ >=│B│ │ │B│ │ │ а │ >=│ │ │ │ │ │ │   │ >=│ │ │ │ │ │ │
│   │ А │ < │B│ │ │B│ │ │ я │ < │ │ │ │ │ │ │   │ < │ │ │ │ │ │ │
│ н │ д │ <=│B│ │ │B│ │ │   │ <=│ │ │ │ │ │ │   │ <=│ │ │ │ │ │ │
│   │ р ├───┼─┼─┼─┼─┼─┼─┤   ├───┼─┼─┼─┼─┼─┼─┤   ├───┼─┼─┼─┼─┼─┼─┤
│ д │ е │AND│ │ │ │ │ │ │   │AND│ │ │ │ │ │ │   │AND│ │ │ │ │ │ │
│   │ с │ OR│ │ │ │ │ │ │   │ OR│ │ │ │ │ │ │   │ OR│ │ │ │ │ │ │
└───┴───┴───┴─┴─┴─┴─┴─┴─┴───┴───┴─┴─┴─┴─┴─┴─┴───┴───┴─┴─┴─┴─┴─┴─┘


