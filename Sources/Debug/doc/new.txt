-> Окна с объектами: указатели
   Указатели обозначаются как адрес 0xZZZZZZZ, они отличаются так от
   целых в чисел 16 c/c 0ZZZH.

-> Dialog: локатор списков
   изменения во всех списках: теперь клавиша Tab используется
   для позиционирования в списках при поиске с помощью локатора
   (unix-подобная кнопка Tab). Пример: модуль opcode, список процедур:
   набираем "co" -> Tab -> локатор стал "CODE::"
   набираем "g" -> Tab -> локатор стал "CODE::ge"
   и так далее.
   Клавиши Ctrl-Down делают поиск чуть по другому.

-> FIXED: BUG00739-33: Local variables are sometimes displayed as "?".

-> xStrip: дополнительные ключи
   -t (preserve file time)
   -q (queit mode)
   -n (do not save debug info)

-> FIXED: Expr: при отображении SET OF на отрезке типа с отрицательными
   индексами - развал

-> Breaks: при постановке отложенной точки на место точки-счетчика
   предлагать умолчательное значение, меньшее на 1.
   при постановке отложенной точки на место точки-счетчика предлагается
   умолчательное значение, равное значению точки-счетчика минус 
   1 (это упрощает типичную последовательность, когда сначала выставляется
   счетчик, чтобы узнать сколько раз мы прошли до развала, а затем
   точка-счетчик заменяется на отложенный останов, который сработает
   на последнем проходе)

-> Call stack: При хождении по стеку вызовов соответственно
   показывать локалы

-> Disable/Enable действий в зависомоти от текущего контекста
   запрещаить или разрещать те или иные действия

-> Expr: в зависимости от языка по разному отображать константы и символы,
   например, Modula-2 - NIL, Jaba - null. 

-> Expr: вычисление локалов охватывающих процедур

-> Expr: показывать правильно 16-битные CHAR

-> Expr: разрешить использовать локалы процедур, обьемлющих исполняемую
   процедуру, в выражении можно использовать локалы процедур, обьемлющих
   исполняемую (текущую) процедуру, при этом допускается квалификация, как
   и раньше, например:

   MODULE m;

   PROCEDURE p1 (p1_v: CARDINAL);
     PROCEDURE p2 (p2_v: CARDINAL);
       PROCEDURE p3 (p3_v: CARDINAL);
        если p3 исполняемая (текущая) процедура, то можно использовать выражения  
        -> p3_v (собственный локал)
        -> p3::p3_v
        -> p2::p3::p3_v (т.к. p3 вложена в p2)
        -> p1::p2::p3::p3_v (т.к. p2 вложена в p1)
        -> m.p1::p2::p3::p3_v 
        -> p2_v  (т.к. p3 вложена в p2, то можно использовать ее локалы)
        -> p2::p2_v (квалификация собственного локала)
        -> p1::p2::p2_v
        -> m.p1::p2::p2_v
        -> p1_v
        -> p1::p1_v
        -> m.p1::p1_v
       END;
     END;
   END;


-> Locals: в заголовке указывать процедуру, локалы которой сейчас отображаются

-> Locals: локалы охватывающих процедур отображать после инициализации фрейма
   вызываемой процедуры, до прохода пролога

-> Locals: подниматься выше к вызвывшей процедуре

-> Locals: показывать локалы охватывающих процедур

-> Locals: разделять переменные разных уровней вложенности в окне локальных
   переменных при отображении вложенных процедур разделяются строками,
   содержащими имена охватывающих процедур 

-> Locals: указатели на динамические массивы, распределенные на регистрах
   правильно показываются указатели на динамические массивы ,распределенные
   на регистрах, при этом можно открыть окно
   для просмотра содержимого таких массивов

-> Для динамических массивов проверять корректность дескриптора

-> Изменить способ поиска файла раскладки клавиатуры
   файл раскладки клавиатуры ищется:
   1) по указанному пути
   2) по файлу списков путей поиска
   3) в текущей директории
   4) на "домашней" директории отладчика

-> Имя RETURN в выражении, как обычная переменная

-> FIXED: Нажатие BackSpace интерпретируется как Ctrl-H

-> FIXED: Неверно отбражаются динамические массивы размерностью больше 1.

-> Показывать настоящий (актуальный) тип обьекта

-> Разыменование указателей при отображении (новый тип вывода)
   в окнах локальных и глобальных переменных для указателей можно
   сменить тип (формат) вывода: либо принятый по умолчанию, т.е. адрес,
   либо допольнительно отображать разыменованое значение 

-> Фиксед: Breaks: Не работает пункт ERASE ALL BREAKS in menu BREAKS

-> Editor: использование clipboard (Win'95/NT only) в диалогах
   copy to    - Ctrl-Ins
   paste from - Ctrl-V

-> Option: Auto-detect actual type - если выключен, то сделать кнопку в окне
   Новая опция Auto-detect actual type. Предназначена для управления режимом
   вычисления настоящего (текущего) типа обьекта. Изменить можно в меню
   File / Options / Auto-detect actual type. По умолчанию опция включена.
   Если опция задана, то тип обьекта вычисляется автоматически, при
   открытии окна. Если опция выключена, то в контекстном меню окна
   структурных переменных появляется пункт Actual type, который задает
   вычисление настоящего типа для данного обьекта.
   
-> Options: при закрытии окна опций все остальные не перерисовываются

-> Довавить в пункт меню Help контекстное меню

-> В меню Help добавить новый пункт - About

-> Call stack: отображать текущий отображаемый контекст

-> Options: отображать указатели с разыменованным значением

-> Options: конфигурирование рамки для окошек
   если кого-то волнует вид рамки окон, то его можн поменять: запишите
   xd.cfg (File/Save config), и затем измените нужным образом строки:
     FrameImageSingle = --¬¦-¦L--
     FrameImageDouble = г=¬¦-¦L=-
     FrameImageMove = ---------

-> Expr: в диалоге при переключении базы счисления перходить в поле ввода
   в диалоге "Вычислить выражение" при переключении системы счисления
   (16, 10, 8, 2 с/с) активным остается поле ввода выражения (не теряется
   активной элемент диалога, как это было раньше при ошибках)

-> Expr: вычисление выражений для указателей, расположенных на регистре

-> Struct window: сделать контекстное меню Type
   в окнах структурных переменных в контекстном меню
   повился пункт Types, как и в окнах локальных, глобальных
   переменных. Для элементов записей можно изменить
   с/с для целых, разыменововать/нет указатели, и т.д.
   Для массивов можно изменить режим отображения всех
   его подэлементов.

-> Options: сделать Save keyboard layout

-> Module variables: сделать много окошек, открывать из контекстного меню
   в окне Module variables из контекстного меню можно открыть окно
   глобальных переменных этого модуля, таких окон может быть сколько
   угодно, для разных модулей. Для отображения глобалов текущего
   модуля существует специальное окно, в его заголовке указано "Auto: "

-> Остановы идентифицировать идентификатором (а не номером)

-> В пакетном отладчике для останова по адресу (ADDR) можно задать количество
   проходов до стабатывания (отложенная точка). Для этого после метки перехода
   нужно указать заданое число: BREAK ident, ADDR, address, label [ , pass ]
   например, BREAK first, ADDR, dry.Proc0, swith_to_dialog, 13

-> При загрузке в пакет выставлять автоматически текущую компоненту и
   модуль по исполняемумому адресу
   в пакетном отладчике просле загрузки программы и после каждого
   останова (выхода в пакет) выставляются текущая компонента и модуль,
   что позволяет не использовать квалификацию для глобальных и локальных
   обьектов исполняемого контекста.

-> Просмотр вещественных регистров

-> Breaks: Было бы очень полезно, если бы отладчик мог запоминать не только
   расположение окон, но и какие были установлены breakpoint'ы

   в диалоговом отладчике в меню File - новое действие Save / Ctrl-F2.
   Предназначена для сохранения конфигурации диалогового отладчика в виде
   пакета отладки: сохраняются все точки останова, остановы по доступу
   и условные остановы, сохраняется содержимое окна слежения. Перед
   сохранением предлагается выбрать файл - по умолчанию <program_name>.xd.
   Для восстановления пока нужно запустить отладчик в пакетном режиме:
   xd /b <batch-file> 

-> Модификаторы останова, активация/деактивация остановов
   для модификации остановов в пакетном отладчике можно использовать
   следующие конструкции:

   BREAK ident, ADDR, address, label [, pass] [, ?, condition] [, /]
   BREAK ident, LINE, module, lineno, label [, pass] [, ?, condition] [, /]

   где:  pass - отложенная точка на pass раз
         сondition - условие останова
         / - одноразовая точка останова

   BREAK ident, ADDR, address, *
   BREAK ident, ADDR, address, .
   BREAK ident, LINE, module, lineno, *
   BREAK ident, LINE, module, lineno, .

   где:	* - watchpoint
 	. - counter

-> Expr: новая функция @PASS(ident) - количество проходов поверх точки

-> His: пакет для отладки ","1 ставим останов счетчик проходов на строки стека вызовов

-> Останов PROC по типу - на начало, на конец пролога, на начало эпилога","Останов по вызову процедуры: по типу - на начало пролога, тела, эпилога, возврата
   из процедуры. Синтаксис:
   BREAK ident, PROC, address, [type] , label
   где: address - выражение адресного типа
        type - P, B, E, R; означают, соответственно, пролог, тело, эпилог, возворат.

   Если параметр-тип отсутствует, то тип останова - на начало тела процедуры.

   Примеры:
     BREAK b1, PROC, Copyright, P, label	; на начало пролога (точка входа)
     BREAK b2, PROC, Copyright, B, label	; на тело процедуры (определены локалы)
     BREAK b3, PROC, Copyright, E, label	; на начало эпилога
     BREAK b4, PROC, Copyright, R, label	; на возврат из процедуры
     BREAK b5, PROC, Copyright,, label	; то же, что останов b2

-> Сохранять Watch в *.ses файле

-> Dialog: сделать надписи Classes на окне модулей для Jaba

-> Dialog: сделать надписи Methods на окне процеруд для Jaba

-> Expr: CheckFileName не работает, если в пути есть цифры

-> Expr: вычисление типа указателя, расположенного на регистре (без ^)

-> Целые 64-битные отображать (но не использовать в выражении)

-> Batch: В командной строке для пакета понимать параметры @ARG1..@ARGN
   PRO00516-43

-> Точки останова на всякие X2C_TRAP в программе

-> Dump: Запись в файл дампа памяти (указть имя файла. начало, размер)

-> Изменен диалог "Browse file", исправлены некоторые ошибки
 
-> Java: передалан порядок поиска и вычисление локальной переменной
   (так как паблики по именам моут совпадать с процедурами)

-> пакетном отладчике при установке условных остановов в теперь
   можно использовать неопределенные в данном контексте выражения,
   что позволяет устанавливать условия для локальных переменных вне
   тела процедуры.

-> в пакетном отладчике при установке остановов на строку в модуле
   теперь при смещении кода относительно текста выдается предупреждение
   и точка ставится на ближайшую вниз строку, если это возможно.

-> в выражении можно использовать новую функцию @PASS(ident) - количество
   проходов поверх точки с идентификатором ident. 

-> утилита his формирует по errinfo.$$$ пакет для отладки программы, при этом
   если в стеке вызовов будет обнаружена (первая) процедура, имеющая отладочную
   информацию (пользовательский код), то при исполнении полученного пакета
   отладки выход в диалог произойдет именно при ее вызове НЕПОСРЕДСТВЕННО
   перед развалом программы (а не при любом ее вызове).

-> исправлены некоторые ошибки в дизассемблере команды 64-битные целые

-> в диалоговом отладчике сохраняется содержимое окна слежения в *.ses файле

-> для параметров методов при включенном ключе Auto-detect actual type
   нередко правильно вычисляется настоящий тип обьекта
   даже если это не указатель на обьект.

-> в окнах локальных, глобальных, структурных переменных
   отображаются 64-битные целые

-> - переделан поиск и вычисление баз охватывающих процедур, теперь
     переменные отображаются всегда правильно, вне зависимости от того,
     использовала ли вложенная процедура локалы охватывающих процедур

   - предыдущее верно так же и при вычислении любого выражения
     (например, в окне слежения)

   - тоже самое для рекурсивных вложенных процедур

-> вероятно, исправлена ошибка: хождение по стеку вызовов приводило к развалу

-> теперь можно в вызывающих процедурах исправлять и просматривать переменные

