<* +M2EXTENSIONS  *>
<* ALIGNMENT="8" *>
<* ENUMSIZE="4" *>
<* SETSIZE="4" *>

DEFINITION MODULE ["StdCall"] WinNT;

(*  WinNT.def

    This module defines the 32-Bit Windows types and constants that are
    defined by NT, but exposed through the Win32 API.

*)

IMPORT SYSTEM;
FROM WinDef IMPORT DWORD, PDWORD, WORD, PWORD, LONG, BOOL8, SHORT, BYTE,
                   WCHAR, PVOID, LPCVOID, PBYTE,
                   HANDLE;

TYPE PPDWORD = POINTER TO PDWORD;
     PPWORD  = POINTER TO PWORD;

CONST ANYSIZE_ARRAY = 1;

(*
** Define API decoration for direct importing system DLL references.
*)

TYPE CCHAR  = CHAR;
TYPE LCID   = DWORD;
TYPE PLCID  = PDWORD;
TYPE LANGID = WORD;

CONST APPLICATION_ERROR_MASK       = 20000000h;
      ERROR_SEVERITY_SUCCESS       = 00000000h;
      ERROR_SEVERITY_INFORMATIONAL = 40000000h;
      ERROR_SEVERITY_WARNING       = 80000000h;
      ERROR_SEVERITY_ERROR         = 0C0000000h;

TYPE LONGLONG = LONGREAL;
     DWORDLONG = LONGREAL;
     PLONGLONG  = POINTER TO LONGLONG;
     PDWORDLONG = POINTER TO DWORDLONG;

(* Update Sequence Number *)

TYPE USN = LONGLONG;

TYPE LARGE_INTEGER = RECORD
                            CASE : BOOLEAN OF
                            | TRUE  : LowPart  : DWORD;
                                      HighPart : LONG;
                            | FALSE : QuadPart : LONGLONG;
                            END;
                     END;
TYPE PLARGE_INTEGER = POINTER TO LARGE_INTEGER;

TYPE ULARGE_INTEGER = RECORD
                            CASE : BOOLEAN OF
                            | TRUE  : LowPart  : DWORD;
                                      HighPart : DWORD;
                            | FALSE : QuadPart : LONGLONG;
                            END;
                     END;
TYPE PULARGE_INTEGER = POINTER TO ULARGE_INTEGER;

(*
** Locally Unique Identifier
*)

TYPE  LUID = LARGE_INTEGER;
     PLUID = POINTER TO LUID;

(*
** Define operations to logically shift an int64 by 0..31 bits and to multiply
** 32-bits by 32-bits to form a 64-bit product.
*)

PROCEDURE Int32x32To64   (Multiplier, Multiplicand : LONG)  : LONGLONG;
PROCEDURE UInt32x32To64  (Multiplier, Multiplicand : DWORD) : DWORDLONG;
PROCEDURE Int64ShllMod32 (Value : DWORDLONG; ShiftCount : DWORD) : DWORDLONG;
PROCEDURE Int64ShraMod32 (Value : LONGLONG;  ShiftCount : DWORD) : LONGLONG;
PROCEDURE Int64ShrlMod32 (Value : DWORDLONG; ShiftCount : DWORD) : DWORDLONG;

CONST UNICODE_NULL = SYSTEM.CAST (WCHAR, VAL (SHORT, 0));
TYPE PBOOLEAN = POINTER TO BOOL8;

(*  Doubly linked list structure.  Can be used as either a list head, or
**  as link words.
*)

TYPE PLIST_ENTRY = POINTER TO LIST_ENTRY;
      LIST_ENTRY = RECORD
                          Flink : PLIST_ENTRY;
                          Blink : PLIST_ENTRY;
                   END;
(*
**  Singly linked list structure. Can be used as either a list head, or
**  as link words.
*)

TYPE PSINGLE_LIST_ENTRY = POINTER TO SINGLE_LIST_ENTRY;
      SINGLE_LIST_ENTRY = RECORD
                                Next : PSINGLE_LIST_ENTRY;
                          END;

(*
** Base data structures for OLE support
*)

TYPE BYTEARRAY8 = ARRAY [0..7] OF BYTE;

TYPE GUID = RECORD                (* size is 16 *)
                   Data1 : DWORD;
                   Data2 : WORD;
                   Data3 : WORD;
                   Data4 : BYTEARRAY8;
            END;
    PGUID = POINTER TO GUID;

TYPE OBJECTID = RECORD     (* size is 20 *)
                       Lineage    : GUID;
                       Uniquifier : DWORD;
                END;
    POBJECTID = POINTER TO OBJECTID;

CONST MINCHAR     = 80h;
      MAXCHAR     = 7fh;
      MINSHORT    = 8000h;
      MAXSHORT    = 7fffh;
      MINLONG     = 80000000h;
      MAXLONG     = 7fffffffh;
      MAXBYTE     = 0ffh;
      MAXWORD     = 0ffffh;
      MAXDWORD    = 0ffffffffh;

(*
 *  Language IDs.
 *
 *  The following two combinations of primary language ID and
 *  sublanguage ID have special semantics:
 *
 *    Primary Language ID   Sublanguage ID      Result
 *    -------------------   ---------------     ------------------------
 *    LANG_NEUTRAL          SUBLANG_NEUTRAL     Language neutral
 *    LANG_NEUTRAL          SUBLANG_DEFAULT     User default language
 *    LANG_NEUTRAL          SUBLANG_SYS_DEFAULT System default language
 *)

(*
 *  Primary language IDs.
 *)

CONST LANG_NEUTRAL                     = 00h;

      LANG_AFRIKAANS                   = 36h;
      LANG_ALBANIAN                    = 1ch;
      LANG_ARABIC                      = 01h;
      LANG_BASQUE                      = 2dh;
      LANG_BELARUSIAN                  = 23h;
      LANG_BULGARIAN                   = 02h;
      LANG_CATALAN                     = 03h;
      LANG_CHINESE                     = 04h;
      LANG_CROATIAN                    = 1ah;
      LANG_CZECH                       = 05h;
      LANG_DANISH                      = 06h;
      LANG_DUTCH                       = 13h;
      LANG_ENGLISH                     = 09h;
      LANG_ESTONIAN                    = 25h;
      LANG_FAEROESE                    = 38h;
      LANG_FARSI                       = 29h;
      LANG_FINNISH                     = 0bh;
      LANG_FRENCH                      = 0ch;
      LANG_GERMAN                      = 07h;
      LANG_GREEK                       = 08h;
      LANG_HEBREW                      = 0Dh;
      LANG_HUNGARIAN                   = 0eh;
      LANG_ICELANDIC                   = 0fh;
      LANG_INDONESIAN                  = 21h;
      LANG_ITALIAN                     = 10h;
      LANG_JAPANESE                    = 11h;
      LANG_KOREAN                      = 12h;
      LANG_LATVIAN                     = 26h;
      LANG_LITHUANIAN                  = 27h;
      LANG_NORWEGIAN                   = 14h;
      LANG_POLISH                      = 15h;
      LANG_PORTUGUESE                  = 16h;
      LANG_ROMANIAN                    = 18h;
      LANG_RUSSIAN                     = 19h;
      LANG_SERBIAN                     = 1Ah;
      LANG_SLOVAK                      = 1bh;
      LANG_SLOVENIAN                   = 24h;
      LANG_SPANISH                     = 0ah;
      LANG_SWEDISH                     = 1dh;
      LANG_THAI                        = 1eh;
      LANG_TURKISH                     = 1fh;
      LANG_UKRAINIAN                   = 22h;
      LANG_VIETNAMESE                  = 2ah;
(*
 *  Sublanguage IDs.
 *
 *  The name immediately following SUBLANG_ dictates which primary
 *  language ID that sublanguage ID can be combined with to form a
 *  valid language ID.
 *)

CONST SUBLANG_NEUTRAL                  = 00h;    (* language neutral *)
      SUBLANG_DEFAULT                  = 01h;    (* user default *)
      SUBLANG_SYS_DEFAULT              = 02h;    (* system default *)

      SUBLANG_ARABIC                   = 01h;    (* Arabic (Saudi Arabia) *)
      SUBLANG_ARABIC_IRAQ              = 02h;    (* Arabic (Iraq) *)
      SUBLANG_ARABIC_EGYPT             = 03h;    (* Arabic (Egypt) *)
      SUBLANG_ARABIC_LIBYA             = 04h;    (* Arabic (Libya) *)
      SUBLANG_ARABIC_ALGERIA           = 05h;    (* Arabic (Algeria) *)
      SUBLANG_ARABIC_MOROCCO           = 06h;    (* Arabic (Morocco) *)
      SUBLANG_ARABIC_TUNISIA           = 07h;    (* Arabic (Tunisia) *)
      SUBLANG_ARABIC_OMAN              = 08h;    (* Arabic (Oman) *)
      SUBLANG_ARABIC_YEMEN             = 09h;    (* Arabic (Yemen) *)
      SUBLANG_ARABIC_SYRIA             = 10h;    (* Arabic (Syria) *)
      SUBLANG_ARABIC_JORDAN            = 11h;    (* Arabic (Jordan) *)
      SUBLANG_ARABIC_LEBANON           = 12h;    (* Arabic (Lebanon) *)
      SUBLANG_ARABIC_KUWAIT            = 13h;    (* Arabic (Kuwait) *)
      SUBLANG_ARABIC_UAE               = 14h;    (* Arabic (United Arab Emirates) *)
      SUBLANG_ARABIC_BAHRAIN           = 15h;    (* Arabic (Bahrain) *)
      SUBLANG_ARABIC_QATAR             = 16h;    (* Arabic (Qatar) *)
      SUBLANG_CHINESE_TRADITIONAL      = 01h;    (* Chinese (Taiwan) *)
      SUBLANG_CHINESE_SIMPLIFIED       = 02h;    (* Chinese (PR China) *)
      SUBLANG_CHINESE_HONGKONG         = 03h;    (* Chinese (Hong Kong) *)
      SUBLANG_CHINESE_SINGAPORE        = 04h;    (* Chinese (Singapore) *)
      SUBLANG_DUTCH                    = 01h;    (* Dutch *)
      SUBLANG_DUTCH_BELGIAN            = 02h;    (* Dutch (Belgian) *)
      SUBLANG_ENGLISH_US               = 01h;    (* English (USA) *)
      SUBLANG_ENGLISH_UK               = 02h;    (* English (UK) *)
      SUBLANG_ENGLISH_AUS              = 03h;    (* English (Australian) *)
      SUBLANG_ENGLISH_CAN              = 04h;    (* English (Canadian) *)
      SUBLANG_ENGLISH_NZ               = 05h;    (* English (New Zealand) *)
      SUBLANG_ENGLISH_EIRE             = 06h;    (* English (Irish) *)
      SUBLANG_ENGLISH_SOUTH_AFRICA     = 07h;    (* English (South Africa) *)
      SUBLANG_ENGLISH_JAMAICA          = 08h;    (* English (Jamaica) *)
      SUBLANG_ENGLISH_CARRIBEAN        = 09h;    (* English (Carribean) *)
      SUBLANG_ENGLISH_BELIZE           = 0ah;    (* English (Belize) *)
      SUBLANG_ENGLISH_TRINIDAD         = 0bh;    (* English (Trinidad) *)

      SUBLANG_FRENCH                   = 01h;    (* French *)
      SUBLANG_FRENCH_BELGIAN           = 02h;    (* French (Belgian) *)
      SUBLANG_FRENCH_CANADIAN          = 03h;    (* French (Canadian) *)
      SUBLANG_FRENCH_SWISS             = 04h;    (* French (Swiss) *)
      SUBLANG_FRENCH_LUXEMBOURG        = 05h;    (* French (Luxembourg) *)
      SUBLANG_GERMAN                   = 01h;    (* German *)
      SUBLANG_GERMAN_SWISS             = 02h;    (* German (Swiss) *)
      SUBLANG_GERMAN_AUSTRIAN          = 03h;    (* German (Austrian) *)
      SUBLANG_GERMAN_LUXEMBOURG        = 04h;    (* German (Luxembourg) *)
      SUBLANG_GERMAN_LIECHTENSTEIN     = 05h;    (* German (Liechtenstein) *)
      SUBLANG_ITALIAN                  = 01h;    (* Italian *)
      SUBLANG_ITALIAN_SWISS            = 02h;    (* Italian (Swiss) *)
      SUBLANG_KOREAN                   = 01h;    (* Korean *)
      SUBLANG_KOREAN_JOHAB             = 02h;    (* Korean (Johab) *)
      SUBLANG_NORWEGIAN_BOKMAL         = 01h;    (* Norwegian (Bokmal) *)
      SUBLANG_NORWEGIAN_NYNORSK        = 02h;    (* Norwegian (Nynorsk) *)
      SUBLANG_PORTUGUESE               = 02h;    (* Portuguese *)
      SUBLANG_PORTUGUESE_BRAZILIAN     = 01h;    (* Portuguese (Brazilian) *)
      SUBLANG_SPANISH                  = 01h;    (* Spanish (Castilian) *)
      SUBLANG_SPANISH_MEXICAN          = 02h;    (* Spanish (Mexican) *)
      SUBLANG_SPANISH_MODERN           = 03h;    (* Spanish (Modern) *)
      SUBLANG_SPANISH_GUATEMALA        = 04h;    (* Spanish (Guatemala) *)
      SUBLANG_SPANISH_COSTARICA        = 05h;    (* Spanish (Costa Rica) *)
      SUBLANG_SPANISH_PANAMA           = 06h;    (* Spanish (Panama) *)
      SUBLANG_SPANISH_DOMINICAN_REPUBLIC = 07h;  (* Spanish (Dominican Republic) *)
      SUBLANG_SPANISH_VENEZUELA        = 08h;    (* Spanish (Venezuela) *)
      SUBLANG_SPANISH_COLOMBIA         = 09h;    (* Spanish (Colombia) *)
      SUBLANG_SPANISH_PERU             = 10h;    (* Spanish (Peru) *)
      SUBLANG_SPANISH_ARGENTINA        = 11h;    (* Spanish (Argentina) *)
      SUBLANG_SPANISH_ECUADOR          = 12h;    (* Spanish (Ecuador) *)
      SUBLANG_SPANISH_CHILE            = 13h;    (* Spanish (Chile) *)
      SUBLANG_SPANISH_URUGUAY          = 14h;    (* Spanish (Uruguay) *)
      SUBLANG_SPANISH_PARAGUAY         = 15h;    (* Spanish (Paraguay) *)
      SUBLANG_SPANISH_BOLIVIA          = 16h;    (* Spanish (Bolivia) *)
      SUBLANG_SPANISH_EL_SALVADOR      = 11h;    (* Spanish (El Salvador) *)
      SUBLANG_SPANISH_HONDURAS         = 12h;    (* Spanish (Honduras) *)
      SUBLANG_SPANISH_NICARAGUA        = 13h;    (* Spanish (Nicaragua) *)
      SUBLANG_SPANISH_PUERTO_RICO      = 14h;    (* Spanish (Puerto Rico) *)
      SUBLANG_SWEDISH                  = 01h;    (* Swedish *)
      SUBLANG_SWEDISH_FINLAND          = 02h;    (* Swedish (Finland) *)

(*
 *  Sorting IDs.
 *
 *)
      SORT_DEFAULT                     = 0;      (* sorting default *)

      SORT_JAPANESE_XJIS               = 0;       (* Japanese XJIS order *)
      SORT_JAPANESE_UNICODE            = 1;       (* Japanese Unicode order *)

      SORT_CHINESE_BIG5                = 0;       (* Chinese BIG5 order *)
      SORT_CHINESE_UNICODE             = 1;       (* Chinese Unicode order *)

      SORT_KOREAN_KSC                  = 0;       (* Korean KSC order *)
      SORT_KOREAN_UNICODE              = 1;       (* Korean Unicode order *)

      SORT_GERMAN_PHONE_BOOK           = 1;       (* German Phone Book order *)

(*
 *  A language ID is a 16 bit value which is the combination of a
 *  primary language ID and a secondary language ID.  The bits are
 *  allocated as follows:
 *
 *       +-----------------------+-------------------------+
 *       |     Sublanguage ID    |   Primary Language ID   |
 *       +-----------------------+-------------------------+
 *        15                   10 9                       0   bit
 *
 *
 *  Language ID creation/extraction macros:
 *
 *    MAKELANGID    - construct language id from a primary language id and
 *                    a sublanguage id.
 *    PRIMARYLANGID - extract primary language id from a language id.
 *    SUBLANGID     - extract sublanguage id from a language id.
 *)

PROCEDURE MAKELANGID    (primary, sublang : WORD) : LANGID;
PROCEDURE PRIMARYLANGID (id : LANGID) : WORD;
PROCEDURE SUBLANGID     (id : LANGID) : WORD;

(*
 *  A locale ID is a 32 bit value which is the combination of a
 *  language ID, a sort ID, and a reserved area.  The bits are
 *  allocated as follows:
 *
 *       +-------------+---------+-------------------------+
 *       |   Reserved  | Sort ID |      Language ID        |
 *       +-------------+---------+-------------------------+
 *        31         20 19     16 15                      0   bit
 *
 *
 *  Locale ID creation/extraction macros:
 *
 *    MAKELCID       - construct locale id from a language id and a sort id.
 *    LANGIDFROMLCID - extract language id from a locale id.
 *    SORTIDFROMLCID - extract sort id from a locale id.
 *)

CONST NLS_VALID_LOCALE_MASK  = 000fffffh;

PROCEDURE MAKELCID (lgid : LANGID; srtid : WORD) : LCID;
PROCEDURE LANGIDFROMLCID (lcid : LCID) : LANGID;
PROCEDURE SORTIDFROMLCID (lcid : LCID) : LANGID;

(*
 *  Default System and User IDs for language and locale.
 *)

CONST LANG_SYSTEM_DEFAULT = 2048;
      LANG_USER_DEFAULT   = 1024;

CONST LOCALE_SYSTEM_DEFAULT  = 2048;
      LOCALE_USER_DEFAULT    = 1024;

<* IF NOT DEFINED (WIN32_NO_STATUS) THEN *>

CONST STATUS_WAIT_0                    = 00000000h;
      STATUS_ABANDONED_WAIT_0          = 00000080h;
      STATUS_USER_APC                  = 000000C0h;
      STATUS_TIMEOUT                   = 00000102h;
      STATUS_PENDING                   = 00000103h;
      STATUS_SEGMENT_NOTIFICATION      = 40000005h;
      STATUS_GUARD_PAGE_VIOLATION      = 80000001h;
      STATUS_DATATYPE_MISALIGNMENT     = 80000002h;
      STATUS_BREAKPOINT                = 80000003h;
      STATUS_SINGLE_STEP               = 80000004h;
      STATUS_ACCESS_VIOLATION          = 0C0000005h;
      STATUS_IN_PAGE_ERROR             = 0C0000006h;
      STATUS_INVALID_HANDLE            = 0C0000008h;
      STATUS_NO_MEMORY                 = 0C0000017h;
      STATUS_ILLEGAL_INSTRUCTION       = 0C000001Dh;
      STATUS_NONCONTINUABLE_EXCEPTION  = 0C0000025h;
      STATUS_INVALID_DISPOSITION       = 0C0000026h;
      STATUS_ARRAY_BOUNDS_EXCEEDED     = 0C000008Ch;
      STATUS_FLOAT_DENORMAL_OPERAND    = 0C000008Dh;
      STATUS_FLOAT_DIVIDE_BY_ZERO      = 0C000008Eh;
      STATUS_FLOAT_INEXACT_RESULT      = 0C000008Fh;
      STATUS_FLOAT_INVALID_OPERATION   = 0C0000090h;
      STATUS_FLOAT_OVERFLOW            = 0C0000091h;
      STATUS_FLOAT_STACK_CHECK         = 0C0000092h;
      STATUS_FLOAT_UNDERFLOW           = 0C0000093h;
      STATUS_INTEGER_DIVIDE_BY_ZERO    = 0C0000094h;
      STATUS_INTEGER_OVERFLOW          = 0C0000095h;
      STATUS_PRIVILEGED_INSTRUCTION    = 0C0000096h;
      STATUS_STACK_OVERFLOW            = 0C00000FDh;
      STATUS_CONTROL_C_EXIT            = 0C000013Ah;

<* END *> (* NOT DEFINED (WIN32_NO_STATUS) *)

CONST MAXIMUM_WAIT_OBJECTS = 64;     (* Maximum number of wait objects *)
CONST MAXIMUM_SUSPEND_COUNT = MAXCHAR; (* Maximum times thread can be suspended *)

TYPE KSPIN_LOCK = DWORD;

PROCEDURE GetFiberData () : PVOID;
PROCEDURE GetCurrentFiber () : PVOID;

(*
**  Define the size of the 80387 save area, which is in the context frame.
*)

CONST SIZE_OF_80387_REGISTERS = 80;

(*
** The following flags control the contents of the CONTEXT structure.
*)

CONST CONTEXT_i386    = {16}; (* 00010000h - this assumes that i386 and *)
      CONTEXT_i486    = {16}; (* 00010000h - i486 have identical context records *)

      CONTEXT_CONTROL         = CONTEXT_i386 + {0}; (* SS:SP, CS:IP, FLAGS, BP *)
      CONTEXT_INTEGER         = CONTEXT_i386 + {1}; (* AX, BX, CX, DX, SI, DI *)
      CONTEXT_SEGMENTS        = CONTEXT_i386 + {2}; (* DS, ES, FS, GS *)
      CONTEXT_FLOATING_POINT  = CONTEXT_i386 + {3}; (* 387 state *)
      CONTEXT_DEBUG_REGISTERS = CONTEXT_i386 + {4}; (* DB 0-3,6,7 *)

      CONTEXT_FULL = CONTEXT_CONTROL + CONTEXT_INTEGER + CONTEXT_SEGMENTS;

TYPE FLOATING_SAVE_AREA = RECORD
                                 ControlWord   : DWORD;
                                 StatusWord    : DWORD;
                                 TagWord       : DWORD;
                                 ErrorOffset   : DWORD;
                                 ErrorSelector : DWORD;
                                 DataOffset    : DWORD;
                                 DataSelector  : DWORD;
                                 RegisterArea  : ARRAY [0..SIZE_OF_80387_REGISTERS-1] OF BYTE;
                                 Cr0NpxState   : DWORD;
                          END;

TYPE PFLOATING_SAVE_AREA  = POINTER TO FLOATING_SAVE_AREA;

(*
** Context Frame
**  This frame has a several purposes: 1) it is used as an argument to
**  NtContinue, 2) is is used to constuct a call frame for APC delivery,
**  and 3) it is used in the user level thread creation routines.
**
**  The layout of the record conforms to a standard call frame.
*)

TYPE CONTEXT = RECORD

    (*
    ** The flags values within this flag control the contents of
    ** a CONTEXT record.
    **
    ** If the context record is used as an input parameter, then
    ** for each portion of the context record controlled by a flag
    ** whose value is set, it is assumed that that portion of the
    ** context record contains valid context. If the context record
    ** is being used to modify a threads context, then only that
    ** portion of the threads context will be modified.
    **
    ** If the context record is used as an IN OUT parameter to capture
    ** the context of a thread, then only those portions of the thread's
    ** context corresponding to set flags will be returned.
    **
    ** The context record is never used as an OUT only parameter.
    *)

    ContextFlags : BITSET;

    (*
    ** This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    ** set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    ** included in CONTEXT_FULL.
    *)

    Dr0 : DWORD;
    Dr1 : DWORD;
    Dr2 : DWORD;
    Dr3 : DWORD;
    Dr6 : DWORD;
    Dr7 : DWORD;

    (*
    ** This section is specified/returned if the
    ** ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    *)

    FloatSave : FLOATING_SAVE_AREA;

    (*
    ** This section is specified/returned if the
    ** ContextFlags word contians the flag CONTEXT_SEGMENTS.
    *)

    SegGs : DWORD;
    SegFs : DWORD;
    SegEs : DWORD;
    SegDs : DWORD;

    (*
    ** This section is specified/returned if the
    ** ContextFlags word contians the flag CONTEXT_INTEGER.
    *)

    Edi : DWORD;
    Esi : DWORD;
    Ebx : DWORD;
    Edx : DWORD;
    Ecx : DWORD;
    Eax : DWORD;

    (*
    ** This section is specified/returned if the
    ** ContextFlags word contians the flag CONTEXT_CONTROL.
    *)

    Ebp    : DWORD;
    Eip    : DWORD;
    SegCs  : DWORD;             (* MUST BE SANITIZED *)
    EFlags : DWORD;             (* MUST BE SANITIZED *)
    Esp    : DWORD;
    SegSs  : DWORD;
END;

TYPE PCONTEXT = POINTER TO CONTEXT;

TYPE LDT_ENTRY = RECORD
                        LimitLow : WORD;
                        BaseLow : WORD;
                        BaseMid : BYTE;
                        Flags1  : BYTE; (* Declare as bytes to avoid alignment *)
                        Flags2  : BYTE; (* Problems. *)
                        BaseHi  : BYTE;
                 END;
    PLDT_ENTRY = POINTER TO LDT_ENTRY;

CONST EXCEPTION_NONCONTINUABLE     = 1;   (* Noncontinuable exception *)
      EXCEPTION_MAXIMUM_PARAMETERS = 15;  (* maximum number of exception parameters *)

(*
** Exception record definition.
*)

TYPE PEXCEPTION_RECORD = POINTER TO EXCEPTION_RECORD;
      EXCEPTION_RECORD = RECORD
                                ExceptionCode    : DWORD;
                                ExceptionFlags   : DWORD;
                                ExceptionRecord  : PEXCEPTION_RECORD;
                                ExceptionAddress : PVOID;
                                NumberParameters : DWORD;
                                ExceptionInformation : ARRAY [0..EXCEPTION_MAXIMUM_PARAMETERS-1] OF DWORD;
                         END;

(*
** Typedef for pointer returned by exception_info()
*)

TYPE EXCEPTION_POINTERS = RECORD
                                 ExceptionRecord : PEXCEPTION_RECORD;
                                 ContextRecord : PCONTEXT;
                          END;
    PEXCEPTION_POINTERS = POINTER TO EXCEPTION_POINTERS;

(* Here in winnt.h there're process object access masks; they're moved below
   where all access masks are defined *)

CONST MAXIMUM_PROCESSORS = 32;

CONST TLS_MINIMUM_AVAILABLE = 64;

TYPE PNT_TIB = POINTER TO NT_TIB;
     NT_TIB = RECORD
                   ExceptionList : PVOID; (* PEXCEPTION_REGISTRATION_RECORD *)
                   StackBase     : PVOID;
                   StackLimit    : PVOID;
                   SubSystemTib  : PVOID;
                   CASE: BOOLEAN OF
                   | TRUE : FiberData : PVOID;
                   | FALSE : Version : DWORD;
                   END;
                   ArbitraryUserPointer : PVOID;
                   Self                 : PNT_TIB;
              END;

CONST THREAD_BASE_PRIORITY_LOWRT  = 15;  (* value that gets a thread to LowRealtime-1 *)
      THREAD_BASE_PRIORITY_MAX    = 2;   (* maximum thread base priority boost *)
      THREAD_BASE_PRIORITY_MIN    = -2;  (* minimum thread base priority boost *)
      THREAD_BASE_PRIORITY_IDLE   = -15; (* value that gets a thread to idle *)

TYPE QUOTA_LIMITS = RECORD
                           PagedPoolLimit        : DWORD;
                           NonPagedPoolLimit     : DWORD;
                           MinimumWorkingSetSize : DWORD;
                           MaximumWorkingSetSize : DWORD;
                           PagefileLimit         : DWORD;
                           TimeLimit             : LARGE_INTEGER;
                    END;
    PQUOTA_LIMITS = POINTER TO QUOTA_LIMITS;

(* Here should be eventand semaphore access masks; they're moved below where all access masks ara defined *)

TYPE TIME_ZONE_ENUM = (TIME_ZONE_ID_UNKNOWN,   (* 0 *)
                       TIME_ZONE_ID_STANDARD,  (* 1 *)
                       TIME_ZONE_ID_DAYLIGHT); (* 2 *)

CONST PROCESSOR_INTEL_386     = 386;
      PROCESSOR_INTEL_486     = 486;
      PROCESSOR_INTEL_PENTIUM = 586;
      PROCESSOR_MIPS_R4000    = 4000;
      PROCESSOR_ALPHA_21064   = 21064;


<* PUSH *> <* ENUMSIZE = "2" *>

TYPE PROCESSOR_ARCHITECTURE_ENUM = (PROCESSOR_ARCHITECTURE_INTEL, (* 0 *)
                                    PROCESSOR_ARCHITECTURE_MIPS,  (* 1 *)
                                    PROCESSOR_ARCHITECTURE_ALPHA, (* 2 *)
                                    PROCESSOR_ARCHITECTURE_PPC);  (* 3 *)

CONST PROCESSOR_ARCHITECTURE_UNKNOWN = SYSTEM.CAST (PROCESSOR_ARCHITECTURE_ENUM, 0FFFFh);

<* POP *>

(* IsProcessorFeaturePresent parameters *)

TYPE PF_ENUM = (PF_FLOATING_POINT_PRECISION_ERRATA, (* 0 - In rare circumstances,
                                                           a floating-point
                                                           precision error can occur (Pentium). *)
                PF_FLOATING_POINT_EMULATED,         (* 1 - Floating-point operations
                                                           are emulated using a software emulator. *)
                PF_COMPARE_EXCHANGE_DOUBLE,         (* 2 - The compare and exchange double operation
                                                           is available (Pentium, MIPS, and Alpha). *)
                PF_MMX_INSTRUCTIONS_AVAILABLE);     (* 3 - The MMX instruction set is available *)

TYPE PROTECT_ENUM = (PROTECT_0, PROTECT_1, PROTECT_2, PROTECT_3,
                     PROTECT_4, PROTECT_5, PROTECT_6, PROTECT_7,
                     PROTECT_8, PROTECT_9, PROTECT_10,PROTECT_11,
                     PROTECT_12,PROTECT_13,PROTECT_14,PROTECT_15,
                     PROTECT_16,PROTECT_17,PROTECT_18,PROTECT_19,
                     PROTECT_20,PROTECT_21,PROTECT_22,PROTECT_23,
                     PROTECT_24,PROTECT_25,PROTECT_26,PROTECT_27,
                     PROTECT_28);

     PROTECT_SET = SET OF PROTECT_ENUM;

CONST PAGE_NOACCESS          = PROTECT_SET {PROTECT_0};  (* 01h; *)
      PAGE_READONLY          = PROTECT_SET {PROTECT_1};  (* 02h; *)
      PAGE_READWRITE         = PROTECT_SET {PROTECT_2};  (* 04h; *)
      PAGE_WRITECOPY         = PROTECT_SET {PROTECT_3};  (* 08h; *)
      PAGE_EXECUTE           = PROTECT_SET {PROTECT_4};  (* 10h; *)
      PAGE_EXECUTE_READ      = PROTECT_SET {PROTECT_5};  (* 20h; *)
      PAGE_EXECUTE_READWRITE = PROTECT_SET {PROTECT_6};  (* 40h; *)
      PAGE_EXECUTE_WRITECOPY = PROTECT_SET {PROTECT_7};  (* 80h; *)
      PAGE_GUARD             = PROTECT_SET {PROTECT_8};  (* 100h; *)
      PAGE_NOCACHE           = PROTECT_SET {PROTECT_9};  (* 200h; *)
      MEM_COMMIT             = PROTECT_SET {PROTECT_12}; (* 1000h; *)
      MEM_RESERVE            = PROTECT_SET {PROTECT_13}; (* 2000h; *)
      MEM_DECOMMIT           = PROTECT_SET {PROTECT_14}; (* 4000h; *)
      MEM_RELEASE            = PROTECT_SET {PROTECT_15}; (* 8000h; *)
      MEM_FREE               = PROTECT_SET {PROTECT_16}; (* 10000h; *)
      MEM_PRIVATE            = PROTECT_SET {PROTECT_17}; (* 20000h; *)
      MEM_MAPPED             = PROTECT_SET {PROTECT_18}; (* 40000h; *)
      MEM_RESET              = PROTECT_SET {PROTECT_19}; (* 80000h; *)
      MEM_TOP_DOWN           = PROTECT_SET {PROTECT_20}; (* 100000h; *)
      SEC_FILE               = PROTECT_SET {PROTECT_23}; (* 800000h; *)
      SEC_IMAGE              = PROTECT_SET {PROTECT_24}; (* 1000000h; *)
      SEC_RESERVE            = PROTECT_SET {PROTECT_26}; (* 4000000h; *)
      SEC_COMMIT             = PROTECT_SET {PROTECT_27}; (* 8000000h; *)
      SEC_NOCACHE            = PROTECT_SET {PROTECT_28}; (* 10000000h; *)
      MEM_IMAGE              = SEC_IMAGE;

TYPE MEMORY_BASIC_INFORMATION = RECORD
                                       BaseAddress       : PVOID;
                                       AllocationBase    : PVOID;
                                       AllocationProtect : PROTECT_SET;
                                       RegionSize        : DWORD;
                                       State             : PROTECT_SET;
                                       Protect           : PROTECT_SET;
                                       Type              : PROTECT_SET;
                                END;
    PMEMORY_BASIC_INFORMATION = POINTER TO MEMORY_BASIC_INFORMATION;


TYPE FILE_SHARE_ENUM = (FILE_SHARE__READ,    (* 0 *)
                        FILE_SHARE__WRITE,   (* 1 *)
                        FILE_SHARE__DELETE); (* 2 *)

     FILE_SHARE_MODE = SET OF FILE_SHARE_ENUM;

CONST FILE_SHARE_READ   = FILE_SHARE_MODE {FILE_SHARE__READ};   (* 00000001h *)
      FILE_SHARE_WRITE  = FILE_SHARE_MODE {FILE_SHARE__WRITE};  (* 00000002h *)
      FILE_SHARE_DELETE = FILE_SHARE_MODE {FILE_SHARE__DELETE}; (* 00000004h *)

(* FILE_BIT_ENUM and FILE_BITFLAGS_SET are generic types used for:
   - file attributes (FILE_ATTRIBUTE_SET)
   - file creation modes (FILE_FLAG_SET)
   - security type of service (SECURITY_SET)
   - named pipe modes
*)

TYPE FILE_BIT_ENUM = (F_0,  F_1,  F_2,  F_3,
                      F_4,  F_5,  F_6,  F_7,
                      F_8,  F_9,  F_10, F_11,
                      F_12, F_13, F_14, F_15,
                      F_16, F_17, F_18, F_19,
                      F_20, F_21, F_22, F_23,
                      F_24, F_25, F_26, F_27,
                      F_28, F_29, F_30, F_31);

     FILE_BIT_SET = SET OF FILE_BIT_ENUM;

TYPE FILE_ATTRIBUTE_ENUM = FILE_BIT_ENUM;

CONST FILE_ATTRIBUTE__READONLY   = F_0;
      FILE_ATTRIBUTE__HIDDEN     = F_1;
      FILE_ATTRIBUTE__SYSTEM     = F_2;
      FILE_ATTRIBUTE__DIRECTORY  = F_4;
      FILE_ATTRIBUTE__ARCHIVE    = F_5;
      FILE_ATTRIBUTE__NORMAL     = F_7;
      FILE_ATTRIBUTE__TEMPORARY  = F_8;
      FILE_ATTRIBUTE__COMPRESSED = F_11;
      FILE_ATTRIBUTE__OFFLINE    = F_12;

TYPE FILE_ATTRIBUTE_SET = FILE_BIT_SET;

CONST FILE_ATTRIBUTE_READONLY   = FILE_ATTRIBUTE_SET {FILE_ATTRIBUTE__READONLY  }; (* 00000001h *)
      FILE_ATTRIBUTE_HIDDEN     = FILE_ATTRIBUTE_SET {FILE_ATTRIBUTE__HIDDEN    }; (* 00000002h *)
      FILE_ATTRIBUTE_SYSTEM     = FILE_ATTRIBUTE_SET {FILE_ATTRIBUTE__SYSTEM    }; (* 00000004h *)
      FILE_ATTRIBUTE_DIRECTORY  = FILE_ATTRIBUTE_SET {FILE_ATTRIBUTE__DIRECTORY }; (* 00000010h *)
      FILE_ATTRIBUTE_ARCHIVE    = FILE_ATTRIBUTE_SET {FILE_ATTRIBUTE__ARCHIVE   }; (* 00000020h *)
      FILE_ATTRIBUTE_NORMAL     = FILE_ATTRIBUTE_SET {FILE_ATTRIBUTE__NORMAL    }; (* 00000080h *)
      FILE_ATTRIBUTE_TEMPORARY  = FILE_ATTRIBUTE_SET {FILE_ATTRIBUTE__TEMPORARY }; (* 00000100h *)
      FILE_ATTRIBUTE_COMPRESSED = FILE_ATTRIBUTE_SET {FILE_ATTRIBUTE__COMPRESSED}; (* 00000800h *)
      FILE_ATTRIBUTE_OFFLINE    = FILE_ATTRIBUTE_SET {FILE_ATTRIBUTE__OFFLINE};    (* 00001000h *)

TYPE FILE_NOTIFY_ENUM = (FILE_NOTIFY__CHANGE_FILE_NAME,   (* 0 *)
                         FILE_NOTIFY__CHANGE_DIR_NAME,    (* 1 *)
                         FILE_NOTIFY__CHANGE_ATTRIBUTES,  (* 2 *)
                         FILE_NOTIFY__CHANGE_SIZE,        (* 3 *)
                         FILE_NOTIFY__CHANGE_LAST_WRITE,  (* 4 *)
                         FILE_NOTIFY__CHANGE_LAST_ACCESS, (* 5*)
                         FILE_NOTIFY__CHANGE_CREATION,    (* 6 *)
                         FILE_NOTIFY__7,
                         FILE_NOTIFY__CHANGE_SECURITY);   (* 8 *)

     FILE_NOTIFY_SET = SET OF FILE_NOTIFY_ENUM;

CONST FILE_NOTIFY_CHANGE_FILE_NAME  = FILE_NOTIFY_SET {FILE_NOTIFY__CHANGE_FILE_NAME }; (* 00000001h *)
      FILE_NOTIFY_CHANGE_DIR_NAME   = FILE_NOTIFY_SET {FILE_NOTIFY__CHANGE_DIR_NAME  }; (* 00000002h *)
      FILE_NOTIFY_CHANGE_ATTRIBUTES = FILE_NOTIFY_SET {FILE_NOTIFY__CHANGE_ATTRIBUTES}; (* 00000004h *)
      FILE_NOTIFY_CHANGE_SIZE       = FILE_NOTIFY_SET {FILE_NOTIFY__CHANGE_SIZE      }; (* 00000008h *)
      FILE_NOTIFY_CHANGE_LAST_WRITE = FILE_NOTIFY_SET {FILE_NOTIFY__CHANGE_LAST_WRITE}; (* 00000010h *)
      FILE_NOTIFY_CHANGE_LAST_ACCESS= FILE_NOTIFY_SET {FILE_NOTIFY__CHANGE_LAST_ACCESS};(* 00000100h *)
      FILE_NOTIFY_CHANGE_CREATION   = FILE_NOTIFY_SET {FILE_NOTIFY__CHANGE_CREATION  }; (* 00000100h *)
      FILE_NOTIFY_CHANGE_SECURITY   = FILE_NOTIFY_SET {FILE_NOTIFY__CHANGE_SECURITY  }; (* 00000100h *)

TYPE FILE_ACTION_ENUM = (FILE_ACTION_0,
                         FILE_ACTION_ADDED,              (* 1 *)
                         FILE_ACTION_REMOVED,            (* 2 *)
                         FILE_ACTION_MODIFIED,           (* 3 *)
                         FILE_ACTION_RENAMED_OLD_NAME,   (* 4 *)
                         FILE_ACTION_RENAMED_NEW_NAME);  (* 5 *)

CONST MAILSLOT_NO_MESSAGE   = SYSTEM.CAST (DWORD, VAL (LONG, -1));
      MAILSLOT_WAIT_FOREVER = SYSTEM.CAST (DWORD, VAL (LONG, -1));

TYPE FILESYSTEM_ENUM = (FILE__CASE_SENSITIVE_SEARCH,  (*  0 *)
                        FILE__CASE_PRESERVED_NAMES,   (*  1 *)
                        FILE__UNICODE_ON_DISK,        (*  2 *)
                        FILE__PERSISTENT_ACLS,        (*  3 *)
                        FILE__FILE_COMPRESSION,       (*  4 *)
                        FILE__5, FILE__6, FILE__7,
                        FILE__8, FILE__9, FILE__10,
                        FILE__11,FILE__12,FILE__13,
                        FILE__14,
                        FILE__VOLUME_IS_COMPRESSED);  (* 15*)

     FILESYSTEM_FLAGS = SET OF FILESYSTEM_ENUM;

CONST FILE_CASE_SENSITIVE_SEARCH = FILESYSTEM_FLAGS {FILE__CASE_SENSITIVE_SEARCH}; (* 00000001h *)
      FILE_CASE_PRESERVED_NAMES  = FILESYSTEM_FLAGS {FILE__CASE_PRESERVED_NAMES }; (* 00000002h *)
      FILE_UNICODE_ON_DISK       = FILESYSTEM_FLAGS {FILE__UNICODE_ON_DISK      }; (* 00000004h *)
      FILE_PERSISTENT_ACLS       = FILESYSTEM_FLAGS {FILE__PERSISTENT_ACLS      }; (* 00000008h *)
      FILE_FILE_COMPRESSION      = FILESYSTEM_FLAGS {FILE__FILE_COMPRESSION     }; (* 00000010h *)
      FILE_VOLUME_IS_COMPRESSED  = FILESYSTEM_FLAGS {FILE__VOLUME_IS_COMPRESSED }; (* 00008000h *)

TYPE FILE_NOTIFY_INFORMATION = RECORD
                                    NextEntryOffset : DWORD;
                                    Action          : FILE_ACTION_ENUM;
                                    FileNameLength  : DWORD;
                                    FileName        : ARRAY [0..0] OF WCHAR;
                               END;

(* DuplicateHandle options *)

TYPE DUPLICATE_ENUM = (DUPLICATE__CLOSE_SOURCE, (* 0 *)
                       DUPLICATE__SAME_ACCESS); (* 1 *)

     DUPLICATE_TYPE = SET OF DUPLICATE_ENUM;

CONST DUPLICATE_CLOSE_SOURCE = DUPLICATE_TYPE {DUPLICATE__CLOSE_SOURCE};  (* 00000001h *)
      DUPLICATE_SAME_ACCESS  = DUPLICATE_TYPE {DUPLICATE__SAME_ACCESS};   (* 00000002h *)

TYPE PACCESS_TOKEN = PVOID;
TYPE PSECURITY_DESCRIPTOR = PVOID;
TYPE PSID = PVOID;

(***********************************************************************
**                                                                    **
**                             ACCESS MASK                            **
**                                                                    **
***********************************************************************)


(*
**  Define the access mask as a longword sized structure divided up as
**  follows:
**
**       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
**       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
**      +---------------+---------------+-------------------------------+
**      |G|G|G|G|Res'd|A| StandardRights|         SpecificRights        |
**      |R|W|E|A|     |S|               |                               |
**      +-+-------------+---------------+-------------------------------+
**
**      typedef struct _ACCESS_MASK {
**          WORD   SpecificRights;
**          BYTE  StandardRights;
**          BYTE  AccessSystemAcl : 1;
**          BYTE  Reserved : 3;
**          BYTE  GenericAll : 1;
**          BYTE  GenericExecute : 1;
**          BYTE  GenericWrite : 1;
**          BYTE  GenericRead : 1;
**      } ACCESS_MASK;
**
**  but to make life simple for programmer's we'll allow them to specify
**  a desired access mask by simply OR'ing together mulitple single rights
**  and treat an access mask as a DWORD.  For example
**
**      DesiredAccess = DELETE | READ_CONTROL
**
**  So we'll declare ACCESS_MASK as DWORD
**  Modula-2 note: DWORD was converted into a bitset.
*)

TYPE ACCESS_ENUM = (ACCESS_0, ACCESS_1, ACCESS_2, ACCESS_3,
                    ACCESS_4, ACCESS_5, ACCESS_6, ACCESS_7,
                    ACCESS_8, ACCESS_9, ACCESS_10,ACCESS_11,
                    ACCESS_12,ACCESS_13,ACCESS_14,ACCESS_15,
                    ACCESS_16,ACCESS_17,ACCESS_18,ACCESS_19,
                    ACCESS_20,ACCESS_21,ACCESS_22,ACCESS_23,
                    ACCESS_24,ACCESS_25,ACCESS_26,ACCESS_27,
                    ACCESS_28,ACCESS_29,ACCESS_30,ACCESS_31);

     ACCESS_MASK = SET OF ACCESS_ENUM;
    PACCESS_MASK = POINTER TO ACCESS_MASK;

(***********************************************************************
**                                                                    **
**                             ACCESS TYPES                           **
**                                                                    **
***********************************************************************)

(*
**  The following are masks for the predefined standard access types
*)

CONST DELETE                           = ACCESS_MASK {ACCESS_16}; (* 00010000h *)
      READ_CONTROL                     = ACCESS_MASK {ACCESS_17}; (* 00020000h *)
      WRITE_DAC                        = ACCESS_MASK {ACCESS_18}; (* 00040000h *)
      WRITE_OWNER                      = ACCESS_MASK {ACCESS_19}; (* 00080000h *)
      SYNCHRONIZE                      = ACCESS_MASK {ACCESS_20}; (* 00100000h *)

      STANDARD_RIGHTS_REQUIRED         = ACCESS_MASK {ACCESS_16..ACCESS_19}; (* 000F0000h *)

      STANDARD_RIGHTS_READ             = READ_CONTROL;
      STANDARD_RIGHTS_WRITE            = READ_CONTROL;
      STANDARD_RIGHTS_EXECUTE          = READ_CONTROL;

      STANDARD_RIGHTS_ALL              = ACCESS_MASK {ACCESS_16..ACCESS_20}; (* 001F0000h *)

      SPECIFIC_RIGHTS_ALL              = ACCESS_MASK {ACCESS_0..ACCESS_15}; (* 0000FFFFh *)

(*
** AccessSystemAcl access type
*)

      ACCESS_SYSTEM_SECURITY           = ACCESS_MASK {ACCESS_24}; (* 01000000h *)

(*
** MaximumAllowed access type
*)


      MAXIMUM_ALLOWED                  = ACCESS_MASK {ACCESS_25}; (* 02000000h *)

(*
**  These are the generic rights.
*)

      GENERIC_READ                     = ACCESS_MASK {ACCESS_31}; (* 80000000h *)
      GENERIC_WRITE                    = ACCESS_MASK {ACCESS_30}; (* 40000000h *)
      GENERIC_EXECUTE                  = ACCESS_MASK {ACCESS_29}; (* 20000000h *)
      GENERIC_ALL                      = ACCESS_MASK {ACCESS_28}; (* 10000000h *)

(* some specific access rights *)

CONST PROCESS_TERMINATE         = ACCESS_MASK {ACCESS_0};  (* 0001h *)
      PROCESS_CREATE_THREAD     = ACCESS_MASK {ACCESS_1};  (* 0002h *)
      PROCESS_VM_OPERATION      = ACCESS_MASK {ACCESS_3};  (* 0008h *)
      PROCESS_VM_READ           = ACCESS_MASK {ACCESS_4};  (* 0010h *)
      PROCESS_VM_WRITE          = ACCESS_MASK {ACCESS_5};  (* 0020h *)
      PROCESS_DUP_HANDLE        = ACCESS_MASK {ACCESS_6};  (* 0040h *)
      PROCESS_CREATE_PROCESS    = ACCESS_MASK {ACCESS_7};  (* 0080h *)
      PROCESS_SET_QUOTA         = ACCESS_MASK {ACCESS_8};  (* 0100h *)
      PROCESS_SET_INFORMATION   = ACCESS_MASK {ACCESS_9};  (* 0200h *)
      PROCESS_QUERY_INFORMATION = ACCESS_MASK {ACCESS_10}; (* 0400h *)
      PROCESS_ALL_ACCESS        = STANDARD_RIGHTS_REQUIRED + SYNCHRONIZE +
                                  ACCESS_MASK {ACCESS_0..ACCESS_11};

      THREAD_TERMINATE               = ACCESS_MASK {ACCESS_0}; (* 0001h *)
      THREAD_SUSPEND_RESUME          = ACCESS_MASK {ACCESS_1}; (* 0002h *)
      THREAD_GET_CONTEXT             = ACCESS_MASK {ACCESS_3}; (* 0008h *)
      THREAD_SET_CONTEXT             = ACCESS_MASK {ACCESS_4}; (* 0010h *)
      THREAD_SET_INFORMATION         = ACCESS_MASK {ACCESS_5}; (* 0020h *)
      THREAD_QUERY_INFORMATION       = ACCESS_MASK {ACCESS_6}; (* 0040h *)
      THREAD_SET_THREAD_TOKEN        = ACCESS_MASK {ACCESS_7}; (* 0080h *)
      THREAD_IMPERSONATE             = ACCESS_MASK {ACCESS_8}; (* 0100h *)
      THREAD_DIRECT_IMPERSONATION    = ACCESS_MASK {ACCESS_9}; (* 0200h *)

      THREAD_ALL_ACCESS         = STANDARD_RIGHTS_REQUIRED + SYNCHRONIZE +
                                  ACCESS_MASK {ACCESS_0 .. ACCESS_9};

CONST EVENT_MODIFY_STATE     = ACCESS_MASK {ACCESS_1};  (* 0x0002 *)
      EVENT_ALL_ACCESS       = STANDARD_RIGHTS_REQUIRED + SYNCHRONIZE +
                               ACCESS_MASK {ACCESS_0, ACCESS_1};

      MUTANT_QUERY_STATE     = ACCESS_MASK {ACCESS_0};  (* 0x0001 *)
      MUTANT_ALL_ACCESS      = STANDARD_RIGHTS_REQUIRED + SYNCHRONIZE +
                               MUTANT_QUERY_STATE;

      SEMAPHORE_MODIFY_STATE = ACCESS_MASK {ACCESS_1};  (* 0x0002 *)
      SEMAPHORE_ALL_ACCESS   = STANDARD_RIGHTS_REQUIRED + SYNCHRONIZE +
                               ACCESS_MASK {ACCESS_0, ACCESS_1};

CONST SECTION_QUERY       = ACCESS_MASK {ACCESS_0}; (* 0001h *)
      SECTION_MAP_WRITE   = ACCESS_MASK {ACCESS_1}; (* 0002h *)
      SECTION_MAP_READ    = ACCESS_MASK {ACCESS_2}; (* 0004h *)
      SECTION_MAP_EXECUTE = ACCESS_MASK {ACCESS_3}; (* 0008h *)
      SECTION_EXTEND_SIZE = ACCESS_MASK {ACCESS_4}; (* 0010h *)

      SECTION_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED +
                            SECTION_QUERY +
                            SECTION_MAP_WRITE +
                            SECTION_MAP_READ +
                            SECTION_MAP_EXECUTE +
                            SECTION_EXTEND_SIZE;

(*
** Define access rights to files and directories
*)

CONST FILE_READ_DATA            = ACCESS_MASK {ACCESS_0}; (* 0001h - file & pipe *)
      FILE_LIST_DIRECTORY       = ACCESS_MASK {ACCESS_0}; (* 0001h - directory *)

      FILE_WRITE_DATA           = ACCESS_MASK {ACCESS_1}; (* 0002h - file & pipe *)
      FILE_ADD_FILE             = ACCESS_MASK {ACCESS_1}; (* 0002h - directory *)

      FILE_APPEND_DATA          = ACCESS_MASK {ACCESS_2}; (* 0004h - file *)
      FILE_ADD_SUBDIRECTORY     = ACCESS_MASK {ACCESS_2}; (* 0004h - directory *)
      FILE_CREATE_PIPE_INSTANCE = ACCESS_MASK {ACCESS_2}; (* 0004h - named pipe *)

      FILE_READ_EA              = ACCESS_MASK {ACCESS_3}; (* 0008h - file & directory *)
      FILE_READ_PROPERTIES      = FILE_READ_EA;

      FILE_WRITE_EA             = ACCESS_MASK {ACCESS_4}; (* 0010h - file & directory *)
      FILE_WRITE_PROPERTIES     = FILE_WRITE_EA;

      FILE_EXECUTE              = ACCESS_MASK {ACCESS_5}; (* 0020h - file *)
      FILE_TRAVERSE             = ACCESS_MASK {ACCESS_5}; (* 0020h - directory *)

      FILE_DELETE_CHILD         = ACCESS_MASK {ACCESS_6}; (* 0040h - directory *)

      FILE_READ_ATTRIBUTES      = ACCESS_MASK {ACCESS_7}; (* 0080h - all *)

      FILE_WRITE_ATTRIBUTES     = ACCESS_MASK {ACCESS_8}; (* 0100h - all *)

      FILE_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED + SYNCHRONIZE + ACCESS_MASK {ACCESS_0..ACCESS_8};

      FILE_GENERIC_READ         = STANDARD_RIGHTS_READ +
                                  FILE_READ_DATA +
                                  FILE_READ_ATTRIBUTES +
                                  FILE_READ_EA +
                                  SYNCHRONIZE;

      FILE_GENERIC_WRITE        = STANDARD_RIGHTS_WRITE +
                                  FILE_WRITE_DATA +
                                  FILE_WRITE_ATTRIBUTES +
                                  FILE_WRITE_EA +
                                  FILE_APPEND_DATA +
                                  SYNCHRONIZE;


      FILE_GENERIC_EXECUTE      = STANDARD_RIGHTS_EXECUTE +
                                  FILE_READ_ATTRIBUTES +
                                  FILE_EXECUTE +
                                  SYNCHRONIZE;

      IO_COMPLETION_MODIFY_STATE = ACCESS_MASK {ACCESS_1}; (* 0002h *)
      IO_COMPLETION_ALL_ACCESS   = STANDARD_RIGHTS_REQUIRED + SYNCHRONIZE +
                                   ACCESS_MASK {ACCESS_0, ACCESS_1};


(*
**  Define the generic mapping array.  This is used to denote the
**  mapping of each generic access right to a specific access mask.
*)

TYPE GENERIC_MAPPING = RECORD
                              GenericRead    : ACCESS_MASK;
                              GenericWrite   : ACCESS_MASK;
                              GenericExecute : ACCESS_MASK;
                              GenericAll     : ACCESS_MASK;
                       END;
    PGENERIC_MAPPING = POINTER TO GENERIC_MAPPING;

(***********************************************************************
**                                                                    **
**                        LUID_AND_ATTRIBUTES                         **
**                                                                    **
***********************************************************************)

<* PUSH *> <* ALIGNMENT = "4" *>

TYPE LUID_AND_ATTRIBUTES = RECORD
                                  Luid       : LUID;
                                  Attributes : BITSET;
                           END;
    PLUID_AND_ATTRIBUTES = POINTER TO LUID_AND_ATTRIBUTES;

<* POP *>

(***********************************************************************
**                                                                    **
**              Security Id     (SID)                                 **
**                                                                    **
************************************************************************
**
**
** Pictorially the structure of an SID is as follows:
**
**         1   1   1   1   1   1
**         5   4   3   2   1   0   9   8   7   6   5   4   3   2   1   0
**      +---------------------------------------------------------------+
**      |      SubAuthorityCount        |Reserved1 (SBZ)|   Revision    |
**      +---------------------------------------------------------------+
**      |                   IdentifierAuthority[0]                      |
**      +---------------------------------------------------------------+
**      |                   IdentifierAuthority[1]                      |
**      +---------------------------------------------------------------+
**      |                   IdentifierAuthority[2]                      |
**      +---------------------------------------------------------------+
**      |                                                               |
**      +- -  -  -  -  -  -  -  SubAuthority[]  -  -  -  -  -  -  -  - -+
**      |                                                               |
**      +---------------------------------------------------------------+
**
*)

TYPE BYTE6 = ARRAY [0..5] OF BYTE;
TYPE SID_IDENTIFIER_AUTHORITY = RECORD
                                       Value : BYTE6;
                                END;
    PSID_IDENTIFIER_AUTHORITY = POINTER TO SID_IDENTIFIER_AUTHORITY;

TYPE SID = RECORD
                  Revision : BYTE;
                  SubAuthorityCount : BYTE;
                  IdentifierAuthority : SID_IDENTIFIER_AUTHORITY;
                  SubAuthority : ARRAY [0..0] OF DWORD;
           END;
    PISID = POINTER TO SID;

CONST SID_REVISION                     =  1;    (* Current revision level *)
      SID_MAX_SUB_AUTHORITIES          = 15;
      SID_RECOMMENDED_SUB_AUTHORITIES  =  1;    (* Will change to around 6 *)
                                                (* in a future release. *)

TYPE SID_NAME_USE = (SID_NAME_USE_0,
                     SidTypeUser,
                     SidTypeGroup,
                     SidTypeDomain,
                     SidTypeAlias,
                     SidTypeWellKnownGroup,
                     SidTypeDeletedAccount,
                     SidTypeInvalid,
                     SidTypeUnknown);
     PSID_NAME_USE = POINTER TO SID_NAME_USE;

TYPE SID_AND_ATTRIBUTES = RECORD
                                 Sid : PSID;
                                 Attributes : BITSET;
                          END;
    PSID_AND_ATTRIBUTES = POINTER TO SID_AND_ATTRIBUTES;


(***************************************************************************/
**                                                                         **
** Universal well-known SIDs                                               **
**                                                                         **
**     Null SID                     S-1-0-0                                **
**     World                        S-1-1-0                                **
**     Local                        S-1-2-0                                **
**     Creator Owner ID             S-1-3-0                                **
**     Creator Group ID             S-1-3-1                                **
**     Creator Owner Server ID      S-1-3-2                                **
**     Creator Group Server ID      S-1-3-3                                **
**                                                                         **
**     (Non-unique IDs)      S-1-4                                         **
**                                                                         **
****************************************************************************)


CONST SECURITY_NULL_SID_AUTHORITY     = SID_IDENTIFIER_AUTHORITY {BYTE6 {0,0,0,0,0,0}};
      SECURITY_WORLD_SID_AUTHORITY    = SID_IDENTIFIER_AUTHORITY {BYTE6 {0,0,0,0,0,1}};
      SECURITY_LOCAL_SID_AUTHORITY    = SID_IDENTIFIER_AUTHORITY {BYTE6 {0,0,0,0,0,2}};
      SECURITY_CREATOR_SID_AUTHORITY  = SID_IDENTIFIER_AUTHORITY {BYTE6 {0,0,0,0,0,3}};
      SECURITY_NON_UNIQUE_AUTHORITY   = SID_IDENTIFIER_AUTHORITY {BYTE6 {0,0,0,0,0,4}};

      SECURITY_NULL_RID               = 00000000h;
      SECURITY_WORLD_RID              = 00000000h;
      SECURITY_LOCAL_RID              = 00000000h;

      SECURITY_CREATOR_OWNER_RID      = 00000000h;
      SECURITY_CREATOR_GROUP_RID      = 00000001h;

      SECURITY_CREATOR_OWNER_SERVER_RID = 00000002h;
      SECURITY_CREATOR_GROUP_SERVER_RID = 00000003h;

(***************************************************************************/
**                                                                         **
** NT well-known SIDs                                                      **
**                                                                         **
**     NT Authority          S-1-5                                         **
**     Dialup                S-1-5-1                                       **
**                                                                         **
**     Network               S-1-5-2                                       **
**     Batch                 S-1-5-3                                       **
**     Interactive           S-1-5-4                                       **
**     Service               S-1-5-6                                       **
**     AnonymousLogon        S-1-5-7       (aka null logon session)        **
**     Proxy                 S-1-5-8                                       **
**     ServerLogon           S-1-5-8       (aka domain controller account) **
**                                                                         **
**     (Logon IDs)           S-1-5-5-X-Y                                   **
**                                                                         **
**     (NT non-unique IDs)   S-1-5-15h-...                                 **
**                                                                         **
**     (Built-in domain)     s-1-5-20h                                     **
**                                                                         **
****************************************************************************)


CONST SECURITY_NT_AUTHORITY           = SID_IDENTIFIER_AUTHORITY {BYTE6{0,0,0,0,0,5}};

      SECURITY_DIALUP_RID             = 00000001h;
      SECURITY_NETWORK_RID            = 00000002h;
      SECURITY_BATCH_RID              = 00000003h;
      SECURITY_INTERACTIVE_RID        = 00000004h;
      SECURITY_SERVICE_RID            = 00000006h;
      SECURITY_ANONYMOUS_LOGON_RID    = 00000007h;
      SECURITY_PROXY_RID              = 00000008h;
      SECURITY_SERVER_LOGON_RID       = 00000009h;

      SECURITY_LOGON_IDS_RID          = 00000005h;
      SECURITY_LOGON_IDS_RID_COUNT    = 3;

      SECURITY_LOCAL_SYSTEM_RID       = 00000012h;

      SECURITY_NT_NON_UNIQUE          = 00000015h;

      SECURITY_BUILTIN_DOMAIN_RID     = 00000020h;

(****************************************************************************
**                                                                         **
** well-known domain relative sub-authority values (RIDs)...               **
**                                                                         **
****************************************************************************)

(* Well-known users ... *)

CONST DOMAIN_USER_RID_ADMIN          = 000001F4h;
      DOMAIN_USER_RID_GUEST          = 000001F5h;



(* well-known groups ... *)

      DOMAIN_GROUP_RID_ADMINS        = 00000200h;
      DOMAIN_GROUP_RID_USERS         = 00000201h;
      DOMAIN_GROUP_RID_GUESTS        = 00000202h;

(* well-known aliases ... *)

      DOMAIN_ALIAS_RID_ADMINS        = 00000220h;
      DOMAIN_ALIAS_RID_USERS         = 00000221h;
      DOMAIN_ALIAS_RID_GUESTS        = 00000222h;
      DOMAIN_ALIAS_RID_POWER_USERS   = 00000223h;

      DOMAIN_ALIAS_RID_ACCOUNT_OPS   = 00000224h;
      DOMAIN_ALIAS_RID_SYSTEM_OPS    = 00000225h;
      DOMAIN_ALIAS_RID_PRINT_OPS     = 00000226h;
      DOMAIN_ALIAS_RID_BACKUP_OPS    = 00000227h;

      DOMAIN_ALIAS_RID_REPLICATOR    = 00000228h;


(***********************************************************************
**                                                                    **
**                          User and Group related SID attributes     **
**                                                                    **
***********************************************************************)

(*
** Group attributes
*)

CONST SE_GROUP_MANDATORY              = {0};     (* 00000001h *)
      SE_GROUP_ENABLED_BY_DEFAULT     = {1};     (* 00000002h *)
      SE_GROUP_ENABLED                = {2};     (* 00000004h *)
      SE_GROUP_OWNER                  = {3};     (* 00000008h *)
      SE_GROUP_LOGON_ID               = {31,30}; (* 0C0000000h *)

(*
** User attributes
*)

(* (None yet defined.) *)


(***********************************************************************
**                                                                    **
**                         ACL  and  ACE                              **
**                                                                    **
***********************************************************************)

(*
**  Define an ACL and the ACE format.  The structure of an ACL header
**  followed by one or more ACEs.  Pictorally the structure of an ACL header
**  is as follows:
**
**       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
**       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
**      +-------------------------------+---------------+---------------+
**      |            AclSize            |      Sbz1     |  AclRevision  |
**      +-------------------------------+---------------+---------------+
**      |              Sbz2             |           AceCount            |
**      +-------------------------------+-------------------------------+
**
**  The current AclRevision is defined to be ACL_REVISION.
**
**  AclSize is the size, in bytes, allocated for the ACL.  This includes
**  the ACL header, ACES, and remaining free space in the buffer.
**
**  AceCount is the number of ACES in the ACL.
*)


(* This is the *current* ACL revision *)

      ACL_REVISION     = 2;

(* This is the history of ACL revisions.  Add a new one whenever
** ACL_REVISION is updated
*)

      ACL_REVISION1   = 1;
      ACL_REVISION2   = 2;
      ACL_REVISION3   = 3;

TYPE ACL = RECORD
                  AclRevision : BYTE;
                  Sbz1        : BYTE;
                  AclSize     : WORD;
                  AceCount    : WORD;
                  Sbz2        : WORD;
           END;
    PACL = POINTER TO ACL;

(*
**  The structure of an ACE is a common ace header followed by ace type
**  specific data.  Pictorally the structure of the common ace header is
**  as follows:
**
**       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
**       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
**      +---------------+-------+-------+---------------+---------------+
**      |            AceSize            |    AceFlags   |     AceType   |
**      +---------------+-------+-------+---------------+---------------+
**
**  AceType denotes the type of the ace, there are some predefined ace
**  types
**
**  AceSize is the size, in bytes, of ace.
**
**  AceFlags are the Ace flags for audit and inheritance, defined shortly.
*)

(*
**  The following are the predefined ace types that go into the AceType
**  field of an Ace header.
*)

<* PUSH *> <* ENUMSIZE = "1" *>

TYPE ACE_TYPE_ENUM = (ACCESS_ALLOWED_ACE_TYPE, (* 0 *)
                      ACCESS_DENIED_ACE_TYPE,  (* 1 *)
                      SYSTEM_AUDIT_ACE_TYPE,   (* 2 *)
                      SYSTEM_ALARM_ACE_TYPE);  (* 3 *)

<* POP *>

(*
**  The following are the inherit flags that go into the AceFlags field
**  of an Ace header.
*)

TYPE ACE_FLAGS_ENUM = (OBJECT_INHERIT__ACE,       (* 0 *)
                       CONTAINER_INHERIT__ACE,    (* 1 *)
                       NO_PROPAGATE_INHERIT__ACE, (* 2 *)
                       INHERIT_ONLY__ACE,         (* 3 *)
                       ACE_FLAG__4,
                       ACE_FLAG__5,
                       SUCCESSFUL_ACCESS__ACE_FLAG, (* 6 *)
                       FAILED_ACCESS__ACE_FLAG);    (* 7 *)

<* PUSH *> <* SETSIZE = "1" *>

TYPE ACE_FLAGS_SET = SET OF ACE_FLAGS_ENUM;

<* POP *>

CONST OBJECT_INHERIT_ACE       = ACE_FLAGS_SET {OBJECT_INHERIT__ACE};       (* 1 *)
      CONTAINER_INHERIT_ACE    = ACE_FLAGS_SET {CONTAINER_INHERIT__ACE};    (* 2 *)
      NO_PROPAGATE_INHERIT_ACE = ACE_FLAGS_SET {NO_PROPAGATE_INHERIT__ACE}; (* 4 *)
      INHERIT_ONLY_ACE         = ACE_FLAGS_SET {INHERIT_ONLY__ACE};         (* 8 *)

      VALID_INHERIT_FLAGS      = OBJECT_INHERIT_ACE +
                                 CONTAINER_INHERIT_ACE +
                                 NO_PROPAGATE_INHERIT_ACE +
                                 INHERIT_ONLY_ACE;

(*  The following are the currently defined ACE flags that go into the
**  AceFlags field of an ACE header.  Each ACE type has its own set of
**  AceFlags.
**
**  SUCCESSFUL_ACCESS_ACE_FLAG - used only with system audit and alarm ACE
**  types to indicate that a message is generated for successful accesses.
**
**  FAILED_ACCESS_ACE_FLAG - used only with system audit and alarm ACE types
**  to indicate that a message is generated for failed accesses.
*)


(*
**  SYSTEM_AUDIT and SYSTEM_ALARM AceFlags
**
**  These control the signaling of audit and alarms for success or failure.
*)


CONST SUCCESSFUL_ACCESS_ACE_FLAG = ACE_FLAGS_SET {SUCCESSFUL_ACCESS__ACE_FLAG}; (* 40h *)
      FAILED_ACCESS_ACE_FLAG     = ACE_FLAGS_SET {FAILED_ACCESS__ACE_FLAG};     (* 80h *)

TYPE ACE_HEADER = RECORD
                         AceType  : ACE_TYPE_ENUM;
                         AceFlags : ACE_FLAGS_SET;
                         AceSize  : WORD;
                  END;
    PACE_HEADER = POINTER TO ACE_HEADER;

(*
**  We'll define the structure of the predefined ACE types.  Pictorally
**  the structure of the predefined ACE's is as follows:
**
**       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
**       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
**      +---------------+-------+-------+---------------+---------------+
**      |    AceFlags   | Resd  |Inherit|    AceSize    |     AceType   |
**      +---------------+-------+-------+---------------+---------------+
**      |                              Mask                             |
**      +---------------------------------------------------------------+
**      |                                                               |
**      +                                                               +
**      |                                                               |
**      +                              Sid                              +
**      |                                                               |
**      +                                                               +
**      |                                                               |
**      +---------------------------------------------------------------+
**
**  Mask is the access mask associated with the ACE.  This is either the
**  access allowed, access denied, audit, or alarm mask.
**
**  Sid is the Sid associated with the ACE.
*)

(*  The following are the four predefined ACE types.
**
**  Examine the AceType field in the Header to determine
**  which structure is appropriate to use for casting.
*)

TYPE ACCESS_ALLOWED_ACE = RECORD
                                 Header   : ACE_HEADER;
                                 Mask     : ACCESS_MASK;
                                 SidStart : DWORD;
                          END;
    PACCESS_ALLOWED_ACE = POINTER TO ACCESS_ALLOWED_ACE;

TYPE ACCESS_DENIED_ACE = RECORD
                                Header   : ACE_HEADER;
                                Mask     : ACCESS_MASK;
                                SidStart : DWORD;
                         END;
    PACCESS_DENIED_ACE = POINTER TO ACCESS_DENIED_ACE;

TYPE SYSTEM_AUDIT_ACE = RECORD
                               Header   : ACE_HEADER;
                               Mask     : ACCESS_MASK;
                               SidStart : DWORD;
                        END;
    PSYSTEM_AUDIT_ACE = POINTER TO SYSTEM_AUDIT_ACE;

TYPE SYSTEM_ALARM_ACE = RECORD
                               Header   : ACE_HEADER;
                               Mask     : ACCESS_MASK;
                               SidStart : DWORD;
                        END;
    PSYSTEM_ALARM_ACE = POINTER TO SYSTEM_ALARM_ACE;

(*
**  The following declarations are used for setting and querying information
**  about and ACL.  First are the various information classes available to
**  the user.
*)

TYPE ACL_INFORMATION_CLASS = (ACL_INFORMATION_0,
                              AclRevisionInformation,
                              AclSizeInformation);

(*
**  This record is returned/sent if the user is requesting/setting the
**  AclRevisionInformation
*)

TYPE ACL_REVISION_INFORMATION = RECORD
                                       AclRevision : DWORD;
                                END;
    PACL_REVISION_INFORMATION = POINTER TO ACL_REVISION_INFORMATION;

(*
**  This record is returned if the user is requesting AclSizeInformation
*)

TYPE ACL_SIZE_INFORMATION = RECORD
                                   AceCount      : DWORD;
                                   AclBytesInUse : DWORD;
                                   AclBytesFree  : DWORD;
                            END;
    PACL_SIZE_INFORMATION = POINTER TO ACL_SIZE_INFORMATION;

(***********************************************************************
**                                                                    **
**                             SECURITY_DESCRIPTOR                    **
**                                                                    **
************************************************************************
**
**  Define the Security Descriptor and related data types.
**  This is an opaque data structure.
*)


(*
** Current security descriptor revision value
*)


CONST SECURITY_DESCRIPTOR_REVISION  = 1;
      SECURITY_DESCRIPTOR_REVISION1 = 1;

(*
** Minimum length, in bytes, needed to build a security descriptor
** (NOTE: This must manually be kept consistent with the)
** sizeof(SECURITY_DESCRIPTOR)
*)

      SECURITY_DESCRIPTOR_MIN_LENGTH   = 20;


TYPE SECURITY_DESCRIPTOR_CONTROL  = WORD;
TYPE PSECURITY_DESCRIPTOR_CONTROL = POINTER TO SECURITY_DESCRIPTOR_CONTROL;

CONST SE_OWNER_DEFAULTED  = {0};  (* 0001h *)
      SE_GROUP_DEFAULTED  = {1};  (* 0002h *)
      SE_DACL_PRESENT     = {2};  (* 0004h *)
      SE_DACL_DEFAULTED   = {3};  (* 0008h *)
      SE_SACL_PRESENT     = {4};  (* 0010h *)
      SE_SACL_DEFAULTED   = {5};  (* 0020h *)
      SE_SELF_RELATIVE    = {15}; (* 8000h *)

(*
**  Where:
**
**      SE_OWNER_DEFAULTED - This boolean flag, when set, indicates that the
**          SID pointed to by the Owner field was provided by a
**          defaulting mechanism rather than explicitly provided by the
**          original provider of the security descriptor.  This may
**          affect the treatment of the SID with respect to inheritence
**          of an owner.
**
**      SE_GROUP_DEFAULTED - This boolean flag, when set, indicates that the
**          SID in the Group field was provided by a defaulting mechanism
**          rather than explicitly provided by the original provider of
**          the security descriptor.  This may affect the treatment of
**          the SID with respect to inheritence of a primary group.
**
**      SE_DACL_PRESENT - This boolean flag, when set, indicates that the
**          security descriptor contains a discretionary ACL.  If this
**          flag is set and the Dacl field of the SECURITY_DESCRIPTOR is
**          null, then a null ACL is explicitly being specified.
**
**      SE_DACL_DEFAULTED - This boolean flag, when set, indicates that the
**          ACL pointed to by the Dacl field was provided by a defaulting
**          mechanism rather than explicitly provided by the original
**          provider of the security descriptor.  This may affect the
**          treatment of the ACL with respect to inheritence of an ACL.
**          This flag is ignored if the DaclPresent flag is not set.
**
**      SE_SACL_PRESENT - This boolean flag, when set,  indicates that the
**          security descriptor contains a system ACL pointed to by the
**          Sacl field.  If this flag is set and the Sacl field of the
**          SECURITY_DESCRIPTOR is null, then an empty (but present)
**          ACL is being specified.
**
**      SE_SACL_DEFAULTED - This boolean flag, when set, indicates that the
**          ACL pointed to by the Sacl field was provided by a defaulting
**          mechanism rather than explicitly provided by the original
**          provider of the security descriptor.  This may affect the
**          treatment of the ACL with respect to inheritence of an ACL.
**          This flag is ignored if the SaclPresent flag is not set.
**
**      SE_SELF_RELATIVE - This boolean flag, when set, indicates that the
**          security descriptor is in self-relative form.  In this form,
**          all fields of the security descriptor are contiguous in memory
**          and all pointer fields are expressed as offsets from the
**          beginning of the security descriptor.  This form is useful
**          for treating security descriptors as opaque data structures
**          for transmission in communication protocol or for storage on
**          secondary media.
**
**
**
** Pictorially the structure of a security descriptor is as follows:
**
**       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
**       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
**      +---------------------------------------------------------------+
**      |            Control            |Reserved1 (SBZ)|   Revision    |
**      +---------------------------------------------------------------+
**      |                            Owner                              |
**      +---------------------------------------------------------------+
**      |                            Group                              |
**      +---------------------------------------------------------------+
**      |                            Sacl                               |
**      +---------------------------------------------------------------+
**      |                            Dacl                               |
**      +---------------------------------------------------------------+
**
** In general, this data structure should be treated opaquely to ensure future
** compatibility.
**
*)

TYPE SECURITY_DESCRIPTOR = RECORD
                                  Revision : BYTE;
                                  Sbz1     : BYTE;
                                  Control  : SECURITY_DESCRIPTOR_CONTROL;
                                  Owner    : PSID;
                                  Group    : PSID;
                                  Sacl     : PACL;
                                  Dacl     : PACL;
                           END;

    PISECURITY_DESCRIPTOR = POINTER TO SECURITY_DESCRIPTOR;

(* Where:
**
**     Revision - Contains the revision level of the security
**         descriptor.  This allows this structure to be passed between
**         systems or stored on disk even though it is expected to
**         change in the future.
**
**     Control - A set of flags which qualify the meaning of the
**         security descriptor or individual fields of the security
**         descriptor.
**
**     Owner - is a pointer to an SID representing an object's owner.
**         If this field is null, then no owner SID is present in the
**         security descriptor.  If the security descriptor is in
**         self-relative form, then this field contains an offset to
**         the SID, rather than a pointer.
**
**     Group - is a pointer to an SID representing an object's primary
**         group.  If this field is null, then no primary group SID is
**         present in the security descriptor.  If the security descriptor
**         is in self-relative form, then this field contains an offset to
**         the SID, rather than a pointer.
**
**     Sacl - is a pointer to a system ACL.  This field value is only
**         valid if the DaclPresent control flag is set.  If the
**         SaclPresent flag is set and this field is null, then a null
**         ACL  is specified.  If the security descriptor is in
**         self-relative form, then this field contains an offset to
**         the ACL, rather than a pointer.
**
**     Dacl - is a pointer to a discretionary ACL.  This field value is
**         only valid if the DaclPresent control flag is set.  If the
**         DaclPresent flag is set and this field is null, then a null
**         ACL (unconditionally granting access) is specified.  If the
**         security descriptor is in self-relative form, then this field
**         contains an offset to the ACL, rather than a pointer.
*)

(***********************************************************************
**                                                                    **
**               Privilege Related Data Structures                    **
**                                                                    **
***********************************************************************)

(*
** Privilege attributes
*)

CONST SE_PRIVILEGE_ENABLED_BY_DEFAULT = { 0}; (* 00000001h *)
      SE_PRIVILEGE_ENABLED            = { 1}; (* 00000002h *)
      SE_PRIVILEGE_USED_FOR_ACCESS    = {31}; (* 80000000h *)

(*
** Privilege Set Control flags
*)


      PRIVILEGE_SET_ALL_NECESSARY    = 1;

(*
**  Privilege Set - This is defined for a privilege set of one.
**                  If more than one privilege is needed, then this structure
**                  will need to be allocated with more space.
**
**  Note: don't change this structure without fixing the INITIAL_PRIVILEGE_SET
**  structure (defined in se.h)
*)


TYPE PRIVILEGE_SET = RECORD
                            PrivilegeCount : DWORD;
                            Control        : DWORD;
                            Privilege      : ARRAY [0..0] OF LUID_AND_ATTRIBUTES;
                     END;
    PPRIVILEGE_SET = POINTER TO  PRIVILEGE_SET;


(***********************************************************************
**                                                                    **
**               NT Defined Privileges                                **
**                                                                    **
***********************************************************************)

(* All following texts should be redefined for UNICODE case *)

CONST SE_CREATE_TOKEN_NAME              = "SeCreateTokenPrivilege";
      SE_ASSIGNPRIMARYTOKEN_NAME        = "SeAssignPrimaryTokenPrivilege";
      SE_LOCK_MEMORY_NAME               = "SeLockMemoryPrivilege";
      SE_INCREASE_QUOTA_NAME            = "SeIncreaseQuotaPrivilege";
      SE_UNSOLICITED_INPUT_NAME         = "SeUnsolicitedInputPrivilege";
      SE_MACHINE_ACCOUNT_NAME           = "SeMachineAccountPrivilege";
      SE_TCB_NAME                       = "SeTcbPrivilege";
      SE_SECURITY_NAME                  = "SeSecurityPrivilege";
      SE_TAKE_OWNERSHIP_NAME            = "SeTakeOwnershipPrivilege";
      SE_LOAD_DRIVER_NAME               = "SeLoadDriverPrivilege";
      SE_SYSTEM_PROFILE_NAME            = "SeSystemProfilePrivilege";
      SE_SYSTEMTIME_NAME                = "SeSystemtimePrivilege";
      SE_PROF_SINGLE_PROCESS_NAME       = "SeProfileSingleProcessPrivilege";
      SE_INC_BASE_PRIORITY_NAME         = "SeIncreaseBasePriorityPrivilege";
      SE_CREATE_PAGEFILE_NAME           = "SeCreatePagefilePrivilege";
      SE_CREATE_PERMANENT_NAME          = "SeCreatePermanentPrivilege";
      SE_BACKUP_NAME                    = "SeBackupPrivilege";
      SE_RESTORE_NAME                   = "SeRestorePrivilege";
      SE_SHUTDOWN_NAME                  = "SeShutdownPrivilege";
      SE_DEBUG_NAME                     = "SeDebugPrivilege";
      SE_AUDIT_NAME                     = "SeAuditPrivilege";
      SE_SYSTEM_ENVIRONMENT_NAME        = "SeSystemEnvironmentPrivilege";
      SE_CHANGE_NOTIFY_NAME             = "SeChangeNotifyPrivilege";
      SE_REMOTE_SHUTDOWN_NAME           = "SeRemoteShutdownPrivilege";


(*******************************************************************
**                                                                **
**           Security Quality Of Service                          **
**                                                                **
*******************************************************************)


(*
** Impersonation Level
**
** Impersonation level is represented by a pair of bits in Windows.
** If a new impersonation level is added or lowest value is changed from
** 0 to something else, fix the Windows CreateFile call.
*)


TYPE SECURITY_IMPERSONATION_LEVEL = (SecurityAnonymous,
                                     SecurityIdentification,
                                     SecurityImpersonation,
                                     SecurityDelegation);
     PSECURITY_IMPERSONATION_LEVEL = POINTER TO SECURITY_IMPERSONATION_LEVEL;

CONST SECURITY_MAX_IMPERSONATION_LEVEL = SecurityDelegation;
      DEFAULT_IMPERSONATION_LEVEL      = SecurityImpersonation;


(*******************************************************************
**                                                                **
**           Token Object Definitions                             **
**                                                                **
*******************************************************************)

(*
** Token Specific Access Rights.
*)


CONST TOKEN_ASSIGN_PRIMARY    = ACCESS_MASK {ACCESS_0}; (* 0x0001 *)
      TOKEN_DUPLICATE         = ACCESS_MASK {ACCESS_1}; (* 0x0002 *)
      TOKEN_IMPERSONATE       = ACCESS_MASK {ACCESS_2}; (* 0x0004 *)
      TOKEN_QUERY             = ACCESS_MASK {ACCESS_3}; (* 0x0008 *)
      TOKEN_QUERY_SOURCE      = ACCESS_MASK {ACCESS_4}; (* 0x0010 *)
      TOKEN_ADJUST_PRIVILEGES = ACCESS_MASK {ACCESS_5}; (* 0x0020 *)
      TOKEN_ADJUST_GROUPS     = ACCESS_MASK {ACCESS_6}; (* 0x0040 *)
      TOKEN_ADJUST_DEFAULT    = ACCESS_MASK {ACCESS_7}; (* 0x0080 *)

      TOKEN_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED+
                         TOKEN_ASSIGN_PRIMARY +
                         TOKEN_DUPLICATE +
                         TOKEN_IMPERSONATE +
                         TOKEN_QUERY +
                         TOKEN_QUERY_SOURCE +
                         TOKEN_ADJUST_PRIVILEGES +
                         TOKEN_ADJUST_GROUPS +
                         TOKEN_ADJUST_DEFAULT;

      TOKEN_READ       = STANDARD_RIGHTS_READ +
                         TOKEN_QUERY;

      TOKEN_WRITE      = STANDARD_RIGHTS_WRITE +
                         TOKEN_ADJUST_PRIVILEGES +
                         TOKEN_ADJUST_GROUPS +
                         TOKEN_ADJUST_DEFAULT;

      TOKEN_EXECUTE    = STANDARD_RIGHTS_EXECUTE;


(*
** Token Types
*)

TYPE TOKEN_TYPE = (TOKEN_0,
                   TokenPrimary,
                   TokenImpersonation);
    PTOKEN_TYPE = POINTER TO TOKEN_TYPE;

(*
** Token Information Classes.
*)

TYPE TOKEN_INFORMATION_CLASS = (TOKEN_INFORMATION_0,
                                TokenUser,
                                TokenGroups,
                                TokenPrivileges,
                                TokenOwner,
                                TokenPrimaryGroup,
                                TokenDefaultDacl,
                                TokenSource,
                                TokenType,
                                TokenImpersonationLevel,
                                TokenStatistics);

     PTOKEN_INFORMATION_CLASS = POINTER TO TOKEN_INFORMATION_CLASS;

(*
** Token information class structures
*)

TYPE TOKEN_USER = RECORD
                         User : SID_AND_ATTRIBUTES;
                  END;
    PTOKEN_USER = POINTER TO TOKEN_USER;

TYPE TOKEN_GROUPS = RECORD
                           GroupCount : DWORD;
                           Groups     : ARRAY [0..0] OF SID_AND_ATTRIBUTES;
                    END;
    PTOKEN_GROUPS = POINTER TO TOKEN_GROUPS;

TYPE TOKEN_PRIVILEGES = RECORD
                               PrivilegeCount : DWORD;
                               Privileges     : ARRAY [0..0] OF LUID_AND_ATTRIBUTES;
                        END;
    PTOKEN_PRIVILEGES = POINTER TO TOKEN_PRIVILEGES;


TYPE TOKEN_OWNER = RECORD
                          Owner : PSID;
                   END;
    PTOKEN_OWNER = POINTER TO TOKEN_OWNER;

TYPE TOKEN_PRIMARY_GROUP = RECORD
                                  PrimaryGroup : PSID;
                           END;
    PTOKEN_PRIMARY_GROUP = POINTER TO TOKEN_PRIMARY_GROUP;

TYPE TOKEN_DEFAULT_DACL = RECORD
                                 DefaultDacl : PACL;
                          END;
    PTOKEN_DEFAULT_DACL = POINTER TO TOKEN_DEFAULT_DACL;

CONST TOKEN_SOURCE_LENGTH = 8;

TYPE TOKEN_SOURCE = RECORD
                           SourceName       : ARRAY [0..TOKEN_SOURCE_LENGTH-1] OF CHAR;
                           SourceIdentifier : LUID;
                    END;
    PTOKEN_SOURCE = POINTER TO TOKEN_SOURCE;

TYPE TOKEN_STATISTICS = RECORD
                               TokenId            : LUID;
                               AuthenticationId   : LUID;
                               ExpirationTime     : LARGE_INTEGER;
                               TokenType          : TOKEN_TYPE;
                               ImpersonationLevel : SECURITY_IMPERSONATION_LEVEL;
                               DynamicCharged     : DWORD;
                               DynamicAvailable   : DWORD;
                               GroupCount         : DWORD;
                               PrivilegeCount     : DWORD;
                               ModifiedId         : LUID;
                        END;
    PTOKEN_STATISTICS = POINTER TO TOKEN_STATISTICS;

TYPE TOKEN_CONTROL = RECORD
                            TokenId          : LUID;
                            AuthenticationId : LUID;
                            ModifiedId       : LUID;
                            TokenSource      : TOKEN_SOURCE;
                     END;
    PTOKEN_CONTROL = POINTER TO TOKEN_CONTROL;

(*
** Security Tracking Mode
*)


TYPE SECURITY_CONTEXT_TRACKING_MODE = BOOL8;
    PSECURITY_CONTEXT_TRACKING_MODE = POINTER TO SECURITY_CONTEXT_TRACKING_MODE;

CONST SECURITY_DYNAMIC_TRACKING = VAL (SECURITY_CONTEXT_TRACKING_MODE, 1);
      SECURITY_STATIC_TRACKING  = VAL (SECURITY_CONTEXT_TRACKING_MODE, 0);


(*
** Quality Of Service
*)

TYPE SECURITY_QUALITY_OF_SERVICE =
     RECORD
            Length              : DWORD;
            ImpersonationLevel  : SECURITY_IMPERSONATION_LEVEL;
            ContextTrackingMode : SECURITY_CONTEXT_TRACKING_MODE;
            EffectiveOnly       : BOOL8;
     END;
     PSECURITY_QUALITY_OF_SERVICE = POINTER TO SECURITY_QUALITY_OF_SERVICE;

(*
** Used to represent information related to a thread impersonation
*)


TYPE SE_IMPERSONATION_STATE =
     RECORD
            Token         : PACCESS_TOKEN;
            CopyOnOpen    : BOOL8;
            EffectiveOnly : BOOL8;
            Level         : SECURITY_IMPERSONATION_LEVEL;
     END;
     PSE_IMPERSONATION_STATE = POINTER TO SE_IMPERSONATION_STATE;


TYPE SECURITY_INFORMATION_ENUM = (SECURITY_INFORMATION_0,
                                  SECURITY_INFORMATION_1,
                                  SECURITY_INFORMATION_2,
                                  SECURITY_INFORMATION_3);
     SECURITY_INFORMATION = SET OF SECURITY_INFORMATION_ENUM;
    PSECURITY_INFORMATION = POINTER TO SECURITY_INFORMATION;

CONST OWNER_SECURITY_INFORMATION = SECURITY_INFORMATION {SECURITY_INFORMATION_0}; (* 0x00000001L *)
      GROUP_SECURITY_INFORMATION = SECURITY_INFORMATION {SECURITY_INFORMATION_1}; (* 0x00000002L *)
      DACL_SECURITY_INFORMATION  = SECURITY_INFORMATION {SECURITY_INFORMATION_2}; (* 0x00000004L *)
      SACL_SECURITY_INFORMATION  = SECURITY_INFORMATION {SECURITY_INFORMATION_3}; (* 0x00000008L *)


(*
** Image Format
*)

<* PUSH *> <* ALIGNMENT = "4" *>                (* 4 byte packing is the default *)

CONST IMAGE_DOS_SIGNATURE                 = 5A4Dh;      (* MZ *)
      IMAGE_OS2_SIGNATURE                 = 454Eh;      (* NE *)
      IMAGE_OS2_SIGNATURE_LE              = 454Ch;      (* LE *)
      IMAGE_VXD_SIGNATURE                 = 454Ch;      (* LE *)
      IMAGE_NT_SIGNATURE                  = 00004550h;  (* PE00 *)

<* PUSH *> <* ALIGNMENT = "2" *>                (* 16 bit headers are 2 byte packed *)

TYPE IMAGE_DOS_HEADER =
     RECORD                                     (* DOS .EXE header *)
            e_magic    : WORD;                  (* Magic number *)
            e_cblp     : WORD;                  (* Bytes on last page of file *)
            e_cp       : WORD;                  (* Pages in file *)
            e_crlc     : WORD;                  (* Relocations *)
            e_cparhdr  : WORD;                  (* Size of header in paragraphs *)
            e_minalloc : WORD;                  (* Minimum extra paragraphs needed *)
            e_maxalloc : WORD;                  (* Maximum extra paragraphs needed *)
            e_ss       : WORD;                  (* Initial (relative) SS value *)
            e_sp       : WORD;                  (* Initial SP value *)
            e_csum     : WORD;                  (* Checksum *)
            e_ip       : WORD;                  (* Initial IP value *)
            e_cs       : WORD;                  (* Initial (relative) CS value *)
            e_lfarlc   : WORD;                  (* File address of relocation table *)
            e_ovno     : WORD;                  (* Overlay number *)
            e_res      : ARRAY [0..3] OF WORD;  (* Reserved words *)
            e_oemid    : WORD;                  (* OEM identifier (for e_oeminfo) *)
            e_oeminfo  : WORD;                  (* OEM information; e_oemid specific *)
            e_res2     : ARRAY [0..9] OF WORD;  (* Reserved words *)
            e_lfanew   : LONG;                  (* File address of new exe header *)
     END;
     PIMAGE_DOS_HEADER = POINTER TO IMAGE_DOS_HEADER;

TYPE IMAGE_OS2_HEADER =
     RECORD                                 (* OS/2 .EXE header *)
            ne_magic        : WORD;         (* Magic number *)
            ne_ver          : CHAR;         (* Version number *)
            ne_rev          : CHAR;         (* Revision number *)
            ne_enttab       : WORD;         (* Offset of Entry Table *)
            ne_cbenttab     : WORD;         (* Number of bytes in Entry Table *)
            ne_crc          : LONG;         (* Checksum of whole file *)
            ne_flags        : WORD;         (* Flag word *)
            ne_autodata     : WORD;         (* Automatic data segment number *)
            ne_heap         : WORD;         (* Initial heap allocation *)
            ne_stack        : WORD;         (* Initial stack allocation *)
            ne_csip         : LONG;         (* Initial CS:IP setting *)
            ne_sssp         : LONG;         (* Initial SS:SP setting *)
            ne_cseg         : WORD;         (* Count of file segments *)
            ne_cmod         : WORD;         (* Entries in Module Reference Table *)
            ne_cbnrestab    : WORD;         (* Size of non-resident name table *)
            ne_segtab       : WORD;         (* Offset of Segment Table *)
            ne_rsrctab      : WORD;         (* Offset of Resource Table *)
            ne_restab       : WORD;         (* Offset of resident name table *)
            ne_modtab       : WORD;         (* Offset of Module Reference Table *)
            ne_imptab       : WORD;         (* Offset of Imported Names Table *)
            ne_nrestab      : LONG;         (* Offset of Non-resident Names Table *)
            ne_cmovent      : WORD;         (* Count of movable entries *)
            ne_align        : WORD;         (* Segment alignment shift count *)
            ne_cres         : WORD;         (* Count of resource segments *)
            ne_exetyp       : BYTE;         (* Target Operating system *)
            ne_flagsothers  : BYTE;         (* Other .EXE flags *)
            ne_pretthunks   : WORD;         (* offset to return thunks *)
            ne_psegrefbytes : WORD;         (* offset to segment ref. bytes *)
            ne_swaparea     : WORD;         (* Minimum code swap area size *)
            ne_expver       : WORD;         (* Expected Windows version number *)
     END;
     PIMAGE_OS2_HEADER = POINTER TO IMAGE_OS2_HEADER;

TYPE IMAGE_VXD_HEADER =
     RECORD                                           (* Windows VXD header *)
            e32_magic        : WORD;                  (* Magic number *)
            e32_border       : BYTE;                  (* The byte ordering for the VXD *)
            e32_worder       : BYTE;                  (* The word ordering for the VXD *)
            e32_level        : DWORD;                 (* The EXE format level for now = 0 *)
            e32_cpu          : WORD;                  (* The CPU type *)
            e32_os           : WORD;                  (* The OS type *)
            e32_ver          : DWORD;                 (* Module version *)
            e32_mflags       : DWORD;                 (* Module flags *)
            e32_mpages       : DWORD;                 (* Module # pages *)
            e32_startobj     : DWORD;                 (* Object # for instruction pointer *)
            e32_eip          : DWORD;                 (* Extended instruction pointer *)
            e32_stackobj     : DWORD;                 (* Object # for stack pointer *)
            e32_esp          : DWORD;                 (* Extended stack pointer *)
            e32_pagesize     : DWORD;                 (* VXD page size *)
            e32_lastpagesize : DWORD;                 (* Last page size in VXD *)
            e32_fixupsize    : DWORD;                 (* Fixup section size *)
            e32_fixupsum     : DWORD;                 (* Fixup section checksum *)
            e32_ldrsize      : DWORD;                 (* Loader section size *)
            e32_ldrsum       : DWORD;                 (* Loader section checksum *)
            e32_objtab       : DWORD;                 (* Object table offset *)
            e32_objcnt       : DWORD;                 (* Number of objects in module *)
            e32_objmap       : DWORD;                 (* Object page map offset *)
            e32_itermap      : DWORD;                 (* Object iterated data map offset *)
            e32_rsrctab      : DWORD;                 (* Offset of Resource Table *)
            e32_rsrccnt      : DWORD;                 (* Number of resource entries *)
            e32_restab       : DWORD;                 (* Offset of resident name table *)
            e32_enttab       : DWORD;                 (* Offset of Entry Table *)
            e32_dirtab       : DWORD;                 (* Offset of Module Directive Table *)
            e32_dircnt       : DWORD;                 (* Number of module directives *)
            e32_fpagetab     : DWORD;                 (* Offset of Fixup Page Table *)
            e32_frectab      : DWORD;                 (* Offset of Fixup Record Table *)
            e32_impmod       : DWORD;                 (* Offset of Import Module Name Table *)
            e32_impmodcnt    : DWORD;                 (* Number of entries in Import Module Name Table *)
            e32_impproc      : DWORD;                 (* Offset of Import Procedure Name Table *)
            e32_pagesum      : DWORD;                 (* Offset of Per-Page Checksum Table *)
            e32_datapage     : DWORD;                 (* Offset of Enumerated Data Pages *)
            e32_preload      : DWORD;                 (* Number of preload pages *)
            e32_nrestab      : DWORD;                 (* Offset of Non-resident Names Table *)
            e32_cbnrestab    : DWORD;                 (* Size of Non-resident Name Table *)
            e32_nressum      : DWORD;                 (* Non-resident Name Table Checksum *)
            e32_autodata     : DWORD;                 (* Object # for automatic data object *)
            e32_debuginfo    : DWORD;                 (* Offset of the debugging information *)
            e32_debuglen     : DWORD;                 (* The length of the debugging info. in bytes *)
            e32_instpreload  : DWORD;                 (* Number of instance pages in preload section of VXD file *)
            e32_instdemand   : DWORD;                 (* Number of instance pages in demand load section of VXD file *)
            e32_heapsize     : DWORD;                 (* Size of heap - for 16-bit apps *)
            e32_res3         : ARRAY [0..11] OF BYTE; (* Reserved words *)
            e32_winresoff    : DWORD;
            e32_winreslen    : DWORD;
            e32_devid        : WORD;                  (* Device ID for VxD *)
            e32_ddkver       : WORD;                  (* DDK version for VxD *)
     END;
     PIMAGE_VXD_HEADER = POINTER TO IMAGE_VXD_HEADER;

<* POP *> (* Back to 4 byte packing *)

(*
** File header format.
*)

(* Characteristics field bits *)

TYPE IMAGE_FILE_ENUM = (IMAGE_FILE__RELOCS_STRIPPED,     (*  0 -  Relocation info stripped from file. *)
                        IMAGE_FILE__EXECUTABLE_IMAGE,    (*  1 - File is executable  (i.e. no unresolved externel references). *)
                        IMAGE_FILE__LINE_NUMS_STRIPPED,  (*  2 - Line nunbers stripped from file. *)
                        IMAGE_FILE__LOCAL_SYMS_STRIPPED, (*  3 - Local symbols stripped from file. *)
                        IMAGE_FILE__4,
                        IMAGE_FILE__5,
                        IMAGE_FILE__6,
                        IMAGE_FILE__BYTES_REVERSED_LO,   (*  7 - Bytes of machine word are reversed. *)
                        IMAGE_FILE__32BIT_MACHINE,       (*  8 - 32 bit word machine. *)
                        IMAGE_FILE__DEBUG_STRIPPED,      (*  9 - Debugging info stripped from file in .DBG file *)
                        IMAGE_FILE__10,
                        IMAGE_FILE__11,
                        IMAGE_FILE__SYSTEM,              (* 12 - System File. *)
                        IMAGE_FILE__DLL,                 (* 13 - File is a DLL. *)
                        IMAGE_FILE__14,
                        IMAGE_FILE__BYTES_REVERSED_HI);  (* 15 - Bytes of machine word are reversed. *)

<* PUSH *> <* SETSIZE = "2" *>

TYPE IMAGE_FILE_FLAGS = SET OF IMAGE_FILE_ENUM;

<* POP *>

CONST IMAGE_FILE_RELOCS_STRIPPED     = IMAGE_FILE_FLAGS {IMAGE_FILE__RELOCS_STRIPPED};     (* 0001h - Relocation info stripped from file. *)
      IMAGE_FILE_EXECUTABLE_IMAGE    = IMAGE_FILE_FLAGS {IMAGE_FILE__EXECUTABLE_IMAGE};    (* 0002h - File is executable  (i.e. no unresolved externel references). *)
      IMAGE_FILE_LINE_NUMS_STRIPPED  = IMAGE_FILE_FLAGS {IMAGE_FILE__LINE_NUMS_STRIPPED};  (* 0004h - Line nunbers stripped from file. *)
      IMAGE_FILE_LOCAL_SYMS_STRIPPED = IMAGE_FILE_FLAGS {IMAGE_FILE__LOCAL_SYMS_STRIPPED}; (* 0008h - Local symbols stripped from file. *)
      IMAGE_FILE_BYTES_REVERSED_LO   = IMAGE_FILE_FLAGS {IMAGE_FILE__BYTES_REVERSED_LO};   (* 0080h - Bytes of machine word are reversed. *)
      IMAGE_FILE_32BIT_MACHINE       = IMAGE_FILE_FLAGS {IMAGE_FILE__32BIT_MACHINE};       (* 0100h - 32 bit word machine. *)
      IMAGE_FILE_DEBUG_STRIPPED      = IMAGE_FILE_FLAGS {IMAGE_FILE__DEBUG_STRIPPED};      (* 0200h - Debugging info stripped from file in .DBG file *)
      IMAGE_FILE_SYSTEM              = IMAGE_FILE_FLAGS {IMAGE_FILE__SYSTEM};              (* 1000h - System File. *)
      IMAGE_FILE_DLL                 = IMAGE_FILE_FLAGS {IMAGE_FILE__DLL};                 (* 2000h - File is a DLL. *)
      IMAGE_FILE_BYTES_REVERSED_HI   = IMAGE_FILE_FLAGS {IMAGE_FILE__BYTES_REVERSED_HI};   (* 8000h - Bytes of machine word are reversed. *)

TYPE IMAGE_FILE_MACHINE_TYPE = WORD;

TYPE IMAGE_FILE_HEADER = RECORD
                                Machine              : IMAGE_FILE_MACHINE_TYPE;
                                NumberOfSections     : WORD;
                                TimeDateStamp        : DWORD;
                                PointerToSymbolTable : DWORD;
                                NumberOfSymbols      : DWORD;
                                SizeOfOptionalHeader : WORD;
                                Characteristics      : IMAGE_FILE_FLAGS;
                         END;
    PIMAGE_FILE_HEADER = POINTER TO IMAGE_FILE_HEADER;

CONST IMAGE_SIZEOF_FILE_HEADER             = 20;

CONST IMAGE_FILE_MACHINE_UNKNOWN           = VAL (IMAGE_FILE_MACHINE_TYPE, 0);
      IMAGE_FILE_MACHINE_I386              = VAL (IMAGE_FILE_MACHINE_TYPE, 14ch);   (* Intel 386. *)
      IMAGE_FILE_MACHINE_R3000             = VAL (IMAGE_FILE_MACHINE_TYPE, 162h);   (* MIPS little-endian, 160h big-endian *)
      IMAGE_FILE_MACHINE_R4000             = VAL (IMAGE_FILE_MACHINE_TYPE, 166h);   (* MIPS little-endian *)
      IMAGE_FILE_MACHINE_R10000            = VAL (IMAGE_FILE_MACHINE_TYPE, 168h);   (* MIPS little-endian *)
      IMAGE_FILE_MACHINE_ALPHA             = VAL (IMAGE_FILE_MACHINE_TYPE, 184h);   (* Alpha_AXP *)
      IMAGE_FILE_MACHINE_POWERPC           = VAL (IMAGE_FILE_MACHINE_TYPE, 1F0h);   (* IBM PowerPC Little-Endian *)

(*
** Directory format.
*)

TYPE IMAGE_DATA_DIRECTORY = RECORD
                                   VirtualAddress : DWORD;
                                   Size : DWORD;
                            END;
    PIMAGE_DATA_DIRECTORY = POINTER TO IMAGE_DATA_DIRECTORY;

CONST IMAGE_NUMBEROF_DIRECTORY_ENTRIES = 16;

(*
** Optional header format.
*)

(* Subsystem Values *)

<* PUSH *> <* ENUMSIZE = "2" *>

TYPE IMAGE_SUBSYSTEM_ENUM = (IMAGE_SUBSYSTEM_UNKNOWN,     (* 0 - Unknown subsystem. *)
                             IMAGE_SUBSYSTEM_NATIVE,      (* 1 - Image doesn't require a subsystem. *)
                             IMAGE_SUBSYSTEM_WINDOWS_GUI, (* 2 - Image runs in the Windows GUI subsystem. *)
                             IMAGE_SUBSYSTEM_WINDOWS_CUI, (* 3 - Image runs in the Windows character subsystem. *)
                             IMAGE_SUBSYSTEM_OS2_CUI,     (* 5 - image runs in the OS/2 character subsystem. *)
                             IMAGE_SUBSYSTEM_POSIX_CUI);  (* 7 - image run  in the Posix character subsystem. *)

<* POP *>

TYPE IMAGE_OPTIONAL_HEADER =
     RECORD

    (*
    ** Standard fields.
    *)

            Magic                   : WORD;
            MajorLinkerVersion      : BYTE;
            MinorLinkerVersion      : BYTE;
            SizeOfCode              : DWORD;
            SizeOfInitializedData   : DWORD;
            SizeOfUninitializedData : DWORD;
            AddressOfEntryPoint     : DWORD;
            BaseOfCode              : DWORD;
            BaseOfData              : DWORD;

    (*
    ** NT additional fields.
    *)

            ImageBase                   : DWORD;
            SectionAlignment            : DWORD;
            FileAlignment               : DWORD;
            MajorOperatingSystemVersion : WORD;
            MinorOperatingSystemVersion : WORD;
            MajorImageVersion           : WORD;
            MinorImageVersion           : WORD;
            MajorSubsystemVersion       : WORD;
            MinorSubsystemVersion       : WORD;
            Win32VersionValue           : DWORD;
            SizeOfImage                 : DWORD;
            SizeOfHeaders               : DWORD;
            CheckSum                    : DWORD;
            Subsystem                   : IMAGE_SUBSYSTEM_ENUM;
            DllCharacteristics          : WORD;
            SizeOfStackReserve          : DWORD;
            SizeOfStackCommit           : DWORD;
            SizeOfHeapReserve           : DWORD;
            SizeOfHeapCommit            : DWORD;
            LoaderFlags                 : DWORD;
            NumberOfRvaAndSizes         : DWORD;
            DataDirectory : ARRAY [0..IMAGE_NUMBEROF_DIRECTORY_ENTRIES-1]
                            OF IMAGE_DATA_DIRECTORY;
       END;
       PIMAGE_OPTIONAL_HEADER = POINTER TO IMAGE_OPTIONAL_HEADER;

TYPE IMAGE_ROM_OPTIONAL_HEADER =
     RECORD
            Magic                   : WORD;
            MajorLinkerVersion      : BYTE;
            MinorLinkerVersion      : BYTE;
            SizeOfCode              : DWORD;
            SizeOfInitializedData   : DWORD;
            SizeOfUninitializedData : DWORD;
            AddressOfEntryPoint     : DWORD;
            BaseOfCode              : DWORD;
            BaseOfData              : DWORD;
            BaseOfBss               : DWORD;
            GprMask                 : DWORD;
            CprMask                 : ARRAY [0..3] OF DWORD;
            GpValue                 : DWORD;
     END;
    PIMAGE_ROM_OPTIONAL_HEADER = POINTER TO IMAGE_ROM_OPTIONAL_HEADER;

CONST IMAGE_SIZEOF_ROM_OPTIONAL_HEADER      =   56;
      IMAGE_SIZEOF_STD_OPTIONAL_HEADER      =   28;
      IMAGE_SIZEOF_NT_OPTIONAL_HEADER       =  224;

      IMAGE_NT_OPTIONAL_HDR_MAGIC           = 10bh;
      IMAGE_ROM_OPTIONAL_HDR_MAGIC          = 107h;

TYPE IMAGE_NT_HEADERS =
     RECORD
            Signature      : DWORD;
            FileHeader     : IMAGE_FILE_HEADER;
            OptionalHeader : IMAGE_OPTIONAL_HEADER;
     END;
    PIMAGE_NT_HEADERS = POINTER TO IMAGE_NT_HEADERS;

TYPE IMAGE_ROM_HEADERS =
     RECORD
            FileHeader     : IMAGE_FILE_HEADER;
            OptionalHeader : IMAGE_ROM_OPTIONAL_HEADER;
     END;
    PIMAGE_ROM_HEADERS = POINTER TO IMAGE_ROM_HEADERS;


(* Directory Entries *)

CONST IMAGE_DIRECTORY_ENTRY_EXPORT         = 0;   (* Export Directory *)
      IMAGE_DIRECTORY_ENTRY_IMPORT         = 1;   (* Import Directory *)
      IMAGE_DIRECTORY_ENTRY_RESOURCE       = 2;   (* Resource Directory *)
      IMAGE_DIRECTORY_ENTRY_EXCEPTION      = 3;   (* Exception Directory *)
      IMAGE_DIRECTORY_ENTRY_SECURITY       = 4;   (* Security Directory *)
      IMAGE_DIRECTORY_ENTRY_BASERELOC      = 5;   (* Base Relocation Table *)
      IMAGE_DIRECTORY_ENTRY_DEBUG          = 6;   (* Debug Directory *)
      IMAGE_DIRECTORY_ENTRY_COPYRIGHT      = 7;   (* Description String *)
      IMAGE_DIRECTORY_ENTRY_GLOBALPTR      = 8;   (* Machine Value (MIPS GP) *)
      IMAGE_DIRECTORY_ENTRY_TLS            = 9;   (* TLS Directory *)
      IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG   = 10;   (* Load Configuration Directory *)
      IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT  = 11;   (* Bound Import Directory in headers *)
      IMAGE_DIRECTORY_ENTRY_IAT           = 12;   (* Import Address Table *)

(*
** Section characteristics.
*)

TYPE IMAGE_SCN_ENUM =  (IMAGE_SCN__TYPE_DSECT,                 (*  0 - Reserved. *)
                        IMAGE_SCN__TYPE_NOLOAD,                (*  1 - Reserved. *)
                        IMAGE_SCN__TYPE_GROUP,                 (*  2 - Reserved. *)
                        IMAGE_SCN__TYPE_NO_PAD,                (*  3 - Reserved. *)
                        IMAGE_SCN__TYPE_COPY,                  (*  4 - Reserved. *)
                        IMAGE_SCN__CNT_CODE,                   (*  5 - Section contains code. *)
                        IMAGE_SCN__CNT_INITIALIZED_DATA,       (*  6 - Section contains initialized data. *)
                        IMAGE_SCN__CNT_UNINITIALIZED_DATA,     (*  7 - Section contains uninitialized data. *)
                        IMAGE_SCN__LNK_OTHER,                  (*  8 - Reserved. *)
                        IMAGE_SCN__LNK_INFO,                   (*  9 - Section contains comments or some other type of information. *)
                        IMAGE_SCN__TYPE_OVER,                  (* 10 - Reserved. *)
                        IMAGE_SCN__LNK_REMOVE,                 (* 11 - Section contents will not become part of image. *)
                        IMAGE_SCN__LNK_COMDAT,                 (* 12 - Section contents comdat. *)
                        IMAGE_SCN__13,
                        IMAGE_SCN__MEM_PROTECTED,              (* 14 - Obsolete *)
                        IMAGE_SCN__MEM_FARDATA,                (* 15 *)
                        IMAGE_SCN__MEM_SYSHEAP,                (* 16 - Obsolete *)
                        IMAGE_SCN__MEM_PURGEABLE,              (* 17 *)
                        IMAGE_SCN__MEM_LOCKED,                 (* 18 *)
                        IMAGE_SCN__MEM_PRELOAD,                (* 19 *)
                        IMAGE_SCN__ALIGN_1BYTES,               (* 20 *)
                        IMAGE_SCN__ALIGN_2BYTES,               (* 21 *)
                        IMAGE_SCN__ALIGN_8BYTES,               (* 22 *)
                        IMAGE_SCN__25,
                        IMAGE_SCN__LNK_NRELOC_OVFL,            (* 24 - Section contains extended relocations. *)
                        IMAGE_SCN__MEM_DISCARDABLE,            (* 25 - Section can be discarded. *)
                        IMAGE_SCN__MEM_NOT_CACHED,             (* 26 - Section is not cachable. *)
                        IMAGE_SCN__MEM_NOT_PAGED,              (* 27 - Section is not pageable. *)
                        IMAGE_SCN__MEM_SHARED,                 (* 28 - Section is shareable. *)
                        IMAGE_SCN__MEM_EXECUTE,                (* 29 - Section is executable. *)
                        IMAGE_SCN__MEM_READ,                   (* 30 - Section is readable. *)
                        IMAGE_SCN__MEM_WRITE);                 (* 31 - Section is writeable. *)

TYPE IMAGE_SCN_SET = SET OF IMAGE_SCN_ENUM;

CONST
      IMAGE_SCN_TYPE_REG               = IMAGE_SCN_SET {};                                 (* 0x00000000 *)
      IMAGE_SCN_TYPE_DSECT             = IMAGE_SCN_SET {IMAGE_SCN__TYPE_DSECT};             (* 0x00000001 *)
      IMAGE_SCN_TYPE_NOLOAD            = IMAGE_SCN_SET {IMAGE_SCN__TYPE_NOLOAD};            (* 0x00000002 *)
      IMAGE_SCN_TYPE_GROUP             = IMAGE_SCN_SET {IMAGE_SCN__TYPE_GROUP};             (* 0x00000004 *)

      IMAGE_SCN_TYPE_NO_PAD            = IMAGE_SCN_SET {IMAGE_SCN__TYPE_NO_PAD};            (* 0x00000008 *)
      IMAGE_SCN_TYPE_COPY              = IMAGE_SCN_SET {IMAGE_SCN__TYPE_COPY};              (* 0x00000010 *)

      IMAGE_SCN_CNT_CODE               = IMAGE_SCN_SET {IMAGE_SCN__CNT_CODE};               (* 0x00000020 *)
      IMAGE_SCN_CNT_INITIALIZED_DATA   = IMAGE_SCN_SET {IMAGE_SCN__CNT_INITIALIZED_DATA};   (* 0x00000040 *)
      IMAGE_SCN_CNT_UNINITIALIZED_DATA = IMAGE_SCN_SET {IMAGE_SCN__CNT_UNINITIALIZED_DATA}; (* 0x00000080 *)

      IMAGE_SCN_LNK_OTHER              = IMAGE_SCN_SET {IMAGE_SCN__LNK_OTHER};              (* 0x00000100 *)
      IMAGE_SCN_LNK_INFO               = IMAGE_SCN_SET {IMAGE_SCN__LNK_INFO};               (* 0x00000200 *)
      IMAGE_SCN_TYPE_OVER              = IMAGE_SCN_SET {IMAGE_SCN__TYPE_OVER};              (* 0x00000400 *)

      IMAGE_SCN_LNK_REMOVE             = IMAGE_SCN_SET {IMAGE_SCN__LNK_REMOVE};             (* 0x00000800 *)
      IMAGE_SCN_LNK_COMDAT             = IMAGE_SCN_SET {IMAGE_SCN__LNK_COMDAT};             (* 0x00001000 *)

      IMAGE_SCN_MEM_PROTECTED          = IMAGE_SCN_SET {IMAGE_SCN__MEM_PROTECTED};          (* 0x00004000 *)

      IMAGE_SCN_MEM_FARDATA            = IMAGE_SCN_SET {IMAGE_SCN__MEM_FARDATA};            (* 0x00008000 *)
      IMAGE_SCN_MEM_SYSHEAP            = IMAGE_SCN_SET {IMAGE_SCN__MEM_SYSHEAP};            (* 0x00010000 *)

      IMAGE_SCN_MEM_PURGEABLE          = IMAGE_SCN_SET {IMAGE_SCN__MEM_PURGEABLE};          (* 0x00020000 *)
      IMAGE_SCN_MEM_16BIT              = IMAGE_SCN_MEM_PURGEABLE;                           (* 0x00020000 *)
      IMAGE_SCN_MEM_LOCKED             = IMAGE_SCN_SET {IMAGE_SCN__MEM_LOCKED};             (* 0x00040000 *)
      IMAGE_SCN_MEM_PRELOAD            = IMAGE_SCN_SET {IMAGE_SCN__MEM_PRELOAD};            (* 0x00080000 *)

      IMAGE_SCN_ALIGN_1BYTES           = IMAGE_SCN_SET {IMAGE_SCN__ALIGN_1BYTES};           (* 0x00100000 *)
      IMAGE_SCN_ALIGN_2BYTES           = IMAGE_SCN_SET {IMAGE_SCN__ALIGN_2BYTES};           (* 0x00200000 *)
      IMAGE_SCN_ALIGN_4BYTES           = IMAGE_SCN_ALIGN_2BYTES +
                                         IMAGE_SCN_ALIGN_1BYTES;                           (* 0x00300000 *)
      IMAGE_SCN_ALIGN_8BYTES           = IMAGE_SCN_SET {IMAGE_SCN__ALIGN_8BYTES};           (* 0x00400000 *)
      IMAGE_SCN_ALIGN_16BYTES          = IMAGE_SCN_ALIGN_8BYTES +
                                         IMAGE_SCN_ALIGN_1BYTES;                           (* 0x00500000h *)
                                                                                           (* Default alignment if no others are specified. *)
      IMAGE_SCN_ALIGN_32BYTES          = IMAGE_SCN_ALIGN_8BYTES +
                                         IMAGE_SCN_ALIGN_2BYTES;                           (* 0x00600000h *)
      IMAGE_SCN_ALIGN_64BYTES          = IMAGE_SCN_ALIGN_8BYTES +
                                         IMAGE_SCN_ALIGN_2BYTES +
                                         IMAGE_SCN_ALIGN_1BYTES;                           (* 0x00700000h *)

      IMAGE_SCN_LNK_NRELOC_OVFL        = IMAGE_SCN_SET {IMAGE_SCN__LNK_NRELOC_OVFL};        (* 0x01000000 *)
      IMAGE_SCN_MEM_DISCARDABLE        = IMAGE_SCN_SET {IMAGE_SCN__MEM_DISCARDABLE};        (* 0x02000000 *)
      IMAGE_SCN_MEM_NOT_CACHED         = IMAGE_SCN_SET {IMAGE_SCN__MEM_NOT_CACHED};         (* 0x04000000 *)
      IMAGE_SCN_MEM_NOT_PAGED          = IMAGE_SCN_SET {IMAGE_SCN__MEM_NOT_PAGED};          (* 0x08000000 *)
      IMAGE_SCN_MEM_SHARED             = IMAGE_SCN_SET {IMAGE_SCN__MEM_SHARED};             (* 0x10000000 *)
      IMAGE_SCN_MEM_EXECUTE            = IMAGE_SCN_SET {IMAGE_SCN__MEM_EXECUTE};            (* 0x20000000 *)
      IMAGE_SCN_MEM_READ               = IMAGE_SCN_SET {IMAGE_SCN__MEM_READ};               (* 0x40000000 *)
      IMAGE_SCN_MEM_WRITE              = IMAGE_SCN_SET {IMAGE_SCN__MEM_WRITE};              (* 0x80000000 *)

(*
** Section header format.
*)

CONST IMAGE_SIZEOF_SHORT_NAME = 8;

TYPE IMAGE_SECTION_HEADER =
     RECORD
            Name : ARRAY [0..IMAGE_SIZEOF_SHORT_NAME-1] OF BYTE;
            CASE : BOOLEAN OF
            | TRUE  : PhysicalAddress : DWORD;
            | FALSE : VirtualSize     : DWORD;
            END;
            VirtualAddress       : DWORD;
            SizeOfRawData        : DWORD;
            PointerToRawData     : DWORD;
            PointerToRelocations : DWORD;
            PointerToLinenumbers : DWORD;
            NumberOfRelocations  : WORD;
            NumberOfLinenumbers  : WORD;
            Characteristics      : IMAGE_SCN_SET;
     END;
    PIMAGE_SECTION_HEADER = POINTER TO IMAGE_SECTION_HEADER;

CONST IMAGE_SIZEOF_SECTION_HEADER = 40;

(*
** TLS Chaacteristic Flags
*)
CONST IMAGE_SCN_SCALE_INDEX = 00000001h; (* Tls index is scaled *)

(*
** Symbol format.
*)

<* PUSH *> <* ALIGNMENT = "2" *>  (* Symbols, relocs, and linenumbers
                                     are 2 byte packed *)

TYPE IMAGE_SYMBOL = RECORD
                           CASE : BOOLEAN OF
                           | TRUE  : ShortName : ARRAY [0..7] OF BYTE;
                           | FALSE : Short     : DWORD; (* if 0, use LongName *)
                                     Long      : DWORD; (* offset into string table *)
                           ELSE
                                     LongName  : ARRAY [0..1] OF PBYTE;
                           END;
                           Value         : DWORD;
                           SectionNumber : SHORT;
                           Type          : WORD;
                           StorageClass  : BYTE;
                           NumberOfAuxSymbols : BYTE;
                    END;
    PIMAGE_SYMBOL = POINTER TO IMAGE_SYMBOL;

CONST IMAGE_SIZEOF_SYMBOL = 18;

(*
** Section values.
**
** Symbols have a section number of the section in which they are
** defined. Otherwise, section numbers have the following meanings:
*)

CONST IMAGE_SYM_UNDEFINED           = VAL (SHORT,  0); (* Symbol is undefined or is common. *)
      IMAGE_SYM_ABSOLUTE            = VAL (SHORT, -1); (* Symbol is an absolute value. *)
      IMAGE_SYM_DEBUG               = VAL (SHORT, -2); (* Symbol is a special debug item. *)

(*
** Type (fundamental) values.
*)

      IMAGE_SYM_TYPE_NULL                 = 0000h;  (* no type. *)
      IMAGE_SYM_TYPE_VOID                 = 0001h;
      IMAGE_SYM_TYPE_CHAR                 = 0002h;  (* type character. *)
      IMAGE_SYM_TYPE_SHORT                = 0003h;  (* type short integer. *)
      IMAGE_SYM_TYPE_INT                  = 0004h;
      IMAGE_SYM_TYPE_LONG                 = 0005h;
      IMAGE_SYM_TYPE_FLOAT                = 0006h;
      IMAGE_SYM_TYPE_DOUBLE               = 0007h;
      IMAGE_SYM_TYPE_STRUCT               = 0008h;
      IMAGE_SYM_TYPE_UNION                = 0009h;
      IMAGE_SYM_TYPE_ENUM                 = 000Ah;  (* enumeration. *)
      IMAGE_SYM_TYPE_MOE                  = 000Bh;  (* member of enumeration. *)
      IMAGE_SYM_TYPE_BYTE                 = 000Ch;
      IMAGE_SYM_TYPE_WORD                 = 000Dh;
      IMAGE_SYM_TYPE_UINT                 = 000Eh;
      IMAGE_SYM_TYPE_DWORD                = 000Fh;
      IMAGE_SYM_TYPE_PCODE                = 8000h;

(*
** Type (derived) values.
*)


CONST IMAGE_SYM_DTYPE_NULL                = 0;       (* no derived type. *)
      IMAGE_SYM_DTYPE_POINTER             = 1;       (* pointer. *)
      IMAGE_SYM_DTYPE_FUNCTION            = 2;       (* function. *)
      IMAGE_SYM_DTYPE_ARRAY               = 3;       (* array. *)

(*
** Storage classes.
*)


CONST IMAGE_SYM_CLASS_END_OF_FUNCTION     = -1;
      IMAGE_SYM_CLASS_NULL                = 0000h;
      IMAGE_SYM_CLASS_AUTOMATIC           = 0001h;
      IMAGE_SYM_CLASS_EXTERNAL            = 0002h;
      IMAGE_SYM_CLASS_STATIC              = 0003h;
      IMAGE_SYM_CLASS_REGISTER            = 0004h;
      IMAGE_SYM_CLASS_EXTERNAL_DEF        = 0005h;
      IMAGE_SYM_CLASS_LABEL               = 0006h;
      IMAGE_SYM_CLASS_UNDEFINED_LABEL     = 0007h;
      IMAGE_SYM_CLASS_MEMBER_OF_STRUCT    = 0008h;
      IMAGE_SYM_CLASS_ARGUMENT            = 0009h;
      IMAGE_SYM_CLASS_STRUCT_TAG          = 000Ah;
      IMAGE_SYM_CLASS_MEMBER_OF_UNION     = 000Bh;
      IMAGE_SYM_CLASS_UNION_TAG           = 000Ch;
      IMAGE_SYM_CLASS_TYPE_DEFINITION     = 000Dh;
      IMAGE_SYM_CLASS_UNDEFINED_STATIC    = 000Eh;
      IMAGE_SYM_CLASS_ENUM_TAG            = 000Fh;
      IMAGE_SYM_CLASS_MEMBER_OF_ENUM      = 0010h;
      IMAGE_SYM_CLASS_REGISTER_PARAM      = 0011h;
      IMAGE_SYM_CLASS_BIT_FIELD           = 0012h;

      IMAGE_SYM_CLASS_FAR_EXTERNAL        = 0044h;  

      IMAGE_SYM_CLASS_BLOCK               = 0064h;
      IMAGE_SYM_CLASS_FUNCTION            = 0065h;
      IMAGE_SYM_CLASS_END_OF_STRUCT       = 0066h;
      IMAGE_SYM_CLASS_FILE                = 0067h;
(* new *)
      IMAGE_SYM_CLASS_SECTION             = 0068h;
      IMAGE_SYM_CLASS_WEAK_EXTERNAL       = 0069h;

(* type packing constants *)

      N_BTMASK                            = 000Fh;
      N_TMASK                             = 0030h;
      N_TMASK1                            = 00C0h;
      N_TMASK2                            = 00F0h;
      N_BTSHFT                            = 4;
      N_TSHIFT                            = 2;

(*
** Auxiliary entry format.
*)

TYPE IMAGE_AUX_SYMBOL =
     RECORD
       CASE : BOOLEAN OF
       | TRUE  : Sym :
                 RECORD
                        TagIndex : DWORD;                      (* struct, union, or enum tag index *)
                        CASE : BOOLEAN OF
                        | TRUE  : Linenumber : WORD;           (* declaration line number *)
                                  Size       : WORD;           (* size of struct, union, or enum *)
                        | FALSE : TotalSize  : DWORD;
                        END;
                        CASE : BOOLEAN OF
                        | TRUE  : PointerToLinenumber   : DWORD;     (* Function *)
                                  PointerToNextFunction : DWORD;
                        | FALSE : Dimension : ARRAY [0..3] OF WORD;  (* Array *)
                        END;
                        TvIndex : WORD;                        (* tv index *)
                 END;
       | FALSE : File :
                 RECORD
                        Name : ARRAY [0..IMAGE_SIZEOF_SYMBOL-1] OF BYTE;
                 END;
       ELSE
                 Section :
                 RECORD
                        Length              : DWORD; (* section length *)
                        NumberOfRelocations : WORD;  (* number of relocation entries *)
                        NumberOfLinenumbers : WORD;  (* number of line numbers *)
                        CheckSum            : DWORD; (* checksum for communal *)
                        Number              : SHORT; (* section number to associate with *)
                        Selection           : BYTE;  (* communal selection type *)
                 END;
       END;
     END;

     PIMAGE_AUX_SYMBOL = POINTER TO IMAGE_AUX_SYMBOL;

CONST IMAGE_SIZEOF_AUX_SYMBOL = 18;

(*
** Communal selection types.
*)

CONST IMAGE_COMDAT_SELECT_NODUPLICATES    = 1;
      IMAGE_COMDAT_SELECT_ANY             = 2;
      IMAGE_COMDAT_SELECT_SAME_SIZE       = 3;
      IMAGE_COMDAT_SELECT_EXACT_MATCH     = 4;
      IMAGE_COMDAT_SELECT_ASSOCIATIVE     = 5;
      IMAGE_COMDAT_SELECT_LARGEST         = 6;
      IMAGE_COMDAT_SELECT_NEWEST          = 7;

      IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY  = 1;
      IMAGE_WEAK_EXTERN_SEARCH_LIBRARY    = 2;
      IMAGE_WEAK_EXTERN_SEARCH_ALIAS      = 3;

(*
** I386 relocation types.
*)

<* PUSH *> <* ENUMSIZE = "2" *>

TYPE IMAGE_REL_I386_ENUM = (IMAGE_REL_I386_ABSOLUTE, (* 0000h - Reference is absolute, no relocation is necessary *)
                            IMAGE_REL_I386_DIR16,    (* 0001h - Direct 16-bit reference to the symbols virtual address *)
                            IMAGE_REL_I386_REL16,    (* 0002h - PC-relative 16-bit reference to the symbols virtual address *)
                            IMAGE_REL_I386_3,
                            IMAGE_REL_I386_4,
                            IMAGE_REL_I386_5,
                            IMAGE_REL_I386_DIR32,    (* 0006h - Direct 32-bit reference to the symbols virtual address *)
                            IMAGE_REL_I386_DIR32NB,  (* 0007h - Direct 32-bit reference to the symbols virtual address, base not included *)
                            IMAGE_REL_I386_8,
                            IMAGE_REL_I386_SEG12,    (* 0009h - Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address *)
                            IMAGE_REL_I386_SECTION,  (* 000Ah *)
                            IMAGE_REL_I386_SECREL,   (* 000Bh *)
                            IMAGE_REL_I386_C,
                            IMAGE_REL_I386_D,
                            IMAGE_REL_I386_E,
                            IMAGE_REL_I386_F,
                            IMAGE_REL_I386_10,
                            IMAGE_REL_I386_11,
                            IMAGE_REL_I386_12,
                            IMAGE_REL_I386_13,
                            IMAGE_REL_I386_REL32);   (* 0014h - PC-relative 32-bit reference to the symbols virtual address *)

<* POP *> (* Back to 4 byte alignment *)

(*
** Relocation format.
*)

TYPE IMAGE_RELOCATION =
     RECORD
            CASE : BOOLEAN OF
            | TRUE  : VirtualAddress : DWORD;
            | FALSE : RelocCount     : DWORD; (* Set to the real count when IMAGE_SCN_LNK_NRELOC_OVFL is set *)
            END;
            SymbolTableIndex : DWORD;
            Type : IMAGE_REL_I386_ENUM;
     END;
    PIMAGE_RELOCATION = POINTER TO IMAGE_RELOCATION;

CONST IMAGE_SIZEOF_RELOCATION = 10;

(*
** Line number format.
*)

TYPE IMAGE_LINENUMBER =
     RECORD
            CASE : BOOLEAN OF
            | TRUE  : SymbolTableIndex : DWORD; (* Symbol table index of function name if Linenumber is 0. *)
            | FALSE : VirtualAddress   : DWORD; (* Virtual address of line number. *)
            END;
            Linenumber : WORD;                  (* Line number. *)
     END;
    PIMAGE_LINENUMBER = POINTER TO IMAGE_LINENUMBER;

CONST IMAGE_SIZEOF_LINENUMBER = 6;

<* POP *> (* Return to 4-byte packing *)

(*
** Based relocation format.
*)

TYPE IMAGE_BASE_RELOCATION =
     RECORD
            VirtualAddress : DWORD;
            SizeOfBlock : DWORD;
         (* TypeOffset = ARRAY [0..0] OF WORD; *)
     END;
    PIMAGE_BASE_RELOCATION = POINTER TO IMAGE_BASE_RELOCATION;

CONST IMAGE_SIZEOF_BASE_RELOCATION = 8;

(*
** Based relocation types.
*)

CONST IMAGE_REL_BASED_ABSOLUTE              = 0;
      IMAGE_REL_BASED_HIGH                  = 1;
      IMAGE_REL_BASED_LOW                   = 2;
      IMAGE_REL_BASED_HIGHLOW               = 3;
      IMAGE_REL_BASED_HIGHADJ               = 4;
      IMAGE_REL_BASED_MIPS_JMPADDR          = 5;

(*
** Archive format.
*)

CONST IMAGE_ARCHIVE_START_SIZE             = 8;
      IMAGE_ARCHIVE_START                  = "!<arch>"+012C;
      IMAGE_ARCHIVE_END                    = "`"+012C;
      IMAGE_ARCHIVE_PAD                    = ""+012C;
      IMAGE_ARCHIVE_LINKER_MEMBER          = "/               ";
      IMAGE_ARCHIVE_LONGNAMES_MEMBER       = "//              ";

TYPE IMAGE_ARCHIVE_MEMBER_HEADER =
     RECORD
            Name      : ARRAY [0..15] OF BYTE;  (* File member name - `/' terminated. *)
            Date      : ARRAY [0..11] OF BYTE;  (* File member date - decimal. *)
            UserID    : ARRAY [0..5]  OF BYTE;  (* File member user id - decimal. *)
            GroupID   : ARRAY [0..5]  OF BYTE;  (* File member group id - decimal. *)
            Mode      : ARRAY [0..7]  OF BYTE;  (* File member mode - octal. *)
            Size      : ARRAY [0..9]  OF BYTE;  (* File member size - decimal. *)
            EndHeader : ARRAY [0..1]  OF BYTE;  (* String to end header. *)
     END;
    PIMAGE_ARCHIVE_MEMBER_HEADER = POINTER TO IMAGE_ARCHIVE_MEMBER_HEADER;

CONST IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR = 60;

(*
** DLL support.
*)


(*
** Export Format
*)


TYPE IMAGE_EXPORT_DIRECTORY =
     RECORD
            Characteristics       : DWORD;
            TimeDateStamp         : DWORD;
            MajorVersion          : WORD;
            MinorVersion          : WORD;
            Name                  : DWORD;
            Base                  : DWORD;
            NumberOfFunctions     : DWORD;
            NumberOfNames         : DWORD;
            AddressOfFunctions    : PPDWORD;
            AddressOfNames        : PPDWORD;
            AddressOfNameOrdinals : PPWORD;
     END;
    PIMAGE_EXPORT_DIRECTORY = POINTER TO IMAGE_EXPORT_DIRECTORY;

(*
** Import Format
*)


TYPE IMAGE_IMPORT_BY_NAME =
     RECORD
            Hint : WORD;
            Name : ARRAY [0..0] OF BYTE;
     END;
    PIMAGE_IMPORT_BY_NAME = POINTER TO IMAGE_IMPORT_BY_NAME;

TYPE IMAGE_THUNK_DATA =
     RECORD
            CASE : INTEGER OF
            | 0 : ForwarderString : PBYTE;
            | 1 : Function : PDWORD;
            | 2 : Ordinal : DWORD;
            | 3 : AddressOfData : PIMAGE_IMPORT_BY_NAME;
            END;
     END;
    PIMAGE_THUNK_DATA = POINTER TO IMAGE_THUNK_DATA;

CONST IMAGE_ORDINAL_FLAG = 80000000h;

TYPE IMAGE_IMPORT_DESCRIPTOR =
     RECORD
            CASE : BOOLEAN OF
            | TRUE  : Characteristics    : DWORD;             (* 0 for terminating null import descriptor *)
            | FALSE : OriginalFirstThunk : PIMAGE_THUNK_DATA; (* RVA to original unbound IAT *)
            END;
            TimeDateStamp : DWORD;          (* 0 if not bound, *)
                                            (* -1 if bound, and real date\time stamp *)
                                            (*     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND) *)
                                            (* O.W. date/time stamp of DLL bound to (Old BIND) *)

            ForwarderChain : DWORD;         (* -1 if no forwarders *)
            Name : DWORD;
            FirstThunk : PIMAGE_THUNK_DATA; (* RVA to IAT (if bound this IAT has actual addresses) *)
     END;
    PIMAGE_IMPORT_DESCRIPTOR = POINTER TO IMAGE_IMPORT_DESCRIPTOR;

(*
** New format import descriptors pointed to by DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ]
*)

TYPE IMAGE_BOUND_IMPORT_DESCRIPTOR =
     RECORD
            TimeDateStamp : DWORD;
            OffsetModuleName : WORD;
            NumberOfModuleForwarderRefs : WORD;
            (* Array of zero or more IMAGE_BOUND_FORWARDER_REF follows *)
     END;
    PIMAGE_BOUND_IMPORT_DESCRIPTOR = POINTER TO IMAGE_BOUND_IMPORT_DESCRIPTOR;

TYPE IMAGE_BOUND_FORWARDER_REF =
     RECORD
            TimeDateStamp    : DWORD;
            OffsetModuleName : WORD;
            Reserved         : WORD;
     END;
    PIMAGE_BOUND_FORWARDER_REF = POINTER TO IMAGE_BOUND_FORWARDER_REF;

(*
** Thread Local Storage
*)

TYPE PIMAGE_TLS_CALLBACK = PROCEDURE ((* DllHandle : *) PVOID,
                                      (* Reason    : *) DWORD,
                                      (* Reserved  : *) PVOID);
TYPE PPIMAGE_TLS_CALLBACK = POINTER TO PIMAGE_TLS_CALLBACK;

TYPE IMAGE_TLS_DIRECTORY =
     RECORD
            StartAddressOfRawData : DWORD;
            EndAddressOfRawData   : DWORD;
            AddressOfIndex        : PDWORD;
            AddressOfCallBacks    : PPIMAGE_TLS_CALLBACK;
            SizeOfZeroFill        : DWORD;
            Characteristics       : DWORD;
       END;
     PIMAGE_TLS_DIRECTORY = POINTER TO IMAGE_TLS_DIRECTORY;

(*
** Resource Format.
*)

(*
** Resource directory consists of two counts, following by a variable length
** array of directory entries.  The first count is the number of entries at
** beginning of the array that have actual names associated with each entry.
** The entries are in ascending order, case insensitive strings.  The second
** count is the number of entries that immediately follow the named entries.
** This second count identifies the number of entries that have 16-bit integer
** Ids as their name.  These entries are also sorted in ascending order.
**
** This structure allows fast lookup by either name or number, but for any
** given resource entry only one form of lookup is supported, not both.
** This is consistant with the syntax of the .RC file and the .RES file.
*)


TYPE IMAGE_RESOURCE_DIRECTORY =
     RECORD
            Characteristics      : DWORD;
            TimeDateStamp        : DWORD;
            MajorVersion         : WORD;
            MinorVersion         : WORD;
            NumberOfNamedEntries : WORD;
            NumberOfIdEntries    : WORD;
           (* IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[]; *)
     END;
    PIMAGE_RESOURCE_DIRECTORY = POINTER TO IMAGE_RESOURCE_DIRECTORY;

CONST IMAGE_RESOURCE_NAME_IS_STRING    = 80000000h;
      IMAGE_RESOURCE_DATA_IS_DIRECTORY = 80000000h;

(*
** Each directory contains the 32-bit Name of the entry and an offset,
** relative to the beginning of the resource directory of the data associated
** with this directory entry.  If the name of the entry is an actual text
** string instead of an integer Id, then the high order bit of the name field
** is set to one and the low order 31-bits are an offset, relative to the
** beginning of the resource directory of the string, which is of type
** IMAGE_RESOURCE_DIRECTORY_STRING.  Otherwise the high bit is clear and the
** low-order 16-bits are the integer Id that identify this resource directory
** entry. If the directory entry is yet another resource directory (i.e. a
** subdirectory), then the high order bit of the offset field will be
** set to indicate this.  Otherwise the high bit is clear and the offset
** field points to a resource data entry.
*)


TYPE IMAGE_RESOURCE_DIRECTORY_ENTRY =
     RECORD
            CASE : BOOLEAN OF
            | TRUE  : Name : DWORD;
            | FALSE : Id : WORD;
            END;
            OffsetToData : DWORD;
     END;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY = POINTER TO IMAGE_RESOURCE_DIRECTORY_ENTRY;

(*
** For resource directory entries that have actual string names, the Name
** field of the directory entry points to an object of the following type.
** All of these string objects are stored together after the last resource
** directory entry and before the first resource data object.  This minimizes
** the impact of these variable length objects on the alignment of the fixed
** size directory entry objects.
*)

TYPE IMAGE_RESOURCE_DIRECTORY_STRING =
     RECORD
            Length : WORD;
            NameString : ARRAY [0..0] OF CHAR;
     END;
    PIMAGE_RESOURCE_DIRECTORY_STRING = POINTER TO IMAGE_RESOURCE_DIRECTORY_STRING;

TYPE IMAGE_RESOURCE_DIR_STRING_U =
     RECORD
            Length : WORD;
            NameString : ARRAY [0..0] OF WCHAR;
     END;
     PIMAGE_RESOURCE_DIR_STRING_U = POINTER TO IMAGE_RESOURCE_DIR_STRING_U;

(*
** Each resource data entry describes a leaf node in the resource directory
** tree.  It contains an offset, relative to the beginning of the resource
** directory of the data for the resource, a size field that gives the number
** of bytes of data at that offset, a CodePage that should be used when
** decoding code point values within the resource data.  Typically for new
** applications the code page would be the unicode code page.
*)

TYPE IMAGE_RESOURCE_DATA_ENTRY =
     RECORD
            OffsetToData : DWORD;
            Size         : DWORD;
            CodePage     : DWORD;
            Reserved     : DWORD;
     END;
     PIMAGE_RESOURCE_DATA_ENTRY = POINTER TO IMAGE_RESOURCE_DATA_ENTRY;

(*
** Load Configuration Directory Entry
*)


TYPE IMAGE_LOAD_CONFIG_DIRECTORY =
     RECORD
            Characteristics               : DWORD;
            TimeDateStamp                 : DWORD;
            MajorVersion                  : WORD;
            MinorVersion                  : WORD;
            GlobalFlagsClear              : DWORD;
            GlobalFlagsSet                : DWORD;
            CriticalSectionDefaultTimeout : DWORD;
            DeCommitFreeBlockThreshold    : DWORD;
            DeCommitTotalFreeThreshold    : DWORD;
            LockPrefixTable               : PVOID;
            MaximumAllocationSize         : DWORD;
            VirtualMemoryThreshold        : DWORD;
            ProcessHeapFlags              : DWORD;
            ProcessAffinityMask           : DWORD;
            Reserved                      : ARRAY [0..2] OF DWORD;
     END;
     PIMAGE_LOAD_CONFIG_DIRECTORY = POINTER TO IMAGE_LOAD_CONFIG_DIRECTORY;

(*
** Function table entry format for MIPS/ALPHA images.  Function table is
** pointed to by the IMAGE_DIRECTORY_ENTRY_EXCEPTION directory entry.
** This definition duplicates ones in ntmips.h and ntalpha.h for use
** by portable image file mungers.
*)

TYPE IMAGE_RUNTIME_FUNCTION_ENTRY =
     RECORD
            BeginAddress     : DWORD;
            EndAddress       : DWORD;
            ExceptionHandler : PVOID;
            HandlerData      : PVOID;
            PrologEndAddress : DWORD;
     END;
    PIMAGE_RUNTIME_FUNCTION_ENTRY = POINTER TO IMAGE_RUNTIME_FUNCTION_ENTRY;

(*
** Debug Format
*)

TYPE IMAGE_DEBUG_TYPE_ENUM = (IMAGE_DEBUG_TYPE_UNKNOWN,        (* 0 *)
                              IMAGE_DEBUG_TYPE_COFF,           (* 1 *)
                              IMAGE_DEBUG_TYPE_CODEVIEW,       (* 2 *)
                              IMAGE_DEBUG_TYPE_FPO,            (* 3 *)
                              IMAGE_DEBUG_TYPE_MISC,           (* 4 *)
                              IMAGE_DEBUG_TYPE_EXCEPTION,      (* 5 *)
                              IMAGE_DEBUG_TYPE_FIXUP,          (* 6 *)
                              IMAGE_DEBUG_TYPE_OMAP_TO_SRC,    (* 7 *)
                              IMAGE_DEBUG_TYPE_OMAP_FROM_SRC); (* 8 *)

TYPE IMAGE_DEBUG_DIRECTORY =
     RECORD
            Characteristics  : DWORD;
            TimeDateStamp    : DWORD;
            MajorVersion     : WORD;
            MinorVersion     : WORD;
            Type             : IMAGE_DEBUG_TYPE_ENUM;
            SizeOfData       : DWORD;
            AddressOfRawData : DWORD;
            PointerToRawData : DWORD;
     END;
    PIMAGE_DEBUG_DIRECTORY = POINTER TO IMAGE_DEBUG_DIRECTORY;

TYPE IMAGE_COFF_SYMBOLS_HEADER =
     RECORD
            NumberOfSymbols      : DWORD;
            LvaToFirstSymbol     : DWORD;
            NumberOfLinenumbers  : DWORD;
            LvaToFirstLinenumber : DWORD;
            RvaToFirstByteOfCode : DWORD;
            RvaToLastByteOfCode  : DWORD;
            RvaToFirstByteOfData : DWORD;
            RvaToLastByteOfData  : DWORD;
     END;
    PIMAGE_COFF_SYMBOLS_HEADER = POINTER TO IMAGE_COFF_SYMBOLS_HEADER;

CONST FRAME_FPO       = 0;
      FRAME_TRAP      = 1;
      FRAME_TSS       = 2;
      FRAME_NONFPO    = 3;

TYPE FPO_DATA = RECORD
                        ulOffStart : DWORD; (* offset 1st byte of function code *)
                        cbProcSize : DWORD; (* # bytes in function *)
                        cdwLocals  : DWORD; (* # bytes in locals/4 *)
                        cdwParams  : WORD;  (* # bytes in params/4 *)
                        cbProlog   : BYTE;  (* # bytes in prolog *)
                        flags      : BYTE;

        (* flags field consists of following bit fields:

                        cbRegs   : 3;       (* # regs saved *)
                        fHasSEH  : 1;       (* TRUE if SEH in func *)
                        fUseBP   : 1;       (* TRUE if EBP has been allocated *)
                        reserved : 1;       (* reserved for future use *)
                        cbFrame  : 2;       (* frame type *)
        *)

                END;
    PFPO_DATA = POINTER TO FPO_DATA;

CONST SIZEOF_RFPO_DATA = 16;

CONST IMAGE_DEBUG_MISC_EXENAME    = 1;

TYPE IMAGE_DEBUG_MISC =
     RECORD
            DataType : DWORD;                  (* type of misc data, see defines *)
            Length   : DWORD;                  (* total length of record, rounded to four *)
                                               (* byte multiple. *)
            Unicode  : BOOL8;                  (* TRUE if data is unicode string *)
            Reserved : ARRAY [0..2] OF BYTE;
            Data     : ARRAY [0..0] OF  BYTE;  (* Actual data *)
     END;
    PIMAGE_DEBUG_MISC = POINTER TO IMAGE_DEBUG_MISC;

(*
** Function table extracted from MIPS/ALPHA images.  Does not contain
** information needed only for runtime support.  Just those fields for
** each entry needed by a debugger.
*)


TYPE IMAGE_FUNCTION_ENTRY =
     RECORD
            StartingAddress : DWORD;
            EndingAddress   : DWORD;
            EndOfPrologue   : DWORD;
     END;
     PIMAGE_FUNCTION_ENTRY = POINTER TO IMAGE_FUNCTION_ENTRY;

(*
** Debugging information can be stripped from an image file and placed
** in a separate .DBG file, whose file name part is the same as the
** image file name part (e.g. symbols for CMD.EXE could be stripped
** and placed in CMD.DBG).  This is indicated by the IMAGE_FILE_DEBUG_STRIPPED
** flag in the Characteristics field of the file header.  The beginning of
** the .DBG file contains the following structure which captures certain
** information from the image file.  This allows a debug to proceed even if
** the original image file is not accessable.  This header is followed by
** zero of more IMAGE_SECTION_HEADER structures, followed by zero or more
** IMAGE_DEBUG_DIRECTORY structures.  The latter structures and those in
** the image file contain file offsets relative to the beginning of the
** .DBG file.
**
** If symbols have been stripped from an image, the IMAGE_DEBUG_MISC structure
** is left in the image file, but not mapped.  This allows a debugger to
** compute the name of the .DBG file, from the name of the image in the
** IMAGE_DEBUG_MISC structure.
*)


TYPE IMAGE_SEPARATE_DEBUG_HEADER =
     RECORD
            Signature          : WORD;
            Flags              : WORD;
            Machine            : IMAGE_FILE_MACHINE_TYPE;
            Characteristics    : WORD;
            TimeDateStamp      : DWORD;
            CheckSum           : DWORD;
            ImageBase          : DWORD;
            SizeOfImage        : DWORD;
            NumberOfSections   : DWORD;
            ExportedNamesSize  : DWORD;
            DebugDirectorySize : DWORD;
            SectionAlignment   : DWORD;
            Reserved           : ARRAY [0..1] OF DWORD;
     END;
    PIMAGE_SEPARATE_DEBUG_HEADER = POINTER TO IMAGE_SEPARATE_DEBUG_HEADER;

CONST IMAGE_SEPARATE_DEBUG_SIGNATURE = 4944h;

CONST IMAGE_SEPARATE_DEBUG_FLAGS_MASK = 8000h;
CONST IMAGE_SEPARATE_DEBUG_MISMATCH   = 8000h; (* when DBG was updated, the
                                                old checksum didn't match.
                                             *)

<* POP *> (* Return to default (8 byte) packing *)

(*
** End Image Format
*)

TYPE HEAP_ENUM = (HEAP__NO_SERIALIZE,             (* 0 *)
                  HEAP__GROWABLE,                 (* 1 *)
                  HEAP__GENERATE_EXCEPTIONS,      (* 2 *)
                  HEAP__ZERO_MEMORY,              (* 3 *)
                  HEAP__REALLOC_IN_PLACE_ONLY,    (* 4 *)
                  HEAP__TAIL_CHECKING_ENABLED,    (* 5 *)
                  HEAP__FREE_CHECKING_ENABLED,    (* 6 *)
                  HEAP__DISABLE_COALESCE_ON_FREE, (* 7 *)
                  HEAP__8,  HEAP__9,
                  HEAP__10, HEAP__11,
                  HEAP__12, HEAP__13,
                  HEAP__14, HEAP__15,
                  HEAP__CREATE_ALIGN_16,          (* 16 *)
                  HEAP__CREATE_ENABLE_TRACING);   (* 17 *)

     HEAP_SET = SET OF HEAP_ENUM;

CONST HEAP_NO_SERIALIZE             = HEAP_SET {HEAP__NO_SERIALIZE            }; (* 00000001 *)
      HEAP_GROWABLE                 = HEAP_SET {HEAP__GROWABLE                }; (* 00000002 *)
      HEAP_GENERATE_EXCEPTIONS      = HEAP_SET {HEAP__GENERATE_EXCEPTIONS     }; (* 00000004 *)
      HEAP_ZERO_MEMORY              = HEAP_SET {HEAP__ZERO_MEMORY             }; (* 00000008 *)
      HEAP_REALLOC_IN_PLACE_ONLY    = HEAP_SET {HEAP__REALLOC_IN_PLACE_ONLY   }; (* 00000010 *)
      HEAP_TAIL_CHECKING_ENABLED    = HEAP_SET {HEAP__TAIL_CHECKING_ENABLED   }; (* 00000020 *)
      HEAP_FREE_CHECKING_ENABLED    = HEAP_SET {HEAP__FREE_CHECKING_ENABLED   }; (* 00000040 *)
      HEAP_DISABLE_COALESCE_ON_FREE = HEAP_SET {HEAP__DISABLE_COALESCE_ON_FREE}; (* 00000080 *)
      HEAP_CREATE_ALIGN_16          = HEAP_SET {HEAP__CREATE_ALIGN_16         }; (* 00010000 *)
      HEAP_CREATE_ENABLE_TRACING    = HEAP_SET {HEAP__CREATE_ENABLE_TRACING   }; (* 00020000 *)

CONST HEAP_MAXIMUM_TAG              = 0FFFh;
      HEAP_PSEUDO_TAG_FLAG          = 8000h;
      HEAP_TAG_SHIFT                = 16;

TYPE IS_TEXT_UNICODE_ENUM = (IS_TEXT_UNICODE__ASCII16,            (*  0 *)
                             IS_TEXT_UNICODE__STATISTICS,         (*  1 *)
                             IS_TEXT_UNICODE__CONTROLS,           (*  2 *)
                             IS_TEXT_UNICODE__SIGNATURE,          (*  3 *)
                             IS_TEXT_UNICODE__REVERSE_ASCII16,    (*  4 *)
                             IS_TEXT_UNICODE__REVERSE_STATISTICS, (*  5 *)
                             IS_TEXT_UNICODE__REVERSE_CONTROLS,   (*  6 *)
                             IS_TEXT_UNICODE__REVERSE_SIGNATURE,  (*  7 *)
                             IS_TEXT_UNICODE__ILLEGAL_CHARS,      (*  8 *)
                             IS_TEXT_UNICODE__ODD_LENGTH,         (*  9 *)
                             IS_TEXT_UNICODE__DBCS_LEADBYTE,      (* 10 *)
                             IS_TEXT_UNICODE__11,
                             IS_TEXT_UNICODE__NULL_BYTES,         (* 12 *)
                             IS_TEXT_UNICODE__13,
                             IS_TEXT_UNICODE__14,
                             IS_TEXT_UNICODE__15);

     IS_TEXT_UNICODE_SET = SET OF IS_TEXT_UNICODE_ENUM;

CONST IS_TEXT_UNICODE_ASCII16            = IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__ASCII16           }; (* 0001h *)
      IS_TEXT_UNICODE_REVERSE_ASCII16    = IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__REVERSE_ASCII16   }; (* 0010h *)

      IS_TEXT_UNICODE_STATISTICS         = IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__STATISTICS        }; (* 0002h *)
      IS_TEXT_UNICODE_REVERSE_STATISTICS = IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__REVERSE_STATISTICS}; (* 0020h *)

      IS_TEXT_UNICODE_CONTROLS           = IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__CONTROLS          }; (* 0004h *)
      IS_TEXT_UNICODE_REVERSE_CONTROLS   = IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__REVERSE_CONTROLS  }; (* 0040h *)

      IS_TEXT_UNICODE_SIGNATURE          = IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__SIGNATURE         }; (* 0008h *)
      IS_TEXT_UNICODE_REVERSE_SIGNATURE  = IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__REVERSE_SIGNATURE }; (* 0080h *)

      IS_TEXT_UNICODE_ILLEGAL_CHARS      = IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__ILLEGAL_CHARS     }; (* 0100h *)
      IS_TEXT_UNICODE_ODD_LENGTH         = IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__ODD_LENGTH        }; (* 0200h *)
      IS_TEXT_UNICODE_DBCS_LEADBYTE      = IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__DBCS_LEADBYTE     }; (* 0400h *)
      IS_TEXT_UNICODE_NULL_BYTES         = IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__NULL_BYTES        }; (* 1000h *)

      IS_TEXT_UNICODE_UNICODE_MASK = IS_TEXT_UNICODE_ASCII16 +
                                     IS_TEXT_UNICODE_STATISTICS +
                                     IS_TEXT_UNICODE_CONTROLS +
                                     IS_TEXT_UNICODE_SIGNATURE;   (* 000Fh *)

      IS_TEXT_UNICODE_REVERSE_MASK = IS_TEXT_UNICODE_REVERSE_ASCII16 +
                                     IS_TEXT_UNICODE_REVERSE_STATISTICS +
                                     IS_TEXT_UNICODE_REVERSE_CONTROLS +
                                     IS_TEXT_UNICODE_REVERSE_SIGNATURE; (* 00F0h *)

      IS_TEXT_UNICODE_NOT_UNICODE_MASK = IS_TEXT_UNICODE_ILLEGAL_CHARS +
                                         IS_TEXT_UNICODE_ODD_LENGTH +
                                         IS_TEXT_UNICODE_DBCS_LEADBYTE +
                                         IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__11}; (* 0F00h *)

      IS_TEXT_UNICODE_NOT_ASCII_MASK = IS_TEXT_UNICODE_NULL_BYTES +
                                       IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__13..
                                                            IS_TEXT_UNICODE__14};  (* 0F000h *)


CONST COMPRESSION_FORMAT_NONE          = 0000h;
      COMPRESSION_FORMAT_DEFAULT       = 0001h;
      COMPRESSION_FORMAT_LZNT1         = 0002h;
      COMPRESSION_ENGINE_STANDARD      = 0000h;
      COMPRESSION_ENGINE_MAXIMUM       = 0100h;

PROCEDURE RtlEqualMemory (Source1 : PVOID;
                          Source2 : LPCVOID;
                          Length  : DWORD);

PROCEDURE RtlCopyMemory (Destination : PVOID;
                         Source      : LPCVOID;
                         Length      : DWORD);

PROCEDURE RtlMoveMemory (Destination : PVOID;
                         Source      : LPCVOID;
                         Length      : DWORD);

PROCEDURE RtlFillMemory (Destination : PVOID;
                         Length      : DWORD;
                         Fill        : BYTE);

PROCEDURE RtlZeroMemory (Destination : PVOID;
                         Length      : DWORD);

TYPE MESSAGE_RESOURCE_ENTRY = RECORD
                                     Length : WORD;
                                     Flags  : WORD;
                                     Text   : ARRAY [0..1] OF BYTE;
                              END;
    PMESSAGE_RESOURCE_ENTRY = POINTER TO MESSAGE_RESOURCE_ENTRY;

CONST MESSAGE_RESOURCE_UNICODE = 0001h;

TYPE MESSAGE_RESOURCE_BLOCK = RECORD
                                     LowId           : DWORD;
                                     HighId          : DWORD;
                                     OffsetToEntries : DWORD;
                              END;
    PMESSAGE_RESOURCE_BLOCK = POINTER TO MESSAGE_RESOURCE_BLOCK;

TYPE MESSAGE_RESOURCE_DATA = RECORD
                                    NumberOfBlocks : DWORD;
                                    Blocks         : ARRAY [0..0] OF MESSAGE_RESOURCE_BLOCK;
                             END;
    PMESSAGE_RESOURCE_DATA = POINTER TO MESSAGE_RESOURCE_DATA;


TYPE PRTL_CRITICAL_SECTION = POINTER TO RTL_CRITICAL_SECTION;
     RTL_CRITICAL_SECTION_DEBUG =
     RECORD
            Type                  : WORD;
            CreatorBackTraceIndex : WORD;
            CriticalSection       : PRTL_CRITICAL_SECTION;
            ProcessLocksList      : LIST_ENTRY;
            EntryCount            : DWORD;
            ContentionCount       : DWORD;
            Spare                 : ARRAY [0..1] OF DWORD;
     END;
     PRTL_CRITICAL_SECTION_DEBUG = POINTER TO RTL_CRITICAL_SECTION_DEBUG;

CONST RTL_CRITSECT_TYPE = 0;
      RTL_RESOURCE_TYPE = 1;

TYPE RTL_CRITICAL_SECTION =
     RECORD
            DebugInfo : PRTL_CRITICAL_SECTION_DEBUG;

    (*
    **  The following three fields control entering and exiting the critical
    **  section for the resource
    *)

            LockCount      : LONG;
            RecursionCount : LONG;
            OwningThread   : HANDLE; (* from the thread's ClientId->UniqueThread *)
            LockSemaphore  : HANDLE;
            Reserved       : DWORD;
     END;

CONST DLL_PROCESS_ATTACH = 1;
      DLL_THREAD_ATTACH  = 2;
      DLL_THREAD_DETACH  = 3;
      DLL_PROCESS_DETACH = 0;

(*
** Defines for the READ flags for Eventlogging (ReadEventLog ReadFlags parameter)
*)

TYPE EVENTLOG_READ_ENUM = (EVENTLOG__SEQUENTIAL_READ,   (* 0 *)
                           EVENTLOG__SEEK_READ,         (* 1 *)
                           EVENTLOG__FORWARDS_READ,     (* 2 *)
                           EVENTLOG__BACKWARDS_READ);   (* 3 *)
     EVENTLOG_READ_SET = SET OF EVENTLOG_READ_ENUM;

CONST EVENTLOG_SEQUENTIAL_READ = EVENTLOG_READ_SET {EVENTLOG__SEQUENTIAL_READ}; (* 0001h *)
      EVENTLOG_SEEK_READ       = EVENTLOG_READ_SET {EVENTLOG__SEEK_READ      }; (* 0002h *)
      EVENTLOG_FORWARDS_READ   = EVENTLOG_READ_SET {EVENTLOG__FORWARDS_READ  }; (* 0004h *)
      EVENTLOG_BACKWARDS_READ  = EVENTLOG_READ_SET {EVENTLOG__BACKWARDS_READ }; (* 0008h *)

(*
** The types of events that can be logged.
*)

TYPE EVENTLOG_ENUM = (EVENTLOG__ERROR_TYPE,       (* 0 *)
                      EVENTLOG__WARNING_TYPE,     (* 1 *)
                      EVENTLOG__INFORMATION_TYPE, (* 2 *)
                      EVENTLOG__AUDIT_SUCCESS,    (* 3 *)
                      EVENTLOG__AUDIT_FAILURE);   (* 4 *)

<* PUSH *> <* SETSIZE = "2" *>

TYPE EVENTLOG_TYPE = SET OF EVENTLOG_ENUM;

<* POP *>

CONST EVENTLOG_SUCCESS          = EVENTLOG_TYPE {};                           (* 0000h *)
      EVENTLOG_ERROR_TYPE       = EVENTLOG_TYPE {EVENTLOG__ERROR_TYPE};       (* 0001h *)
      EVENTLOG_WARNING_TYPE     = EVENTLOG_TYPE {EVENTLOG__WARNING_TYPE};     (* 0002h *)
      EVENTLOG_INFORMATION_TYPE = EVENTLOG_TYPE {EVENTLOG__INFORMATION_TYPE}; (* 0004h *)
      EVENTLOG_AUDIT_SUCCESS    = EVENTLOG_TYPE {EVENTLOG__AUDIT_SUCCESS};    (* 0008h *)
      EVENTLOG_AUDIT_FAILURE    = EVENTLOG_TYPE {EVENTLOG__AUDIT_FAILURE};    (* 0010h *)

(*
** Defines for the WRITE flags used by Auditing for paired events
** These are not implemented in Product 1
*)

TYPE EVENTLOG_WRITE_ENUM = (EVENTLOG__START_PAIRED_EVENT,     (* 0 *)
                            EVENTLOG__END_PAIRED_EVENT,       (* 1 *)
                            EVENTLOG__END_ALL_PAIRED_EVENTS,  (* 2 *)
                            EVENTLOG__PAIRED_EVENT_ACTIVE,    (* 3 *)
                            EVENTLOG__PAIRED_EVENT_INACTIVE); (* 4 *)

     EVENTLOG_WRITE_SET = SET OF EVENTLOG_WRITE_ENUM;

CONST EVENTLOG_START_PAIRED_EVENT    = EVENTLOG_WRITE_SET {EVENTLOG__START_PAIRED_EVENT};    (* 0001h *)
      EVENTLOG_END_PAIRED_EVENT      = EVENTLOG_WRITE_SET {EVENTLOG__END_PAIRED_EVENT};      (* 0002h *)
      EVENTLOG_END_ALL_PAIRED_EVENTS = EVENTLOG_WRITE_SET {EVENTLOG__END_ALL_PAIRED_EVENTS}; (* 0004h *)
      EVENTLOG_PAIRED_EVENT_ACTIVE   = EVENTLOG_WRITE_SET {EVENTLOG__PAIRED_EVENT_ACTIVE};   (* 0008h *)
      EVENTLOG_PAIRED_EVENT_INACTIVE = EVENTLOG_WRITE_SET {EVENTLOG__PAIRED_EVENT_INACTIVE}; (* 0010h *)

(*
** Structure that defines the header of the Eventlog record. This is the
** fixed-sized portion before all the variable-length strings, binary
** data and pad bytes.
**
** TimeGenerated is the time it was generated at the client.
** TimeWritten is the time it was put into the log at the server end.
*)


TYPE EVENTLOGRECORD =
     RECORD
            Length              : DWORD;  (* Length of full record *)
            Reserved            : DWORD;  (* Used by the service *)
            RecordNumber        : DWORD;  (* Absolute record number *)
            TimeGenerated       : DWORD;  (* Seconds since 1-1-1970 *)
            TimeWritten         : DWORD;  (* Seconds since 1-1-1970 *)
            EventID             : DWORD;
            EventType           : EVENTLOG_TYPE;
            NumStrings          : WORD;
            EventCategory       : WORD;
            ReservedFlags       : WORD;   (* For use with paired events (auditing) *)
            ClosingRecordNumber : DWORD;  (* For use with paired events (auditing) *)
            StringOffset        : DWORD;  (* Offset from beginning of record *)
            UserSidLength       : DWORD;
            UserSidOffset       : DWORD;
            DataLength          : DWORD;
            DataOffset          : DWORD;  (* Offset from beginning of record *)

            (*
            ** Then follow:
            **
            ** WCHAR SourceName[]
            ** WCHAR Computername[]
            ** SID   UserSid
            ** WCHAR Strings[]
            ** BYTE  Data[]
            ** CHAR  Pad[]
            ** DWORD Length;
            *)
     END;
     PEVENTLOGRECORD = POINTER TO EVENTLOGRECORD;

CONST DBG_CONTINUE                    = 00010002h;
      DBG_TERMINATE_THREAD            = 40010003h;
      DBG_TERMINATE_PROCESS           = 40010004h;
      DBG_CONTROL_C                   = 40010005h;
      DBG_CONTROL_BREAK               = 40010008h;
      DBG_EXCEPTION_NOT_HANDLED       = 80010001h;


(*
** Registry Specific Access Rights.
*)

CONST KEY_QUERY_VALUE         = ACCESS_MASK {ACCESS_0}; (* 0001h) *)
      KEY_SET_VALUE           = ACCESS_MASK {ACCESS_1}; (* 0002h) *)
      KEY_CREATE_SUB_KEY      = ACCESS_MASK {ACCESS_2}; (* 0004h) *)
      KEY_ENUMERATE_SUB_KEYS  = ACCESS_MASK {ACCESS_3}; (* 0008h) *)
      KEY_NOTIFY              = ACCESS_MASK {ACCESS_4}; (* 0010h) *)
      KEY_CREATE_LINK         = ACCESS_MASK {ACCESS_5}; (* 0020h) *)

      KEY_READ                = STANDARD_RIGHTS_READ
                                + KEY_QUERY_VALUE
                                + KEY_ENUMERATE_SUB_KEYS
                                + KEY_NOTIFY
                                - SYNCHRONIZE;

      KEY_WRITE               = STANDARD_RIGHTS_WRITE 
                                + KEY_SET_VALUE
                                + KEY_CREATE_SUB_KEY
                                - SYNCHRONIZE;

      KEY_EXECUTE             = KEY_READ - SYNCHRONIZE;

      KEY_ALL_ACCESS          = STANDARD_RIGHTS_ALL
                                + KEY_QUERY_VALUE
                                + KEY_SET_VALUE
                                + KEY_CREATE_SUB_KEY
                                + KEY_ENUMERATE_SUB_KEYS
                                + KEY_NOTIFY
                                + KEY_CREATE_LINK
                                - SYNCHRONIZE;

(*
** Open/Create Options
*)

TYPE REG_OPTION_ENUM = (REG_OPTION__VOLATILE,        (* 0 *)
                        REG_OPTION__CREATE_LINK,     (* 1 *)
                        REG_OPTION__BACKUP_RESTORE,  (* 2 *)
                        REG_OPTION__OPEN_LINK);      (* 3 *)

     REG_OPTION_SET = SET OF REG_OPTION_ENUM;

CONST REG_OPTION_RESERVED       = REG_OPTION_SET {};                           (* 00000000h *)
                                  (* Parameter is reserved *)

      REG_OPTION_NON_VOLATILE   = REG_OPTION_SET {};                           (* 00000000h *)
                                  (* Key is preserved *)
                                  (* when system is rebooted *)

      REG_OPTION_VOLATILE       = REG_OPTION_SET {REG_OPTION__VOLATILE};       (* 00000001h *)
                                  (* Key is not preserved *)
                                  (* when system is rebooted *)

      REG_OPTION_CREATE_LINK    = REG_OPTION_SET {REG_OPTION__CREATE_LINK};    (* 00000002h *)
                                  (* Created key is a *)
                                  (* symbolic link *)

      REG_OPTION_OPEN_LINK      = REG_OPTION_SET {REG_OPTION__OPEN_LINK};    (* 00000002h *)
                                  (* Open symbolic link *)

      REG_OPTION_BACKUP_RESTORE = REG_OPTION_SET {REG_OPTION__BACKUP_RESTORE}; (* 00000004h *)
                                  (* open for backup or restore *)
                                  (* special access rules *)
                                  (* privilege required *)

      REG_LEGAL_OPTION  = REG_OPTION_RESERVED     +
                          REG_OPTION_NON_VOLATILE +
                          REG_OPTION_VOLATILE     +
                          REG_OPTION_CREATE_LINK  +
                          REG_OPTION_BACKUP_RESTORE +
                          REG_OPTION_OPEN_LINK;

(*
** Key creation/open disposition
*)


TYPE REG_DISPOSITION = (REG_DISPOSITION_0,
                        REG_CREATED_NEW_KEY,       (* 00000001h; New Registry Key created *)
                        REG_OPENED_EXISTING_KEY);  (* 00000002h; Existing Key opened *)

(*
** Key restore flags
*)

TYPE REG_RESTORE_ENUM = (REG__WHOLE_HIVE_VOLATILE, (* 0 *)
                         REG__REFRESH_HIVE,        (* 1 *)
                         REG__NO_LAZY_FLUSH);      (* 2 *)

     REG_RESTORE_SET = SET OF REG_RESTORE_ENUM;

CONST REG_WHOLE_HIVE_VOLATILE = REG_RESTORE_SET {REG__WHOLE_HIVE_VOLATILE}; (* 00000001h; Restore whole hive volatile  *)
      REG_REFRESH_HIVE        = REG_RESTORE_SET {REG__REFRESH_HIVE};        (* 00000002h; Unwind changes to last flush *)
      REG_NO_LAZY_FLUSH       = REG_RESTORE_SET {REG__NO_LAZY_FLUSH};       (* 00000004h; Never lazy flush this hive   *)

(* Notify filter values *)

TYPE REG_NOTIFY_ENUM = (REG_NOTIFY__CHANGE_NAME,       (* 0 - Create or delete (child) *)
                        REG_NOTIFY__CHANGE_ATTRIBUTES, (* 1 *)
                        REG_NOTIFY__CHANGE_LAST_SET,   (* 2 - time stamp *)
                        REG_NOTIFY__CHANGE_SECURITY);  (* 3 *)
     REG_NOTIFY_SET = SET OF REG_NOTIFY_ENUM;

CONST REG_NOTIFY_CHANGE_NAME       = REG_NOTIFY_SET {REG_NOTIFY__CHANGE_NAME      }; (* 00000001h *)
      REG_NOTIFY_CHANGE_ATTRIBUTES = REG_NOTIFY_SET {REG_NOTIFY__CHANGE_ATTRIBUTES}; (* 00000002h *)
      REG_NOTIFY_CHANGE_LAST_SET   = REG_NOTIFY_SET {REG_NOTIFY__CHANGE_LAST_SET  }; (* 00000004h *)
      REG_NOTIFY_CHANGE_SECURITY   = REG_NOTIFY_SET {REG_NOTIFY__CHANGE_SECURITY  }; (* 00000008h *)

      REG_LEGAL_CHANGE_FILTER = REG_NOTIFY_CHANGE_NAME       +
                                REG_NOTIFY_CHANGE_ATTRIBUTES +
                                REG_NOTIFY_CHANGE_LAST_SET   +
                                REG_NOTIFY_CHANGE_SECURITY;


(*
** Predefined Value Types.
*)

TYPE REG_TYPE = (REG_NONE,                        (*  0 - No value type *)
                 REG_SZ,                          (*  1 - Unicode nul terminated string *)
                 REG_EXPAND_SZ,                   (*  2 - Unicode nul terminated string *)
                                                  (*      (with environment variable references) *)
                 REG_BINARY,                      (*  3 - Free form binary *)
                 REG_DWORD_LITTLE_ENDIAN,         (*  4 - 32-bit number (same as REG_DWORD) *)
                 REG_DWORD_BIG_ENDIAN,            (*  5 - 32-bit number *)
                 REG_LINK,                        (*  6 - Symbolic Link (unicode) *)
                 REG_MULTI_SZ,                    (*  7 - Multiple Unicode strings *)
                 REG_RESOURCE_LIST,               (*  8 - Resource list in the resource map *)
                 REG_FULL_RESOURCE_DESCRIPTOR,    (*  9 - Resource list in the hardware description *)
                 REG_RESOURCE_REQUIREMENTS_LIST); (* 10 *)

CONST REG_DWORD = REG_DWORD_LITTLE_ENDIAN;

(*
** Service Types (Bit Mask)
*)

TYPE SERVICE_ENUM = (SERVICE__KERNEL_DRIVER,        (* 0 *)
                     SERVICE__FILE_SYSTEM_DRIVER,   (* 1 *)
                     SERVICE__ADAPTER,              (* 2 *)
                     SERVICE__RECOGNIZER_DRIVER,    (* 3 *)
                     SERVICE__WIN32_OWN_PROCESS,    (* 4 *)
                     SERVICE__WIN32_SHARE_PROCESS,  (* 5 *)
                     SERVICE__6, SERVICE__7,
                     SERVICE__INTERACTIVE_PROCESS); (* 8 *)

     SERVICE_NODE_TYPE = SET OF SERVICE_ENUM;

CONST SERVICE_KERNEL_DRIVER          = SERVICE_NODE_TYPE {SERVICE__KERNEL_DRIVER     }; (* 00000001h *)
      SERVICE_FILE_SYSTEM_DRIVER     = SERVICE_NODE_TYPE {SERVICE__FILE_SYSTEM_DRIVER}; (* 00000002h *)
      SERVICE_ADAPTER                = SERVICE_NODE_TYPE {SERVICE__ADAPTER           }; (* 00000004h *)
      SERVICE_RECOGNIZER_DRIVER      = SERVICE_NODE_TYPE {SERVICE__RECOGNIZER_DRIVER }; (* 00000008h *)
      SERVICE_DRIVER                 = SERVICE_KERNEL_DRIVER +
                                       SERVICE_FILE_SYSTEM_DRIVER +
                                       SERVICE_RECOGNIZER_DRIVER;

      SERVICE_WIN32_OWN_PROCESS      = SERVICE_NODE_TYPE {SERVICE__WIN32_OWN_PROCESS      }; (* 00000010h *)
      SERVICE_WIN32_SHARE_PROCESS    = SERVICE_NODE_TYPE {SERVICE__WIN32_SHARE_PROCESS    }; (* 00000020h *)
      SERVICE_WIN32                  = SERVICE_WIN32_OWN_PROCESS +
                                       SERVICE_WIN32_SHARE_PROCESS;

      SERVICE_INTERACTIVE_PROCESS    = SERVICE_NODE_TYPE {SERVICE__INTERACTIVE_PROCESS    }; (* 00000100h *)

      SERVICE_TYPE_ALL               = SERVICE_WIN32   +
                                       SERVICE_ADAPTER +
                                       SERVICE_DRIVER  +
                                       SERVICE_INTERACTIVE_PROCESS;

(*
** Start Type
*)

TYPE SERVICE_LOAD_TYPE = (SERVICE_BOOT_START,   (* 00000000h *)
                          SERVICE_SYSTEM_START, (* 00000001h *)
                          SERVICE_AUTO_START,   (* 00000002h *)
                          SERVICE_DEMAND_START, (* 00000003h *)
                          SERVICE_DISABLED);    (* 00000004h *)

(*
** Error control type
*)

TYPE SERVICE_ERROR_TYPE = (SERVICE_ERROR_IGNORE,    (* 00000000h *)
                           SERVICE_ERROR_NORMAL,    (* 00000001h *)
                           SERVICE_ERROR_SEVERE,    (* 00000002h *)
                           SERVICE_ERROR_CRITICAL); (* 00000003h *)

(*
** Define the registry driver node enumerations
*)


CONST DriverType               = SERVICE_KERNEL_DRIVER;
      FileSystemType           = SERVICE_FILE_SYSTEM_DRIVER;
      Win32ServiceOwnProcess   = SERVICE_WIN32_OWN_PROCESS;
      Win32ServiceShareProcess = SERVICE_WIN32_SHARE_PROCESS;
      AdapterType              = SERVICE_ADAPTER;
      RecognizerType           = SERVICE_RECOGNIZER_DRIVER;

CONST BootLoad    = SERVICE_BOOT_START;
      SystemLoad  = SERVICE_SYSTEM_START;
      AutoLoad    = SERVICE_AUTO_START;
      DemandLoad  = SERVICE_DEMAND_START;
      DisableLoad = SERVICE_DISABLED;

CONST IgnoreError   = SERVICE_ERROR_IGNORE;
      NormalError   = SERVICE_ERROR_NORMAL;
      SevereError   = SERVICE_ERROR_SEVERE;
      CriticalError = SERVICE_ERROR_CRITICAL;


(*
** IOCTL_TAPE_ERASE definitions
*)

TYPE TAPE_ERASE_TYPE = (TAPE_ERASE_SHORT,  (* 0 *)
                        TAPE_ERASE_LONG ); (* 1 *)

TYPE TAPE_ERASE = RECORD
                         Type      : DWORD;
                         Immediate : BOOL8;
                  END;
    PTAPE_ERASE = POINTER TO TAPE_ERASE;

(*
** IOCTL_TAPE_PREPARE definitions
*)

TYPE TAPE_OPERATION = (TAPE_LOAD,      (* 0 *)
                       TAPE_UNLOAD,    (* 1 *)
                       TAPE_TENSION,   (* 2 *)
                       TAPE_LOCK,      (* 3 *)
                       TAPE_UNLOCK,    (* 4 *)
                       TAPE_FORMAT);   (* 5 *)

TYPE TAPE_PREPARE = RECORD
                           Operation : TAPE_OPERATION;
                           Immediate : BOOL8;
                    END;
    PTAPE_PREPARE = POINTER TO TAPE_PREPARE;

(*
** IOCTL_TAPE_WRITE_MARKS definitions
*)


TYPE TAPE_MARK_TYPE = (TAPE_SETMARKS,         (* 0 *)
                       TAPE_FILEMARKS,        (* 1 *)
                       TAPE_SHORT_FILEMARKS,  (* 2 *)
                       TAPE_LONG_FILEMARKS);  (* 3 *)

TYPE TAPE_WRITE_MARKS = RECORD
                               Type      : TAPE_MARK_TYPE;
                               Count     : DWORD;
                               Immediate : BOOL8;
                        END;
    PTAPE_WRITE_MARKS = POINTER TO TAPE_WRITE_MARKS;

(*
** IOCTL_TAPE_GET_POSITION definitions
*)

TYPE TAPE_GET_POSITION_TYPE = (TAPE_ABSOLUTE_POSITION,        (* 0 *)
                               TAPE_LOGICAL_POSITION,         (* 1 *)
                               TAPE_PSEUDO_LOGICAL_POSITION); (* 2 *)

TYPE TAPE_GET_POSITION = RECORD
                                Type      : TAPE_GET_POSITION_TYPE;
                                Partition : DWORD;
                                Offset    : LARGE_INTEGER;
                         END;
    PTAPE_GET_POSITION = POINTER TO TAPE_GET_POSITION;

(*
** IOCTL_TAPE_SET_POSITION definitions
*)

TYPE TAPE_SET_POSITION_TYPE = (TAPE_REWIND,                 (* 0 *)
                               TAPE_ABSOLUTE_BLOCK,         (* 1 *)
                               TAPE_LOGICAL_BLOCK,          (* 2 *)
                               TAPE_PSEUDO_LOGICAL_BLOCK,   (* 3 *)
                               TAPE_SPACE_END_OF_DATA,      (* 4 *)
                               TAPE_SPACE_RELATIVE_BLOCKS,  (* 5 *)
                               TAPE_SPACE_FILEMARKS,        (* 6 *)
                               TAPE_SPACE_SEQUENTIAL_FMKS,  (* 7 *)
                               TAPE_SPACE_SETMARKS,         (* 8 *)
                               TAPE_SPACE_SEQUENTIAL_SMKS); (* 9 *)

TYPE TAPE_SET_POSITION = RECORD
                                Method    : TAPE_SET_POSITION_TYPE;
                                Partition : DWORD;
                                Offset    : LARGE_INTEGER;
                                Immediate : BOOL8;
                         END;
    PTAPE_SET_POSITION = POINTER TO TAPE_SET_POSITION;

(*
** IOCTL_TAPE_GET_DRIVE_PARAMS definitions
*)


(*
** Definitions for FeaturesLow parameter
*)


CONST TAPE_DRIVE_FIXED            = { 0}; (* 00000001h *)
      TAPE_DRIVE_SELECT           = { 1}; (* 00000002h *)
      TAPE_DRIVE_INITIATOR        = { 2}; (* 00000004h *)

      TAPE_DRIVE_ERASE_SHORT      = { 4}; (* 00000010h *)
      TAPE_DRIVE_ERASE_LONG       = { 5}; (* 00000020h *)
      TAPE_DRIVE_ERASE_BOP_ONLY   = { 6}; (* 00000040h *)
      TAPE_DRIVE_ERASE_IMMEDIATE  = { 7}; (* 00000080h *)

      TAPE_DRIVE_TAPE_CAPACITY    = { 8}; (* 00000100h *)
      TAPE_DRIVE_TAPE_REMAINING   = { 9}; (* 00000200h *)
      TAPE_DRIVE_FIXED_BLOCK      = {10}; (* 00000400h *)
      TAPE_DRIVE_VARIABLE_BLOCK   = {11}; (* 00000800h *)

      TAPE_DRIVE_WRITE_PROTECT    = {12}; (* 00001000h *)
      TAPE_DRIVE_EOT_WZ_SIZE      = {13}; (* 00002000h *)

      TAPE_DRIVE_ECC              = {16}; (* 00010000h *)
      TAPE_DRIVE_COMPRESSION      = {17}; (* 00020000h *)
      TAPE_DRIVE_PADDING          = {18}; (* 00040000h *)
      TAPE_DRIVE_REPORT_SMKS      = {19}; (* 00080000h *)

      TAPE_DRIVE_GET_ABSOLUTE_BLK = {20}; (* 00100000h *)
      TAPE_DRIVE_GET_LOGICAL_BLK  = {21}; (* 00200000h *)
      TAPE_DRIVE_SET_EOT_WZ_SIZE  = {22}; (* 00400000h *)

      TAPE_DRIVE_RESERVED_BIT     = {31}; (* 80000000h;  don't use this bit! *)
                                                       (*can't be a low features bit! *)
                                                       (*reserved; high features only *)
(*
** Definitions for FeaturesHigh parameter
*)

      TAPE_DRIVE_LOAD_UNLOAD      = {31,0};  (* 80000001h *)
      TAPE_DRIVE_TENSION          = {31,1};  (* 80000002h *)
      TAPE_DRIVE_LOCK_UNLOCK      = {31,2};  (* 80000004h *)
      TAPE_DRIVE_REWIND_IMMEDIATE = {31,3};  (* 80000008h *)

      TAPE_DRIVE_SET_BLOCK_SIZE   = {31,4};  (* 80000010h *)
      TAPE_DRIVE_LOAD_UNLD_IMMED  = {31,5};  (* 80000020h *)
      TAPE_DRIVE_TENSION_IMMED    = {31,6};  (* 80000040h *)
      TAPE_DRIVE_LOCK_UNLK_IMMED  = {31,7};  (* 80000080h *)

      TAPE_DRIVE_SET_ECC          = {31,8};  (* 80000100h *)
      TAPE_DRIVE_SET_COMPRESSION  = {31,9};  (* 80000200h *)
      TAPE_DRIVE_SET_PADDING      = {31,10}; (* 80000400h *)
      TAPE_DRIVE_SET_REPORT_SMKS  = {31,11}; (* 80000800h *)

      TAPE_DRIVE_ABSOLUTE_BLK     = {31,12}; (* 80001000h *)
      TAPE_DRIVE_ABS_BLK_IMMED    = {31,13}; (* 80002000h *)
      TAPE_DRIVE_LOGICAL_BLK      = {31,14}; (* 80004000h *)
      TAPE_DRIVE_LOG_BLK_IMMED    = {31,15}; (* 80008000h *)

      TAPE_DRIVE_END_OF_DATA      = {31,16}; (* 80010000h *)
      TAPE_DRIVE_RELATIVE_BLKS    = {31,17}; (* 80020000h *)
      TAPE_DRIVE_FILEMARKS        = {31,18}; (* 80040000h *)
      TAPE_DRIVE_SEQUENTIAL_FMKS  = {31,19}; (* 80080000h *)

      TAPE_DRIVE_SETMARKS         = {31,20}; (* 80100000h *)
      TAPE_DRIVE_SEQUENTIAL_SMKS  = {31,21}; (* 80200000h *)
      TAPE_DRIVE_REVERSE_POSITION = {31,22}; (* 80400000h *)
      TAPE_DRIVE_SPACE_IMMEDIATE  = {31,23}; (* 80800000h *)

      TAPE_DRIVE_WRITE_SETMARKS   = {31,24}; (* 81000000h *)
      TAPE_DRIVE_WRITE_FILEMARKS  = {31,25}; (* 82000000h *)
      TAPE_DRIVE_WRITE_SHORT_FMKS = {31,26}; (* 84000000h *)
      TAPE_DRIVE_WRITE_LONG_FMKS  = {31,27}; (* 88000000h *)

      TAPE_DRIVE_WRITE_MARK_IMMED = {31,28}; (* 90000000h *)
      TAPE_DRIVE_FORMAT           = {31,29}; (* A0000000h *)
      TAPE_DRIVE_FORMAT_IMMEDIATE = {31,30}; (* C0000000h *)
      TAPE_DRIVE_HIGH_FEATURES    = {31};    (* 80000000h;  mask for high features flag *)

TYPE TAPE_GET_DRIVE_PARAMETERS =
     RECORD
            ECC                   : BOOL8;
            Compression           : BOOL8;
            DataPadding           : BOOL8;
            ReportSetmarks        : BOOL8;
            DefaultBlockSize      : DWORD;
            MaximumBlockSize      : DWORD;
            MinimumBlockSize      : DWORD;
            MaximumPartitionCount : DWORD;
            FeaturesLow           : BITSET;
            FeaturesHigh          : BITSET;
            EOTWarningZoneSize    : DWORD;
     END;
     PTAPE_GET_DRIVE_PARAMETERS = POINTER TO TAPE_GET_DRIVE_PARAMETERS;

(*
** IOCTL_TAPE_SET_DRIVE_PARAMETERS definitions
*)

TYPE TAPE_SET_DRIVE_PARAMETERS =
     RECORD
            ECC                : BOOL8;
            Compression        : BOOL8;
            DataPadding        : BOOL8;
            ReportSetmarks     : BOOL8;
            EOTWarningZoneSize : DWORD;
     END;
     PTAPE_SET_DRIVE_PARAMETERS = POINTER TO TAPE_SET_DRIVE_PARAMETERS;

(*
** IOCTL_TAPE_GET_MEDIA_PARAMETERS definitions
*)


TYPE TAPE_GET_MEDIA_PARAMETERS =
     RECORD
            Capacity       : LARGE_INTEGER;
            Remaining      : LARGE_INTEGER;
            BlockSize      : DWORD;
            PartitionCount : DWORD;
            WriteProtected : BOOL8;
     END;
     PTAPE_GET_MEDIA_PARAMETERS = POINTER TO TAPE_GET_MEDIA_PARAMETERS;

(*
** IOCTL_TAPE_SET_MEDIA_PARAMETERS definitions
*)


TYPE TAPE_SET_MEDIA_PARAMETERS =
     RECORD
            BlockSize : DWORD;
     END;
     PTAPE_SET_MEDIA_PARAMETERS = POINTER TO TAPE_SET_MEDIA_PARAMETERS;

(*
** IOCTL_TAPE_CREATE_PARTITION definitions
*)


TYPE TAPE_PARTITION_TYPE = (TAPE_FIXED_PARTITIONS,      (* 0 *)
                            TAPE_SELECT_PARTITIONS,     (* 1 *)
                            TAPE_INITIATOR_PARTITIONS); (* 2 *)

TYPE TAPE_CREATE_PARTITION =
     RECORD
            Method : TAPE_PARTITION_TYPE;
            Count : DWORD;
            Size : DWORD;
     END;
     PTAPE_CREATE_PARTITION = POINTER TO TAPE_CREATE_PARTITION;


END WinNT.
