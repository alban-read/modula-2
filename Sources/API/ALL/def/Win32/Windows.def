<* M2EXTENSIONS+ *>
<* IF BACKEND = "C" THEN *>
  <* NOHEADER+ *>
  <* GENTYPEDEF+ *>
<* ELSE *>
  <* ALIGNMENT = "8" *>
  <* ENUMSIZE = "4" *>
  <* SETSIZE = "4" *>
<* END *>
DEFINITION MODULE ["StdCall"] Windows;

IMPORT SYSTEM;


CONST CALLBACK = "StdCall";

CONST WINVER = 0400H;

TYPE
     ULONG  = SYSTEM.CARD32;
     USHORT = SYSTEM.CARD16;
     UCHAR  = CHAR;
     PULONG = POINTER TO ULONG;
     PUCHAR = POINTER TO UCHAR;
     PSZ    = POINTER TO CHAR;

CONST MAX_PATH = 260;

TYPE
     DWORD  = SYSTEM.CARD32;
     BOOL   = SYSTEM.BOOL32;
     BOOL8  = SYSTEM.BOOL8;
     BYTE   = SYSTEM.CARD8;
     INT8   = SYSTEM.INT8;
     CARD8  = SYSTEM.CARD8;
     WORD   = SYSTEM.CARD16;
     FLOAT  = REAL;
     PBOOL  = POINTER TO BOOL;
     PCHAR  = POINTER TO CHAR;
     PWORD  = POINTER TO SYSTEM.WORD;
     PBYTE  = POINTER TO SYSTEM.BYTE;
     PVOID  = POINTER TO SYSTEM.BYTE;
     LPCVOID = POINTER TO SYSTEM.BYTE;
     LPVOID = PVOID;
     PCARD8 = POINTER TO CARD8;
     PINT   = POINTER TO INTEGER;

     UINT   = SYSTEM.unsigned;
     PUINT  = POINTER TO UINT;
     SHORT  = SYSTEM.INT16;
     LONG   = SYSTEM.INT32;
     PLONG  = POINTER TO LONG;
     PSHORT = POINTER TO SHORT;

     LONGWORD = SYSTEM.CARD32; (* should be SYSTEM.LONGWORD in fact *)

     HANDLE = POINTER TO RECORD END;
     PHANDLE = POINTER TO HANDLE;
     PCHANDLE = PHANDLE;

     WPARAM  = UINT;
     LPARAM  = SYSTEM.INT32;
     LRESULT = SYSTEM.INT32;

     WCHAR   = SYSTEM.CARD16;

     PSTR    = POINTER TO CHAR;
     LPSTR   = POINTER TO CHAR;
     PWSTR   = POINTER TO WCHAR;
     PPSTR   = POINTER TO PSTR;
     PPWSTR  = POINTER TO PWSTR;
     PCSTR   = PSTR;
     PPCSTR  = POINTER TO PCSTR;
     PCWSTR  = PWSTR;
     PPCWSTR = POINTER TO PCWSTR;
     STRING  = PSTR;
     WSTRING = PWSTR;
     RESOURCESTRA = PCSTR;
     RESOURCESTRW = PCWSTR;
     ATOMSTR      = PCSTR;
     ATOMWSTR     = PCWSTR;
     STR     = POINTER TO ARRAY [0..MAX (INTEGER)-1] OF CHAR;
     WSTR    = POINTER TO ARRAY [0..MAX (INTEGER) DIV 2] OF WCHAR;

     INTARRAY = POINTER TO ARRAY [0..MAX (INTEGER) DIV 4-1] OF INTEGER;

     PCBYTE  = PBYTE;
     ATOM    = WORD;

     PDWORD  = POINTER TO DWORD;
     PCDWORD = PDWORD;

<* IF DEFINED (UNICODE) THEN *>
      TYPE RESOURCESTR = RESOURCESTRW;
<* ELSE *>
      TYPE RESOURCESTR = RESOURCESTRA;
<* END *>


CONST TRUE  = VAL (BOOL, 1);
      FALSE = VAL (BOOL, 0);

(* Convention of using PSTR-like parameters:
   [W]STRING        - pointer to a string that is used as input-output
                      or pure output parameter and can't be NIL or converted
                      integer value
   PC[W]STR         - pointer to constant string (input parameter) that can be
                      omited (NIL passed) or receive non-address values, such as
                      resource ids.
   P[W]STR          - same, input-output of pure output parameter
   RESOURCE[W]STR   - resource name: either pointer to constant string, or
                      result of MAKEINTRESOURCE call
   ATOM[W]STR       - either pointer to constant string or result
                      of MAKEINTATOM call
*)

PROCEDURE GetPSTR  (x : ARRAY OF CHAR)  : PSTR;
PROCEDURE GetPWSTR (x : ARRAY OF WCHAR) : PWSTR;

(* following procedures were macro in windef.h; in Modula-2 thay all
   are run-time functions *)

PROCEDURE max (a, b : INTEGER) : INTEGER;
PROCEDURE min (a, b : INTEGER) : INTEGER;

PROCEDURE MAKEWORD (lo, hi : BYTE) : WORD;
PROCEDURE MAKELONG (lo, hi : WORD) : DWORD;
PROCEDURE LOWORD (x : DWORD) : WORD;
PROCEDURE HIWORD (x : DWORD) : WORD;
PROCEDURE LOBYTE (x : WORD) : BYTE;
PROCEDURE HIBYTE (x : WORD) : BYTE;

TYPE
     HWND         = POINTER TO RECORD END;
     HHOOK        = POINTER TO RECORD END;
     HGLOBAL      = POINTER TO RECORD END;
     HLOCAL       = POINTER TO RECORD END;
     GLOBALHANDLE = POINTER TO RECORD END;
     LOCALHANDLE  = POINTER TO RECORD END;
     HGDIOBJ      = POINTER TO RECORD END;

     FARPROC  = PROCEDURE () : INTEGER;
     NEARPROC = PROCEDURE () : INTEGER;
     PROC     = PROCEDURE () : INTEGER;

     HACCEL     = POINTER TO RECORD END;
     HBITMAP    = HGDIOBJ;
     HBRUSH     = HGDIOBJ;
     HCOLORSPACE = POINTER TO RECORD END;
     HDC        = POINTER TO RECORD END;
     HGLRC      = POINTER TO RECORD END;         (*  OpenGL    *)
     HDESK      = POINTER TO RECORD END;
     HENHMETAFILE  = POINTER TO RECORD END;
     HFONT      = HGDIOBJ;
     HICON      = POINTER TO RECORD END;
     HMENU      = POINTER TO RECORD END;
     HMETAFILE  = POINTER TO RECORD END;
     HINSTANCE  = POINTER TO RECORD END;
     HMODULE    = HINSTANCE;      (* HMODULEs can be used in place of HINSTANCEs *)
     HPALETTE   = POINTER TO RECORD END;
     HPEN       = HGDIOBJ;
     HRGN       = HGDIOBJ;
     HRSRC      = POINTER TO RECORD END;
     HSTR       = POINTER TO RECORD END;
     HTASK      = POINTER TO RECORD END;
     HWINSTA    = POINTER TO RECORD END;
     HKL        = POINTER TO RECORD END;

     HFILE      = INTEGER;
     HCURSOR    = HICON; (* HICONs & HCURSORs are polymorphic *)

    COLORREF    = DWORD;

<* IF DEFINED (UNICODE) THEN *>
      TYPE PTSTR  = PWSTR;
           PCTSTR = PCWSTR;
           TCHAR  = WCHAR;
<* ELSE *>
      TYPE PTSTR  = PSTR;
           PCTSTR = PCSTR;
           TCHAR  = CHAR;
<* END *>


CONST HFILE_ERROR = -1;

TYPE
    RECT = RECORD
                left   : LONG;
                top    : LONG;
                right  : LONG;
                bottom : LONG;
           END;
    PRECT  = POINTER TO RECT;
    PCRECT = POINTER TO RECT;    (* pointer to constant rect *)

    RECTL = RECORD
                left   : LONG;
                top    : LONG;
                right  : LONG;
                bottom : LONG;
           END;
    PRECTL  = POINTER TO RECTL;
    PCRECTL = POINTER TO RECTL;

    POINT = RECORD
                x : LONG;
                y : LONG;
            END;
   PPOINT = POINTER TO POINT;

    POINTL = RECORD
                x : LONG;
                y : LONG;
             END;
   PPOINTL = POINTER TO POINT;

    POINTS = RECORD
                x : SHORT;
                y : SHORT;
             END;
   PPOINTS = POINTER TO POINTS;

    SIZEL  = RECORD   (* was SIZE in windef.h; SIZE is reserved in Modula-2 *)
                cx : LONG;
                cy : LONG;
             END;
    PSIZE  = POINTER TO SIZEL;
    PCSIZE = PSIZE;

PROCEDURE MyInstance () : HINSTANCE; (* Specially designed for Modula-2 *)



(*  WinNT.def

    This module defines the 32-Bit Windows types and constants that are
    defined by NT, but exposed through the Win32 API.

*)


TYPE PPDWORD = POINTER TO PDWORD;
     PPWORD  = POINTER TO PWORD;

CONST ANYSIZE_ARRAY = 1;

(*
** Define API decoration for direct importing system DLL references.
*)

TYPE CCHAR  = CHAR;
TYPE LCID   = DWORD;
TYPE PLCID  = PDWORD;
TYPE LANGID = WORD;

CONST APPLICATION_ERROR_MASK       = 20000000h;
      ERROR_SEVERITY_SUCCESS       = 00000000h;
      ERROR_SEVERITY_INFORMATIONAL = 40000000h;
      ERROR_SEVERITY_WARNING       = 80000000h;
      ERROR_SEVERITY_ERROR         = 0C0000000h;

TYPE LONGLONG = LONGREAL;
     DWORDLONG = LONGREAL;
     PLONGLONG  = POINTER TO LONGLONG;
     PDWORDLONG = POINTER TO DWORDLONG;

(* Update Sequence Number *)

TYPE USN = LONGLONG;

TYPE LARGE_INTEGER = RECORD
                            CASE : BOOLEAN OF
                            | TRUE  : LowPart  : DWORD;
                                      HighPart : LONG;
                            | FALSE : QuadPart : LONGLONG;
                            END;
                     END;
TYPE PLARGE_INTEGER = POINTER TO LARGE_INTEGER;

TYPE ULARGE_INTEGER = RECORD
                            CASE : BOOLEAN OF
                            | TRUE  : LowPart  : DWORD;
                                      HighPart : DWORD;
                            | FALSE : QuadPart : LONGLONG;
                            END;
                     END;
TYPE PULARGE_INTEGER = POINTER TO ULARGE_INTEGER;

(*
** Locally Unique Identifier
*)

TYPE  LUID = LARGE_INTEGER;
     PLUID = POINTER TO LUID;

(*
** Define operations to logically shift an int64 by 0..31 bits and to multiply
** 32-bits by 32-bits to form a 64-bit product.
*)

PROCEDURE Int32x32To64   (Multiplier, Multiplicand : LONG)  : LONGLONG;
PROCEDURE UInt32x32To64  (Multiplier, Multiplicand : DWORD) : DWORDLONG;
PROCEDURE Int64ShllMod32 (Value : DWORDLONG; ShiftCount : DWORD) : DWORDLONG;
PROCEDURE Int64ShraMod32 (Value : LONGLONG;  ShiftCount : DWORD) : LONGLONG;
PROCEDURE Int64ShrlMod32 (Value : DWORDLONG; ShiftCount : DWORD) : DWORDLONG;

CONST UNICODE_NULL = SYSTEM.CAST (WCHAR, VAL (SHORT, 0));
TYPE PBOOLEAN = POINTER TO BOOL8;

(*  Doubly linked list structure.  Can be used as either a list head, or
**  as link words.
*)

TYPE PLIST_ENTRY = POINTER TO LIST_ENTRY;
      LIST_ENTRY = RECORD
                          Flink : PLIST_ENTRY;
                          Blink : PLIST_ENTRY;
                   END;
(*
**  Singly linked list structure. Can be used as either a list head, or
**  as link words.
*)

TYPE PSINGLE_LIST_ENTRY = POINTER TO SINGLE_LIST_ENTRY;
      SINGLE_LIST_ENTRY = RECORD
                                Next : PSINGLE_LIST_ENTRY;
                          END;

(*
** Base data structures for OLE support
*)

TYPE BYTEARRAY8 = ARRAY [0..7] OF BYTE;

TYPE GUID = RECORD                (* size is 16 *)
                   Data1 : DWORD;
                   Data2 : WORD;
                   Data3 : WORD;
                   Data4 : BYTEARRAY8;
            END;
    PGUID = POINTER TO GUID;

TYPE OBJECTID = RECORD     (* size is 20 *)
                       Lineage    : GUID;
                       Uniquifier : DWORD;
                END;
    POBJECTID = POINTER TO OBJECTID;

CONST MINCHAR     = 80h;
      MAXCHAR     = 7fh;
      MINSHORT    = 8000h;
      MAXSHORT    = 7fffh;
      MINLONG     = 80000000h;
      MAXLONG     = 7fffffffh;
      MAXBYTE     = 0ffh;
      MAXWORD     = 0ffffh;
      MAXDWORD    = 0ffffffffh;

(*
 *  Language IDs.
 *
 *  The following two combinations of primary language ID and
 *  sublanguage ID have special semantics:
 *
 *    Primary Language ID   Sublanguage ID      Result
 *    -------------------   ---------------     ------------------------
 *    LANG_NEUTRAL          SUBLANG_NEUTRAL     Language neutral
 *    LANG_NEUTRAL          SUBLANG_DEFAULT     User default language
 *    LANG_NEUTRAL          SUBLANG_SYS_DEFAULT System default language
 *)

(*
 *  Primary language IDs.
 *)

CONST LANG_NEUTRAL                     = 00h;

      LANG_AFRIKAANS                   = 36h;
      LANG_ALBANIAN                    = 1ch;
      LANG_ARABIC                      = 01h;
      LANG_BASQUE                      = 2dh;
      LANG_BELARUSIAN                  = 23h;
      LANG_BULGARIAN                   = 02h;
      LANG_CATALAN                     = 03h;
      LANG_CHINESE                     = 04h;
      LANG_CROATIAN                    = 1ah;
      LANG_CZECH                       = 05h;
      LANG_DANISH                      = 06h;
      LANG_DUTCH                       = 13h;
      LANG_ENGLISH                     = 09h;
      LANG_ESTONIAN                    = 25h;
      LANG_FAEROESE                    = 38h;
      LANG_FARSI                       = 29h;
      LANG_FINNISH                     = 0bh;
      LANG_FRENCH                      = 0ch;
      LANG_GERMAN                      = 07h;
      LANG_GREEK                       = 08h;
      LANG_HEBREW                      = 0Dh;
      LANG_HUNGARIAN                   = 0eh;
      LANG_ICELANDIC                   = 0fh;
      LANG_INDONESIAN                  = 21h;
      LANG_ITALIAN                     = 10h;
      LANG_JAPANESE                    = 11h;
      LANG_KOREAN                      = 12h;
      LANG_LATVIAN                     = 26h;
      LANG_LITHUANIAN                  = 27h;
      LANG_NORWEGIAN                   = 14h;
      LANG_POLISH                      = 15h;
      LANG_PORTUGUESE                  = 16h;
      LANG_ROMANIAN                    = 18h;
      LANG_RUSSIAN                     = 19h;
      LANG_SERBIAN                     = 1Ah;
      LANG_SLOVAK                      = 1bh;
      LANG_SLOVENIAN                   = 24h;
      LANG_SPANISH                     = 0ah;
      LANG_SWEDISH                     = 1dh;
      LANG_THAI                        = 1eh;
      LANG_TURKISH                     = 1fh;
      LANG_UKRAINIAN                   = 22h;
      LANG_VIETNAMESE                  = 2ah;
(*
 *  Sublanguage IDs.
 *
 *  The name immediately following SUBLANG_ dictates which primary
 *  language ID that sublanguage ID can be combined with to form a
 *  valid language ID.
 *)

CONST SUBLANG_NEUTRAL                  = 00h;    (* language neutral *)
      SUBLANG_DEFAULT                  = 01h;    (* user default *)
      SUBLANG_SYS_DEFAULT              = 02h;    (* system default *)

      SUBLANG_ARABIC                   = 01h;    (* Arabic (Saudi Arabia) *)
      SUBLANG_ARABIC_IRAQ              = 02h;    (* Arabic (Iraq) *)
      SUBLANG_ARABIC_EGYPT             = 03h;    (* Arabic (Egypt) *)
      SUBLANG_ARABIC_LIBYA             = 04h;    (* Arabic (Libya) *)
      SUBLANG_ARABIC_ALGERIA           = 05h;    (* Arabic (Algeria) *)
      SUBLANG_ARABIC_MOROCCO           = 06h;    (* Arabic (Morocco) *)
      SUBLANG_ARABIC_TUNISIA           = 07h;    (* Arabic (Tunisia) *)
      SUBLANG_ARABIC_OMAN              = 08h;    (* Arabic (Oman) *)
      SUBLANG_ARABIC_YEMEN             = 09h;    (* Arabic (Yemen) *)
      SUBLANG_ARABIC_SYRIA             = 10h;    (* Arabic (Syria) *)
      SUBLANG_ARABIC_JORDAN            = 11h;    (* Arabic (Jordan) *)
      SUBLANG_ARABIC_LEBANON           = 12h;    (* Arabic (Lebanon) *)
      SUBLANG_ARABIC_KUWAIT            = 13h;    (* Arabic (Kuwait) *)
      SUBLANG_ARABIC_UAE               = 14h;    (* Arabic (United Arab Emirates) *)
      SUBLANG_ARABIC_BAHRAIN           = 15h;    (* Arabic (Bahrain) *)
      SUBLANG_ARABIC_QATAR             = 16h;    (* Arabic (Qatar) *)
      SUBLANG_CHINESE_TRADITIONAL      = 01h;    (* Chinese (Taiwan) *)
      SUBLANG_CHINESE_SIMPLIFIED       = 02h;    (* Chinese (PR China) *)
      SUBLANG_CHINESE_HONGKONG         = 03h;    (* Chinese (Hong Kong) *)
      SUBLANG_CHINESE_SINGAPORE        = 04h;    (* Chinese (Singapore) *)
      SUBLANG_DUTCH                    = 01h;    (* Dutch *)
      SUBLANG_DUTCH_BELGIAN            = 02h;    (* Dutch (Belgian) *)
      SUBLANG_ENGLISH_US               = 01h;    (* English (USA) *)
      SUBLANG_ENGLISH_UK               = 02h;    (* English (UK) *)
      SUBLANG_ENGLISH_AUS              = 03h;    (* English (Australian) *)
      SUBLANG_ENGLISH_CAN              = 04h;    (* English (Canadian) *)
      SUBLANG_ENGLISH_NZ               = 05h;    (* English (New Zealand) *)
      SUBLANG_ENGLISH_EIRE             = 06h;    (* English (Irish) *)
      SUBLANG_ENGLISH_SOUTH_AFRICA     = 07h;    (* English (South Africa) *)
      SUBLANG_ENGLISH_JAMAICA          = 08h;    (* English (Jamaica) *)
      SUBLANG_ENGLISH_CARRIBEAN        = 09h;    (* English (Carribean) *)
      SUBLANG_ENGLISH_BELIZE           = 0ah;    (* English (Belize) *)
      SUBLANG_ENGLISH_TRINIDAD         = 0bh;    (* English (Trinidad) *)

      SUBLANG_FRENCH                   = 01h;    (* French *)
      SUBLANG_FRENCH_BELGIAN           = 02h;    (* French (Belgian) *)
      SUBLANG_FRENCH_CANADIAN          = 03h;    (* French (Canadian) *)
      SUBLANG_FRENCH_SWISS             = 04h;    (* French (Swiss) *)
      SUBLANG_FRENCH_LUXEMBOURG        = 05h;    (* French (Luxembourg) *)
      SUBLANG_GERMAN                   = 01h;    (* German *)
      SUBLANG_GERMAN_SWISS             = 02h;    (* German (Swiss) *)
      SUBLANG_GERMAN_AUSTRIAN          = 03h;    (* German (Austrian) *)
      SUBLANG_GERMAN_LUXEMBOURG        = 04h;    (* German (Luxembourg) *)
      SUBLANG_GERMAN_LIECHTENSTEIN     = 05h;    (* German (Liechtenstein) *)
      SUBLANG_ITALIAN                  = 01h;    (* Italian *)
      SUBLANG_ITALIAN_SWISS            = 02h;    (* Italian (Swiss) *)
      SUBLANG_KOREAN                   = 01h;    (* Korean *)
      SUBLANG_KOREAN_JOHAB             = 02h;    (* Korean (Johab) *)
      SUBLANG_NORWEGIAN_BOKMAL         = 01h;    (* Norwegian (Bokmal) *)
      SUBLANG_NORWEGIAN_NYNORSK        = 02h;    (* Norwegian (Nynorsk) *)
      SUBLANG_PORTUGUESE               = 02h;    (* Portuguese *)
      SUBLANG_PORTUGUESE_BRAZILIAN     = 01h;    (* Portuguese (Brazilian) *)
      SUBLANG_SPANISH                  = 01h;    (* Spanish (Castilian) *)
      SUBLANG_SPANISH_MEXICAN          = 02h;    (* Spanish (Mexican) *)
      SUBLANG_SPANISH_MODERN           = 03h;    (* Spanish (Modern) *)
      SUBLANG_SPANISH_GUATEMALA        = 04h;    (* Spanish (Guatemala) *)
      SUBLANG_SPANISH_COSTARICA        = 05h;    (* Spanish (Costa Rica) *)
      SUBLANG_SPANISH_PANAMA           = 06h;    (* Spanish (Panama) *)
      SUBLANG_SPANISH_DOMINICAN_REPUBLIC = 07h;  (* Spanish (Dominican Republic) *)
      SUBLANG_SPANISH_VENEZUELA        = 08h;    (* Spanish (Venezuela) *)
      SUBLANG_SPANISH_COLOMBIA         = 09h;    (* Spanish (Colombia) *)
      SUBLANG_SPANISH_PERU             = 10h;    (* Spanish (Peru) *)
      SUBLANG_SPANISH_ARGENTINA        = 11h;    (* Spanish (Argentina) *)
      SUBLANG_SPANISH_ECUADOR          = 12h;    (* Spanish (Ecuador) *)
      SUBLANG_SPANISH_CHILE            = 13h;    (* Spanish (Chile) *)
      SUBLANG_SPANISH_URUGUAY          = 14h;    (* Spanish (Uruguay) *)
      SUBLANG_SPANISH_PARAGUAY         = 15h;    (* Spanish (Paraguay) *)
      SUBLANG_SPANISH_BOLIVIA          = 16h;    (* Spanish (Bolivia) *)
      SUBLANG_SPANISH_EL_SALVADOR      = 11h;    (* Spanish (El Salvador) *)
      SUBLANG_SPANISH_HONDURAS         = 12h;    (* Spanish (Honduras) *)
      SUBLANG_SPANISH_NICARAGUA        = 13h;    (* Spanish (Nicaragua) *)
      SUBLANG_SPANISH_PUERTO_RICO      = 14h;    (* Spanish (Puerto Rico) *)
      SUBLANG_SWEDISH                  = 01h;    (* Swedish *)
      SUBLANG_SWEDISH_FINLAND          = 02h;    (* Swedish (Finland) *)

(*
 *  Sorting IDs.
 *
 *)
      SORT_DEFAULT                     = 0;      (* sorting default *)

      SORT_JAPANESE_XJIS               = 0;       (* Japanese XJIS order *)
      SORT_JAPANESE_UNICODE            = 1;       (* Japanese Unicode order *)

      SORT_CHINESE_BIG5                = 0;       (* Chinese BIG5 order *)
      SORT_CHINESE_UNICODE             = 1;       (* Chinese Unicode order *)

      SORT_KOREAN_KSC                  = 0;       (* Korean KSC order *)
      SORT_KOREAN_UNICODE              = 1;       (* Korean Unicode order *)

      SORT_GERMAN_PHONE_BOOK           = 1;       (* German Phone Book order *)

(*
 *  A language ID is a 16 bit value which is the combination of a
 *  primary language ID and a secondary language ID.  The bits are
 *  allocated as follows:
 *
 *       +-----------------------+-------------------------+
 *       |     Sublanguage ID    |   Primary Language ID   |
 *       +-----------------------+-------------------------+
 *        15                   10 9                       0   bit
 *
 *
 *  Language ID creation/extraction macros:
 *
 *    MAKELANGID    - construct language id from a primary language id and
 *                    a sublanguage id.
 *    PRIMARYLANGID - extract primary language id from a language id.
 *    SUBLANGID     - extract sublanguage id from a language id.
 *)

PROCEDURE MAKELANGID    (primary, sublang : WORD) : LANGID;
PROCEDURE PRIMARYLANGID (id : LANGID) : WORD;
PROCEDURE SUBLANGID     (id : LANGID) : WORD;

(*
 *  A locale ID is a 32 bit value which is the combination of a
 *  language ID, a sort ID, and a reserved area.  The bits are
 *  allocated as follows:
 *
 *       +-------------+---------+-------------------------+
 *       |   Reserved  | Sort ID |      Language ID        |
 *       +-------------+---------+-------------------------+
 *        31         20 19     16 15                      0   bit
 *
 *
 *  Locale ID creation/extraction macros:
 *
 *    MAKELCID       - construct locale id from a language id and a sort id.
 *    LANGIDFROMLCID - extract language id from a locale id.
 *    SORTIDFROMLCID - extract sort id from a locale id.
 *)

CONST NLS_VALID_LOCALE_MASK  = 000fffffh;

PROCEDURE MAKELCID (lgid : LANGID; srtid : WORD) : LCID;
PROCEDURE LANGIDFROMLCID (lcid : LCID) : LANGID;
PROCEDURE SORTIDFROMLCID (lcid : LCID) : LANGID;

(*
 *  Default System and User IDs for language and locale.
 *)

CONST LANG_SYSTEM_DEFAULT = 2048;
      LANG_USER_DEFAULT   = 1024;

CONST LOCALE_SYSTEM_DEFAULT  = 2048;
      LOCALE_USER_DEFAULT    = 1024;

<* IF NOT DEFINED (WIN32_NO_STATUS) THEN *>

CONST STATUS_WAIT_0                    = 00000000h;
      STATUS_ABANDONED_WAIT_0          = 00000080h;
      STATUS_USER_APC                  = 000000C0h;
      STATUS_TIMEOUT                   = 00000102h;
      STATUS_PENDING                   = 00000103h;
      STATUS_SEGMENT_NOTIFICATION      = 40000005h;
      STATUS_GUARD_PAGE_VIOLATION      = 80000001h;
      STATUS_DATATYPE_MISALIGNMENT     = 80000002h;
      STATUS_BREAKPOINT                = 80000003h;
      STATUS_SINGLE_STEP               = 80000004h;
      STATUS_ACCESS_VIOLATION          = 0C0000005h;
      STATUS_IN_PAGE_ERROR             = 0C0000006h;
      STATUS_INVALID_HANDLE            = 0C0000008h;
      STATUS_NO_MEMORY                 = 0C0000017h;
      STATUS_ILLEGAL_INSTRUCTION       = 0C000001Dh;
      STATUS_NONCONTINUABLE_EXCEPTION  = 0C0000025h;
      STATUS_INVALID_DISPOSITION       = 0C0000026h;
      STATUS_ARRAY_BOUNDS_EXCEEDED     = 0C000008Ch;
      STATUS_FLOAT_DENORMAL_OPERAND    = 0C000008Dh;
      STATUS_FLOAT_DIVIDE_BY_ZERO      = 0C000008Eh;
      STATUS_FLOAT_INEXACT_RESULT      = 0C000008Fh;
      STATUS_FLOAT_INVALID_OPERATION   = 0C0000090h;
      STATUS_FLOAT_OVERFLOW            = 0C0000091h;
      STATUS_FLOAT_STACK_CHECK         = 0C0000092h;
      STATUS_FLOAT_UNDERFLOW           = 0C0000093h;
      STATUS_INTEGER_DIVIDE_BY_ZERO    = 0C0000094h;
      STATUS_INTEGER_OVERFLOW          = 0C0000095h;
      STATUS_PRIVILEGED_INSTRUCTION    = 0C0000096h;
      STATUS_STACK_OVERFLOW            = 0C00000FDh;
      STATUS_CONTROL_C_EXIT            = 0C000013Ah;

<* END *> (* NOT DEFINED (WIN32_NO_STATUS) *)

CONST MAXIMUM_WAIT_OBJECTS = 64;     (* Maximum number of wait objects *)
CONST MAXIMUM_SUSPEND_COUNT = MAXCHAR; (* Maximum times thread can be suspended *)

TYPE KSPIN_LOCK = DWORD;

PROCEDURE GetFiberData () : PVOID;
PROCEDURE GetCurrentFiber () : PVOID;

(*
**  Define the size of the 80387 save area, which is in the context frame.
*)

CONST SIZE_OF_80387_REGISTERS = 80;

(*
** The following flags control the contents of the CONTEXT structure.
*)

CONST CONTEXT_i386    = {16}; (* 00010000h - this assumes that i386 and *)
      CONTEXT_i486    = {16}; (* 00010000h - i486 have identical context records *)

      CONTEXT_CONTROL         = CONTEXT_i386 + {0}; (* SS:SP, CS:IP, FLAGS, BP *)
      CONTEXT_INTEGER         = CONTEXT_i386 + {1}; (* AX, BX, CX, DX, SI, DI *)
      CONTEXT_SEGMENTS        = CONTEXT_i386 + {2}; (* DS, ES, FS, GS *)
      CONTEXT_FLOATING_POINT  = CONTEXT_i386 + {3}; (* 387 state *)
      CONTEXT_DEBUG_REGISTERS = CONTEXT_i386 + {4}; (* DB 0-3,6,7 *)

      CONTEXT_FULL = CONTEXT_CONTROL + CONTEXT_INTEGER + CONTEXT_SEGMENTS;

TYPE FLOATING_SAVE_AREA = RECORD
                                 ControlWord   : DWORD;
                                 StatusWord    : DWORD;
                                 TagWord       : DWORD;
                                 ErrorOffset   : DWORD;
                                 ErrorSelector : DWORD;
                                 DataOffset    : DWORD;
                                 DataSelector  : DWORD;
                                 RegisterArea  : ARRAY [0..SIZE_OF_80387_REGISTERS-1] OF BYTE;
                                 Cr0NpxState   : DWORD;
                          END;

TYPE PFLOATING_SAVE_AREA  = POINTER TO FLOATING_SAVE_AREA;

(*
** Context Frame
**  This frame has a several purposes: 1) it is used as an argument to
**  NtContinue, 2) is is used to constuct a call frame for APC delivery,
**  and 3) it is used in the user level thread creation routines.
**
**  The layout of the record conforms to a standard call frame.
*)

TYPE CONTEXT = RECORD

    (*
    ** The flags values within this flag control the contents of
    ** a CONTEXT record.
    **
    ** If the context record is used as an input parameter, then
    ** for each portion of the context record controlled by a flag
    ** whose value is set, it is assumed that that portion of the
    ** context record contains valid context. If the context record
    ** is being used to modify a threads context, then only that
    ** portion of the threads context will be modified.
    **
    ** If the context record is used as an IN OUT parameter to capture
    ** the context of a thread, then only those portions of the thread's
    ** context corresponding to set flags will be returned.
    **
    ** The context record is never used as an OUT only parameter.
    *)

    ContextFlags : BITSET;

    (*
    ** This section is specified/returned if CONTEXT_DEBUG_REGISTERS is
    ** set in ContextFlags.  Note that CONTEXT_DEBUG_REGISTERS is NOT
    ** included in CONTEXT_FULL.
    *)

    Dr0 : DWORD;
    Dr1 : DWORD;
    Dr2 : DWORD;
    Dr3 : DWORD;
    Dr6 : DWORD;
    Dr7 : DWORD;

    (*
    ** This section is specified/returned if the
    ** ContextFlags word contians the flag CONTEXT_FLOATING_POINT.
    *)

    FloatSave : FLOATING_SAVE_AREA;

    (*
    ** This section is specified/returned if the
    ** ContextFlags word contians the flag CONTEXT_SEGMENTS.
    *)

    SegGs : DWORD;
    SegFs : DWORD;
    SegEs : DWORD;
    SegDs : DWORD;

    (*
    ** This section is specified/returned if the
    ** ContextFlags word contians the flag CONTEXT_INTEGER.
    *)

    Edi : DWORD;
    Esi : DWORD;
    Ebx : DWORD;
    Edx : DWORD;
    Ecx : DWORD;
    Eax : DWORD;

    (*
    ** This section is specified/returned if the
    ** ContextFlags word contians the flag CONTEXT_CONTROL.
    *)

    Ebp    : DWORD;
    Eip    : DWORD;
    SegCs  : DWORD;             (* MUST BE SANITIZED *)
    EFlags : DWORD;             (* MUST BE SANITIZED *)
    Esp    : DWORD;
    SegSs  : DWORD;
END;

TYPE PCONTEXT = POINTER TO CONTEXT;

TYPE LDT_ENTRY = RECORD
                        LimitLow : WORD;
                        BaseLow : WORD;
                        BaseMid : BYTE;
                        Flags1  : BYTE; (* Declare as bytes to avoid alignment *)
                        Flags2  : BYTE; (* Problems. *)
                        BaseHi  : BYTE;
                 END;
    PLDT_ENTRY = POINTER TO LDT_ENTRY;

CONST EXCEPTION_NONCONTINUABLE     = 1;   (* Noncontinuable exception *)
      EXCEPTION_MAXIMUM_PARAMETERS = 15;  (* maximum number of exception parameters *)

(*
** Exception record definition.
*)

TYPE PEXCEPTION_RECORD = POINTER TO EXCEPTION_RECORD;
      EXCEPTION_RECORD = RECORD
                                ExceptionCode    : DWORD;
                                ExceptionFlags   : DWORD;
                                ExceptionRecord  : PEXCEPTION_RECORD;
                                ExceptionAddress : PVOID;
                                NumberParameters : DWORD;
                                ExceptionInformation : ARRAY [0..EXCEPTION_MAXIMUM_PARAMETERS-1] OF DWORD;
                         END;

(*
** Typedef for pointer returned by exception_info()
*)

TYPE EXCEPTION_POINTERS = RECORD
                                 ExceptionRecord : PEXCEPTION_RECORD;
                                 ContextRecord : PCONTEXT;
                          END;
    PEXCEPTION_POINTERS = POINTER TO EXCEPTION_POINTERS;

(* Here in winnt.h there're process object access masks; they're moved below
   where all access masks are defined *)

CONST MAXIMUM_PROCESSORS = 32;

CONST TLS_MINIMUM_AVAILABLE = 64;

TYPE PNT_TIB = POINTER TO NT_TIB;
     NT_TIB = RECORD
                   ExceptionList : PVOID; (* PEXCEPTION_REGISTRATION_RECORD *)
                   StackBase     : PVOID;
                   StackLimit    : PVOID;
                   SubSystemTib  : PVOID;
                   CASE: BOOLEAN OF
                   | TRUE : FiberData : PVOID;
                   | FALSE : Version : DWORD;
                   END;
                   ArbitraryUserPointer : PVOID;
                   Self                 : PNT_TIB;
              END;

CONST THREAD_BASE_PRIORITY_LOWRT  = 15;  (* value that gets a thread to LowRealtime-1 *)
      THREAD_BASE_PRIORITY_MAX    = 2;   (* maximum thread base priority boost *)
      THREAD_BASE_PRIORITY_MIN    = -2;  (* minimum thread base priority boost *)
      THREAD_BASE_PRIORITY_IDLE   = -15; (* value that gets a thread to idle *)

TYPE QUOTA_LIMITS = RECORD
                           PagedPoolLimit        : DWORD;
                           NonPagedPoolLimit     : DWORD;
                           MinimumWorkingSetSize : DWORD;
                           MaximumWorkingSetSize : DWORD;
                           PagefileLimit         : DWORD;
                           TimeLimit             : LARGE_INTEGER;
                    END;
    PQUOTA_LIMITS = POINTER TO QUOTA_LIMITS;

(* Here should be eventand semaphore access masks; they're moved below where all access masks ara defined *)

TYPE TIME_ZONE_ENUM = (TIME_ZONE_ID_UNKNOWN,   (* 0 *)
                       TIME_ZONE_ID_STANDARD,  (* 1 *)
                       TIME_ZONE_ID_DAYLIGHT); (* 2 *)

CONST PROCESSOR_INTEL_386     = 386;
      PROCESSOR_INTEL_486     = 486;
      PROCESSOR_INTEL_PENTIUM = 586;
      PROCESSOR_MIPS_R4000    = 4000;
      PROCESSOR_ALPHA_21064   = 21064;


<* PUSH *> <* ENUMSIZE = "2" *>

TYPE PROCESSOR_ARCHITECTURE_ENUM = (PROCESSOR_ARCHITECTURE_INTEL, (* 0 *)
                                    PROCESSOR_ARCHITECTURE_MIPS,  (* 1 *)
                                    PROCESSOR_ARCHITECTURE_ALPHA, (* 2 *)
                                    PROCESSOR_ARCHITECTURE_PPC);  (* 3 *)

CONST PROCESSOR_ARCHITECTURE_UNKNOWN = SYSTEM.CAST (PROCESSOR_ARCHITECTURE_ENUM, 0FFFFh);

<* POP *>

(* IsProcessorFeaturePresent parameters *)

TYPE PF_ENUM = (PF_FLOATING_POINT_PRECISION_ERRATA, (* 0 - In rare circumstances,
                                                           a floating-point
                                                           precision error can occur (Pentium). *)
                PF_FLOATING_POINT_EMULATED,         (* 1 - Floating-point operations
                                                           are emulated using a software emulator. *)
                PF_COMPARE_EXCHANGE_DOUBLE,         (* 2 - The compare and exchange double operation
                                                           is available (Pentium, MIPS, and Alpha). *)
                PF_MMX_INSTRUCTIONS_AVAILABLE);     (* 3 - The MMX instruction set is available *)

TYPE PROTECT_ENUM = (PROTECT_0, PROTECT_1, PROTECT_2, PROTECT_3,
                     PROTECT_4, PROTECT_5, PROTECT_6, PROTECT_7,
                     PROTECT_8, PROTECT_9, PROTECT_10,PROTECT_11,
                     PROTECT_12,PROTECT_13,PROTECT_14,PROTECT_15,
                     PROTECT_16,PROTECT_17,PROTECT_18,PROTECT_19,
                     PROTECT_20,PROTECT_21,PROTECT_22,PROTECT_23,
                     PROTECT_24,PROTECT_25,PROTECT_26,PROTECT_27,
                     PROTECT_28);

     PROTECT_SET = SET OF PROTECT_ENUM;

CONST PAGE_NOACCESS          = PROTECT_SET {PROTECT_0};  (* 01h; *)
      PAGE_READONLY          = PROTECT_SET {PROTECT_1};  (* 02h; *)
      PAGE_READWRITE         = PROTECT_SET {PROTECT_2};  (* 04h; *)
      PAGE_WRITECOPY         = PROTECT_SET {PROTECT_3};  (* 08h; *)
      PAGE_EXECUTE           = PROTECT_SET {PROTECT_4};  (* 10h; *)
      PAGE_EXECUTE_READ      = PROTECT_SET {PROTECT_5};  (* 20h; *)
      PAGE_EXECUTE_READWRITE = PROTECT_SET {PROTECT_6};  (* 40h; *)
      PAGE_EXECUTE_WRITECOPY = PROTECT_SET {PROTECT_7};  (* 80h; *)
      PAGE_GUARD             = PROTECT_SET {PROTECT_8};  (* 100h; *)
      PAGE_NOCACHE           = PROTECT_SET {PROTECT_9};  (* 200h; *)
      MEM_COMMIT             = PROTECT_SET {PROTECT_12}; (* 1000h; *)
      MEM_RESERVE            = PROTECT_SET {PROTECT_13}; (* 2000h; *)
      MEM_DECOMMIT           = PROTECT_SET {PROTECT_14}; (* 4000h; *)
      MEM_RELEASE            = PROTECT_SET {PROTECT_15}; (* 8000h; *)
      MEM_FREE               = PROTECT_SET {PROTECT_16}; (* 10000h; *)
      MEM_PRIVATE            = PROTECT_SET {PROTECT_17}; (* 20000h; *)
      MEM_MAPPED             = PROTECT_SET {PROTECT_18}; (* 40000h; *)
      MEM_RESET              = PROTECT_SET {PROTECT_19}; (* 80000h; *)
      MEM_TOP_DOWN           = PROTECT_SET {PROTECT_20}; (* 100000h; *)
      SEC_FILE               = PROTECT_SET {PROTECT_23}; (* 800000h; *)
      SEC_IMAGE              = PROTECT_SET {PROTECT_24}; (* 1000000h; *)
      SEC_RESERVE            = PROTECT_SET {PROTECT_26}; (* 4000000h; *)
      SEC_COMMIT             = PROTECT_SET {PROTECT_27}; (* 8000000h; *)
      SEC_NOCACHE            = PROTECT_SET {PROTECT_28}; (* 10000000h; *)
      MEM_IMAGE              = SEC_IMAGE;

TYPE MEMORY_BASIC_INFORMATION = RECORD
                                       BaseAddress       : PVOID;
                                       AllocationBase    : PVOID;
                                       AllocationProtect : PROTECT_SET;
                                       RegionSize        : DWORD;
                                       State             : PROTECT_SET;
                                       Protect           : PROTECT_SET;
                                       Type              : PROTECT_SET;
                                END;
    PMEMORY_BASIC_INFORMATION = POINTER TO MEMORY_BASIC_INFORMATION;


TYPE FILE_SHARE_ENUM = (FILE_SHARE__READ,    (* 0 *)
                        FILE_SHARE__WRITE,   (* 1 *)
                        FILE_SHARE__DELETE); (* 2 *)

     FILE_SHARE_MODE = SET OF FILE_SHARE_ENUM;

CONST FILE_SHARE_READ   = FILE_SHARE_MODE {FILE_SHARE__READ};   (* 00000001h *)
      FILE_SHARE_WRITE  = FILE_SHARE_MODE {FILE_SHARE__WRITE};  (* 00000002h *)
      FILE_SHARE_DELETE = FILE_SHARE_MODE {FILE_SHARE__DELETE}; (* 00000004h *)

(* FILE_BIT_ENUM and FILE_BITFLAGS_SET are generic types used for:
   - file attributes (FILE_ATTRIBUTE_SET)
   - file creation modes (FILE_FLAG_SET)
   - security type of service (SECURITY_SET)
   - named pipe modes
*)

TYPE FILE_BIT_ENUM = (F_0,  F_1,  F_2,  F_3,
                      F_4,  F_5,  F_6,  F_7,
                      F_8,  F_9,  F_10, F_11,
                      F_12, F_13, F_14, F_15,
                      F_16, F_17, F_18, F_19,
                      F_20, F_21, F_22, F_23,
                      F_24, F_25, F_26, F_27,
                      F_28, F_29, F_30, F_31);

     FILE_BIT_SET = SET OF FILE_BIT_ENUM;

TYPE FILE_ATTRIBUTE_ENUM = FILE_BIT_ENUM;

CONST FILE_ATTRIBUTE__READONLY   = F_0;
      FILE_ATTRIBUTE__HIDDEN     = F_1;
      FILE_ATTRIBUTE__SYSTEM     = F_2;
      FILE_ATTRIBUTE__DIRECTORY  = F_4;
      FILE_ATTRIBUTE__ARCHIVE    = F_5;
      FILE_ATTRIBUTE__NORMAL     = F_7;
      FILE_ATTRIBUTE__TEMPORARY  = F_8;
      FILE_ATTRIBUTE__COMPRESSED = F_11;
      FILE_ATTRIBUTE__OFFLINE    = F_12;

TYPE FILE_ATTRIBUTE_SET = FILE_BIT_SET;

CONST FILE_ATTRIBUTE_READONLY   = FILE_ATTRIBUTE_SET {FILE_ATTRIBUTE__READONLY  }; (* 00000001h *)
      FILE_ATTRIBUTE_HIDDEN     = FILE_ATTRIBUTE_SET {FILE_ATTRIBUTE__HIDDEN    }; (* 00000002h *)
      FILE_ATTRIBUTE_SYSTEM     = FILE_ATTRIBUTE_SET {FILE_ATTRIBUTE__SYSTEM    }; (* 00000004h *)
      FILE_ATTRIBUTE_DIRECTORY  = FILE_ATTRIBUTE_SET {FILE_ATTRIBUTE__DIRECTORY }; (* 00000010h *)
      FILE_ATTRIBUTE_ARCHIVE    = FILE_ATTRIBUTE_SET {FILE_ATTRIBUTE__ARCHIVE   }; (* 00000020h *)
      FILE_ATTRIBUTE_NORMAL     = FILE_ATTRIBUTE_SET {FILE_ATTRIBUTE__NORMAL    }; (* 00000080h *)
      FILE_ATTRIBUTE_TEMPORARY  = FILE_ATTRIBUTE_SET {FILE_ATTRIBUTE__TEMPORARY }; (* 00000100h *)
      FILE_ATTRIBUTE_COMPRESSED = FILE_ATTRIBUTE_SET {FILE_ATTRIBUTE__COMPRESSED}; (* 00000800h *)
      FILE_ATTRIBUTE_OFFLINE    = FILE_ATTRIBUTE_SET {FILE_ATTRIBUTE__OFFLINE};    (* 00001000h *)

TYPE FILE_NOTIFY_ENUM = (FILE_NOTIFY__CHANGE_FILE_NAME,   (* 0 *)
                         FILE_NOTIFY__CHANGE_DIR_NAME,    (* 1 *)
                         FILE_NOTIFY__CHANGE_ATTRIBUTES,  (* 2 *)
                         FILE_NOTIFY__CHANGE_SIZE,        (* 3 *)
                         FILE_NOTIFY__CHANGE_LAST_WRITE,  (* 4 *)
                         FILE_NOTIFY__CHANGE_LAST_ACCESS, (* 5*)
                         FILE_NOTIFY__CHANGE_CREATION,    (* 6 *)
                         FILE_NOTIFY__7,
                         FILE_NOTIFY__CHANGE_SECURITY);   (* 8 *)

     FILE_NOTIFY_SET = SET OF FILE_NOTIFY_ENUM;

CONST FILE_NOTIFY_CHANGE_FILE_NAME  = FILE_NOTIFY_SET {FILE_NOTIFY__CHANGE_FILE_NAME }; (* 00000001h *)
      FILE_NOTIFY_CHANGE_DIR_NAME   = FILE_NOTIFY_SET {FILE_NOTIFY__CHANGE_DIR_NAME  }; (* 00000002h *)
      FILE_NOTIFY_CHANGE_ATTRIBUTES = FILE_NOTIFY_SET {FILE_NOTIFY__CHANGE_ATTRIBUTES}; (* 00000004h *)
      FILE_NOTIFY_CHANGE_SIZE       = FILE_NOTIFY_SET {FILE_NOTIFY__CHANGE_SIZE      }; (* 00000008h *)
      FILE_NOTIFY_CHANGE_LAST_WRITE = FILE_NOTIFY_SET {FILE_NOTIFY__CHANGE_LAST_WRITE}; (* 00000010h *)
      FILE_NOTIFY_CHANGE_LAST_ACCESS= FILE_NOTIFY_SET {FILE_NOTIFY__CHANGE_LAST_ACCESS};(* 00000100h *)
      FILE_NOTIFY_CHANGE_CREATION   = FILE_NOTIFY_SET {FILE_NOTIFY__CHANGE_CREATION  }; (* 00000100h *)
      FILE_NOTIFY_CHANGE_SECURITY   = FILE_NOTIFY_SET {FILE_NOTIFY__CHANGE_SECURITY  }; (* 00000100h *)

TYPE FILE_ACTION_ENUM = (FILE_ACTION_0,
                         FILE_ACTION_ADDED,              (* 1 *)
                         FILE_ACTION_REMOVED,            (* 2 *)
                         FILE_ACTION_MODIFIED,           (* 3 *)
                         FILE_ACTION_RENAMED_OLD_NAME,   (* 4 *)
                         FILE_ACTION_RENAMED_NEW_NAME);  (* 5 *)

CONST MAILSLOT_NO_MESSAGE   = SYSTEM.CAST (DWORD, VAL (LONG, -1));
      MAILSLOT_WAIT_FOREVER = SYSTEM.CAST (DWORD, VAL (LONG, -1));

TYPE FILESYSTEM_ENUM = (FILE__CASE_SENSITIVE_SEARCH,  (*  0 *)
                        FILE__CASE_PRESERVED_NAMES,   (*  1 *)
                        FILE__UNICODE_ON_DISK,        (*  2 *)
                        FILE__PERSISTENT_ACLS,        (*  3 *)
                        FILE__FILE_COMPRESSION,       (*  4 *)
                        FILE__5, FILE__6, FILE__7,
                        FILE__8, FILE__9, FILE__10,
                        FILE__11,FILE__12,FILE__13,
                        FILE__14,
                        FILE__VOLUME_IS_COMPRESSED);  (* 15*)

     FILESYSTEM_FLAGS = SET OF FILESYSTEM_ENUM;

CONST FILE_CASE_SENSITIVE_SEARCH = FILESYSTEM_FLAGS {FILE__CASE_SENSITIVE_SEARCH}; (* 00000001h *)
      FILE_CASE_PRESERVED_NAMES  = FILESYSTEM_FLAGS {FILE__CASE_PRESERVED_NAMES }; (* 00000002h *)
      FILE_UNICODE_ON_DISK       = FILESYSTEM_FLAGS {FILE__UNICODE_ON_DISK      }; (* 00000004h *)
      FILE_PERSISTENT_ACLS       = FILESYSTEM_FLAGS {FILE__PERSISTENT_ACLS      }; (* 00000008h *)
      FILE_FILE_COMPRESSION      = FILESYSTEM_FLAGS {FILE__FILE_COMPRESSION     }; (* 00000010h *)
      FILE_VOLUME_IS_COMPRESSED  = FILESYSTEM_FLAGS {FILE__VOLUME_IS_COMPRESSED }; (* 00008000h *)

TYPE FILE_NOTIFY_INFORMATION = RECORD
                                    NextEntryOffset : DWORD;
                                    Action          : FILE_ACTION_ENUM;
                                    FileNameLength  : DWORD;
                                    FileName        : ARRAY [0..0] OF WCHAR;
                               END;

(* DuplicateHandle options *)

TYPE DUPLICATE_ENUM = (DUPLICATE__CLOSE_SOURCE, (* 0 *)
                       DUPLICATE__SAME_ACCESS); (* 1 *)

     DUPLICATE_TYPE = SET OF DUPLICATE_ENUM;

CONST DUPLICATE_CLOSE_SOURCE = DUPLICATE_TYPE {DUPLICATE__CLOSE_SOURCE};  (* 00000001h *)
      DUPLICATE_SAME_ACCESS  = DUPLICATE_TYPE {DUPLICATE__SAME_ACCESS};   (* 00000002h *)

TYPE PACCESS_TOKEN = PVOID;
TYPE PSECURITY_DESCRIPTOR = PVOID;
TYPE PSID = PVOID;

(***********************************************************************
**                                                                    **
**                             ACCESS MASK                            **
**                                                                    **
***********************************************************************)


(*
**  Define the access mask as a longword sized structure divided up as
**  follows:
**
**       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
**       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
**      +---------------+---------------+-------------------------------+
**      |G|G|G|G|Res'd|A| StandardRights|         SpecificRights        |
**      |R|W|E|A|     |S|               |                               |
**      +-+-------------+---------------+-------------------------------+
**
**      typedef struct _ACCESS_MASK {
**          WORD   SpecificRights;
**          BYTE  StandardRights;
**          BYTE  AccessSystemAcl : 1;
**          BYTE  Reserved : 3;
**          BYTE  GenericAll : 1;
**          BYTE  GenericExecute : 1;
**          BYTE  GenericWrite : 1;
**          BYTE  GenericRead : 1;
**      } ACCESS_MASK;
**
**  but to make life simple for programmer's we'll allow them to specify
**  a desired access mask by simply OR'ing together mulitple single rights
**  and treat an access mask as a DWORD.  For example
**
**      DesiredAccess = DELETE | READ_CONTROL
**
**  So we'll declare ACCESS_MASK as DWORD
**  Modula-2 note: DWORD was converted into a bitset.
*)

TYPE ACCESS_ENUM = (ACCESS_0, ACCESS_1, ACCESS_2, ACCESS_3,
                    ACCESS_4, ACCESS_5, ACCESS_6, ACCESS_7,
                    ACCESS_8, ACCESS_9, ACCESS_10,ACCESS_11,
                    ACCESS_12,ACCESS_13,ACCESS_14,ACCESS_15,
                    ACCESS_16,ACCESS_17,ACCESS_18,ACCESS_19,
                    ACCESS_20,ACCESS_21,ACCESS_22,ACCESS_23,
                    ACCESS_24,ACCESS_25,ACCESS_26,ACCESS_27,
                    ACCESS_28,ACCESS_29,ACCESS_30,ACCESS_31);

     ACCESS_MASK = SET OF ACCESS_ENUM;
    PACCESS_MASK = POINTER TO ACCESS_MASK;

(***********************************************************************
**                                                                    **
**                             ACCESS TYPES                           **
**                                                                    **
***********************************************************************)

(*
**  The following are masks for the predefined standard access types
*)

CONST DELETE                           = ACCESS_MASK {ACCESS_16}; (* 00010000h *)
      READ_CONTROL                     = ACCESS_MASK {ACCESS_17}; (* 00020000h *)
      WRITE_DAC                        = ACCESS_MASK {ACCESS_18}; (* 00040000h *)
      WRITE_OWNER                      = ACCESS_MASK {ACCESS_19}; (* 00080000h *)
      SYNCHRONIZE                      = ACCESS_MASK {ACCESS_20}; (* 00100000h *)

      STANDARD_RIGHTS_REQUIRED         = ACCESS_MASK {ACCESS_16..ACCESS_19}; (* 000F0000h *)

      STANDARD_RIGHTS_READ             = READ_CONTROL;
      STANDARD_RIGHTS_WRITE            = READ_CONTROL;
      STANDARD_RIGHTS_EXECUTE          = READ_CONTROL;

      STANDARD_RIGHTS_ALL              = ACCESS_MASK {ACCESS_16..ACCESS_20}; (* 001F0000h *)

      SPECIFIC_RIGHTS_ALL              = ACCESS_MASK {ACCESS_0..ACCESS_15}; (* 0000FFFFh *)

(*
** AccessSystemAcl access type
*)

      ACCESS_SYSTEM_SECURITY           = ACCESS_MASK {ACCESS_24}; (* 01000000h *)

(*
** MaximumAllowed access type
*)


      MAXIMUM_ALLOWED                  = ACCESS_MASK {ACCESS_25}; (* 02000000h *)

(*
**  These are the generic rights.
*)

      GENERIC_READ                     = ACCESS_MASK {ACCESS_31}; (* 80000000h *)
      GENERIC_WRITE                    = ACCESS_MASK {ACCESS_30}; (* 40000000h *)
      GENERIC_EXECUTE                  = ACCESS_MASK {ACCESS_29}; (* 20000000h *)
      GENERIC_ALL                      = ACCESS_MASK {ACCESS_28}; (* 10000000h *)

(* some specific access rights *)

CONST PROCESS_TERMINATE         = ACCESS_MASK {ACCESS_0};  (* 0001h *)
      PROCESS_CREATE_THREAD     = ACCESS_MASK {ACCESS_1};  (* 0002h *)
      PROCESS_VM_OPERATION      = ACCESS_MASK {ACCESS_3};  (* 0008h *)
      PROCESS_VM_READ           = ACCESS_MASK {ACCESS_4};  (* 0010h *)
      PROCESS_VM_WRITE          = ACCESS_MASK {ACCESS_5};  (* 0020h *)
      PROCESS_DUP_HANDLE        = ACCESS_MASK {ACCESS_6};  (* 0040h *)
      PROCESS_CREATE_PROCESS    = ACCESS_MASK {ACCESS_7};  (* 0080h *)
      PROCESS_SET_QUOTA         = ACCESS_MASK {ACCESS_8};  (* 0100h *)
      PROCESS_SET_INFORMATION   = ACCESS_MASK {ACCESS_9};  (* 0200h *)
      PROCESS_QUERY_INFORMATION = ACCESS_MASK {ACCESS_10}; (* 0400h *)
      PROCESS_ALL_ACCESS        = STANDARD_RIGHTS_REQUIRED + SYNCHRONIZE +
                                  ACCESS_MASK {ACCESS_0..ACCESS_11};

      THREAD_TERMINATE               = ACCESS_MASK {ACCESS_0}; (* 0001h *)
      THREAD_SUSPEND_RESUME          = ACCESS_MASK {ACCESS_1}; (* 0002h *)
      THREAD_GET_CONTEXT             = ACCESS_MASK {ACCESS_3}; (* 0008h *)
      THREAD_SET_CONTEXT             = ACCESS_MASK {ACCESS_4}; (* 0010h *)
      THREAD_SET_INFORMATION         = ACCESS_MASK {ACCESS_5}; (* 0020h *)
      THREAD_QUERY_INFORMATION       = ACCESS_MASK {ACCESS_6}; (* 0040h *)
      THREAD_SET_THREAD_TOKEN        = ACCESS_MASK {ACCESS_7}; (* 0080h *)
      THREAD_IMPERSONATE             = ACCESS_MASK {ACCESS_8}; (* 0100h *)
      THREAD_DIRECT_IMPERSONATION    = ACCESS_MASK {ACCESS_9}; (* 0200h *)

      THREAD_ALL_ACCESS         = STANDARD_RIGHTS_REQUIRED + SYNCHRONIZE +
                                  ACCESS_MASK {ACCESS_0 .. ACCESS_9};

CONST EVENT_MODIFY_STATE     = ACCESS_MASK {ACCESS_1};  (* 0x0002 *)
      EVENT_ALL_ACCESS       = STANDARD_RIGHTS_REQUIRED + SYNCHRONIZE +
                               ACCESS_MASK {ACCESS_0, ACCESS_1};

      MUTANT_QUERY_STATE     = ACCESS_MASK {ACCESS_0};  (* 0x0001 *)
      MUTANT_ALL_ACCESS      = STANDARD_RIGHTS_REQUIRED + SYNCHRONIZE +
                               MUTANT_QUERY_STATE;

      SEMAPHORE_MODIFY_STATE = ACCESS_MASK {ACCESS_1};  (* 0x0002 *)
      SEMAPHORE_ALL_ACCESS   = STANDARD_RIGHTS_REQUIRED + SYNCHRONIZE +
                               ACCESS_MASK {ACCESS_0, ACCESS_1};

CONST SECTION_QUERY       = ACCESS_MASK {ACCESS_0}; (* 0001h *)
      SECTION_MAP_WRITE   = ACCESS_MASK {ACCESS_1}; (* 0002h *)
      SECTION_MAP_READ    = ACCESS_MASK {ACCESS_2}; (* 0004h *)
      SECTION_MAP_EXECUTE = ACCESS_MASK {ACCESS_3}; (* 0008h *)
      SECTION_EXTEND_SIZE = ACCESS_MASK {ACCESS_4}; (* 0010h *)

      SECTION_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED +
                            SECTION_QUERY +
                            SECTION_MAP_WRITE +
                            SECTION_MAP_READ +
                            SECTION_MAP_EXECUTE +
                            SECTION_EXTEND_SIZE;

(*
** Define access rights to files and directories
*)

CONST FILE_READ_DATA            = ACCESS_MASK {ACCESS_0}; (* 0001h - file & pipe *)
      FILE_LIST_DIRECTORY       = ACCESS_MASK {ACCESS_0}; (* 0001h - directory *)

      FILE_WRITE_DATA           = ACCESS_MASK {ACCESS_1}; (* 0002h - file & pipe *)
      FILE_ADD_FILE             = ACCESS_MASK {ACCESS_1}; (* 0002h - directory *)

      FILE_APPEND_DATA          = ACCESS_MASK {ACCESS_2}; (* 0004h - file *)
      FILE_ADD_SUBDIRECTORY     = ACCESS_MASK {ACCESS_2}; (* 0004h - directory *)
      FILE_CREATE_PIPE_INSTANCE = ACCESS_MASK {ACCESS_2}; (* 0004h - named pipe *)

      FILE_READ_EA              = ACCESS_MASK {ACCESS_3}; (* 0008h - file & directory *)
      FILE_READ_PROPERTIES      = FILE_READ_EA;

      FILE_WRITE_EA             = ACCESS_MASK {ACCESS_4}; (* 0010h - file & directory *)
      FILE_WRITE_PROPERTIES     = FILE_WRITE_EA;

      FILE_EXECUTE              = ACCESS_MASK {ACCESS_5}; (* 0020h - file *)
      FILE_TRAVERSE             = ACCESS_MASK {ACCESS_5}; (* 0020h - directory *)

      FILE_DELETE_CHILD         = ACCESS_MASK {ACCESS_6}; (* 0040h - directory *)

      FILE_READ_ATTRIBUTES      = ACCESS_MASK {ACCESS_7}; (* 0080h - all *)

      FILE_WRITE_ATTRIBUTES     = ACCESS_MASK {ACCESS_8}; (* 0100h - all *)

      FILE_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED + SYNCHRONIZE + ACCESS_MASK {ACCESS_0..ACCESS_8};

      FILE_GENERIC_READ         = STANDARD_RIGHTS_READ +
                                  FILE_READ_DATA +
                                  FILE_READ_ATTRIBUTES +
                                  FILE_READ_EA +
                                  SYNCHRONIZE;

      FILE_GENERIC_WRITE        = STANDARD_RIGHTS_WRITE +
                                  FILE_WRITE_DATA +
                                  FILE_WRITE_ATTRIBUTES +
                                  FILE_WRITE_EA +
                                  FILE_APPEND_DATA +
                                  SYNCHRONIZE;


      FILE_GENERIC_EXECUTE      = STANDARD_RIGHTS_EXECUTE +
                                  FILE_READ_ATTRIBUTES +
                                  FILE_EXECUTE +
                                  SYNCHRONIZE;

      IO_COMPLETION_MODIFY_STATE = ACCESS_MASK {ACCESS_1}; (* 0002h *)
      IO_COMPLETION_ALL_ACCESS   = STANDARD_RIGHTS_REQUIRED + SYNCHRONIZE +
                                   ACCESS_MASK {ACCESS_0, ACCESS_1};


(*
**  Define the generic mapping array.  This is used to denote the
**  mapping of each generic access right to a specific access mask.
*)

TYPE GENERIC_MAPPING = RECORD
                              GenericRead    : ACCESS_MASK;
                              GenericWrite   : ACCESS_MASK;
                              GenericExecute : ACCESS_MASK;
                              GenericAll     : ACCESS_MASK;
                       END;
    PGENERIC_MAPPING = POINTER TO GENERIC_MAPPING;

(***********************************************************************
**                                                                    **
**                        LUID_AND_ATTRIBUTES                         **
**                                                                    **
***********************************************************************)

<* PUSH *> <* ALIGNMENT = "4" *>

TYPE LUID_AND_ATTRIBUTES = RECORD
                                  Luid       : LUID;
                                  Attributes : BITSET;
                           END;
    PLUID_AND_ATTRIBUTES = POINTER TO LUID_AND_ATTRIBUTES;

<* POP *>

(***********************************************************************
**                                                                    **
**              Security Id     (SID)                                 **
**                                                                    **
************************************************************************
**
**
** Pictorially the structure of an SID is as follows:
**
**         1   1   1   1   1   1
**         5   4   3   2   1   0   9   8   7   6   5   4   3   2   1   0
**      +---------------------------------------------------------------+
**      |      SubAuthorityCount        |Reserved1 (SBZ)|   Revision    |
**      +---------------------------------------------------------------+
**      |                   IdentifierAuthority[0]                      |
**      +---------------------------------------------------------------+
**      |                   IdentifierAuthority[1]                      |
**      +---------------------------------------------------------------+
**      |                   IdentifierAuthority[2]                      |
**      +---------------------------------------------------------------+
**      |                                                               |
**      +- -  -  -  -  -  -  -  SubAuthority[]  -  -  -  -  -  -  -  - -+
**      |                                                               |
**      +---------------------------------------------------------------+
**
*)

TYPE BYTE6 = ARRAY [0..5] OF BYTE;
TYPE SID_IDENTIFIER_AUTHORITY = RECORD
                                       Value : BYTE6;
                                END;
    PSID_IDENTIFIER_AUTHORITY = POINTER TO SID_IDENTIFIER_AUTHORITY;

TYPE SID = RECORD
                  Revision : BYTE;
                  SubAuthorityCount : BYTE;
                  IdentifierAuthority : SID_IDENTIFIER_AUTHORITY;
                  SubAuthority : ARRAY [0..0] OF DWORD;
           END;
    PISID = POINTER TO SID;

CONST SID_REVISION                     =  1;    (* Current revision level *)
      SID_MAX_SUB_AUTHORITIES          = 15;
      SID_RECOMMENDED_SUB_AUTHORITIES  =  1;    (* Will change to around 6 *)
                                                (* in a future release. *)

TYPE SID_NAME_USE = (SID_NAME_USE_0,
                     SidTypeUser,
                     SidTypeGroup,
                     SidTypeDomain,
                     SidTypeAlias,
                     SidTypeWellKnownGroup,
                     SidTypeDeletedAccount,
                     SidTypeInvalid,
                     SidTypeUnknown);
     PSID_NAME_USE = POINTER TO SID_NAME_USE;

TYPE SID_AND_ATTRIBUTES = RECORD
                                 Sid : PSID;
                                 Attributes : BITSET;
                          END;
    PSID_AND_ATTRIBUTES = POINTER TO SID_AND_ATTRIBUTES;


(***************************************************************************/
**                                                                         **
** Universal well-known SIDs                                               **
**                                                                         **
**     Null SID                     S-1-0-0                                **
**     World                        S-1-1-0                                **
**     Local                        S-1-2-0                                **
**     Creator Owner ID             S-1-3-0                                **
**     Creator Group ID             S-1-3-1                                **
**     Creator Owner Server ID      S-1-3-2                                **
**     Creator Group Server ID      S-1-3-3                                **
**                                                                         **
**     (Non-unique IDs)      S-1-4                                         **
**                                                                         **
****************************************************************************)


CONST SECURITY_NULL_SID_AUTHORITY     = SID_IDENTIFIER_AUTHORITY {BYTE6 {0,0,0,0,0,0}};
      SECURITY_WORLD_SID_AUTHORITY    = SID_IDENTIFIER_AUTHORITY {BYTE6 {0,0,0,0,0,1}};
      SECURITY_LOCAL_SID_AUTHORITY    = SID_IDENTIFIER_AUTHORITY {BYTE6 {0,0,0,0,0,2}};
      SECURITY_CREATOR_SID_AUTHORITY  = SID_IDENTIFIER_AUTHORITY {BYTE6 {0,0,0,0,0,3}};
      SECURITY_NON_UNIQUE_AUTHORITY   = SID_IDENTIFIER_AUTHORITY {BYTE6 {0,0,0,0,0,4}};

      SECURITY_NULL_RID               = 00000000h;
      SECURITY_WORLD_RID              = 00000000h;
      SECURITY_LOCAL_RID              = 00000000h;

      SECURITY_CREATOR_OWNER_RID      = 00000000h;
      SECURITY_CREATOR_GROUP_RID      = 00000001h;

      SECURITY_CREATOR_OWNER_SERVER_RID = 00000002h;
      SECURITY_CREATOR_GROUP_SERVER_RID = 00000003h;

(***************************************************************************/
**                                                                         **
** NT well-known SIDs                                                      **
**                                                                         **
**     NT Authority          S-1-5                                         **
**     Dialup                S-1-5-1                                       **
**                                                                         **
**     Network               S-1-5-2                                       **
**     Batch                 S-1-5-3                                       **
**     Interactive           S-1-5-4                                       **
**     Service               S-1-5-6                                       **
**     AnonymousLogon        S-1-5-7       (aka null logon session)        **
**     Proxy                 S-1-5-8                                       **
**     ServerLogon           S-1-5-8       (aka domain controller account) **
**                                                                         **
**     (Logon IDs)           S-1-5-5-X-Y                                   **
**                                                                         **
**     (NT non-unique IDs)   S-1-5-15h-...                                 **
**                                                                         **
**     (Built-in domain)     s-1-5-20h                                     **
**                                                                         **
****************************************************************************)


CONST SECURITY_NT_AUTHORITY           = SID_IDENTIFIER_AUTHORITY {BYTE6{0,0,0,0,0,5}};

      SECURITY_DIALUP_RID             = 00000001h;
      SECURITY_NETWORK_RID            = 00000002h;
      SECURITY_BATCH_RID              = 00000003h;
      SECURITY_INTERACTIVE_RID        = 00000004h;
      SECURITY_SERVICE_RID            = 00000006h;
      SECURITY_ANONYMOUS_LOGON_RID    = 00000007h;
      SECURITY_PROXY_RID              = 00000008h;
      SECURITY_SERVER_LOGON_RID       = 00000009h;

      SECURITY_LOGON_IDS_RID          = 00000005h;
      SECURITY_LOGON_IDS_RID_COUNT    = 3;

      SECURITY_LOCAL_SYSTEM_RID       = 00000012h;

      SECURITY_NT_NON_UNIQUE          = 00000015h;

      SECURITY_BUILTIN_DOMAIN_RID     = 00000020h;

(****************************************************************************
**                                                                         **
** well-known domain relative sub-authority values (RIDs)...               **
**                                                                         **
****************************************************************************)

(* Well-known users ... *)

CONST DOMAIN_USER_RID_ADMIN          = 000001F4h;
      DOMAIN_USER_RID_GUEST          = 000001F5h;



(* well-known groups ... *)

      DOMAIN_GROUP_RID_ADMINS        = 00000200h;
      DOMAIN_GROUP_RID_USERS         = 00000201h;
      DOMAIN_GROUP_RID_GUESTS        = 00000202h;

(* well-known aliases ... *)

      DOMAIN_ALIAS_RID_ADMINS        = 00000220h;
      DOMAIN_ALIAS_RID_USERS         = 00000221h;
      DOMAIN_ALIAS_RID_GUESTS        = 00000222h;
      DOMAIN_ALIAS_RID_POWER_USERS   = 00000223h;

      DOMAIN_ALIAS_RID_ACCOUNT_OPS   = 00000224h;
      DOMAIN_ALIAS_RID_SYSTEM_OPS    = 00000225h;
      DOMAIN_ALIAS_RID_PRINT_OPS     = 00000226h;
      DOMAIN_ALIAS_RID_BACKUP_OPS    = 00000227h;

      DOMAIN_ALIAS_RID_REPLICATOR    = 00000228h;


(***********************************************************************
**                                                                    **
**                          User and Group related SID attributes     **
**                                                                    **
***********************************************************************)

(*
** Group attributes
*)

CONST SE_GROUP_MANDATORY              = {0};     (* 00000001h *)
      SE_GROUP_ENABLED_BY_DEFAULT     = {1};     (* 00000002h *)
      SE_GROUP_ENABLED                = {2};     (* 00000004h *)
      SE_GROUP_OWNER                  = {3};     (* 00000008h *)
      SE_GROUP_LOGON_ID               = {31,30}; (* 0C0000000h *)

(*
** User attributes
*)

(* (None yet defined.) *)


(***********************************************************************
**                                                                    **
**                         ACL  and  ACE                              **
**                                                                    **
***********************************************************************)

(*
**  Define an ACL and the ACE format.  The structure of an ACL header
**  followed by one or more ACEs.  Pictorally the structure of an ACL header
**  is as follows:
**
**       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
**       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
**      +-------------------------------+---------------+---------------+
**      |            AclSize            |      Sbz1     |  AclRevision  |
**      +-------------------------------+---------------+---------------+
**      |              Sbz2             |           AceCount            |
**      +-------------------------------+-------------------------------+
**
**  The current AclRevision is defined to be ACL_REVISION.
**
**  AclSize is the size, in bytes, allocated for the ACL.  This includes
**  the ACL header, ACES, and remaining free space in the buffer.
**
**  AceCount is the number of ACES in the ACL.
*)


(* This is the *current* ACL revision *)

      ACL_REVISION     = 2;

(* This is the history of ACL revisions.  Add a new one whenever
** ACL_REVISION is updated
*)

      ACL_REVISION1   = 1;
      ACL_REVISION2   = 2;
      ACL_REVISION3   = 3;

TYPE ACL = RECORD
                  AclRevision : BYTE;
                  Sbz1        : BYTE;
                  AclSize     : WORD;
                  AceCount    : WORD;
                  Sbz2        : WORD;
           END;
    PACL = POINTER TO ACL;

(*
**  The structure of an ACE is a common ace header followed by ace type
**  specific data.  Pictorally the structure of the common ace header is
**  as follows:
**
**       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
**       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
**      +---------------+-------+-------+---------------+---------------+
**      |            AceSize            |    AceFlags   |     AceType   |
**      +---------------+-------+-------+---------------+---------------+
**
**  AceType denotes the type of the ace, there are some predefined ace
**  types
**
**  AceSize is the size, in bytes, of ace.
**
**  AceFlags are the Ace flags for audit and inheritance, defined shortly.
*)

(*
**  The following are the predefined ace types that go into the AceType
**  field of an Ace header.
*)

<* PUSH *> <* ENUMSIZE = "1" *>

TYPE ACE_TYPE_ENUM = (ACCESS_ALLOWED_ACE_TYPE, (* 0 *)
                      ACCESS_DENIED_ACE_TYPE,  (* 1 *)
                      SYSTEM_AUDIT_ACE_TYPE,   (* 2 *)
                      SYSTEM_ALARM_ACE_TYPE);  (* 3 *)

<* POP *>

(*
**  The following are the inherit flags that go into the AceFlags field
**  of an Ace header.
*)

TYPE ACE_FLAGS_ENUM = (OBJECT_INHERIT__ACE,       (* 0 *)
                       CONTAINER_INHERIT__ACE,    (* 1 *)
                       NO_PROPAGATE_INHERIT__ACE, (* 2 *)
                       INHERIT_ONLY__ACE,         (* 3 *)
                       ACE_FLAG__4,
                       ACE_FLAG__5,
                       SUCCESSFUL_ACCESS__ACE_FLAG, (* 6 *)
                       FAILED_ACCESS__ACE_FLAG);    (* 7 *)

<* PUSH *> <* SETSIZE = "1" *>

TYPE ACE_FLAGS_SET = SET OF ACE_FLAGS_ENUM;

<* POP *>

CONST OBJECT_INHERIT_ACE       = ACE_FLAGS_SET {OBJECT_INHERIT__ACE};       (* 1 *)
      CONTAINER_INHERIT_ACE    = ACE_FLAGS_SET {CONTAINER_INHERIT__ACE};    (* 2 *)
      NO_PROPAGATE_INHERIT_ACE = ACE_FLAGS_SET {NO_PROPAGATE_INHERIT__ACE}; (* 4 *)
      INHERIT_ONLY_ACE         = ACE_FLAGS_SET {INHERIT_ONLY__ACE};         (* 8 *)

      VALID_INHERIT_FLAGS      = OBJECT_INHERIT_ACE +
                                 CONTAINER_INHERIT_ACE +
                                 NO_PROPAGATE_INHERIT_ACE +
                                 INHERIT_ONLY_ACE;

(*  The following are the currently defined ACE flags that go into the
**  AceFlags field of an ACE header.  Each ACE type has its own set of
**  AceFlags.
**
**  SUCCESSFUL_ACCESS_ACE_FLAG - used only with system audit and alarm ACE
**  types to indicate that a message is generated for successful accesses.
**
**  FAILED_ACCESS_ACE_FLAG - used only with system audit and alarm ACE types
**  to indicate that a message is generated for failed accesses.
*)


(*
**  SYSTEM_AUDIT and SYSTEM_ALARM AceFlags
**
**  These control the signaling of audit and alarms for success or failure.
*)


CONST SUCCESSFUL_ACCESS_ACE_FLAG = ACE_FLAGS_SET {SUCCESSFUL_ACCESS__ACE_FLAG}; (* 40h *)
      FAILED_ACCESS_ACE_FLAG     = ACE_FLAGS_SET {FAILED_ACCESS__ACE_FLAG};     (* 80h *)

TYPE ACE_HEADER = RECORD
                         AceType  : ACE_TYPE_ENUM;
                         AceFlags : ACE_FLAGS_SET;
                         AceSize  : WORD;
                  END;
    PACE_HEADER = POINTER TO ACE_HEADER;

(*
**  We'll define the structure of the predefined ACE types.  Pictorally
**  the structure of the predefined ACE's is as follows:
**
**       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
**       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
**      +---------------+-------+-------+---------------+---------------+
**      |    AceFlags   | Resd  |Inherit|    AceSize    |     AceType   |
**      +---------------+-------+-------+---------------+---------------+
**      |                              Mask                             |
**      +---------------------------------------------------------------+
**      |                                                               |
**      +                                                               +
**      |                                                               |
**      +                              Sid                              +
**      |                                                               |
**      +                                                               +
**      |                                                               |
**      +---------------------------------------------------------------+
**
**  Mask is the access mask associated with the ACE.  This is either the
**  access allowed, access denied, audit, or alarm mask.
**
**  Sid is the Sid associated with the ACE.
*)

(*  The following are the four predefined ACE types.
**
**  Examine the AceType field in the Header to determine
**  which structure is appropriate to use for casting.
*)

TYPE ACCESS_ALLOWED_ACE = RECORD
                                 Header   : ACE_HEADER;
                                 Mask     : ACCESS_MASK;
                                 SidStart : DWORD;
                          END;
    PACCESS_ALLOWED_ACE = POINTER TO ACCESS_ALLOWED_ACE;

TYPE ACCESS_DENIED_ACE = RECORD
                                Header   : ACE_HEADER;
                                Mask     : ACCESS_MASK;
                                SidStart : DWORD;
                         END;
    PACCESS_DENIED_ACE = POINTER TO ACCESS_DENIED_ACE;

TYPE SYSTEM_AUDIT_ACE = RECORD
                               Header   : ACE_HEADER;
                               Mask     : ACCESS_MASK;
                               SidStart : DWORD;
                        END;
    PSYSTEM_AUDIT_ACE = POINTER TO SYSTEM_AUDIT_ACE;

TYPE SYSTEM_ALARM_ACE = RECORD
                               Header   : ACE_HEADER;
                               Mask     : ACCESS_MASK;
                               SidStart : DWORD;
                        END;
    PSYSTEM_ALARM_ACE = POINTER TO SYSTEM_ALARM_ACE;

(*
**  The following declarations are used for setting and querying information
**  about and ACL.  First are the various information classes available to
**  the user.
*)

TYPE ACL_INFORMATION_CLASS = (ACL_INFORMATION_0,
                              AclRevisionInformation,
                              AclSizeInformation);

(*
**  This record is returned/sent if the user is requesting/setting the
**  AclRevisionInformation
*)

TYPE ACL_REVISION_INFORMATION = RECORD
                                       AclRevision : DWORD;
                                END;
    PACL_REVISION_INFORMATION = POINTER TO ACL_REVISION_INFORMATION;

(*
**  This record is returned if the user is requesting AclSizeInformation
*)

TYPE ACL_SIZE_INFORMATION = RECORD
                                   AceCount      : DWORD;
                                   AclBytesInUse : DWORD;
                                   AclBytesFree  : DWORD;
                            END;
    PACL_SIZE_INFORMATION = POINTER TO ACL_SIZE_INFORMATION;

(***********************************************************************
**                                                                    **
**                             SECURITY_DESCRIPTOR                    **
**                                                                    **
************************************************************************
**
**  Define the Security Descriptor and related data types.
**  This is an opaque data structure.
*)


(*
** Current security descriptor revision value
*)


CONST SECURITY_DESCRIPTOR_REVISION  = 1;
      SECURITY_DESCRIPTOR_REVISION1 = 1;

(*
** Minimum length, in bytes, needed to build a security descriptor
** (NOTE: This must manually be kept consistent with the)
** sizeof(SECURITY_DESCRIPTOR)
*)

      SECURITY_DESCRIPTOR_MIN_LENGTH   = 20;


TYPE SECURITY_DESCRIPTOR_CONTROL  = WORD;
TYPE PSECURITY_DESCRIPTOR_CONTROL = POINTER TO SECURITY_DESCRIPTOR_CONTROL;

CONST SE_OWNER_DEFAULTED  = {0};  (* 0001h *)
      SE_GROUP_DEFAULTED  = {1};  (* 0002h *)
      SE_DACL_PRESENT     = {2};  (* 0004h *)
      SE_DACL_DEFAULTED   = {3};  (* 0008h *)
      SE_SACL_PRESENT     = {4};  (* 0010h *)
      SE_SACL_DEFAULTED   = {5};  (* 0020h *)
      SE_SELF_RELATIVE    = {15}; (* 8000h *)

(*
**  Where:
**
**      SE_OWNER_DEFAULTED - This boolean flag, when set, indicates that the
**          SID pointed to by the Owner field was provided by a
**          defaulting mechanism rather than explicitly provided by the
**          original provider of the security descriptor.  This may
**          affect the treatment of the SID with respect to inheritence
**          of an owner.
**
**      SE_GROUP_DEFAULTED - This boolean flag, when set, indicates that the
**          SID in the Group field was provided by a defaulting mechanism
**          rather than explicitly provided by the original provider of
**          the security descriptor.  This may affect the treatment of
**          the SID with respect to inheritence of a primary group.
**
**      SE_DACL_PRESENT - This boolean flag, when set, indicates that the
**          security descriptor contains a discretionary ACL.  If this
**          flag is set and the Dacl field of the SECURITY_DESCRIPTOR is
**          null, then a null ACL is explicitly being specified.
**
**      SE_DACL_DEFAULTED - This boolean flag, when set, indicates that the
**          ACL pointed to by the Dacl field was provided by a defaulting
**          mechanism rather than explicitly provided by the original
**          provider of the security descriptor.  This may affect the
**          treatment of the ACL with respect to inheritence of an ACL.
**          This flag is ignored if the DaclPresent flag is not set.
**
**      SE_SACL_PRESENT - This boolean flag, when set,  indicates that the
**          security descriptor contains a system ACL pointed to by the
**          Sacl field.  If this flag is set and the Sacl field of the
**          SECURITY_DESCRIPTOR is null, then an empty (but present)
**          ACL is being specified.
**
**      SE_SACL_DEFAULTED - This boolean flag, when set, indicates that the
**          ACL pointed to by the Sacl field was provided by a defaulting
**          mechanism rather than explicitly provided by the original
**          provider of the security descriptor.  This may affect the
**          treatment of the ACL with respect to inheritence of an ACL.
**          This flag is ignored if the SaclPresent flag is not set.
**
**      SE_SELF_RELATIVE - This boolean flag, when set, indicates that the
**          security descriptor is in self-relative form.  In this form,
**          all fields of the security descriptor are contiguous in memory
**          and all pointer fields are expressed as offsets from the
**          beginning of the security descriptor.  This form is useful
**          for treating security descriptors as opaque data structures
**          for transmission in communication protocol or for storage on
**          secondary media.
**
**
**
** Pictorially the structure of a security descriptor is as follows:
**
**       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
**       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
**      +---------------------------------------------------------------+
**      |            Control            |Reserved1 (SBZ)|   Revision    |
**      +---------------------------------------------------------------+
**      |                            Owner                              |
**      +---------------------------------------------------------------+
**      |                            Group                              |
**      +---------------------------------------------------------------+
**      |                            Sacl                               |
**      +---------------------------------------------------------------+
**      |                            Dacl                               |
**      +---------------------------------------------------------------+
**
** In general, this data structure should be treated opaquely to ensure future
** compatibility.
**
*)

TYPE SECURITY_DESCRIPTOR = RECORD
                                  Revision : BYTE;
                                  Sbz1     : BYTE;
                                  Control  : SECURITY_DESCRIPTOR_CONTROL;
                                  Owner    : PSID;
                                  Group    : PSID;
                                  Sacl     : PACL;
                                  Dacl     : PACL;
                           END;

    PISECURITY_DESCRIPTOR = POINTER TO SECURITY_DESCRIPTOR;

(* Where:
**
**     Revision - Contains the revision level of the security
**         descriptor.  This allows this structure to be passed between
**         systems or stored on disk even though it is expected to
**         change in the future.
**
**     Control - A set of flags which qualify the meaning of the
**         security descriptor or individual fields of the security
**         descriptor.
**
**     Owner - is a pointer to an SID representing an object's owner.
**         If this field is null, then no owner SID is present in the
**         security descriptor.  If the security descriptor is in
**         self-relative form, then this field contains an offset to
**         the SID, rather than a pointer.
**
**     Group - is a pointer to an SID representing an object's primary
**         group.  If this field is null, then no primary group SID is
**         present in the security descriptor.  If the security descriptor
**         is in self-relative form, then this field contains an offset to
**         the SID, rather than a pointer.
**
**     Sacl - is a pointer to a system ACL.  This field value is only
**         valid if the DaclPresent control flag is set.  If the
**         SaclPresent flag is set and this field is null, then a null
**         ACL  is specified.  If the security descriptor is in
**         self-relative form, then this field contains an offset to
**         the ACL, rather than a pointer.
**
**     Dacl - is a pointer to a discretionary ACL.  This field value is
**         only valid if the DaclPresent control flag is set.  If the
**         DaclPresent flag is set and this field is null, then a null
**         ACL (unconditionally granting access) is specified.  If the
**         security descriptor is in self-relative form, then this field
**         contains an offset to the ACL, rather than a pointer.
*)

(***********************************************************************
**                                                                    **
**               Privilege Related Data Structures                    **
**                                                                    **
***********************************************************************)

(*
** Privilege attributes
*)

CONST SE_PRIVILEGE_ENABLED_BY_DEFAULT = { 0}; (* 00000001h *)
      SE_PRIVILEGE_ENABLED            = { 1}; (* 00000002h *)
      SE_PRIVILEGE_USED_FOR_ACCESS    = {31}; (* 80000000h *)

(*
** Privilege Set Control flags
*)


      PRIVILEGE_SET_ALL_NECESSARY    = 1;

(*
**  Privilege Set - This is defined for a privilege set of one.
**                  If more than one privilege is needed, then this structure
**                  will need to be allocated with more space.
**
**  Note: don't change this structure without fixing the INITIAL_PRIVILEGE_SET
**  structure (defined in se.h)
*)


TYPE PRIVILEGE_SET = RECORD
                            PrivilegeCount : DWORD;
                            Control        : DWORD;
                            Privilege      : ARRAY [0..0] OF LUID_AND_ATTRIBUTES;
                     END;
    PPRIVILEGE_SET = POINTER TO  PRIVILEGE_SET;


(***********************************************************************
**                                                                    **
**               NT Defined Privileges                                **
**                                                                    **
***********************************************************************)

(* All following texts should be redefined for UNICODE case *)

CONST SE_CREATE_TOKEN_NAME              = "SeCreateTokenPrivilege";
      SE_ASSIGNPRIMARYTOKEN_NAME        = "SeAssignPrimaryTokenPrivilege";
      SE_LOCK_MEMORY_NAME               = "SeLockMemoryPrivilege";
      SE_INCREASE_QUOTA_NAME            = "SeIncreaseQuotaPrivilege";
      SE_UNSOLICITED_INPUT_NAME         = "SeUnsolicitedInputPrivilege";
      SE_MACHINE_ACCOUNT_NAME           = "SeMachineAccountPrivilege";
      SE_TCB_NAME                       = "SeTcbPrivilege";
      SE_SECURITY_NAME                  = "SeSecurityPrivilege";
      SE_TAKE_OWNERSHIP_NAME            = "SeTakeOwnershipPrivilege";
      SE_LOAD_DRIVER_NAME               = "SeLoadDriverPrivilege";
      SE_SYSTEM_PROFILE_NAME            = "SeSystemProfilePrivilege";
      SE_SYSTEMTIME_NAME                = "SeSystemtimePrivilege";
      SE_PROF_SINGLE_PROCESS_NAME       = "SeProfileSingleProcessPrivilege";
      SE_INC_BASE_PRIORITY_NAME         = "SeIncreaseBasePriorityPrivilege";
      SE_CREATE_PAGEFILE_NAME           = "SeCreatePagefilePrivilege";
      SE_CREATE_PERMANENT_NAME          = "SeCreatePermanentPrivilege";
      SE_BACKUP_NAME                    = "SeBackupPrivilege";
      SE_RESTORE_NAME                   = "SeRestorePrivilege";
      SE_SHUTDOWN_NAME                  = "SeShutdownPrivilege";
      SE_DEBUG_NAME                     = "SeDebugPrivilege";
      SE_AUDIT_NAME                     = "SeAuditPrivilege";
      SE_SYSTEM_ENVIRONMENT_NAME        = "SeSystemEnvironmentPrivilege";
      SE_CHANGE_NOTIFY_NAME             = "SeChangeNotifyPrivilege";
      SE_REMOTE_SHUTDOWN_NAME           = "SeRemoteShutdownPrivilege";


(*******************************************************************
**                                                                **
**           Security Quality Of Service                          **
**                                                                **
*******************************************************************)


(*
** Impersonation Level
**
** Impersonation level is represented by a pair of bits in Windows.
** If a new impersonation level is added or lowest value is changed from
** 0 to something else, fix the Windows CreateFile call.
*)


TYPE SECURITY_IMPERSONATION_LEVEL = (SecurityAnonymous,
                                     SecurityIdentification,
                                     SecurityImpersonation,
                                     SecurityDelegation);
     PSECURITY_IMPERSONATION_LEVEL = POINTER TO SECURITY_IMPERSONATION_LEVEL;

CONST SECURITY_MAX_IMPERSONATION_LEVEL = SecurityDelegation;
      DEFAULT_IMPERSONATION_LEVEL      = SecurityImpersonation;


(*******************************************************************
**                                                                **
**           Token Object Definitions                             **
**                                                                **
*******************************************************************)

(*
** Token Specific Access Rights.
*)


CONST TOKEN_ASSIGN_PRIMARY    = ACCESS_MASK {ACCESS_0}; (* 0x0001 *)
      TOKEN_DUPLICATE         = ACCESS_MASK {ACCESS_1}; (* 0x0002 *)
      TOKEN_IMPERSONATE       = ACCESS_MASK {ACCESS_2}; (* 0x0004 *)
      TOKEN_QUERY             = ACCESS_MASK {ACCESS_3}; (* 0x0008 *)
      TOKEN_QUERY_SOURCE      = ACCESS_MASK {ACCESS_4}; (* 0x0010 *)
      TOKEN_ADJUST_PRIVILEGES = ACCESS_MASK {ACCESS_5}; (* 0x0020 *)
      TOKEN_ADJUST_GROUPS     = ACCESS_MASK {ACCESS_6}; (* 0x0040 *)
      TOKEN_ADJUST_DEFAULT    = ACCESS_MASK {ACCESS_7}; (* 0x0080 *)

      TOKEN_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED+
                         TOKEN_ASSIGN_PRIMARY +
                         TOKEN_DUPLICATE +
                         TOKEN_IMPERSONATE +
                         TOKEN_QUERY +
                         TOKEN_QUERY_SOURCE +
                         TOKEN_ADJUST_PRIVILEGES +
                         TOKEN_ADJUST_GROUPS +
                         TOKEN_ADJUST_DEFAULT;

      TOKEN_READ       = STANDARD_RIGHTS_READ +
                         TOKEN_QUERY;

      TOKEN_WRITE      = STANDARD_RIGHTS_WRITE +
                         TOKEN_ADJUST_PRIVILEGES +
                         TOKEN_ADJUST_GROUPS +
                         TOKEN_ADJUST_DEFAULT;

      TOKEN_EXECUTE    = STANDARD_RIGHTS_EXECUTE;


(*
** Token Types
*)

TYPE TOKEN_TYPE = (TOKEN_0,
                   TokenPrimary,
                   TokenImpersonation);
    PTOKEN_TYPE = POINTER TO TOKEN_TYPE;

(*
** Token Information Classes.
*)

TYPE TOKEN_INFORMATION_CLASS = (TOKEN_INFORMATION_0,
                                TokenUser,
                                TokenGroups,
                                TokenPrivileges,
                                TokenOwner,
                                TokenPrimaryGroup,
                                TokenDefaultDacl,
                                TokenSource,
                                TokenType,
                                TokenImpersonationLevel,
                                TokenStatistics);

     PTOKEN_INFORMATION_CLASS = POINTER TO TOKEN_INFORMATION_CLASS;

(*
** Token information class structures
*)

TYPE TOKEN_USER = RECORD
                         User : SID_AND_ATTRIBUTES;
                  END;
    PTOKEN_USER = POINTER TO TOKEN_USER;

TYPE TOKEN_GROUPS = RECORD
                           GroupCount : DWORD;
                           Groups     : ARRAY [0..0] OF SID_AND_ATTRIBUTES;
                    END;
    PTOKEN_GROUPS = POINTER TO TOKEN_GROUPS;

TYPE TOKEN_PRIVILEGES = RECORD
                               PrivilegeCount : DWORD;
                               Privileges     : ARRAY [0..0] OF LUID_AND_ATTRIBUTES;
                        END;
    PTOKEN_PRIVILEGES = POINTER TO TOKEN_PRIVILEGES;


TYPE TOKEN_OWNER = RECORD
                          Owner : PSID;
                   END;
    PTOKEN_OWNER = POINTER TO TOKEN_OWNER;

TYPE TOKEN_PRIMARY_GROUP = RECORD
                                  PrimaryGroup : PSID;
                           END;
    PTOKEN_PRIMARY_GROUP = POINTER TO TOKEN_PRIMARY_GROUP;

TYPE TOKEN_DEFAULT_DACL = RECORD
                                 DefaultDacl : PACL;
                          END;
    PTOKEN_DEFAULT_DACL = POINTER TO TOKEN_DEFAULT_DACL;

CONST TOKEN_SOURCE_LENGTH = 8;

TYPE TOKEN_SOURCE = RECORD
                           SourceName       : ARRAY [0..TOKEN_SOURCE_LENGTH-1] OF CHAR;
                           SourceIdentifier : LUID;
                    END;
    PTOKEN_SOURCE = POINTER TO TOKEN_SOURCE;

TYPE TOKEN_STATISTICS = RECORD
                               TokenId            : LUID;
                               AuthenticationId   : LUID;
                               ExpirationTime     : LARGE_INTEGER;
                               TokenType          : TOKEN_TYPE;
                               ImpersonationLevel : SECURITY_IMPERSONATION_LEVEL;
                               DynamicCharged     : DWORD;
                               DynamicAvailable   : DWORD;
                               GroupCount         : DWORD;
                               PrivilegeCount     : DWORD;
                               ModifiedId         : LUID;
                        END;
    PTOKEN_STATISTICS = POINTER TO TOKEN_STATISTICS;

TYPE TOKEN_CONTROL = RECORD
                            TokenId          : LUID;
                            AuthenticationId : LUID;
                            ModifiedId       : LUID;
                            TokenSource      : TOKEN_SOURCE;
                     END;
    PTOKEN_CONTROL = POINTER TO TOKEN_CONTROL;

(*
** Security Tracking Mode
*)


TYPE SECURITY_CONTEXT_TRACKING_MODE = BOOL8;
    PSECURITY_CONTEXT_TRACKING_MODE = POINTER TO SECURITY_CONTEXT_TRACKING_MODE;

CONST SECURITY_DYNAMIC_TRACKING = VAL (SECURITY_CONTEXT_TRACKING_MODE, 1);
      SECURITY_STATIC_TRACKING  = VAL (SECURITY_CONTEXT_TRACKING_MODE, 0);


(*
** Quality Of Service
*)

TYPE SECURITY_QUALITY_OF_SERVICE =
     RECORD
            Length              : DWORD;
            ImpersonationLevel  : SECURITY_IMPERSONATION_LEVEL;
            ContextTrackingMode : SECURITY_CONTEXT_TRACKING_MODE;
            EffectiveOnly       : BOOL8;
     END;
     PSECURITY_QUALITY_OF_SERVICE = POINTER TO SECURITY_QUALITY_OF_SERVICE;

(*
** Used to represent information related to a thread impersonation
*)


TYPE SE_IMPERSONATION_STATE =
     RECORD
            Token         : PACCESS_TOKEN;
            CopyOnOpen    : BOOL8;
            EffectiveOnly : BOOL8;
            Level         : SECURITY_IMPERSONATION_LEVEL;
     END;
     PSE_IMPERSONATION_STATE = POINTER TO SE_IMPERSONATION_STATE;


TYPE SECURITY_INFORMATION_ENUM = (SECURITY_INFORMATION_0,
                                  SECURITY_INFORMATION_1,
                                  SECURITY_INFORMATION_2,
                                  SECURITY_INFORMATION_3);
     SECURITY_INFORMATION = SET OF SECURITY_INFORMATION_ENUM;
    PSECURITY_INFORMATION = POINTER TO SECURITY_INFORMATION;

CONST OWNER_SECURITY_INFORMATION = SECURITY_INFORMATION {SECURITY_INFORMATION_0}; (* 0x00000001L *)
      GROUP_SECURITY_INFORMATION = SECURITY_INFORMATION {SECURITY_INFORMATION_1}; (* 0x00000002L *)
      DACL_SECURITY_INFORMATION  = SECURITY_INFORMATION {SECURITY_INFORMATION_2}; (* 0x00000004L *)
      SACL_SECURITY_INFORMATION  = SECURITY_INFORMATION {SECURITY_INFORMATION_3}; (* 0x00000008L *)


(*
** Image Format
*)

<* PUSH *> <* ALIGNMENT = "4" *>                (* 4 byte packing is the default *)

CONST IMAGE_DOS_SIGNATURE                 = 5A4Dh;      (* MZ *)
      IMAGE_OS2_SIGNATURE                 = 454Eh;      (* NE *)
      IMAGE_OS2_SIGNATURE_LE              = 454Ch;      (* LE *)
      IMAGE_VXD_SIGNATURE                 = 454Ch;      (* LE *)
      IMAGE_NT_SIGNATURE                  = 00004550h;  (* PE00 *)

<* PUSH *> <* ALIGNMENT = "2" *>                (* 16 bit headers are 2 byte packed *)

TYPE IMAGE_DOS_HEADER =
     RECORD                                     (* DOS .EXE header *)
            e_magic    : WORD;                  (* Magic number *)
            e_cblp     : WORD;                  (* Bytes on last page of file *)
            e_cp       : WORD;                  (* Pages in file *)
            e_crlc     : WORD;                  (* Relocations *)
            e_cparhdr  : WORD;                  (* Size of header in paragraphs *)
            e_minalloc : WORD;                  (* Minimum extra paragraphs needed *)
            e_maxalloc : WORD;                  (* Maximum extra paragraphs needed *)
            e_ss       : WORD;                  (* Initial (relative) SS value *)
            e_sp       : WORD;                  (* Initial SP value *)
            e_csum     : WORD;                  (* Checksum *)
            e_ip       : WORD;                  (* Initial IP value *)
            e_cs       : WORD;                  (* Initial (relative) CS value *)
            e_lfarlc   : WORD;                  (* File address of relocation table *)
            e_ovno     : WORD;                  (* Overlay number *)
            e_res      : ARRAY [0..3] OF WORD;  (* Reserved words *)
            e_oemid    : WORD;                  (* OEM identifier (for e_oeminfo) *)
            e_oeminfo  : WORD;                  (* OEM information; e_oemid specific *)
            e_res2     : ARRAY [0..9] OF WORD;  (* Reserved words *)
            e_lfanew   : LONG;                  (* File address of new exe header *)
     END;
     PIMAGE_DOS_HEADER = POINTER TO IMAGE_DOS_HEADER;

TYPE IMAGE_OS2_HEADER =
     RECORD                                 (* OS/2 .EXE header *)
            ne_magic        : WORD;         (* Magic number *)
            ne_ver          : CHAR;         (* Version number *)
            ne_rev          : CHAR;         (* Revision number *)
            ne_enttab       : WORD;         (* Offset of Entry Table *)
            ne_cbenttab     : WORD;         (* Number of bytes in Entry Table *)
            ne_crc          : LONG;         (* Checksum of whole file *)
            ne_flags        : WORD;         (* Flag word *)
            ne_autodata     : WORD;         (* Automatic data segment number *)
            ne_heap         : WORD;         (* Initial heap allocation *)
            ne_stack        : WORD;         (* Initial stack allocation *)
            ne_csip         : LONG;         (* Initial CS:IP setting *)
            ne_sssp         : LONG;         (* Initial SS:SP setting *)
            ne_cseg         : WORD;         (* Count of file segments *)
            ne_cmod         : WORD;         (* Entries in Module Reference Table *)
            ne_cbnrestab    : WORD;         (* Size of non-resident name table *)
            ne_segtab       : WORD;         (* Offset of Segment Table *)
            ne_rsrctab      : WORD;         (* Offset of Resource Table *)
            ne_restab       : WORD;         (* Offset of resident name table *)
            ne_modtab       : WORD;         (* Offset of Module Reference Table *)
            ne_imptab       : WORD;         (* Offset of Imported Names Table *)
            ne_nrestab      : LONG;         (* Offset of Non-resident Names Table *)
            ne_cmovent      : WORD;         (* Count of movable entries *)
            ne_align        : WORD;         (* Segment alignment shift count *)
            ne_cres         : WORD;         (* Count of resource segments *)
            ne_exetyp       : BYTE;         (* Target Operating system *)
            ne_flagsothers  : BYTE;         (* Other .EXE flags *)
            ne_pretthunks   : WORD;         (* offset to return thunks *)
            ne_psegrefbytes : WORD;         (* offset to segment ref. bytes *)
            ne_swaparea     : WORD;         (* Minimum code swap area size *)
            ne_expver       : WORD;         (* Expected Windows version number *)
     END;
     PIMAGE_OS2_HEADER = POINTER TO IMAGE_OS2_HEADER;

TYPE IMAGE_VXD_HEADER =
     RECORD                                           (* Windows VXD header *)
            e32_magic        : WORD;                  (* Magic number *)
            e32_border       : BYTE;                  (* The byte ordering for the VXD *)
            e32_worder       : BYTE;                  (* The word ordering for the VXD *)
            e32_level        : DWORD;                 (* The EXE format level for now = 0 *)
            e32_cpu          : WORD;                  (* The CPU type *)
            e32_os           : WORD;                  (* The OS type *)
            e32_ver          : DWORD;                 (* Module version *)
            e32_mflags       : DWORD;                 (* Module flags *)
            e32_mpages       : DWORD;                 (* Module # pages *)
            e32_startobj     : DWORD;                 (* Object # for instruction pointer *)
            e32_eip          : DWORD;                 (* Extended instruction pointer *)
            e32_stackobj     : DWORD;                 (* Object # for stack pointer *)
            e32_esp          : DWORD;                 (* Extended stack pointer *)
            e32_pagesize     : DWORD;                 (* VXD page size *)
            e32_lastpagesize : DWORD;                 (* Last page size in VXD *)
            e32_fixupsize    : DWORD;                 (* Fixup section size *)
            e32_fixupsum     : DWORD;                 (* Fixup section checksum *)
            e32_ldrsize      : DWORD;                 (* Loader section size *)
            e32_ldrsum       : DWORD;                 (* Loader section checksum *)
            e32_objtab       : DWORD;                 (* Object table offset *)
            e32_objcnt       : DWORD;                 (* Number of objects in module *)
            e32_objmap       : DWORD;                 (* Object page map offset *)
            e32_itermap      : DWORD;                 (* Object iterated data map offset *)
            e32_rsrctab      : DWORD;                 (* Offset of Resource Table *)
            e32_rsrccnt      : DWORD;                 (* Number of resource entries *)
            e32_restab       : DWORD;                 (* Offset of resident name table *)
            e32_enttab       : DWORD;                 (* Offset of Entry Table *)
            e32_dirtab       : DWORD;                 (* Offset of Module Directive Table *)
            e32_dircnt       : DWORD;                 (* Number of module directives *)
            e32_fpagetab     : DWORD;                 (* Offset of Fixup Page Table *)
            e32_frectab      : DWORD;                 (* Offset of Fixup Record Table *)
            e32_impmod       : DWORD;                 (* Offset of Import Module Name Table *)
            e32_impmodcnt    : DWORD;                 (* Number of entries in Import Module Name Table *)
            e32_impproc      : DWORD;                 (* Offset of Import Procedure Name Table *)
            e32_pagesum      : DWORD;                 (* Offset of Per-Page Checksum Table *)
            e32_datapage     : DWORD;                 (* Offset of Enumerated Data Pages *)
            e32_preload      : DWORD;                 (* Number of preload pages *)
            e32_nrestab      : DWORD;                 (* Offset of Non-resident Names Table *)
            e32_cbnrestab    : DWORD;                 (* Size of Non-resident Name Table *)
            e32_nressum      : DWORD;                 (* Non-resident Name Table Checksum *)
            e32_autodata     : DWORD;                 (* Object # for automatic data object *)
            e32_debuginfo    : DWORD;                 (* Offset of the debugging information *)
            e32_debuglen     : DWORD;                 (* The length of the debugging info. in bytes *)
            e32_instpreload  : DWORD;                 (* Number of instance pages in preload section of VXD file *)
            e32_instdemand   : DWORD;                 (* Number of instance pages in demand load section of VXD file *)
            e32_heapsize     : DWORD;                 (* Size of heap - for 16-bit apps *)
            e32_res3         : ARRAY [0..11] OF BYTE; (* Reserved words *)
            e32_winresoff    : DWORD;
            e32_winreslen    : DWORD;
            e32_devid        : WORD;                  (* Device ID for VxD *)
            e32_ddkver       : WORD;                  (* DDK version for VxD *)
     END;
     PIMAGE_VXD_HEADER = POINTER TO IMAGE_VXD_HEADER;

<* POP *> (* Back to 4 byte packing *)

(*
** File header format.
*)

(* Characteristics field bits *)

TYPE IMAGE_FILE_ENUM = (IMAGE_FILE__RELOCS_STRIPPED,     (*  0 -  Relocation info stripped from file. *)
                        IMAGE_FILE__EXECUTABLE_IMAGE,    (*  1 - File is executable  (i.e. no unresolved externel references). *)
                        IMAGE_FILE__LINE_NUMS_STRIPPED,  (*  2 - Line nunbers stripped from file. *)
                        IMAGE_FILE__LOCAL_SYMS_STRIPPED, (*  3 - Local symbols stripped from file. *)
                        IMAGE_FILE__4,
                        IMAGE_FILE__5,
                        IMAGE_FILE__6,
                        IMAGE_FILE__BYTES_REVERSED_LO,   (*  7 - Bytes of machine word are reversed. *)
                        IMAGE_FILE__32BIT_MACHINE,       (*  8 - 32 bit word machine. *)
                        IMAGE_FILE__DEBUG_STRIPPED,      (*  9 - Debugging info stripped from file in .DBG file *)
                        IMAGE_FILE__10,
                        IMAGE_FILE__11,
                        IMAGE_FILE__SYSTEM,              (* 12 - System File. *)
                        IMAGE_FILE__DLL,                 (* 13 - File is a DLL. *)
                        IMAGE_FILE__14,
                        IMAGE_FILE__BYTES_REVERSED_HI);  (* 15 - Bytes of machine word are reversed. *)

<* PUSH *> <* SETSIZE = "2" *>

TYPE IMAGE_FILE_FLAGS = SET OF IMAGE_FILE_ENUM;

<* POP *>

CONST IMAGE_FILE_RELOCS_STRIPPED     = IMAGE_FILE_FLAGS {IMAGE_FILE__RELOCS_STRIPPED};     (* 0001h - Relocation info stripped from file. *)
      IMAGE_FILE_EXECUTABLE_IMAGE    = IMAGE_FILE_FLAGS {IMAGE_FILE__EXECUTABLE_IMAGE};    (* 0002h - File is executable  (i.e. no unresolved externel references). *)
      IMAGE_FILE_LINE_NUMS_STRIPPED  = IMAGE_FILE_FLAGS {IMAGE_FILE__LINE_NUMS_STRIPPED};  (* 0004h - Line nunbers stripped from file. *)
      IMAGE_FILE_LOCAL_SYMS_STRIPPED = IMAGE_FILE_FLAGS {IMAGE_FILE__LOCAL_SYMS_STRIPPED}; (* 0008h - Local symbols stripped from file. *)
      IMAGE_FILE_BYTES_REVERSED_LO   = IMAGE_FILE_FLAGS {IMAGE_FILE__BYTES_REVERSED_LO};   (* 0080h - Bytes of machine word are reversed. *)
      IMAGE_FILE_32BIT_MACHINE       = IMAGE_FILE_FLAGS {IMAGE_FILE__32BIT_MACHINE};       (* 0100h - 32 bit word machine. *)
      IMAGE_FILE_DEBUG_STRIPPED      = IMAGE_FILE_FLAGS {IMAGE_FILE__DEBUG_STRIPPED};      (* 0200h - Debugging info stripped from file in .DBG file *)
      IMAGE_FILE_SYSTEM              = IMAGE_FILE_FLAGS {IMAGE_FILE__SYSTEM};              (* 1000h - System File. *)
      IMAGE_FILE_DLL                 = IMAGE_FILE_FLAGS {IMAGE_FILE__DLL};                 (* 2000h - File is a DLL. *)
      IMAGE_FILE_BYTES_REVERSED_HI   = IMAGE_FILE_FLAGS {IMAGE_FILE__BYTES_REVERSED_HI};   (* 8000h - Bytes of machine word are reversed. *)

TYPE IMAGE_FILE_MACHINE_TYPE = WORD;

TYPE IMAGE_FILE_HEADER = RECORD
                                Machine              : IMAGE_FILE_MACHINE_TYPE;
                                NumberOfSections     : WORD;
                                TimeDateStamp        : DWORD;
                                PointerToSymbolTable : DWORD;
                                NumberOfSymbols      : DWORD;
                                SizeOfOptionalHeader : WORD;
                                Characteristics      : IMAGE_FILE_FLAGS;
                         END;
    PIMAGE_FILE_HEADER = POINTER TO IMAGE_FILE_HEADER;

CONST IMAGE_SIZEOF_FILE_HEADER             = 20;

CONST IMAGE_FILE_MACHINE_UNKNOWN           = VAL (IMAGE_FILE_MACHINE_TYPE, 0);
      IMAGE_FILE_MACHINE_I386              = VAL (IMAGE_FILE_MACHINE_TYPE, 14ch);   (* Intel 386. *)
      IMAGE_FILE_MACHINE_R3000             = VAL (IMAGE_FILE_MACHINE_TYPE, 162h);   (* MIPS little-endian, 160h big-endian *)
      IMAGE_FILE_MACHINE_R4000             = VAL (IMAGE_FILE_MACHINE_TYPE, 166h);   (* MIPS little-endian *)
      IMAGE_FILE_MACHINE_R10000            = VAL (IMAGE_FILE_MACHINE_TYPE, 168h);   (* MIPS little-endian *)
      IMAGE_FILE_MACHINE_ALPHA             = VAL (IMAGE_FILE_MACHINE_TYPE, 184h);   (* Alpha_AXP *)
      IMAGE_FILE_MACHINE_POWERPC           = VAL (IMAGE_FILE_MACHINE_TYPE, 1F0h);   (* IBM PowerPC Little-Endian *)

(*
** Directory format.
*)

TYPE IMAGE_DATA_DIRECTORY = RECORD
                                   VirtualAddress : DWORD;
                                   Size : DWORD;
                            END;
    PIMAGE_DATA_DIRECTORY = POINTER TO IMAGE_DATA_DIRECTORY;

CONST IMAGE_NUMBEROF_DIRECTORY_ENTRIES = 16;

(*
** Optional header format.
*)

(* Subsystem Values *)

<* PUSH *> <* ENUMSIZE = "2" *>

TYPE IMAGE_SUBSYSTEM_ENUM = (IMAGE_SUBSYSTEM_UNKNOWN,     (* 0 - Unknown subsystem. *)
                             IMAGE_SUBSYSTEM_NATIVE,      (* 1 - Image doesn't require a subsystem. *)
                             IMAGE_SUBSYSTEM_WINDOWS_GUI, (* 2 - Image runs in the Windows GUI subsystem. *)
                             IMAGE_SUBSYSTEM_WINDOWS_CUI, (* 3 - Image runs in the Windows character subsystem. *)
                             IMAGE_SUBSYSTEM_OS2_CUI,     (* 5 - image runs in the OS/2 character subsystem. *)
                             IMAGE_SUBSYSTEM_POSIX_CUI);  (* 7 - image run  in the Posix character subsystem. *)

<* POP *>

TYPE IMAGE_OPTIONAL_HEADER =
     RECORD

    (*
    ** Standard fields.
    *)

            Magic                   : WORD;
            MajorLinkerVersion      : BYTE;
            MinorLinkerVersion      : BYTE;
            SizeOfCode              : DWORD;
            SizeOfInitializedData   : DWORD;
            SizeOfUninitializedData : DWORD;
            AddressOfEntryPoint     : DWORD;
            BaseOfCode              : DWORD;
            BaseOfData              : DWORD;

    (*
    ** NT additional fields.
    *)

            ImageBase                   : DWORD;
            SectionAlignment            : DWORD;
            FileAlignment               : DWORD;
            MajorOperatingSystemVersion : WORD;
            MinorOperatingSystemVersion : WORD;
            MajorImageVersion           : WORD;
            MinorImageVersion           : WORD;
            MajorSubsystemVersion       : WORD;
            MinorSubsystemVersion       : WORD;
            Win32VersionValue           : DWORD;
            SizeOfImage                 : DWORD;
            SizeOfHeaders               : DWORD;
            CheckSum                    : DWORD;
            Subsystem                   : IMAGE_SUBSYSTEM_ENUM;
            DllCharacteristics          : WORD;
            SizeOfStackReserve          : DWORD;
            SizeOfStackCommit           : DWORD;
            SizeOfHeapReserve           : DWORD;
            SizeOfHeapCommit            : DWORD;
            LoaderFlags                 : DWORD;
            NumberOfRvaAndSizes         : DWORD;
            DataDirectory : ARRAY [0..IMAGE_NUMBEROF_DIRECTORY_ENTRIES-1]
                            OF IMAGE_DATA_DIRECTORY;
       END;
       PIMAGE_OPTIONAL_HEADER = POINTER TO IMAGE_OPTIONAL_HEADER;

TYPE IMAGE_ROM_OPTIONAL_HEADER =
     RECORD
            Magic                   : WORD;
            MajorLinkerVersion      : BYTE;
            MinorLinkerVersion      : BYTE;
            SizeOfCode              : DWORD;
            SizeOfInitializedData   : DWORD;
            SizeOfUninitializedData : DWORD;
            AddressOfEntryPoint     : DWORD;
            BaseOfCode              : DWORD;
            BaseOfData              : DWORD;
            BaseOfBss               : DWORD;
            GprMask                 : DWORD;
            CprMask                 : ARRAY [0..3] OF DWORD;
            GpValue                 : DWORD;
     END;
    PIMAGE_ROM_OPTIONAL_HEADER = POINTER TO IMAGE_ROM_OPTIONAL_HEADER;

CONST IMAGE_SIZEOF_ROM_OPTIONAL_HEADER      =   56;
      IMAGE_SIZEOF_STD_OPTIONAL_HEADER      =   28;
      IMAGE_SIZEOF_NT_OPTIONAL_HEADER       =  224;

      IMAGE_NT_OPTIONAL_HDR_MAGIC           = 10bh;
      IMAGE_ROM_OPTIONAL_HDR_MAGIC          = 107h;

TYPE IMAGE_NT_HEADERS =
     RECORD
            Signature      : DWORD;
            FileHeader     : IMAGE_FILE_HEADER;
            OptionalHeader : IMAGE_OPTIONAL_HEADER;
     END;
    PIMAGE_NT_HEADERS = POINTER TO IMAGE_NT_HEADERS;

TYPE IMAGE_ROM_HEADERS =
     RECORD
            FileHeader     : IMAGE_FILE_HEADER;
            OptionalHeader : IMAGE_ROM_OPTIONAL_HEADER;
     END;
    PIMAGE_ROM_HEADERS = POINTER TO IMAGE_ROM_HEADERS;


(* Directory Entries *)

CONST IMAGE_DIRECTORY_ENTRY_EXPORT         = 0;   (* Export Directory *)
      IMAGE_DIRECTORY_ENTRY_IMPORT         = 1;   (* Import Directory *)
      IMAGE_DIRECTORY_ENTRY_RESOURCE       = 2;   (* Resource Directory *)
      IMAGE_DIRECTORY_ENTRY_EXCEPTION      = 3;   (* Exception Directory *)
      IMAGE_DIRECTORY_ENTRY_SECURITY       = 4;   (* Security Directory *)
      IMAGE_DIRECTORY_ENTRY_BASERELOC      = 5;   (* Base Relocation Table *)
      IMAGE_DIRECTORY_ENTRY_DEBUG          = 6;   (* Debug Directory *)
      IMAGE_DIRECTORY_ENTRY_COPYRIGHT      = 7;   (* Description String *)
      IMAGE_DIRECTORY_ENTRY_GLOBALPTR      = 8;   (* Machine Value (MIPS GP) *)
      IMAGE_DIRECTORY_ENTRY_TLS            = 9;   (* TLS Directory *)
      IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG   = 10;   (* Load Configuration Directory *)
      IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT  = 11;   (* Bound Import Directory in headers *)
      IMAGE_DIRECTORY_ENTRY_IAT           = 12;   (* Import Address Table *)

(*
** Section characteristics.
*)

TYPE IMAGE_SCN_ENUM =  (IMAGE_SCN__TYPE_DSECT,                 (*  0 - Reserved. *)
                        IMAGE_SCN__TYPE_NOLOAD,                (*  1 - Reserved. *)
                        IMAGE_SCN__TYPE_GROUP,                 (*  2 - Reserved. *)
                        IMAGE_SCN__TYPE_NO_PAD,                (*  3 - Reserved. *)
                        IMAGE_SCN__TYPE_COPY,                  (*  4 - Reserved. *)
                        IMAGE_SCN__CNT_CODE,                   (*  5 - Section contains code. *)
                        IMAGE_SCN__CNT_INITIALIZED_DATA,       (*  6 - Section contains initialized data. *)
                        IMAGE_SCN__CNT_UNINITIALIZED_DATA,     (*  7 - Section contains uninitialized data. *)
                        IMAGE_SCN__LNK_OTHER,                  (*  8 - Reserved. *)
                        IMAGE_SCN__LNK_INFO,                   (*  9 - Section contains comments or some other type of information. *)
                        IMAGE_SCN__TYPE_OVER,                  (* 10 - Reserved. *)
                        IMAGE_SCN__LNK_REMOVE,                 (* 11 - Section contents will not become part of image. *)
                        IMAGE_SCN__LNK_COMDAT,                 (* 12 - Section contents comdat. *)
                        IMAGE_SCN__13,
                        IMAGE_SCN__MEM_PROTECTED,              (* 14 - Obsolete *)
                        IMAGE_SCN__MEM_FARDATA,                (* 15 *)
                        IMAGE_SCN__MEM_SYSHEAP,                (* 16 - Obsolete *)
                        IMAGE_SCN__MEM_PURGEABLE,              (* 17 *)
                        IMAGE_SCN__MEM_LOCKED,                 (* 18 *)
                        IMAGE_SCN__MEM_PRELOAD,                (* 19 *)
                        IMAGE_SCN__ALIGN_1BYTES,               (* 20 *)
                        IMAGE_SCN__ALIGN_2BYTES,               (* 21 *)
                        IMAGE_SCN__ALIGN_8BYTES,               (* 22 *)
                        IMAGE_SCN__25,
                        IMAGE_SCN__LNK_NRELOC_OVFL,            (* 24 - Section contains extended relocations. *)
                        IMAGE_SCN__MEM_DISCARDABLE,            (* 25 - Section can be discarded. *)
                        IMAGE_SCN__MEM_NOT_CACHED,             (* 26 - Section is not cachable. *)
                        IMAGE_SCN__MEM_NOT_PAGED,              (* 27 - Section is not pageable. *)
                        IMAGE_SCN__MEM_SHARED,                 (* 28 - Section is shareable. *)
                        IMAGE_SCN__MEM_EXECUTE,                (* 29 - Section is executable. *)
                        IMAGE_SCN__MEM_READ,                   (* 30 - Section is readable. *)
                        IMAGE_SCN__MEM_WRITE);                 (* 31 - Section is writeable. *)

TYPE IMAGE_SCN_SET = SET OF IMAGE_SCN_ENUM;

CONST
      IMAGE_SCN_TYPE_REG               = IMAGE_SCN_SET {};                                 (* 0x00000000 *)
      IMAGE_SCN_TYPE_DSECT             = IMAGE_SCN_SET {IMAGE_SCN__TYPE_DSECT};             (* 0x00000001 *)
      IMAGE_SCN_TYPE_NOLOAD            = IMAGE_SCN_SET {IMAGE_SCN__TYPE_NOLOAD};            (* 0x00000002 *)
      IMAGE_SCN_TYPE_GROUP             = IMAGE_SCN_SET {IMAGE_SCN__TYPE_GROUP};             (* 0x00000004 *)

      IMAGE_SCN_TYPE_NO_PAD            = IMAGE_SCN_SET {IMAGE_SCN__TYPE_NO_PAD};            (* 0x00000008 *)
      IMAGE_SCN_TYPE_COPY              = IMAGE_SCN_SET {IMAGE_SCN__TYPE_COPY};              (* 0x00000010 *)

      IMAGE_SCN_CNT_CODE               = IMAGE_SCN_SET {IMAGE_SCN__CNT_CODE};               (* 0x00000020 *)
      IMAGE_SCN_CNT_INITIALIZED_DATA   = IMAGE_SCN_SET {IMAGE_SCN__CNT_INITIALIZED_DATA};   (* 0x00000040 *)
      IMAGE_SCN_CNT_UNINITIALIZED_DATA = IMAGE_SCN_SET {IMAGE_SCN__CNT_UNINITIALIZED_DATA}; (* 0x00000080 *)

      IMAGE_SCN_LNK_OTHER              = IMAGE_SCN_SET {IMAGE_SCN__LNK_OTHER};              (* 0x00000100 *)
      IMAGE_SCN_LNK_INFO               = IMAGE_SCN_SET {IMAGE_SCN__LNK_INFO};               (* 0x00000200 *)
      IMAGE_SCN_TYPE_OVER              = IMAGE_SCN_SET {IMAGE_SCN__TYPE_OVER};              (* 0x00000400 *)

      IMAGE_SCN_LNK_REMOVE             = IMAGE_SCN_SET {IMAGE_SCN__LNK_REMOVE};             (* 0x00000800 *)
      IMAGE_SCN_LNK_COMDAT             = IMAGE_SCN_SET {IMAGE_SCN__LNK_COMDAT};             (* 0x00001000 *)

      IMAGE_SCN_MEM_PROTECTED          = IMAGE_SCN_SET {IMAGE_SCN__MEM_PROTECTED};          (* 0x00004000 *)

      IMAGE_SCN_MEM_FARDATA            = IMAGE_SCN_SET {IMAGE_SCN__MEM_FARDATA};            (* 0x00008000 *)
      IMAGE_SCN_MEM_SYSHEAP            = IMAGE_SCN_SET {IMAGE_SCN__MEM_SYSHEAP};            (* 0x00010000 *)

      IMAGE_SCN_MEM_PURGEABLE          = IMAGE_SCN_SET {IMAGE_SCN__MEM_PURGEABLE};          (* 0x00020000 *)
      IMAGE_SCN_MEM_16BIT              = IMAGE_SCN_MEM_PURGEABLE;                           (* 0x00020000 *)
      IMAGE_SCN_MEM_LOCKED             = IMAGE_SCN_SET {IMAGE_SCN__MEM_LOCKED};             (* 0x00040000 *)
      IMAGE_SCN_MEM_PRELOAD            = IMAGE_SCN_SET {IMAGE_SCN__MEM_PRELOAD};            (* 0x00080000 *)

      IMAGE_SCN_ALIGN_1BYTES           = IMAGE_SCN_SET {IMAGE_SCN__ALIGN_1BYTES};           (* 0x00100000 *)
      IMAGE_SCN_ALIGN_2BYTES           = IMAGE_SCN_SET {IMAGE_SCN__ALIGN_2BYTES};           (* 0x00200000 *)
      IMAGE_SCN_ALIGN_4BYTES           = IMAGE_SCN_ALIGN_2BYTES +
                                         IMAGE_SCN_ALIGN_1BYTES;                           (* 0x00300000 *)
      IMAGE_SCN_ALIGN_8BYTES           = IMAGE_SCN_SET {IMAGE_SCN__ALIGN_8BYTES};           (* 0x00400000 *)
      IMAGE_SCN_ALIGN_16BYTES          = IMAGE_SCN_ALIGN_8BYTES +
                                         IMAGE_SCN_ALIGN_1BYTES;                           (* 0x00500000h *)
                                                                                           (* Default alignment if no others are specified. *)
      IMAGE_SCN_ALIGN_32BYTES          = IMAGE_SCN_ALIGN_8BYTES +
                                         IMAGE_SCN_ALIGN_2BYTES;                           (* 0x00600000h *)
      IMAGE_SCN_ALIGN_64BYTES          = IMAGE_SCN_ALIGN_8BYTES +
                                         IMAGE_SCN_ALIGN_2BYTES +
                                         IMAGE_SCN_ALIGN_1BYTES;                           (* 0x00700000h *)

      IMAGE_SCN_LNK_NRELOC_OVFL        = IMAGE_SCN_SET {IMAGE_SCN__LNK_NRELOC_OVFL};        (* 0x01000000 *)
      IMAGE_SCN_MEM_DISCARDABLE        = IMAGE_SCN_SET {IMAGE_SCN__MEM_DISCARDABLE};        (* 0x02000000 *)
      IMAGE_SCN_MEM_NOT_CACHED         = IMAGE_SCN_SET {IMAGE_SCN__MEM_NOT_CACHED};         (* 0x04000000 *)
      IMAGE_SCN_MEM_NOT_PAGED          = IMAGE_SCN_SET {IMAGE_SCN__MEM_NOT_PAGED};          (* 0x08000000 *)
      IMAGE_SCN_MEM_SHARED             = IMAGE_SCN_SET {IMAGE_SCN__MEM_SHARED};             (* 0x10000000 *)
      IMAGE_SCN_MEM_EXECUTE            = IMAGE_SCN_SET {IMAGE_SCN__MEM_EXECUTE};            (* 0x20000000 *)
      IMAGE_SCN_MEM_READ               = IMAGE_SCN_SET {IMAGE_SCN__MEM_READ};               (* 0x40000000 *)
      IMAGE_SCN_MEM_WRITE              = IMAGE_SCN_SET {IMAGE_SCN__MEM_WRITE};              (* 0x80000000 *)

(*
** Section header format.
*)

CONST IMAGE_SIZEOF_SHORT_NAME = 8;

TYPE IMAGE_SECTION_HEADER =
     RECORD
            Name : ARRAY [0..IMAGE_SIZEOF_SHORT_NAME-1] OF BYTE;
            CASE : BOOLEAN OF
            | TRUE  : PhysicalAddress : DWORD;
            | FALSE : VirtualSize     : DWORD;
            END;
            VirtualAddress       : DWORD;
            SizeOfRawData        : DWORD;
            PointerToRawData     : DWORD;
            PointerToRelocations : DWORD;
            PointerToLinenumbers : DWORD;
            NumberOfRelocations  : WORD;
            NumberOfLinenumbers  : WORD;
            Characteristics      : IMAGE_SCN_SET;
     END;
    PIMAGE_SECTION_HEADER = POINTER TO IMAGE_SECTION_HEADER;

CONST IMAGE_SIZEOF_SECTION_HEADER = 40;

(*
** TLS Chaacteristic Flags
*)
CONST IMAGE_SCN_SCALE_INDEX = 00000001h; (* Tls index is scaled *)

(*
** Symbol format.
*)

<* PUSH *> <* ALIGNMENT = "2" *>  (* Symbols, relocs, and linenumbers
                                     are 2 byte packed *)

TYPE IMAGE_SYMBOL = RECORD
                           CASE : BOOLEAN OF
                           | TRUE  : ShortName : ARRAY [0..7] OF BYTE;
                           | FALSE : Short     : DWORD; (* if 0, use LongName *)
                                     Long      : DWORD; (* offset into string table *)
                           ELSE
                                     LongName  : ARRAY [0..1] OF PBYTE;
                           END;
                           Value         : DWORD;
                           SectionNumber : SHORT;
                           Type          : WORD;
                           StorageClass  : BYTE;
                           NumberOfAuxSymbols : BYTE;
                    END;
    PIMAGE_SYMBOL = POINTER TO IMAGE_SYMBOL;

CONST IMAGE_SIZEOF_SYMBOL = 18;

(*
** Section values.
**
** Symbols have a section number of the section in which they are
** defined. Otherwise, section numbers have the following meanings:
*)

CONST IMAGE_SYM_UNDEFINED           = VAL (SHORT,  0); (* Symbol is undefined or is common. *)
      IMAGE_SYM_ABSOLUTE            = VAL (SHORT, -1); (* Symbol is an absolute value. *)
      IMAGE_SYM_DEBUG               = VAL (SHORT, -2); (* Symbol is a special debug item. *)

(*
** Type (fundamental) values.
*)

      IMAGE_SYM_TYPE_NULL                 = 0000h;  (* no type. *)
      IMAGE_SYM_TYPE_VOID                 = 0001h;
      IMAGE_SYM_TYPE_CHAR                 = 0002h;  (* type character. *)
      IMAGE_SYM_TYPE_SHORT                = 0003h;  (* type short integer. *)
      IMAGE_SYM_TYPE_INT                  = 0004h;
      IMAGE_SYM_TYPE_LONG                 = 0005h;
      IMAGE_SYM_TYPE_FLOAT                = 0006h;
      IMAGE_SYM_TYPE_DOUBLE               = 0007h;
      IMAGE_SYM_TYPE_STRUCT               = 0008h;
      IMAGE_SYM_TYPE_UNION                = 0009h;
      IMAGE_SYM_TYPE_ENUM                 = 000Ah;  (* enumeration. *)
      IMAGE_SYM_TYPE_MOE                  = 000Bh;  (* member of enumeration. *)
      IMAGE_SYM_TYPE_BYTE                 = 000Ch;
      IMAGE_SYM_TYPE_WORD                 = 000Dh;
      IMAGE_SYM_TYPE_UINT                 = 000Eh;
      IMAGE_SYM_TYPE_DWORD                = 000Fh;
      IMAGE_SYM_TYPE_PCODE                = 8000h;

(*
** Type (derived) values.
*)


CONST IMAGE_SYM_DTYPE_NULL                = 0;       (* no derived type. *)
      IMAGE_SYM_DTYPE_POINTER             = 1;       (* pointer. *)
      IMAGE_SYM_DTYPE_FUNCTION            = 2;       (* function. *)
      IMAGE_SYM_DTYPE_ARRAY               = 3;       (* array. *)

(*
** Storage classes.
*)


CONST IMAGE_SYM_CLASS_END_OF_FUNCTION     = -1;
      IMAGE_SYM_CLASS_NULL                = 0000h;
      IMAGE_SYM_CLASS_AUTOMATIC           = 0001h;
      IMAGE_SYM_CLASS_EXTERNAL            = 0002h;
      IMAGE_SYM_CLASS_STATIC              = 0003h;
      IMAGE_SYM_CLASS_REGISTER            = 0004h;
      IMAGE_SYM_CLASS_EXTERNAL_DEF        = 0005h;
      IMAGE_SYM_CLASS_LABEL               = 0006h;
      IMAGE_SYM_CLASS_UNDEFINED_LABEL     = 0007h;
      IMAGE_SYM_CLASS_MEMBER_OF_STRUCT    = 0008h;
      IMAGE_SYM_CLASS_ARGUMENT            = 0009h;
      IMAGE_SYM_CLASS_STRUCT_TAG          = 000Ah;
      IMAGE_SYM_CLASS_MEMBER_OF_UNION     = 000Bh;
      IMAGE_SYM_CLASS_UNION_TAG           = 000Ch;
      IMAGE_SYM_CLASS_TYPE_DEFINITION     = 000Dh;
      IMAGE_SYM_CLASS_UNDEFINED_STATIC    = 000Eh;
      IMAGE_SYM_CLASS_ENUM_TAG            = 000Fh;
      IMAGE_SYM_CLASS_MEMBER_OF_ENUM      = 0010h;
      IMAGE_SYM_CLASS_REGISTER_PARAM      = 0011h;
      IMAGE_SYM_CLASS_BIT_FIELD           = 0012h;

      IMAGE_SYM_CLASS_FAR_EXTERNAL        = 0044h;  

      IMAGE_SYM_CLASS_BLOCK               = 0064h;
      IMAGE_SYM_CLASS_FUNCTION            = 0065h;
      IMAGE_SYM_CLASS_END_OF_STRUCT       = 0066h;
      IMAGE_SYM_CLASS_FILE                = 0067h;
(* new *)
      IMAGE_SYM_CLASS_SECTION             = 0068h;
      IMAGE_SYM_CLASS_WEAK_EXTERNAL       = 0069h;

(* type packing constants *)

      N_BTMASK                            = 000Fh;
      N_TMASK                             = 0030h;
      N_TMASK1                            = 00C0h;
      N_TMASK2                            = 00F0h;
      N_BTSHFT                            = 4;
      N_TSHIFT                            = 2;

(*
** Auxiliary entry format.
*)

TYPE IMAGE_AUX_SYMBOL =
     RECORD
       CASE : BOOLEAN OF
       | TRUE  : Sym :
                 RECORD
                        TagIndex : DWORD;                      (* struct, union, or enum tag index *)
                        CASE : BOOLEAN OF
                        | TRUE  : Linenumber : WORD;           (* declaration line number *)
                                  Size       : WORD;           (* size of struct, union, or enum *)
                        | FALSE : TotalSize  : DWORD;
                        END;
                        CASE : BOOLEAN OF
                        | TRUE  : PointerToLinenumber   : DWORD;     (* Function *)
                                  PointerToNextFunction : DWORD;
                        | FALSE : Dimension : ARRAY [0..3] OF WORD;  (* Array *)
                        END;
                        TvIndex : WORD;                        (* tv index *)
                 END;
       | FALSE : File :
                 RECORD
                        Name : ARRAY [0..IMAGE_SIZEOF_SYMBOL-1] OF BYTE;
                 END;
       ELSE
                 Section :
                 RECORD
                        Length              : DWORD; (* section length *)
                        NumberOfRelocations : WORD;  (* number of relocation entries *)
                        NumberOfLinenumbers : WORD;  (* number of line numbers *)
                        CheckSum            : DWORD; (* checksum for communal *)
                        Number              : SHORT; (* section number to associate with *)
                        Selection           : BYTE;  (* communal selection type *)
                 END;
       END;
     END;

     PIMAGE_AUX_SYMBOL = POINTER TO IMAGE_AUX_SYMBOL;

CONST IMAGE_SIZEOF_AUX_SYMBOL = 18;

(*
** Communal selection types.
*)

CONST IMAGE_COMDAT_SELECT_NODUPLICATES    = 1;
      IMAGE_COMDAT_SELECT_ANY             = 2;
      IMAGE_COMDAT_SELECT_SAME_SIZE       = 3;
      IMAGE_COMDAT_SELECT_EXACT_MATCH     = 4;
      IMAGE_COMDAT_SELECT_ASSOCIATIVE     = 5;
      IMAGE_COMDAT_SELECT_LARGEST         = 6;
      IMAGE_COMDAT_SELECT_NEWEST          = 7;

      IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY  = 1;
      IMAGE_WEAK_EXTERN_SEARCH_LIBRARY    = 2;
      IMAGE_WEAK_EXTERN_SEARCH_ALIAS      = 3;

(*
** I386 relocation types.
*)

<* PUSH *> <* ENUMSIZE = "2" *>

TYPE IMAGE_REL_I386_ENUM = (IMAGE_REL_I386_ABSOLUTE, (* 0000h - Reference is absolute, no relocation is necessary *)
                            IMAGE_REL_I386_DIR16,    (* 0001h - Direct 16-bit reference to the symbols virtual address *)
                            IMAGE_REL_I386_REL16,    (* 0002h - PC-relative 16-bit reference to the symbols virtual address *)
                            IMAGE_REL_I386_3,
                            IMAGE_REL_I386_4,
                            IMAGE_REL_I386_5,
                            IMAGE_REL_I386_DIR32,    (* 0006h - Direct 32-bit reference to the symbols virtual address *)
                            IMAGE_REL_I386_DIR32NB,  (* 0007h - Direct 32-bit reference to the symbols virtual address, base not included *)
                            IMAGE_REL_I386_8,
                            IMAGE_REL_I386_SEG12,    (* 0009h - Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address *)
                            IMAGE_REL_I386_SECTION,  (* 000Ah *)
                            IMAGE_REL_I386_SECREL,   (* 000Bh *)
                            IMAGE_REL_I386_C,
                            IMAGE_REL_I386_D,
                            IMAGE_REL_I386_E,
                            IMAGE_REL_I386_F,
                            IMAGE_REL_I386_10,
                            IMAGE_REL_I386_11,
                            IMAGE_REL_I386_12,
                            IMAGE_REL_I386_13,
                            IMAGE_REL_I386_REL32);   (* 0014h - PC-relative 32-bit reference to the symbols virtual address *)

<* POP *> (* Back to 4 byte alignment *)

(*
** Relocation format.
*)

TYPE IMAGE_RELOCATION =
     RECORD
            CASE : BOOLEAN OF
            | TRUE  : VirtualAddress : DWORD;
            | FALSE : RelocCount     : DWORD; (* Set to the real count when IMAGE_SCN_LNK_NRELOC_OVFL is set *)
            END;
            SymbolTableIndex : DWORD;
            Type : IMAGE_REL_I386_ENUM;
     END;
    PIMAGE_RELOCATION = POINTER TO IMAGE_RELOCATION;

CONST IMAGE_SIZEOF_RELOCATION = 10;

(*
** Line number format.
*)

TYPE IMAGE_LINENUMBER =
     RECORD
            CASE : BOOLEAN OF
            | TRUE  : SymbolTableIndex : DWORD; (* Symbol table index of function name if Linenumber is 0. *)
            | FALSE : VirtualAddress   : DWORD; (* Virtual address of line number. *)
            END;
            Linenumber : WORD;                  (* Line number. *)
     END;
    PIMAGE_LINENUMBER = POINTER TO IMAGE_LINENUMBER;

CONST IMAGE_SIZEOF_LINENUMBER = 6;

<* POP *> (* Return to 4-byte packing *)

(*
** Based relocation format.
*)

TYPE IMAGE_BASE_RELOCATION =
     RECORD
            VirtualAddress : DWORD;
            SizeOfBlock : DWORD;
         (* TypeOffset = ARRAY [0..0] OF WORD; *)
     END;
    PIMAGE_BASE_RELOCATION = POINTER TO IMAGE_BASE_RELOCATION;

CONST IMAGE_SIZEOF_BASE_RELOCATION = 8;

(*
** Based relocation types.
*)

CONST IMAGE_REL_BASED_ABSOLUTE              = 0;
      IMAGE_REL_BASED_HIGH                  = 1;
      IMAGE_REL_BASED_LOW                   = 2;
      IMAGE_REL_BASED_HIGHLOW               = 3;
      IMAGE_REL_BASED_HIGHADJ               = 4;
      IMAGE_REL_BASED_MIPS_JMPADDR          = 5;

(*
** Archive format.
*)

CONST IMAGE_ARCHIVE_START_SIZE             = 8;
      IMAGE_ARCHIVE_START                  = "!<arch>"+012C;
      IMAGE_ARCHIVE_END                    = "`"+012C;
      IMAGE_ARCHIVE_PAD                    = ""+012C;
      IMAGE_ARCHIVE_LINKER_MEMBER          = "/               ";
      IMAGE_ARCHIVE_LONGNAMES_MEMBER       = "//              ";

TYPE IMAGE_ARCHIVE_MEMBER_HEADER =
     RECORD
            Name      : ARRAY [0..15] OF BYTE;  (* File member name - `/' terminated. *)
            Date      : ARRAY [0..11] OF BYTE;  (* File member date - decimal. *)
            UserID    : ARRAY [0..5]  OF BYTE;  (* File member user id - decimal. *)
            GroupID   : ARRAY [0..5]  OF BYTE;  (* File member group id - decimal. *)
            Mode      : ARRAY [0..7]  OF BYTE;  (* File member mode - octal. *)
            Size      : ARRAY [0..9]  OF BYTE;  (* File member size - decimal. *)
            EndHeader : ARRAY [0..1]  OF BYTE;  (* String to end header. *)
     END;
    PIMAGE_ARCHIVE_MEMBER_HEADER = POINTER TO IMAGE_ARCHIVE_MEMBER_HEADER;

CONST IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR = 60;

(*
** DLL support.
*)


(*
** Export Format
*)


TYPE IMAGE_EXPORT_DIRECTORY =
     RECORD
            Characteristics       : DWORD;
            TimeDateStamp         : DWORD;
            MajorVersion          : WORD;
            MinorVersion          : WORD;
            Name                  : DWORD;
            Base                  : DWORD;
            NumberOfFunctions     : DWORD;
            NumberOfNames         : DWORD;
            AddressOfFunctions    : PPDWORD;
            AddressOfNames        : PPDWORD;
            AddressOfNameOrdinals : PPWORD;
     END;
    PIMAGE_EXPORT_DIRECTORY = POINTER TO IMAGE_EXPORT_DIRECTORY;

(*
** Import Format
*)


TYPE IMAGE_IMPORT_BY_NAME =
     RECORD
            Hint : WORD;
            Name : ARRAY [0..0] OF BYTE;
     END;
    PIMAGE_IMPORT_BY_NAME = POINTER TO IMAGE_IMPORT_BY_NAME;

TYPE IMAGE_THUNK_DATA =
     RECORD
            CASE : INTEGER OF
            | 0 : ForwarderString : PBYTE;
            | 1 : Function : PDWORD;
            | 2 : Ordinal : DWORD;
            | 3 : AddressOfData : PIMAGE_IMPORT_BY_NAME;
            END;
     END;
    PIMAGE_THUNK_DATA = POINTER TO IMAGE_THUNK_DATA;

CONST IMAGE_ORDINAL_FLAG = 80000000h;

TYPE IMAGE_IMPORT_DESCRIPTOR =
     RECORD
            CASE : BOOLEAN OF
            | TRUE  : Characteristics    : DWORD;             (* 0 for terminating null import descriptor *)
            | FALSE : OriginalFirstThunk : PIMAGE_THUNK_DATA; (* RVA to original unbound IAT *)
            END;
            TimeDateStamp : DWORD;          (* 0 if not bound, *)
                                            (* -1 if bound, and real date\time stamp *)
                                            (*     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND) *)
                                            (* O.W. date/time stamp of DLL bound to (Old BIND) *)

            ForwarderChain : DWORD;         (* -1 if no forwarders *)
            Name : DWORD;
            FirstThunk : PIMAGE_THUNK_DATA; (* RVA to IAT (if bound this IAT has actual addresses) *)
     END;
    PIMAGE_IMPORT_DESCRIPTOR = POINTER TO IMAGE_IMPORT_DESCRIPTOR;

(*
** New format import descriptors pointed to by DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ]
*)

TYPE IMAGE_BOUND_IMPORT_DESCRIPTOR =
     RECORD
            TimeDateStamp : DWORD;
            OffsetModuleName : WORD;
            NumberOfModuleForwarderRefs : WORD;
            (* Array of zero or more IMAGE_BOUND_FORWARDER_REF follows *)
     END;
    PIMAGE_BOUND_IMPORT_DESCRIPTOR = POINTER TO IMAGE_BOUND_IMPORT_DESCRIPTOR;

TYPE IMAGE_BOUND_FORWARDER_REF =
     RECORD
            TimeDateStamp    : DWORD;
            OffsetModuleName : WORD;
            Reserved         : WORD;
     END;
    PIMAGE_BOUND_FORWARDER_REF = POINTER TO IMAGE_BOUND_FORWARDER_REF;

(*
** Thread Local Storage
*)

TYPE PIMAGE_TLS_CALLBACK = PROCEDURE ((* DllHandle : *) PVOID,
                                      (* Reason    : *) DWORD,
                                      (* Reserved  : *) PVOID);
TYPE PPIMAGE_TLS_CALLBACK = POINTER TO PIMAGE_TLS_CALLBACK;

TYPE IMAGE_TLS_DIRECTORY =
     RECORD
            StartAddressOfRawData : DWORD;
            EndAddressOfRawData   : DWORD;
            AddressOfIndex        : PDWORD;
            AddressOfCallBacks    : PPIMAGE_TLS_CALLBACK;
            SizeOfZeroFill        : DWORD;
            Characteristics       : DWORD;
       END;
     PIMAGE_TLS_DIRECTORY = POINTER TO IMAGE_TLS_DIRECTORY;

(*
** Resource Format.
*)

(*
** Resource directory consists of two counts, following by a variable length
** array of directory entries.  The first count is the number of entries at
** beginning of the array that have actual names associated with each entry.
** The entries are in ascending order, case insensitive strings.  The second
** count is the number of entries that immediately follow the named entries.
** This second count identifies the number of entries that have 16-bit integer
** Ids as their name.  These entries are also sorted in ascending order.
**
** This structure allows fast lookup by either name or number, but for any
** given resource entry only one form of lookup is supported, not both.
** This is consistant with the syntax of the .RC file and the .RES file.
*)


TYPE IMAGE_RESOURCE_DIRECTORY =
     RECORD
            Characteristics      : DWORD;
            TimeDateStamp        : DWORD;
            MajorVersion         : WORD;
            MinorVersion         : WORD;
            NumberOfNamedEntries : WORD;
            NumberOfIdEntries    : WORD;
           (* IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[]; *)
     END;
    PIMAGE_RESOURCE_DIRECTORY = POINTER TO IMAGE_RESOURCE_DIRECTORY;

CONST IMAGE_RESOURCE_NAME_IS_STRING    = 80000000h;
      IMAGE_RESOURCE_DATA_IS_DIRECTORY = 80000000h;

(*
** Each directory contains the 32-bit Name of the entry and an offset,
** relative to the beginning of the resource directory of the data associated
** with this directory entry.  If the name of the entry is an actual text
** string instead of an integer Id, then the high order bit of the name field
** is set to one and the low order 31-bits are an offset, relative to the
** beginning of the resource directory of the string, which is of type
** IMAGE_RESOURCE_DIRECTORY_STRING.  Otherwise the high bit is clear and the
** low-order 16-bits are the integer Id that identify this resource directory
** entry. If the directory entry is yet another resource directory (i.e. a
** subdirectory), then the high order bit of the offset field will be
** set to indicate this.  Otherwise the high bit is clear and the offset
** field points to a resource data entry.
*)


TYPE IMAGE_RESOURCE_DIRECTORY_ENTRY =
     RECORD
            CASE : BOOLEAN OF
            | TRUE  : Name : DWORD;
            | FALSE : Id : WORD;
            END;
            OffsetToData : DWORD;
     END;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY = POINTER TO IMAGE_RESOURCE_DIRECTORY_ENTRY;

(*
** For resource directory entries that have actual string names, the Name
** field of the directory entry points to an object of the following type.
** All of these string objects are stored together after the last resource
** directory entry and before the first resource data object.  This minimizes
** the impact of these variable length objects on the alignment of the fixed
** size directory entry objects.
*)

TYPE IMAGE_RESOURCE_DIRECTORY_STRING =
     RECORD
            Length : WORD;
            NameString : ARRAY [0..0] OF CHAR;
     END;
    PIMAGE_RESOURCE_DIRECTORY_STRING = POINTER TO IMAGE_RESOURCE_DIRECTORY_STRING;

TYPE IMAGE_RESOURCE_DIR_STRING_U =
     RECORD
            Length : WORD;
            NameString : ARRAY [0..0] OF WCHAR;
     END;
     PIMAGE_RESOURCE_DIR_STRING_U = POINTER TO IMAGE_RESOURCE_DIR_STRING_U;

(*
** Each resource data entry describes a leaf node in the resource directory
** tree.  It contains an offset, relative to the beginning of the resource
** directory of the data for the resource, a size field that gives the number
** of bytes of data at that offset, a CodePage that should be used when
** decoding code point values within the resource data.  Typically for new
** applications the code page would be the unicode code page.
*)

TYPE IMAGE_RESOURCE_DATA_ENTRY =
     RECORD
            OffsetToData : DWORD;
            Size         : DWORD;
            CodePage     : DWORD;
            Reserved     : DWORD;
     END;
     PIMAGE_RESOURCE_DATA_ENTRY = POINTER TO IMAGE_RESOURCE_DATA_ENTRY;

(*
** Load Configuration Directory Entry
*)


TYPE IMAGE_LOAD_CONFIG_DIRECTORY =
     RECORD
            Characteristics               : DWORD;
            TimeDateStamp                 : DWORD;
            MajorVersion                  : WORD;
            MinorVersion                  : WORD;
            GlobalFlagsClear              : DWORD;
            GlobalFlagsSet                : DWORD;
            CriticalSectionDefaultTimeout : DWORD;
            DeCommitFreeBlockThreshold    : DWORD;
            DeCommitTotalFreeThreshold    : DWORD;
            LockPrefixTable               : PVOID;
            MaximumAllocationSize         : DWORD;
            VirtualMemoryThreshold        : DWORD;
            ProcessHeapFlags              : DWORD;
            ProcessAffinityMask           : DWORD;
            Reserved                      : ARRAY [0..2] OF DWORD;
     END;
     PIMAGE_LOAD_CONFIG_DIRECTORY = POINTER TO IMAGE_LOAD_CONFIG_DIRECTORY;

(*
** Function table entry format for MIPS/ALPHA images.  Function table is
** pointed to by the IMAGE_DIRECTORY_ENTRY_EXCEPTION directory entry.
** This definition duplicates ones in ntmips.h and ntalpha.h for use
** by portable image file mungers.
*)

TYPE IMAGE_RUNTIME_FUNCTION_ENTRY =
     RECORD
            BeginAddress     : DWORD;
            EndAddress       : DWORD;
            ExceptionHandler : PVOID;
            HandlerData      : PVOID;
            PrologEndAddress : DWORD;
     END;
    PIMAGE_RUNTIME_FUNCTION_ENTRY = POINTER TO IMAGE_RUNTIME_FUNCTION_ENTRY;

(*
** Debug Format
*)

TYPE IMAGE_DEBUG_TYPE_ENUM = (IMAGE_DEBUG_TYPE_UNKNOWN,        (* 0 *)
                              IMAGE_DEBUG_TYPE_COFF,           (* 1 *)
                              IMAGE_DEBUG_TYPE_CODEVIEW,       (* 2 *)
                              IMAGE_DEBUG_TYPE_FPO,            (* 3 *)
                              IMAGE_DEBUG_TYPE_MISC,           (* 4 *)
                              IMAGE_DEBUG_TYPE_EXCEPTION,      (* 5 *)
                              IMAGE_DEBUG_TYPE_FIXUP,          (* 6 *)
                              IMAGE_DEBUG_TYPE_OMAP_TO_SRC,    (* 7 *)
                              IMAGE_DEBUG_TYPE_OMAP_FROM_SRC); (* 8 *)

TYPE IMAGE_DEBUG_DIRECTORY =
     RECORD
            Characteristics  : DWORD;
            TimeDateStamp    : DWORD;
            MajorVersion     : WORD;
            MinorVersion     : WORD;
            Type             : IMAGE_DEBUG_TYPE_ENUM;
            SizeOfData       : DWORD;
            AddressOfRawData : DWORD;
            PointerToRawData : DWORD;
     END;
    PIMAGE_DEBUG_DIRECTORY = POINTER TO IMAGE_DEBUG_DIRECTORY;

TYPE IMAGE_COFF_SYMBOLS_HEADER =
     RECORD
            NumberOfSymbols      : DWORD;
            LvaToFirstSymbol     : DWORD;
            NumberOfLinenumbers  : DWORD;
            LvaToFirstLinenumber : DWORD;
            RvaToFirstByteOfCode : DWORD;
            RvaToLastByteOfCode  : DWORD;
            RvaToFirstByteOfData : DWORD;
            RvaToLastByteOfData  : DWORD;
     END;
    PIMAGE_COFF_SYMBOLS_HEADER = POINTER TO IMAGE_COFF_SYMBOLS_HEADER;

CONST FRAME_FPO       = 0;
      FRAME_TRAP      = 1;
      FRAME_TSS       = 2;
      FRAME_NONFPO    = 3;

TYPE FPO_DATA = RECORD
                        ulOffStart : DWORD; (* offset 1st byte of function code *)
                        cbProcSize : DWORD; (* # bytes in function *)
                        cdwLocals  : DWORD; (* # bytes in locals/4 *)
                        cdwParams  : WORD;  (* # bytes in params/4 *)
                        cbProlog   : BYTE;  (* # bytes in prolog *)
                        flags      : BYTE;

        (* flags field consists of following bit fields:

                        cbRegs   : 3;       (* # regs saved *)
                        fHasSEH  : 1;       (* TRUE if SEH in func *)
                        fUseBP   : 1;       (* TRUE if EBP has been allocated *)
                        reserved : 1;       (* reserved for future use *)
                        cbFrame  : 2;       (* frame type *)
        *)

                END;
    PFPO_DATA = POINTER TO FPO_DATA;

CONST SIZEOF_RFPO_DATA = 16;

CONST IMAGE_DEBUG_MISC_EXENAME    = 1;

TYPE IMAGE_DEBUG_MISC =
     RECORD
            DataType : DWORD;                  (* type of misc data, see defines *)
            Length   : DWORD;                  (* total length of record, rounded to four *)
                                               (* byte multiple. *)
            Unicode  : BOOL8;                  (* TRUE if data is unicode string *)
            Reserved : ARRAY [0..2] OF BYTE;
            Data     : ARRAY [0..0] OF  BYTE;  (* Actual data *)
     END;
    PIMAGE_DEBUG_MISC = POINTER TO IMAGE_DEBUG_MISC;

(*
** Function table extracted from MIPS/ALPHA images.  Does not contain
** information needed only for runtime support.  Just those fields for
** each entry needed by a debugger.
*)


TYPE IMAGE_FUNCTION_ENTRY =
     RECORD
            StartingAddress : DWORD;
            EndingAddress   : DWORD;
            EndOfPrologue   : DWORD;
     END;
     PIMAGE_FUNCTION_ENTRY = POINTER TO IMAGE_FUNCTION_ENTRY;

(*
** Debugging information can be stripped from an image file and placed
** in a separate .DBG file, whose file name part is the same as the
** image file name part (e.g. symbols for CMD.EXE could be stripped
** and placed in CMD.DBG).  This is indicated by the IMAGE_FILE_DEBUG_STRIPPED
** flag in the Characteristics field of the file header.  The beginning of
** the .DBG file contains the following structure which captures certain
** information from the image file.  This allows a debug to proceed even if
** the original image file is not accessable.  This header is followed by
** zero of more IMAGE_SECTION_HEADER structures, followed by zero or more
** IMAGE_DEBUG_DIRECTORY structures.  The latter structures and those in
** the image file contain file offsets relative to the beginning of the
** .DBG file.
**
** If symbols have been stripped from an image, the IMAGE_DEBUG_MISC structure
** is left in the image file, but not mapped.  This allows a debugger to
** compute the name of the .DBG file, from the name of the image in the
** IMAGE_DEBUG_MISC structure.
*)


TYPE IMAGE_SEPARATE_DEBUG_HEADER =
     RECORD
            Signature          : WORD;
            Flags              : WORD;
            Machine            : IMAGE_FILE_MACHINE_TYPE;
            Characteristics    : WORD;
            TimeDateStamp      : DWORD;
            CheckSum           : DWORD;
            ImageBase          : DWORD;
            SizeOfImage        : DWORD;
            NumberOfSections   : DWORD;
            ExportedNamesSize  : DWORD;
            DebugDirectorySize : DWORD;
            SectionAlignment   : DWORD;
            Reserved           : ARRAY [0..1] OF DWORD;
     END;
    PIMAGE_SEPARATE_DEBUG_HEADER = POINTER TO IMAGE_SEPARATE_DEBUG_HEADER;

CONST IMAGE_SEPARATE_DEBUG_SIGNATURE = 4944h;

CONST IMAGE_SEPARATE_DEBUG_FLAGS_MASK = 8000h;
CONST IMAGE_SEPARATE_DEBUG_MISMATCH   = 8000h; (* when DBG was updated, the
                                                old checksum didn't match.
                                             *)

<* POP *> (* Return to default (8 byte) packing *)

(*
** End Image Format
*)

TYPE HEAP_ENUM = (HEAP__NO_SERIALIZE,             (* 0 *)
                  HEAP__GROWABLE,                 (* 1 *)
                  HEAP__GENERATE_EXCEPTIONS,      (* 2 *)
                  HEAP__ZERO_MEMORY,              (* 3 *)
                  HEAP__REALLOC_IN_PLACE_ONLY,    (* 4 *)
                  HEAP__TAIL_CHECKING_ENABLED,    (* 5 *)
                  HEAP__FREE_CHECKING_ENABLED,    (* 6 *)
                  HEAP__DISABLE_COALESCE_ON_FREE, (* 7 *)
                  HEAP__8,  HEAP__9,
                  HEAP__10, HEAP__11,
                  HEAP__12, HEAP__13,
                  HEAP__14, HEAP__15,
                  HEAP__CREATE_ALIGN_16,          (* 16 *)
                  HEAP__CREATE_ENABLE_TRACING);   (* 17 *)

     HEAP_SET = SET OF HEAP_ENUM;

CONST HEAP_NO_SERIALIZE             = HEAP_SET {HEAP__NO_SERIALIZE            }; (* 00000001 *)
      HEAP_GROWABLE                 = HEAP_SET {HEAP__GROWABLE                }; (* 00000002 *)
      HEAP_GENERATE_EXCEPTIONS      = HEAP_SET {HEAP__GENERATE_EXCEPTIONS     }; (* 00000004 *)
      HEAP_ZERO_MEMORY              = HEAP_SET {HEAP__ZERO_MEMORY             }; (* 00000008 *)
      HEAP_REALLOC_IN_PLACE_ONLY    = HEAP_SET {HEAP__REALLOC_IN_PLACE_ONLY   }; (* 00000010 *)
      HEAP_TAIL_CHECKING_ENABLED    = HEAP_SET {HEAP__TAIL_CHECKING_ENABLED   }; (* 00000020 *)
      HEAP_FREE_CHECKING_ENABLED    = HEAP_SET {HEAP__FREE_CHECKING_ENABLED   }; (* 00000040 *)
      HEAP_DISABLE_COALESCE_ON_FREE = HEAP_SET {HEAP__DISABLE_COALESCE_ON_FREE}; (* 00000080 *)
      HEAP_CREATE_ALIGN_16          = HEAP_SET {HEAP__CREATE_ALIGN_16         }; (* 00010000 *)
      HEAP_CREATE_ENABLE_TRACING    = HEAP_SET {HEAP__CREATE_ENABLE_TRACING   }; (* 00020000 *)

CONST HEAP_MAXIMUM_TAG              = 0FFFh;
      HEAP_PSEUDO_TAG_FLAG          = 8000h;
      HEAP_TAG_SHIFT                = 16;

TYPE IS_TEXT_UNICODE_ENUM = (IS_TEXT_UNICODE__ASCII16,            (*  0 *)
                             IS_TEXT_UNICODE__STATISTICS,         (*  1 *)
                             IS_TEXT_UNICODE__CONTROLS,           (*  2 *)
                             IS_TEXT_UNICODE__SIGNATURE,          (*  3 *)
                             IS_TEXT_UNICODE__REVERSE_ASCII16,    (*  4 *)
                             IS_TEXT_UNICODE__REVERSE_STATISTICS, (*  5 *)
                             IS_TEXT_UNICODE__REVERSE_CONTROLS,   (*  6 *)
                             IS_TEXT_UNICODE__REVERSE_SIGNATURE,  (*  7 *)
                             IS_TEXT_UNICODE__ILLEGAL_CHARS,      (*  8 *)
                             IS_TEXT_UNICODE__ODD_LENGTH,         (*  9 *)
                             IS_TEXT_UNICODE__DBCS_LEADBYTE,      (* 10 *)
                             IS_TEXT_UNICODE__11,
                             IS_TEXT_UNICODE__NULL_BYTES,         (* 12 *)
                             IS_TEXT_UNICODE__13,
                             IS_TEXT_UNICODE__14,
                             IS_TEXT_UNICODE__15);

     IS_TEXT_UNICODE_SET = SET OF IS_TEXT_UNICODE_ENUM;

CONST IS_TEXT_UNICODE_ASCII16            = IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__ASCII16           }; (* 0001h *)
      IS_TEXT_UNICODE_REVERSE_ASCII16    = IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__REVERSE_ASCII16   }; (* 0010h *)

      IS_TEXT_UNICODE_STATISTICS         = IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__STATISTICS        }; (* 0002h *)
      IS_TEXT_UNICODE_REVERSE_STATISTICS = IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__REVERSE_STATISTICS}; (* 0020h *)

      IS_TEXT_UNICODE_CONTROLS           = IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__CONTROLS          }; (* 0004h *)
      IS_TEXT_UNICODE_REVERSE_CONTROLS   = IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__REVERSE_CONTROLS  }; (* 0040h *)

      IS_TEXT_UNICODE_SIGNATURE          = IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__SIGNATURE         }; (* 0008h *)
      IS_TEXT_UNICODE_REVERSE_SIGNATURE  = IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__REVERSE_SIGNATURE }; (* 0080h *)

      IS_TEXT_UNICODE_ILLEGAL_CHARS      = IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__ILLEGAL_CHARS     }; (* 0100h *)
      IS_TEXT_UNICODE_ODD_LENGTH         = IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__ODD_LENGTH        }; (* 0200h *)
      IS_TEXT_UNICODE_DBCS_LEADBYTE      = IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__DBCS_LEADBYTE     }; (* 0400h *)
      IS_TEXT_UNICODE_NULL_BYTES         = IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__NULL_BYTES        }; (* 1000h *)

      IS_TEXT_UNICODE_UNICODE_MASK = IS_TEXT_UNICODE_ASCII16 +
                                     IS_TEXT_UNICODE_STATISTICS +
                                     IS_TEXT_UNICODE_CONTROLS +
                                     IS_TEXT_UNICODE_SIGNATURE;   (* 000Fh *)

      IS_TEXT_UNICODE_REVERSE_MASK = IS_TEXT_UNICODE_REVERSE_ASCII16 +
                                     IS_TEXT_UNICODE_REVERSE_STATISTICS +
                                     IS_TEXT_UNICODE_REVERSE_CONTROLS +
                                     IS_TEXT_UNICODE_REVERSE_SIGNATURE; (* 00F0h *)

      IS_TEXT_UNICODE_NOT_UNICODE_MASK = IS_TEXT_UNICODE_ILLEGAL_CHARS +
                                         IS_TEXT_UNICODE_ODD_LENGTH +
                                         IS_TEXT_UNICODE_DBCS_LEADBYTE +
                                         IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__11}; (* 0F00h *)

      IS_TEXT_UNICODE_NOT_ASCII_MASK = IS_TEXT_UNICODE_NULL_BYTES +
                                       IS_TEXT_UNICODE_SET {IS_TEXT_UNICODE__13..
                                                            IS_TEXT_UNICODE__14};  (* 0F000h *)


CONST COMPRESSION_FORMAT_NONE          = 0000h;
      COMPRESSION_FORMAT_DEFAULT       = 0001h;
      COMPRESSION_FORMAT_LZNT1         = 0002h;
      COMPRESSION_ENGINE_STANDARD      = 0000h;
      COMPRESSION_ENGINE_MAXIMUM       = 0100h;

PROCEDURE RtlEqualMemory (Source1 : PVOID;
                          Source2 : LPCVOID;
                          Length  : DWORD);

PROCEDURE RtlCopyMemory (Destination : PVOID;
                         Source      : LPCVOID;
                         Length      : DWORD);

PROCEDURE RtlMoveMemory (Destination : PVOID;
                         Source      : LPCVOID;
                         Length      : DWORD);

PROCEDURE RtlFillMemory (Destination : PVOID;
                         Length      : DWORD;
                         Fill        : BYTE);

PROCEDURE RtlZeroMemory (Destination : PVOID;
                         Length      : DWORD);

TYPE MESSAGE_RESOURCE_ENTRY = RECORD
                                     Length : WORD;
                                     Flags  : WORD;
                                     Text   : ARRAY [0..1] OF BYTE;
                              END;
    PMESSAGE_RESOURCE_ENTRY = POINTER TO MESSAGE_RESOURCE_ENTRY;

CONST MESSAGE_RESOURCE_UNICODE = 0001h;

TYPE MESSAGE_RESOURCE_BLOCK = RECORD
                                     LowId           : DWORD;
                                     HighId          : DWORD;
                                     OffsetToEntries : DWORD;
                              END;
    PMESSAGE_RESOURCE_BLOCK = POINTER TO MESSAGE_RESOURCE_BLOCK;

TYPE MESSAGE_RESOURCE_DATA = RECORD
                                    NumberOfBlocks : DWORD;
                                    Blocks         : ARRAY [0..0] OF MESSAGE_RESOURCE_BLOCK;
                             END;
    PMESSAGE_RESOURCE_DATA = POINTER TO MESSAGE_RESOURCE_DATA;


TYPE PRTL_CRITICAL_SECTION = POINTER TO RTL_CRITICAL_SECTION;
     RTL_CRITICAL_SECTION_DEBUG =
     RECORD
            Type                  : WORD;
            CreatorBackTraceIndex : WORD;
            CriticalSection       : PRTL_CRITICAL_SECTION;
            ProcessLocksList      : LIST_ENTRY;
            EntryCount            : DWORD;
            ContentionCount       : DWORD;
            Spare                 : ARRAY [0..1] OF DWORD;
     END;
     PRTL_CRITICAL_SECTION_DEBUG = POINTER TO RTL_CRITICAL_SECTION_DEBUG;

CONST RTL_CRITSECT_TYPE = 0;
      RTL_RESOURCE_TYPE = 1;

TYPE RTL_CRITICAL_SECTION =
     RECORD
            DebugInfo : PRTL_CRITICAL_SECTION_DEBUG;

    (*
    **  The following three fields control entering and exiting the critical
    **  section for the resource
    *)

            LockCount      : LONG;
            RecursionCount : LONG;
            OwningThread   : HANDLE; (* from the thread's ClientId->UniqueThread *)
            LockSemaphore  : HANDLE;
            Reserved       : DWORD;
     END;

CONST DLL_PROCESS_ATTACH = 1;
      DLL_THREAD_ATTACH  = 2;
      DLL_THREAD_DETACH  = 3;
      DLL_PROCESS_DETACH = 0;

(*
** Defines for the READ flags for Eventlogging (ReadEventLog ReadFlags parameter)
*)

TYPE EVENTLOG_READ_ENUM = (EVENTLOG__SEQUENTIAL_READ,   (* 0 *)
                           EVENTLOG__SEEK_READ,         (* 1 *)
                           EVENTLOG__FORWARDS_READ,     (* 2 *)
                           EVENTLOG__BACKWARDS_READ);   (* 3 *)
     EVENTLOG_READ_SET = SET OF EVENTLOG_READ_ENUM;

CONST EVENTLOG_SEQUENTIAL_READ = EVENTLOG_READ_SET {EVENTLOG__SEQUENTIAL_READ}; (* 0001h *)
      EVENTLOG_SEEK_READ       = EVENTLOG_READ_SET {EVENTLOG__SEEK_READ      }; (* 0002h *)
      EVENTLOG_FORWARDS_READ   = EVENTLOG_READ_SET {EVENTLOG__FORWARDS_READ  }; (* 0004h *)
      EVENTLOG_BACKWARDS_READ  = EVENTLOG_READ_SET {EVENTLOG__BACKWARDS_READ }; (* 0008h *)

(*
** The types of events that can be logged.
*)

TYPE EVENTLOG_ENUM = (EVENTLOG__ERROR_TYPE,       (* 0 *)
                      EVENTLOG__WARNING_TYPE,     (* 1 *)
                      EVENTLOG__INFORMATION_TYPE, (* 2 *)
                      EVENTLOG__AUDIT_SUCCESS,    (* 3 *)
                      EVENTLOG__AUDIT_FAILURE);   (* 4 *)

<* PUSH *> <* SETSIZE = "2" *>

TYPE EVENTLOG_TYPE = SET OF EVENTLOG_ENUM;

<* POP *>

CONST EVENTLOG_SUCCESS          = EVENTLOG_TYPE {};                           (* 0000h *)
      EVENTLOG_ERROR_TYPE       = EVENTLOG_TYPE {EVENTLOG__ERROR_TYPE};       (* 0001h *)
      EVENTLOG_WARNING_TYPE     = EVENTLOG_TYPE {EVENTLOG__WARNING_TYPE};     (* 0002h *)
      EVENTLOG_INFORMATION_TYPE = EVENTLOG_TYPE {EVENTLOG__INFORMATION_TYPE}; (* 0004h *)
      EVENTLOG_AUDIT_SUCCESS    = EVENTLOG_TYPE {EVENTLOG__AUDIT_SUCCESS};    (* 0008h *)
      EVENTLOG_AUDIT_FAILURE    = EVENTLOG_TYPE {EVENTLOG__AUDIT_FAILURE};    (* 0010h *)

(*
** Defines for the WRITE flags used by Auditing for paired events
** These are not implemented in Product 1
*)

TYPE EVENTLOG_WRITE_ENUM = (EVENTLOG__START_PAIRED_EVENT,     (* 0 *)
                            EVENTLOG__END_PAIRED_EVENT,       (* 1 *)
                            EVENTLOG__END_ALL_PAIRED_EVENTS,  (* 2 *)
                            EVENTLOG__PAIRED_EVENT_ACTIVE,    (* 3 *)
                            EVENTLOG__PAIRED_EVENT_INACTIVE); (* 4 *)

     EVENTLOG_WRITE_SET = SET OF EVENTLOG_WRITE_ENUM;

CONST EVENTLOG_START_PAIRED_EVENT    = EVENTLOG_WRITE_SET {EVENTLOG__START_PAIRED_EVENT};    (* 0001h *)
      EVENTLOG_END_PAIRED_EVENT      = EVENTLOG_WRITE_SET {EVENTLOG__END_PAIRED_EVENT};      (* 0002h *)
      EVENTLOG_END_ALL_PAIRED_EVENTS = EVENTLOG_WRITE_SET {EVENTLOG__END_ALL_PAIRED_EVENTS}; (* 0004h *)
      EVENTLOG_PAIRED_EVENT_ACTIVE   = EVENTLOG_WRITE_SET {EVENTLOG__PAIRED_EVENT_ACTIVE};   (* 0008h *)
      EVENTLOG_PAIRED_EVENT_INACTIVE = EVENTLOG_WRITE_SET {EVENTLOG__PAIRED_EVENT_INACTIVE}; (* 0010h *)

(*
** Structure that defines the header of the Eventlog record. This is the
** fixed-sized portion before all the variable-length strings, binary
** data and pad bytes.
**
** TimeGenerated is the time it was generated at the client.
** TimeWritten is the time it was put into the log at the server end.
*)


TYPE EVENTLOGRECORD =
     RECORD
            Length              : DWORD;  (* Length of full record *)
            Reserved            : DWORD;  (* Used by the service *)
            RecordNumber        : DWORD;  (* Absolute record number *)
            TimeGenerated       : DWORD;  (* Seconds since 1-1-1970 *)
            TimeWritten         : DWORD;  (* Seconds since 1-1-1970 *)
            EventID             : DWORD;
            EventType           : EVENTLOG_TYPE;
            NumStrings          : WORD;
            EventCategory       : WORD;
            ReservedFlags       : WORD;   (* For use with paired events (auditing) *)
            ClosingRecordNumber : DWORD;  (* For use with paired events (auditing) *)
            StringOffset        : DWORD;  (* Offset from beginning of record *)
            UserSidLength       : DWORD;
            UserSidOffset       : DWORD;
            DataLength          : DWORD;
            DataOffset          : DWORD;  (* Offset from beginning of record *)

            (*
            ** Then follow:
            **
            ** WCHAR SourceName[]
            ** WCHAR Computername[]
            ** SID   UserSid
            ** WCHAR Strings[]
            ** BYTE  Data[]
            ** CHAR  Pad[]
            ** DWORD Length;
            *)
     END;
     PEVENTLOGRECORD = POINTER TO EVENTLOGRECORD;

CONST DBG_CONTINUE                    = 00010002h;
      DBG_TERMINATE_THREAD            = 40010003h;
      DBG_TERMINATE_PROCESS           = 40010004h;
      DBG_CONTROL_C                   = 40010005h;
      DBG_CONTROL_BREAK               = 40010008h;
      DBG_EXCEPTION_NOT_HANDLED       = 80010001h;


(*
** Registry Specific Access Rights.
*)

CONST KEY_QUERY_VALUE         = ACCESS_MASK {ACCESS_0}; (* 0001h) *)
      KEY_SET_VALUE           = ACCESS_MASK {ACCESS_1}; (* 0002h) *)
      KEY_CREATE_SUB_KEY      = ACCESS_MASK {ACCESS_2}; (* 0004h) *)
      KEY_ENUMERATE_SUB_KEYS  = ACCESS_MASK {ACCESS_3}; (* 0008h) *)
      KEY_NOTIFY              = ACCESS_MASK {ACCESS_4}; (* 0010h) *)
      KEY_CREATE_LINK         = ACCESS_MASK {ACCESS_5}; (* 0020h) *)

      KEY_READ                = STANDARD_RIGHTS_READ
                                + KEY_QUERY_VALUE
                                + KEY_ENUMERATE_SUB_KEYS
                                + KEY_NOTIFY
                                - SYNCHRONIZE;

      KEY_WRITE               = STANDARD_RIGHTS_WRITE 
                                + KEY_SET_VALUE
                                + KEY_CREATE_SUB_KEY
                                - SYNCHRONIZE;

      KEY_EXECUTE             = KEY_READ - SYNCHRONIZE;

      KEY_ALL_ACCESS          = STANDARD_RIGHTS_ALL
                                + KEY_QUERY_VALUE
                                + KEY_SET_VALUE
                                + KEY_CREATE_SUB_KEY
                                + KEY_ENUMERATE_SUB_KEYS
                                + KEY_NOTIFY
                                + KEY_CREATE_LINK
                                - SYNCHRONIZE;

(*
** Open/Create Options
*)

TYPE REG_OPTION_ENUM = (REG_OPTION__VOLATILE,        (* 0 *)
                        REG_OPTION__CREATE_LINK,     (* 1 *)
                        REG_OPTION__BACKUP_RESTORE,  (* 2 *)
                        REG_OPTION__OPEN_LINK);      (* 3 *)

     REG_OPTION_SET = SET OF REG_OPTION_ENUM;

CONST REG_OPTION_RESERVED       = REG_OPTION_SET {};                           (* 00000000h *)
                                  (* Parameter is reserved *)

      REG_OPTION_NON_VOLATILE   = REG_OPTION_SET {};                           (* 00000000h *)
                                  (* Key is preserved *)
                                  (* when system is rebooted *)

      REG_OPTION_VOLATILE       = REG_OPTION_SET {REG_OPTION__VOLATILE};       (* 00000001h *)
                                  (* Key is not preserved *)
                                  (* when system is rebooted *)

      REG_OPTION_CREATE_LINK    = REG_OPTION_SET {REG_OPTION__CREATE_LINK};    (* 00000002h *)
                                  (* Created key is a *)
                                  (* symbolic link *)

      REG_OPTION_OPEN_LINK      = REG_OPTION_SET {REG_OPTION__OPEN_LINK};    (* 00000002h *)
                                  (* Open symbolic link *)

      REG_OPTION_BACKUP_RESTORE = REG_OPTION_SET {REG_OPTION__BACKUP_RESTORE}; (* 00000004h *)
                                  (* open for backup or restore *)
                                  (* special access rules *)
                                  (* privilege required *)

      REG_LEGAL_OPTION  = REG_OPTION_RESERVED     +
                          REG_OPTION_NON_VOLATILE +
                          REG_OPTION_VOLATILE     +
                          REG_OPTION_CREATE_LINK  +
                          REG_OPTION_BACKUP_RESTORE +
                          REG_OPTION_OPEN_LINK;

(*
** Key creation/open disposition
*)


TYPE REG_DISPOSITION = (REG_DISPOSITION_0,
                        REG_CREATED_NEW_KEY,       (* 00000001h; New Registry Key created *)
                        REG_OPENED_EXISTING_KEY);  (* 00000002h; Existing Key opened *)

(*
** Key restore flags
*)

TYPE REG_RESTORE_ENUM = (REG__WHOLE_HIVE_VOLATILE, (* 0 *)
                         REG__REFRESH_HIVE,        (* 1 *)
                         REG__NO_LAZY_FLUSH);      (* 2 *)

     REG_RESTORE_SET = SET OF REG_RESTORE_ENUM;

CONST REG_WHOLE_HIVE_VOLATILE = REG_RESTORE_SET {REG__WHOLE_HIVE_VOLATILE}; (* 00000001h; Restore whole hive volatile  *)
      REG_REFRESH_HIVE        = REG_RESTORE_SET {REG__REFRESH_HIVE};        (* 00000002h; Unwind changes to last flush *)
      REG_NO_LAZY_FLUSH       = REG_RESTORE_SET {REG__NO_LAZY_FLUSH};       (* 00000004h; Never lazy flush this hive   *)

(* Notify filter values *)

TYPE REG_NOTIFY_ENUM = (REG_NOTIFY__CHANGE_NAME,       (* 0 - Create or delete (child) *)
                        REG_NOTIFY__CHANGE_ATTRIBUTES, (* 1 *)
                        REG_NOTIFY__CHANGE_LAST_SET,   (* 2 - time stamp *)
                        REG_NOTIFY__CHANGE_SECURITY);  (* 3 *)
     REG_NOTIFY_SET = SET OF REG_NOTIFY_ENUM;

CONST REG_NOTIFY_CHANGE_NAME       = REG_NOTIFY_SET {REG_NOTIFY__CHANGE_NAME      }; (* 00000001h *)
      REG_NOTIFY_CHANGE_ATTRIBUTES = REG_NOTIFY_SET {REG_NOTIFY__CHANGE_ATTRIBUTES}; (* 00000002h *)
      REG_NOTIFY_CHANGE_LAST_SET   = REG_NOTIFY_SET {REG_NOTIFY__CHANGE_LAST_SET  }; (* 00000004h *)
      REG_NOTIFY_CHANGE_SECURITY   = REG_NOTIFY_SET {REG_NOTIFY__CHANGE_SECURITY  }; (* 00000008h *)

      REG_LEGAL_CHANGE_FILTER = REG_NOTIFY_CHANGE_NAME       +
                                REG_NOTIFY_CHANGE_ATTRIBUTES +
                                REG_NOTIFY_CHANGE_LAST_SET   +
                                REG_NOTIFY_CHANGE_SECURITY;


(*
** Predefined Value Types.
*)

TYPE REG_TYPE = (REG_NONE,                        (*  0 - No value type *)
                 REG_SZ,                          (*  1 - Unicode nul terminated string *)
                 REG_EXPAND_SZ,                   (*  2 - Unicode nul terminated string *)
                                                  (*      (with environment variable references) *)
                 REG_BINARY,                      (*  3 - Free form binary *)
                 REG_DWORD_LITTLE_ENDIAN,         (*  4 - 32-bit number (same as REG_DWORD) *)
                 REG_DWORD_BIG_ENDIAN,            (*  5 - 32-bit number *)
                 REG_LINK,                        (*  6 - Symbolic Link (unicode) *)
                 REG_MULTI_SZ,                    (*  7 - Multiple Unicode strings *)
                 REG_RESOURCE_LIST,               (*  8 - Resource list in the resource map *)
                 REG_FULL_RESOURCE_DESCRIPTOR,    (*  9 - Resource list in the hardware description *)
                 REG_RESOURCE_REQUIREMENTS_LIST); (* 10 *)

CONST REG_DWORD = REG_DWORD_LITTLE_ENDIAN;

(*
** Service Types (Bit Mask)
*)

TYPE SERVICE_ENUM = (SERVICE__KERNEL_DRIVER,        (* 0 *)
                     SERVICE__FILE_SYSTEM_DRIVER,   (* 1 *)
                     SERVICE__ADAPTER,              (* 2 *)
                     SERVICE__RECOGNIZER_DRIVER,    (* 3 *)
                     SERVICE__WIN32_OWN_PROCESS,    (* 4 *)
                     SERVICE__WIN32_SHARE_PROCESS,  (* 5 *)
                     SERVICE__6, SERVICE__7,
                     SERVICE__INTERACTIVE_PROCESS); (* 8 *)

     SERVICE_NODE_TYPE = SET OF SERVICE_ENUM;

CONST SERVICE_KERNEL_DRIVER          = SERVICE_NODE_TYPE {SERVICE__KERNEL_DRIVER     }; (* 00000001h *)
      SERVICE_FILE_SYSTEM_DRIVER     = SERVICE_NODE_TYPE {SERVICE__FILE_SYSTEM_DRIVER}; (* 00000002h *)
      SERVICE_ADAPTER                = SERVICE_NODE_TYPE {SERVICE__ADAPTER           }; (* 00000004h *)
      SERVICE_RECOGNIZER_DRIVER      = SERVICE_NODE_TYPE {SERVICE__RECOGNIZER_DRIVER }; (* 00000008h *)
      SERVICE_DRIVER                 = SERVICE_KERNEL_DRIVER +
                                       SERVICE_FILE_SYSTEM_DRIVER +
                                       SERVICE_RECOGNIZER_DRIVER;

      SERVICE_WIN32_OWN_PROCESS      = SERVICE_NODE_TYPE {SERVICE__WIN32_OWN_PROCESS      }; (* 00000010h *)
      SERVICE_WIN32_SHARE_PROCESS    = SERVICE_NODE_TYPE {SERVICE__WIN32_SHARE_PROCESS    }; (* 00000020h *)
      SERVICE_WIN32                  = SERVICE_WIN32_OWN_PROCESS +
                                       SERVICE_WIN32_SHARE_PROCESS;

      SERVICE_INTERACTIVE_PROCESS    = SERVICE_NODE_TYPE {SERVICE__INTERACTIVE_PROCESS    }; (* 00000100h *)

      SERVICE_TYPE_ALL               = SERVICE_WIN32   +
                                       SERVICE_ADAPTER +
                                       SERVICE_DRIVER  +
                                       SERVICE_INTERACTIVE_PROCESS;

(*
** Start Type
*)

TYPE SERVICE_LOAD_TYPE = (SERVICE_BOOT_START,   (* 00000000h *)
                          SERVICE_SYSTEM_START, (* 00000001h *)
                          SERVICE_AUTO_START,   (* 00000002h *)
                          SERVICE_DEMAND_START, (* 00000003h *)
                          SERVICE_DISABLED);    (* 00000004h *)

(*
** Error control type
*)

TYPE SERVICE_ERROR_TYPE = (SERVICE_ERROR_IGNORE,    (* 00000000h *)
                           SERVICE_ERROR_NORMAL,    (* 00000001h *)
                           SERVICE_ERROR_SEVERE,    (* 00000002h *)
                           SERVICE_ERROR_CRITICAL); (* 00000003h *)

(*
** Define the registry driver node enumerations
*)


CONST DriverType               = SERVICE_KERNEL_DRIVER;
      FileSystemType           = SERVICE_FILE_SYSTEM_DRIVER;
      Win32ServiceOwnProcess   = SERVICE_WIN32_OWN_PROCESS;
      Win32ServiceShareProcess = SERVICE_WIN32_SHARE_PROCESS;
      AdapterType              = SERVICE_ADAPTER;
      RecognizerType           = SERVICE_RECOGNIZER_DRIVER;

CONST BootLoad    = SERVICE_BOOT_START;
      SystemLoad  = SERVICE_SYSTEM_START;
      AutoLoad    = SERVICE_AUTO_START;
      DemandLoad  = SERVICE_DEMAND_START;
      DisableLoad = SERVICE_DISABLED;

CONST IgnoreError   = SERVICE_ERROR_IGNORE;
      NormalError   = SERVICE_ERROR_NORMAL;
      SevereError   = SERVICE_ERROR_SEVERE;
      CriticalError = SERVICE_ERROR_CRITICAL;


(*
** IOCTL_TAPE_ERASE definitions
*)

TYPE TAPE_ERASE_TYPE = (TAPE_ERASE_SHORT,  (* 0 *)
                        TAPE_ERASE_LONG ); (* 1 *)

TYPE TAPE_ERASE = RECORD
                         Type      : DWORD;
                         Immediate : BOOL8;
                  END;
    PTAPE_ERASE = POINTER TO TAPE_ERASE;

(*
** IOCTL_TAPE_PREPARE definitions
*)

TYPE TAPE_OPERATION = (TAPE_LOAD,      (* 0 *)
                       TAPE_UNLOAD,    (* 1 *)
                       TAPE_TENSION,   (* 2 *)
                       TAPE_LOCK,      (* 3 *)
                       TAPE_UNLOCK,    (* 4 *)
                       TAPE_FORMAT);   (* 5 *)

TYPE TAPE_PREPARE = RECORD
                           Operation : TAPE_OPERATION;
                           Immediate : BOOL8;
                    END;
    PTAPE_PREPARE = POINTER TO TAPE_PREPARE;

(*
** IOCTL_TAPE_WRITE_MARKS definitions
*)


TYPE TAPE_MARK_TYPE = (TAPE_SETMARKS,         (* 0 *)
                       TAPE_FILEMARKS,        (* 1 *)
                       TAPE_SHORT_FILEMARKS,  (* 2 *)
                       TAPE_LONG_FILEMARKS);  (* 3 *)

TYPE TAPE_WRITE_MARKS = RECORD
                               Type      : TAPE_MARK_TYPE;
                               Count     : DWORD;
                               Immediate : BOOL8;
                        END;
    PTAPE_WRITE_MARKS = POINTER TO TAPE_WRITE_MARKS;

(*
** IOCTL_TAPE_GET_POSITION definitions
*)

TYPE TAPE_GET_POSITION_TYPE = (TAPE_ABSOLUTE_POSITION,        (* 0 *)
                               TAPE_LOGICAL_POSITION,         (* 1 *)
                               TAPE_PSEUDO_LOGICAL_POSITION); (* 2 *)

TYPE TAPE_GET_POSITION = RECORD
                                Type      : TAPE_GET_POSITION_TYPE;
                                Partition : DWORD;
                                Offset    : LARGE_INTEGER;
                         END;
    PTAPE_GET_POSITION = POINTER TO TAPE_GET_POSITION;

(*
** IOCTL_TAPE_SET_POSITION definitions
*)

TYPE TAPE_SET_POSITION_TYPE = (TAPE_REWIND,                 (* 0 *)
                               TAPE_ABSOLUTE_BLOCK,         (* 1 *)
                               TAPE_LOGICAL_BLOCK,          (* 2 *)
                               TAPE_PSEUDO_LOGICAL_BLOCK,   (* 3 *)
                               TAPE_SPACE_END_OF_DATA,      (* 4 *)
                               TAPE_SPACE_RELATIVE_BLOCKS,  (* 5 *)
                               TAPE_SPACE_FILEMARKS,        (* 6 *)
                               TAPE_SPACE_SEQUENTIAL_FMKS,  (* 7 *)
                               TAPE_SPACE_SETMARKS,         (* 8 *)
                               TAPE_SPACE_SEQUENTIAL_SMKS); (* 9 *)

TYPE TAPE_SET_POSITION = RECORD
                                Method    : TAPE_SET_POSITION_TYPE;
                                Partition : DWORD;
                                Offset    : LARGE_INTEGER;
                                Immediate : BOOL8;
                         END;
    PTAPE_SET_POSITION = POINTER TO TAPE_SET_POSITION;

(*
** IOCTL_TAPE_GET_DRIVE_PARAMS definitions
*)


(*
** Definitions for FeaturesLow parameter
*)


CONST TAPE_DRIVE_FIXED            = { 0}; (* 00000001h *)
      TAPE_DRIVE_SELECT           = { 1}; (* 00000002h *)
      TAPE_DRIVE_INITIATOR        = { 2}; (* 00000004h *)

      TAPE_DRIVE_ERASE_SHORT      = { 4}; (* 00000010h *)
      TAPE_DRIVE_ERASE_LONG       = { 5}; (* 00000020h *)
      TAPE_DRIVE_ERASE_BOP_ONLY   = { 6}; (* 00000040h *)
      TAPE_DRIVE_ERASE_IMMEDIATE  = { 7}; (* 00000080h *)

      TAPE_DRIVE_TAPE_CAPACITY    = { 8}; (* 00000100h *)
      TAPE_DRIVE_TAPE_REMAINING   = { 9}; (* 00000200h *)
      TAPE_DRIVE_FIXED_BLOCK      = {10}; (* 00000400h *)
      TAPE_DRIVE_VARIABLE_BLOCK   = {11}; (* 00000800h *)

      TAPE_DRIVE_WRITE_PROTECT    = {12}; (* 00001000h *)
      TAPE_DRIVE_EOT_WZ_SIZE      = {13}; (* 00002000h *)

      TAPE_DRIVE_ECC              = {16}; (* 00010000h *)
      TAPE_DRIVE_COMPRESSION      = {17}; (* 00020000h *)
      TAPE_DRIVE_PADDING          = {18}; (* 00040000h *)
      TAPE_DRIVE_REPORT_SMKS      = {19}; (* 00080000h *)

      TAPE_DRIVE_GET_ABSOLUTE_BLK = {20}; (* 00100000h *)
      TAPE_DRIVE_GET_LOGICAL_BLK  = {21}; (* 00200000h *)
      TAPE_DRIVE_SET_EOT_WZ_SIZE  = {22}; (* 00400000h *)

      TAPE_DRIVE_RESERVED_BIT     = {31}; (* 80000000h;  don't use this bit! *)
                                                       (*can't be a low features bit! *)
                                                       (*reserved; high features only *)
(*
** Definitions for FeaturesHigh parameter
*)

      TAPE_DRIVE_LOAD_UNLOAD      = {31,0};  (* 80000001h *)
      TAPE_DRIVE_TENSION          = {31,1};  (* 80000002h *)
      TAPE_DRIVE_LOCK_UNLOCK      = {31,2};  (* 80000004h *)
      TAPE_DRIVE_REWIND_IMMEDIATE = {31,3};  (* 80000008h *)

      TAPE_DRIVE_SET_BLOCK_SIZE   = {31,4};  (* 80000010h *)
      TAPE_DRIVE_LOAD_UNLD_IMMED  = {31,5};  (* 80000020h *)
      TAPE_DRIVE_TENSION_IMMED    = {31,6};  (* 80000040h *)
      TAPE_DRIVE_LOCK_UNLK_IMMED  = {31,7};  (* 80000080h *)

      TAPE_DRIVE_SET_ECC          = {31,8};  (* 80000100h *)
      TAPE_DRIVE_SET_COMPRESSION  = {31,9};  (* 80000200h *)
      TAPE_DRIVE_SET_PADDING      = {31,10}; (* 80000400h *)
      TAPE_DRIVE_SET_REPORT_SMKS  = {31,11}; (* 80000800h *)

      TAPE_DRIVE_ABSOLUTE_BLK     = {31,12}; (* 80001000h *)
      TAPE_DRIVE_ABS_BLK_IMMED    = {31,13}; (* 80002000h *)
      TAPE_DRIVE_LOGICAL_BLK      = {31,14}; (* 80004000h *)
      TAPE_DRIVE_LOG_BLK_IMMED    = {31,15}; (* 80008000h *)

      TAPE_DRIVE_END_OF_DATA      = {31,16}; (* 80010000h *)
      TAPE_DRIVE_RELATIVE_BLKS    = {31,17}; (* 80020000h *)
      TAPE_DRIVE_FILEMARKS        = {31,18}; (* 80040000h *)
      TAPE_DRIVE_SEQUENTIAL_FMKS  = {31,19}; (* 80080000h *)

      TAPE_DRIVE_SETMARKS         = {31,20}; (* 80100000h *)
      TAPE_DRIVE_SEQUENTIAL_SMKS  = {31,21}; (* 80200000h *)
      TAPE_DRIVE_REVERSE_POSITION = {31,22}; (* 80400000h *)
      TAPE_DRIVE_SPACE_IMMEDIATE  = {31,23}; (* 80800000h *)

      TAPE_DRIVE_WRITE_SETMARKS   = {31,24}; (* 81000000h *)
      TAPE_DRIVE_WRITE_FILEMARKS  = {31,25}; (* 82000000h *)
      TAPE_DRIVE_WRITE_SHORT_FMKS = {31,26}; (* 84000000h *)
      TAPE_DRIVE_WRITE_LONG_FMKS  = {31,27}; (* 88000000h *)

      TAPE_DRIVE_WRITE_MARK_IMMED = {31,28}; (* 90000000h *)
      TAPE_DRIVE_FORMAT           = {31,29}; (* A0000000h *)
      TAPE_DRIVE_FORMAT_IMMEDIATE = {31,30}; (* C0000000h *)
      TAPE_DRIVE_HIGH_FEATURES    = {31};    (* 80000000h;  mask for high features flag *)

TYPE TAPE_GET_DRIVE_PARAMETERS =
     RECORD
            ECC                   : BOOL8;
            Compression           : BOOL8;
            DataPadding           : BOOL8;
            ReportSetmarks        : BOOL8;
            DefaultBlockSize      : DWORD;
            MaximumBlockSize      : DWORD;
            MinimumBlockSize      : DWORD;
            MaximumPartitionCount : DWORD;
            FeaturesLow           : BITSET;
            FeaturesHigh          : BITSET;
            EOTWarningZoneSize    : DWORD;
     END;
     PTAPE_GET_DRIVE_PARAMETERS = POINTER TO TAPE_GET_DRIVE_PARAMETERS;

(*
** IOCTL_TAPE_SET_DRIVE_PARAMETERS definitions
*)

TYPE TAPE_SET_DRIVE_PARAMETERS =
     RECORD
            ECC                : BOOL8;
            Compression        : BOOL8;
            DataPadding        : BOOL8;
            ReportSetmarks     : BOOL8;
            EOTWarningZoneSize : DWORD;
     END;
     PTAPE_SET_DRIVE_PARAMETERS = POINTER TO TAPE_SET_DRIVE_PARAMETERS;

(*
** IOCTL_TAPE_GET_MEDIA_PARAMETERS definitions
*)


TYPE TAPE_GET_MEDIA_PARAMETERS =
     RECORD
            Capacity       : LARGE_INTEGER;
            Remaining      : LARGE_INTEGER;
            BlockSize      : DWORD;
            PartitionCount : DWORD;
            WriteProtected : BOOL8;
     END;
     PTAPE_GET_MEDIA_PARAMETERS = POINTER TO TAPE_GET_MEDIA_PARAMETERS;

(*
** IOCTL_TAPE_SET_MEDIA_PARAMETERS definitions
*)


TYPE TAPE_SET_MEDIA_PARAMETERS =
     RECORD
            BlockSize : DWORD;
     END;
     PTAPE_SET_MEDIA_PARAMETERS = POINTER TO TAPE_SET_MEDIA_PARAMETERS;

(*
** IOCTL_TAPE_CREATE_PARTITION definitions
*)


TYPE TAPE_PARTITION_TYPE = (TAPE_FIXED_PARTITIONS,      (* 0 *)
                            TAPE_SELECT_PARTITIONS,     (* 1 *)
                            TAPE_INITIATOR_PARTITIONS); (* 2 *)

TYPE TAPE_CREATE_PARTITION =
     RECORD
            Method : TAPE_PARTITION_TYPE;
            Count : DWORD;
            Size : DWORD;
     END;
     PTAPE_CREATE_PARTITION = POINTER TO TAPE_CREATE_PARTITION;



(************************************************************************
*                                                                       *
*   Winbase -- This module defines the 32-Bit Windows Base APIs         *
*                                                                       *
************************************************************************)




(* -------------------------------------------------------- *)

CONST INVALID_HANDLE_VALUE = SYSTEM.CAST (HANDLE, VAL (INTEGER, -1));
      INVALID_FILE_SIZE    = VAL (DWORD, 0FFFFFFFFh);

TYPE MOVE_TYPE = (FILE_BEGIN,   (* 0 *)
                  FILE_CURRENT, (* 1 *)
                  FILE_END);    (* 2 *)

CONST TIME_ZONE_ID_INVALID = VAL (DWORD, 0FFFFFFFFh);

CONST WAIT_FAILED      = VAL (DWORD, 0FFFFFFFFh);
      WAIT_OBJECT_0    = STATUS_WAIT_0 + 0;
      WAIT_ABANDONED   = STATUS_ABANDONED_WAIT_0 + 0;
      WAIT_ABANDONED_0 = STATUS_ABANDONED_WAIT_0 + 0;

      WAIT_TIMEOUT                       = STATUS_TIMEOUT;
      WAIT_IO_COMPLETION                 = STATUS_USER_APC;
      STILL_ACTIVE                       = STATUS_PENDING;
      EXCEPTION_ACCESS_VIOLATION         = STATUS_ACCESS_VIOLATION;
      EXCEPTION_DATATYPE_MISALIGNMENT    = STATUS_DATATYPE_MISALIGNMENT;
      EXCEPTION_BREAKPOINT               = STATUS_BREAKPOINT;
      EXCEPTION_SINGLE_STEP              = STATUS_SINGLE_STEP;
      EXCEPTION_ARRAY_BOUNDS_EXCEEDED    = STATUS_ARRAY_BOUNDS_EXCEEDED;
      EXCEPTION_FLT_DENORMAL_OPERAND     = STATUS_FLOAT_DENORMAL_OPERAND;
      EXCEPTION_FLT_DIVIDE_BY_ZERO       = STATUS_FLOAT_DIVIDE_BY_ZERO;
      EXCEPTION_FLT_INEXACT_RESULT       = STATUS_FLOAT_INEXACT_RESULT;
      EXCEPTION_FLT_INVALID_OPERATION    = STATUS_FLOAT_INVALID_OPERATION;
      EXCEPTION_FLT_OVERFLOW             = STATUS_FLOAT_OVERFLOW;
      EXCEPTION_FLT_STACK_CHECK          = STATUS_FLOAT_STACK_CHECK;
      EXCEPTION_FLT_UNDERFLOW            = STATUS_FLOAT_UNDERFLOW;
      EXCEPTION_INT_DIVIDE_BY_ZERO       = STATUS_INTEGER_DIVIDE_BY_ZERO;
      EXCEPTION_INT_OVERFLOW             = STATUS_INTEGER_OVERFLOW;
      EXCEPTION_PRIV_INSTRUCTION         = STATUS_PRIVILEGED_INSTRUCTION;
      EXCEPTION_IN_PAGE_ERROR            = STATUS_IN_PAGE_ERROR;
      EXCEPTION_ILLEGAL_INSTRUCTION      = STATUS_ILLEGAL_INSTRUCTION;
      EXCEPTION_NONCONTINUABLE_EXCEPTION = STATUS_NONCONTINUABLE_EXCEPTION;
      EXCEPTION_STACK_OVERFLOW           = STATUS_STACK_OVERFLOW;
      EXCEPTION_INVALID_DISPOSITION      = STATUS_INVALID_DISPOSITION;
      EXCEPTION_GUARD_PAGE               = STATUS_GUARD_PAGE_VIOLATION;
      EXCEPTION_INVALID_HANDLE           = STATUS_INVALID_HANDLE;
      CONTROL_C_EXIT                     = STATUS_CONTROL_C_EXIT;

CONST MoveMemory = RtlMoveMemory;
      CopyMemory = RtlCopyMemory;
      FillMemory = RtlFillMemory;
      ZeroMemory = RtlZeroMemory;

(* File creation flags must start at the high end since they
   are combined with the attributes
*)

TYPE FILE_FLAG_ENUM = FILE_BIT_ENUM;

CONST FILE_FLAG__WRITE_THROUGH     = F_31;
      FILE_FLAG__OVERLAPPED        = F_30;
      FILE_FLAG__NO_BUFFERING      = F_29;
      FILE_FLAG__RANDOM_ACCESS     = F_28;
      FILE_FLAG__SEQUENTIAL_SCAN   = F_27;
      FILE_FLAG__DELETE_ON_CLOSE   = F_26;
      FILE_FLAG__BACKUP_SEMANTICS  = F_25;
      FILE_FLAG__POSIX_SEMANTICS   = F_24;

TYPE FILE_FLAG_SET = FILE_BIT_SET;

CONST FILE_FLAG_WRITE_THROUGH     = FILE_FLAG_SET {FILE_FLAG__WRITE_THROUGH   }; (* 80000000h *)
      FILE_FLAG_OVERLAPPED        = FILE_FLAG_SET {FILE_FLAG__OVERLAPPED      }; (* 40000000h *)
      FILE_FLAG_NO_BUFFERING      = FILE_FLAG_SET {FILE_FLAG__NO_BUFFERING    }; (* 20000000h *)
      FILE_FLAG_RANDOM_ACCESS     = FILE_FLAG_SET {FILE_FLAG__RANDOM_ACCESS   }; (* 10000000h *)
      FILE_FLAG_SEQUENTIAL_SCAN   = FILE_FLAG_SET {FILE_FLAG__SEQUENTIAL_SCAN }; (* 08000000h *)
      FILE_FLAG_DELETE_ON_CLOSE   = FILE_FLAG_SET {FILE_FLAG__DELETE_ON_CLOSE }; (* 04000000h *)
      FILE_FLAG_BACKUP_SEMANTICS  = FILE_FLAG_SET {FILE_FLAG__BACKUP_SEMANTICS}; (* 02000000h *)
      FILE_FLAG_POSIX_SEMANTICS   = FILE_FLAG_SET {FILE_FLAG__POSIX_SEMANTICS }; (* 01000000h *)

TYPE CREATION_DISTRIBUTION = (CREATE_0,
                              CREATE_NEW,         (* 1 *)
                              CREATE_ALWAYS,      (* 2 *)
                              OPEN_EXISTING,      (* 3 *)
                              OPEN_ALWAYS,        (* 4 *)
                              TRUNCATE_EXISTING); (* 5 *)

(*
** Define possible return codes from the CopyFileEx callback routine
*)

TYPE PROGRESS_ENUM = (PROGRESS_CONTINUE, (* 0 *)
                      PROGRESS_CANCEL,   (* 1 *)
                      PROGRESS_STOP,     (* 2 *)
                      PROGRESS_QUIET);   (* 3 *)

(*
** Define CopyFileEx callback routine state change values
*)

TYPE COPYFILEEX_CALLBACK_ENUM = (CALLBACK_CHUNK_FINISHED, (* 0x00000000 *)
                                 CALLBACK_STREAM_SWITCH); (* 0x00000001 *)

(*
** Define CopyFileEx option flags
*)

TYPE COPY_FILE_ENUM = (COPY_FILE__FAIL_IF_EXISTS, (* 0 *)
                       COPY_FILE__RESTARTABLE);   (* 1 *)

     COPY_FILE_SET = SET OF COPY_FILE_ENUM;

CONST COPY_FILE_FAIL_IF_EXISTS = COPY_FILE_SET {COPY_FILE__FAIL_IF_EXISTS};  (* 0x00000001 *)
      COPY_FILE_RESTARTABLE    = COPY_FILE_SET {COPY_FILE__RESTARTABLE};     (* 0x00000002 *)

(* Define the NamedPipe definitions *)

(* Define the dwOpenMode values for CreateNamedPipe *)

TYPE PIPE_ACCESS_SET = FILE_BIT_SET;

CONST PIPE_ACCESS_INBOUND  = SYSTEM.CAST (PIPE_ACCESS_SET, 00000001h);
      PIPE_ACCESS_OUTBOUND = SYSTEM.CAST (PIPE_ACCESS_SET, 00000002h);
      PIPE_ACCESS_DUPLEX   = SYSTEM.CAST (PIPE_ACCESS_SET, 00000003h);

(* Define the dwPipeMode values for CreateNamedPipe *)

TYPE PIPE_MODE_ENUM = (PIPE__NOWAIT,            (* 0 *)
                       PIPE__READMODE_MESSAGE,  (* 1 *)
                       PIPE__TYPE_MESSAGE);     (* 2 *)

TYPE PIPE_MODE_SET = SET OF PIPE_MODE_ENUM;

CONST PIPE_WAIT                  = PIPE_MODE_SET {};                      (* 0x00000000 *)
      PIPE_NOWAIT                = PIPE_MODE_SET {PIPE__NOWAIT};          (* 0x00000001 *)
      PIPE_READMODE_BYTE         = PIPE_MODE_SET {};                      (* 0x00000000 *)
      PIPE_READMODE_MESSAGE      = PIPE_MODE_SET {PIPE__READMODE_MESSAGE};(* 0x00000002 *)
      PIPE_TYPE_BYTE             = PIPE_MODE_SET {};                      (* 0x00000000 *)
      PIPE_TYPE_MESSAGE          = PIPE_MODE_SET {PIPE__TYPE_MESSAGE};    (* 0x00000004 *)

(* Define the Named Pipe End flags for GetNamedPipeInfo *)

CONST PIPE__SERVER_END = PIPE__NOWAIT; (* 0 *)

      PIPE_CLIENT_END  = PIPE_MODE_SET {};                 (* 0x00000000 *)
      PIPE_SERVER_END  = PIPE_MODE_SET {PIPE__SERVER_END}; (* 0x00000001 *)

(* Define the well known values for CreateNamedPipe nMaxInstances *)

CONST  PIPE_UNLIMITED_INSTANCES  = 255;


(* Define the Security Quality of Service bits to be passed
   into CreateFile
*)

TYPE SECURITY_ENUM = FILE_BIT_ENUM;

CONST SECURITY__CONTEXT_TRACKING = F_18;
      SECURITY__EFFECTIVE_ONLY   = F_19;
      SECURITY__SQOS_PRESENT     = F_20;

TYPE SECURITY_SET = FILE_BIT_SET;

CONST SECURITY_ANONYMOUS        = SYSTEM.CAST (SECURITY_SET, 65536 * ORD (SecurityAnonymous));
      SECURITY_IDENTIFICATION   = SYSTEM.CAST (SECURITY_SET, 65536 * ORD (SecurityIdentification));
      SECURITY_IMPERSONATION    = SYSTEM.CAST (SECURITY_SET, 65536 * ORD (SecurityImpersonation));
      SECURITY_DELEGATION       = SYSTEM.CAST (SECURITY_SET, 65536 * ORD (SecurityDelegation));

      SECURITY_CONTEXT_TRACKING = SECURITY_SET {SECURITY__CONTEXT_TRACKING}; (* 00040000h *)
      SECURITY_EFFECTIVE_ONLY   = SECURITY_SET {SECURITY__EFFECTIVE_ONLY};   (* 00080000h *)

      SECURITY_SQOS_PRESENT     = SECURITY_SET {SECURITY__SQOS_PRESENT};     (* 00100000h *)

      SECURITY_VALID_SQOS_FLAGS = SECURITY_SET {F_16..F_20};                (* 001F0000h *)

(*  File structures *)

TYPE OVERLAPPED = RECORD
                       Internal     : DWORD;
                       InternalHigh : DWORD;
                       Offset       : DWORD;
                       OffsetHigh   : DWORD;
                       hEvent       : HANDLE;
                  END;
    POVERLAPPED = POINTER TO OVERLAPPED;

TYPE SECURITY_ATTRIBUTES = RECORD
                                nLength              : DWORD;
                                lpSecurityDescriptor : PVOID;
                                bInheritHandle       : BOOL;
                           END;
     PSECURITY_ATTRIBUTES = POINTER TO SECURITY_ATTRIBUTES;

TYPE PROCESS_INFORMATION = RECORD
                                hProcess    : HANDLE;
                                hThread     : HANDLE;
                                dwProcessId : DWORD;
                                dwThreadId  : DWORD;
                           END;
     PPROCESS_INFORMATION = POINTER TO PROCESS_INFORMATION;

(* File System time stamps are represented with the following structure: *)

TYPE FILETIME = RECORD
                     dwLowDateTime  : DWORD;
                     dwHighDateTime : DWORD;
                END;
     PFILETIME  = POINTER TO FILETIME;

(* System time is represented with the following structure: *)

TYPE SYSTEMTIME = RECORD
                       wYear         : WORD;
                       wMonth        : WORD;
                       wDayOfWeek    : WORD;
                       wDay          : WORD;
                       wHour         : WORD;
                       wMinute       : WORD;
                       wSecond       : WORD;
                       wMilliseconds : WORD;
                  END;
     PSYSTEMTIME = POINTER TO SYSTEMTIME;

TYPE PTHREAD_START_ROUTINE = PROCEDURE ((* ThreadParameter : *) PVOID) : DWORD;
TYPE PFIBER_START_ROUTINE  = PROCEDURE ((* FiberParameter  : *) PVOID);

TYPE  CRITICAL_SECTION =  RTL_CRITICAL_SECTION;
TYPE PCRITICAL_SECTION = PRTL_CRITICAL_SECTION;

TYPE  CRITICAL_SECTION_DEBUG =  RTL_CRITICAL_SECTION_DEBUG;
TYPE PCRITICAL_SECTION_DEBUG = PRTL_CRITICAL_SECTION_DEBUG;

CONST MUTEX_MODIFY_STATE = MUTANT_QUERY_STATE;
CONST MUTEX_ALL_ACCESS   = MUTANT_ALL_ACCESS;

(* Serial provider type. *)

CONST SP_SERIALCOMM = DWORD (00000001h);

(* Provider SubTypes *)

TYPE PST_TYPE = DWORD;

CONST  PST_UNSPECIFIED      = VAL (PST_TYPE, 00000000h);
       PST_RS232            = VAL (PST_TYPE, 00000001h);
       PST_PARALLELPORT     = VAL (PST_TYPE, 00000002h);
       PST_RS422            = VAL (PST_TYPE, 00000003h);
       PST_RS423            = VAL (PST_TYPE, 00000004h);
       PST_RS449            = VAL (PST_TYPE, 00000005h);
       PST_MODEM            = VAL (PST_TYPE, 00000006h);
       PST_FAX              = VAL (PST_TYPE, 00000021h);
       PST_SCANNER          = VAL (PST_TYPE, 00000022h);
       PST_NETWORK_BRIDGE   = VAL (PST_TYPE, 00000100h);
       PST_LAT              = VAL (PST_TYPE, 00000101h);
       PST_TCPIP_TELNET     = VAL (PST_TYPE, 00000102h);
       PST_X25              = VAL (PST_TYPE, 00000103h);

(* Provider capabilities flags. *)

TYPE PCF_ENUM = (PCF__DTRDSR,        (* 0 *)
                 PCF__RTSCTS,        (* 1 *)
                 PCF__RLSD,          (* 2 *)
                 PCF__PARITY_CHECK,  (* 3 *)
                 PCF__XONXOFF,       (* 4 *)
                 PCF__SETXCHAR,      (* 5 *)
                 PCF__TOTALTIMEOUTS, (* 6 *)
                 PCF__INTTIMEOUTS,   (* 7 *)
                 PCF__SPECIALCHARS,  (* 8 *)
                 PCF__16BITMODE);    (* 9 *)

     PCF_SET = SET OF PCF_ENUM;

CONST PCF_DTRDSR         = PCF_SET {PCF__DTRDSR};        (* 0001h *)
      PCF_RTSCTS         = PCF_SET {PCF__RTSCTS};        (* 0002h *)
      PCF_RLSD           = PCF_SET {PCF__RLSD};          (* 0004h *)
      PCF_PARITY_CHECK   = PCF_SET {PCF__PARITY_CHECK};  (* 0008h *)
      PCF_XONXOFF        = PCF_SET {PCF__XONXOFF};       (* 0010h *)
      PCF_SETXCHAR       = PCF_SET {PCF__SETXCHAR};      (* 0020h *)
      PCF_TOTALTIMEOUTS  = PCF_SET {PCF__TOTALTIMEOUTS}; (* 0040h *)
      PCF_INTTIMEOUTS    = PCF_SET {PCF__INTTIMEOUTS};   (* 0080h *)
      PCF_SPECIALCHARS   = PCF_SET {PCF__SPECIALCHARS};  (* 0100h *)
      PCF_16BITMODE      = PCF_SET {PCF__16BITMODE};     (* 0200h *)

(* Comm provider settable parameters. *)

TYPE SP_ENUM = (SP__PARITY,       (* 0 *)
                SP__BAUD,         (* 1 *)
                SP__DATABITS,     (* 2 *)
                SP__STOPBITS,     (* 3 *)
                SP__HANDSHAKING,  (* 4 *)
                SP__PARITY_CHECK, (* 5 *)
                SP__RLSD);        (* 6 *)

     SP_SET = SET OF SP_ENUM;

CONST  SP_PARITY         = SP_SET {SP__PARITY};       (* 0001h*)
       SP_BAUD           = SP_SET {SP__BAUD};         (* 0002h*)
       SP_DATABITS       = SP_SET {SP__DATABITS};     (* 0004h*)
       SP_STOPBITS       = SP_SET {SP__STOPBITS};     (* 0008h*)
       SP_HANDSHAKING    = SP_SET {SP__HANDSHAKING};  (* 0010h*)
       SP_PARITY_CHECK   = SP_SET {SP__PARITY_CHECK}; (* 0020h*)
       SP_RLSD           = SP_SET {SP__RLSD};         (* 0040h*)

(* Settable baud rates in the provider. *)

TYPE BAUD_ENUM = (BAUD__075,          (*  0 *)
                  BAUD__110,          (*  1 *)
                  BAUD__134_5,        (*  2 *)
                  BAUD__150,          (*  3 *)
                  BAUD__300,          (*  4 *)
                  BAUD__600,          (*  5 *)
                  BAUD__1200,         (*  6 *)
                  BAUD__1800,         (*  7 *)
                  BAUD__2400,         (*  8 *)
                  BAUD__4800,         (*  9 *)
                  BAUD__7200,         (* 10 *)
                  BAUD__9600,         (* 11 *)
                  BAUD__14400,        (* 12 *)
                  BAUD__19200,        (* 13 *)
                  BAUD__38400,        (* 14 *)
                  BAUD__56K,          (* 15 *)
                  BAUD__128K,         (* 16 *)
                  BAUD__115200,       (* 17 *)
                  BAUD__57600,        (* 18 *)
                  BAUD__19, BAUD__20,
                  BAUD__21, BAUD__22,
                  BAUD__23, BAUD__24,
                  BAUD__25, BAUD__26,
                  BAUD__27,
                  BAUD__USER);        (* 28 *)

TYPE BAUD_SET = SET OF BAUD_ENUM;

CONST  BAUD_075          = BAUD_SET {BAUD__075};    (* 0x00000001 *)
       BAUD_110          = BAUD_SET {BAUD__110};    (* 0x00000002 *)
       BAUD_134_5        = BAUD_SET {BAUD__134_5};  (* 0x00000004 *)
       BAUD_150          = BAUD_SET {BAUD__150};    (* 0x00000008 *)
       BAUD_300          = BAUD_SET {BAUD__300};    (* 0x00000010 *)
       BAUD_600          = BAUD_SET {BAUD__600};    (* 0x00000020 *)
       BAUD_1200         = BAUD_SET {BAUD__1200};   (* 0x00000040 *)
       BAUD_1800         = BAUD_SET {BAUD__1800};   (* 0x00000080 *)
       BAUD_2400         = BAUD_SET {BAUD__2400};   (* 0x00000100 *)
       BAUD_4800         = BAUD_SET {BAUD__4800};   (* 0x00000200 *)
       BAUD_7200         = BAUD_SET {BAUD__7200};   (* 0x00000400 *)
       BAUD_9600         = BAUD_SET {BAUD__9600};   (* 0x00000800 *)
       BAUD_14400        = BAUD_SET {BAUD__14400};  (* 0x00001000 *)
       BAUD_19200        = BAUD_SET {BAUD__19200};  (* 0x00002000 *)
       BAUD_38400        = BAUD_SET {BAUD__38400};  (* 0x00004000 *)
       BAUD_56K          = BAUD_SET {BAUD__56K};    (* 0x00008000 *)
       BAUD_128K         = BAUD_SET {BAUD__128K};   (* 0x00010000 *)
       BAUD_115200       = BAUD_SET {BAUD__115200}; (* 0x00020000 *)
       BAUD_57600        = BAUD_SET {BAUD__57600};  (* 0x00040000 *)
       BAUD_USER         = BAUD_SET {BAUD__USER};   (* 0x10000000 *)

(* Settable Data Bits *)

TYPE DATABITS_ENUM = (DATABITS__5,    (* 0 *)
                      DATABITS__6,    (* 1 *)
                      DATABITS__7,    (* 2 *)
                      DATABITS__8,    (* 3 *)
                      DATABITS__16,   (* 4 *)
                      DATABITS__16X); (* 5 *)

<* PUSH *> <* SETSIZE = "2" *>

TYPE DATABITS_SET = SET OF DATABITS_ENUM;

CONST  DATABITS_5   = DATABITS_SET {DATABITS__5};   (* 0x0001 *)
       DATABITS_6   = DATABITS_SET {DATABITS__6};   (* 0x0002 *)
       DATABITS_7   = DATABITS_SET {DATABITS__7};   (* 0x0004 *)
       DATABITS_8   = DATABITS_SET {DATABITS__8};   (* 0x0008 *)
       DATABITS_16  = DATABITS_SET {DATABITS__16};  (* 0x0010 *)
       DATABITS_16X = DATABITS_SET {DATABITS__16X}; (* 0x0020 *)

<* POP *>

(* Settable Stop and Parity bits. *)

TYPE STOPBITS_ENUM = (STOPBITS__10,    (*  0 *)
                      STOPBITS__15,    (*  1 *)
                      STOPBITS__20,    (*  2 *)
                      STOPBITS__3,
                      STOPBITS__4,
                      STOPBITS__5,
                      STOPBITS__6,
                      STOPBITS__7,
                      PARITY__NONE,    (*  8 *)
                      PARITY__ODD,     (*  9 *)
                      PARITY__EVEN,    (* 10 *)
                      PARITY__MARK,    (* 11 *)
                      PARITY__SPACE);  (* 12 *)

<* PUSH *> <* SETSIZE = "2" *>

TYPE STOPBITS_SET = SET OF STOPBITS_ENUM;

CONST  STOPBITS_10  = STOPBITS_SET {STOPBITS__10};  (* 0x0001 *)
       STOPBITS_15  = STOPBITS_SET {STOPBITS__15};  (* 0x0002 *)
       STOPBITS_20  = STOPBITS_SET {STOPBITS__20};  (* 0x0004 *)
       PARITY_NONE  = STOPBITS_SET {PARITY__NONE};  (* 0x0100 *)
       PARITY_ODD   = STOPBITS_SET {PARITY__ODD};   (* 0x0200 *)
       PARITY_EVEN  = STOPBITS_SET {PARITY__EVEN};  (* 0x0400 *)
       PARITY_MARK  = STOPBITS_SET {PARITY__MARK};  (* 0x0800 *)
       PARITY_SPACE = STOPBITS_SET {PARITY__SPACE}; (* 0x1000 *)

<* POP *>

TYPE COMMPROP = RECORD
                     wPacketLength       :  WORD;
                     wPacketVersion      :  WORD;
                     dwServiceMask       : DWORD;
                     dwReserved1         : DWORD;
                     dwMaxTxQueue        : DWORD;
                     dwMaxRxQueue        : DWORD;
                     dwMaxBaud           : BAUD_SET;
                     dwProvSubType       : PST_TYPE;
                     dwProvCapabilities  : PCF_SET;
                     dwSettableParams    : SP_SET;
                     dwSettableBaud      : BAUD_SET;
                     wSettableData       : DATABITS_SET;
                     wSettableStopParity : STOPBITS_SET;
                     dwCurrentTxQueue    : DWORD;
                     dwCurrentRxQueue    : DWORD;
                     dwProvSpec1         : DWORD;
                     dwProvSpec2         : DWORD;
                     wcProvChar          : ARRAY [0..0] OF WCHAR;
                 END;
     PCOMMPROP = POINTER TO COMMPROP;

(* Set dwProvSpec1 to COMMPROP_INITIALIZED to indicate that wPacketLength
   is valid before a call to GetCommProperties().
*)

CONST COMMPROP_INITIALIZED = SYSTEM.CAST (DWORD, VAL (ULONG, 0E73CF52Eh));

(* Originally COMSTAT was a structure containing bit fields fCtsHold, ..., fTxim;
   they were collected in a set
*)

TYPE COMSTAT_FLAGS = (COMSTAT_fCtsHold,
                      COMSTAT_fDsrHold,
                      COMSTAT_fRlsdHold,
                      COMSTAT_fXoffHold,
                      COMSTAT_fXoffSent,
                      COMSTAT_fEof,
                      COMSTAT_fTxim);

     COMSTAT_SET = SET OF COMSTAT_FLAGS;

TYPE COMSTAT = RECORD
                      Flags    : COMSTAT_SET;
                      cbInQue  : DWORD;
                      cbOutQue : DWORD;
               END;
    PCOMSTAT = POINTER TO COMSTAT;

(* Originally DCB was a structure containing bit fields fBinary, ..., fAbortOnError;
   they were collected in a set.
   Fields fDtrControl and fRtsControl were 2 bits wide; so two set elements were
   assigned to them
*)

TYPE DCB_FLAG  = (DCB_fBinary,           (* Binary Mode (skip EOF check)    *)
                  DCB_fParity,           (* Enable parity checking          *)
                  DCB_fOutxCtsFlow,      (* CTS handshaking on output       *)
                  DCB_fOutxDsrFlow,      (* DSR handshaking on output       *)
                  DCB_fDtrControl_1,     (* DTR Flow control                *)
                  DCB_fDtrControl_2,
                  DCB_fDsrSensitivity,   (* DSR Sensitivity                 *)
                  DCB_fTXContinueOnXoff, (* Continue TX when Xoff sent      *)
                  DCB_fOutX,             (* Enable output X-ON/X-OFF        *)
                  DCB_fInX,              (* Enable input X-ON/X-OFF         *)
                  DCB_fErrorChar,        (* Enable Err Replacement          *)
                  DCB_fNull,             (* Enable Null stripping           *)
                  DCB_fRtsControl_1,     (* Rts Flow control                *)
                  DCB_fRtsControl_2,
                  DCB_fAbortOnError);    (* Abort all reads and writes on Error *)

     DCB_FLAGS = SET OF DCB_FLAG;

(* DTR Control Flow Values. *)

CONST DTR_CONTROL_DISABLE   = DCB_FLAGS {};                  (* 0 *)
      DTR_CONTROL_ENABLE    = DCB_FLAGS {DCB_fDtrControl_1}; (* 1 *)
      DTR_CONTROL_HANDSHAKE = DCB_FLAGS {DCB_fDtrControl_2}; (* 2 *)

(* RTS Control Flow Values *)

CONST RTS_CONTROL_DISABLE   = DCB_FLAGS {};                  (* 0 *)
      RTS_CONTROL_ENABLE    = DCB_FLAGS {DCB_fRtsControl_1}; (* 1 *)
      RTS_CONTROL_HANDSHAKE = DCB_FLAGS {DCB_fRtsControl_2}; (* 2 *)
      RTS_CONTROL_TOGGLE    = DCB_FLAGS {DCB_fRtsControl_1, DCB_fRtsControl_2}; (* 3 *)

(* Parity values for DCB *)

<* PUSH *> <* ENUMSIZE = "1" *>

TYPE PARITY_TYPE = (NOPARITY,      (* 0 *)
                    ODDPARITY,     (* 1 *)
                    EVENPARITY,    (* 2 *)
                    MARKPARITY,    (* 3 *)
                    SPACEPARITY);  (* 4 *)

<* POP *>

(* Stop bits values for DCB *)

<* PUSH *> <* ENUMSIZE = "1" *>

TYPE STOPBITS_TYPE = (ONESTOPBIT,     (* 0 *)
                      ONE5STOPBITS,   (* 1 *)
                      TWOSTOPBITS);   (* 2 *)

<* POP *>

TYPE DCB = RECORD
                  DCBlength  : DWORD;         (* sizeof(DCB)                     *)
                  BaudRate   : DWORD;         (* Baudrate at which running       *)
                  Flags      : DCB_FLAGS;
                  wReserved  : WORD;          (* Not currently used              *)
                  XonLim     : WORD;          (* Transmit X-ON threshold         *)
                  XoffLim    : WORD;          (* Transmit X-OFF threshold        *)
                  ByteSize   : BYTE;          (* Number of bits/byte, 4-8        *)
                  Parity     : PARITY_TYPE;   (* 0-4=None,Odd,Even,Mark,Space    *)
                  StopBits   : STOPBITS_TYPE; (* 0,1,2 = 1, 1.5, 2               *)
                  XonChar    : CHAR;          (* Tx and Rx X-ON character        *)
                  XoffChar   : CHAR;          (* Tx and Rx X-OFF character       *)
                  ErrorChar  : CHAR;          (* Error replacement char          *)
                  EofChar    : CHAR;          (* End of Input character          *)
                  EvtChar    : CHAR;          (* Received Event character        *)
                  wReserved1 : WORD;          (* Fill for now.                   *)
           END;
    PDCB = POINTER TO DCB;

TYPE COMMTIMEOUTS =
     RECORD
          ReadIntervalTimeout         : DWORD; (* Maximum time between read chars. *)
          ReadTotalTimeoutMultiplier  : DWORD; (* Multiplier of characters.        *)
          ReadTotalTimeoutConstant    : DWORD; (* Constant in milliseconds.        *)
          WriteTotalTimeoutMultiplier : DWORD; (* Multiplier of characters.        *)
          WriteTotalTimeoutConstant   : DWORD; (* Constant in milliseconds.        *)
     END;
     PCOMMTIMEOUTS = POINTER TO COMMTIMEOUTS;

TYPE COMMCONFIG =
     RECORD
         dwSize            : DWORD;    (* Size of the entire struct *)
         wVersion          : WORD;     (* version of the structure *)
         wReserved         : WORD;     (* alignment *)
         dcb               : DCB;      (* device control block *)
         dwProviderSubType : PST_TYPE; (* ordinal value for identifying
                                          provider-defined data structure format*)
         dwProviderOffset  : DWORD;    (* Specifies the offset of provider specific
                                          data field in bytes from the start *)
         dwProviderSize    : DWORD;    (* size of the provider-specific data field *)
         wcProviderData    : ARRAY [0..1] OF WCHAR; (* provider-specific data *)
     END;
     PCOMMCONFIG = POINTER TO COMMCONFIG;

TYPE SYSTEM_INFO =
     RECORD
         CASE : BOOLEAN OF
         | FALSE: dwOemId : DWORD;          (* Obsolete field...do not use *)
         | TRUE:  wProcessorArchitecture : PROCESSOR_ARCHITECTURE_ENUM;
                  wReserved : WORD;
         END;
         dwPageSize                  : DWORD;
         lpMinimumApplicationAddress : PVOID;
         lpMaximumApplicationAddress : PVOID;
         dwActiveProcessorMask       : BITSET;
         dwNumberOfProcessors        : DWORD;
         dwProcessorType             : DWORD;
         dwAllocationGranularity     : DWORD;
         wProcessorLevel             : WORD;
         wProcessorRevision          : WORD;
     END;
     PSYSTEM_INFO = POINTER TO SYSTEM_INFO;

(* Global Memory Flags *)

TYPE GMEM_ENUM = (GMEM__0,
                  GMEM__MOVEABLE,       (*  1 *)
                  GMEM__2,
                  GMEM__3,
                  GMEM__NOCOMPACT,      (*  4 *)
                  GMEM__NODISCARD,      (*  5 *)
                  GMEM__ZEROINIT,       (*  6 *)
                  GMEM__MODIFY,         (*  7 *)
                  GMEM__DISCARDABLE,    (*  8 *)
                  GMEM__9,
                  GMEM__10,
                  GMEM__11,
                  GMEM__NOT_BANKED,     (* 12 *)
                  GMEM__SHARE,          (* 13 *)
                  GMEM__NOTIFY,         (* 14 *)
                  GMEM__INVALID_HANDLE);(* 15 *)

TYPE GMEM_SET = SET OF GMEM_ENUM;

CONST GMEM_FIXED          = GMEM_SET {};                     (* 0x0000 *)
      GMEM_MOVEABLE       = GMEM_SET {GMEM__MOVEABLE};       (* 0x0002 *)
      GMEM_NOCOMPACT      = GMEM_SET {GMEM__NOCOMPACT};      (* 0x0010 *)
      GMEM_NODISCARD      = GMEM_SET {GMEM__NODISCARD};      (* 0x0020 *)
      GMEM_ZEROINIT       = GMEM_SET {GMEM__ZEROINIT};       (* 0x0040 *)
      GMEM_MODIFY         = GMEM_SET {GMEM__MODIFY};         (* 0x0080 *)
      GMEM_DISCARDABLE    = GMEM_SET {GMEM__DISCARDABLE};    (* 0x0100 *)
      GMEM_NOT_BANKED     = GMEM_SET {GMEM__NOT_BANKED};     (* 0x1000 *)
      GMEM_SHARE          = GMEM_SET {GMEM__SHARE};          (* 0x2000 *)
      GMEM_NOTIFY         = GMEM_SET {GMEM__NOTIFY};         (* 0x4000 *)
      GMEM_INVALID_HANDLE = GMEM_SET {GMEM__INVALID_HANDLE}; (* 0x8000 *)

      GMEM_VALID_FLAGS    = GMEM_SET {GMEM__NOTIFY..GMEM__DISCARDABLE,
                                      GMEM__ZEROINIT..GMEM__NOCOMPACT,
                                      GMEM__MOVEABLE};                 (* 0x7F72 *)

      GMEM_LOWER          = GMEM_NOT_BANKED;
      GMEM_DDESHARE       = GMEM_SHARE;

      GHND = GMEM_MOVEABLE + GMEM_ZEROINIT;
      GPTR = GMEM_FIXED + GMEM_ZEROINIT;

PROCEDURE GlobalDiscard (h : HGLOBAL) : HGLOBAL;  (* was a macro; now in RTL *)

(* Flags returned by GlobalFlags (in addition to GMEM_DISCARDABLE) *)

CONST GMEM__DISCARDED = GMEM__NOTIFY;

      GMEM_DISCARDED = GMEM_SET {GMEM__DISCARDED}; (* 0x4000 *)

      GMEM_LOCKCOUNT = SYSTEM.CAST (GMEM_SET, VAL (DWORD, 00FFh));

TYPE MEMORYSTATUS = RECORD
                         dwLength        : DWORD;
                         dwMemoryLoad    : DWORD;
                         dwTotalPhys     : DWORD;
                         dwAvailPhys     : DWORD;
                         dwTotalPageFile : DWORD;
                         dwAvailPageFile : DWORD;
                         dwTotalVirtual  : DWORD;
                         dwAvailVirtual  : DWORD;
                    END;
     PMEMORYSTATUS = POINTER TO MEMORYSTATUS;

(* Local Memory Flags *)

TYPE LMEM_ENUM = (LMEM__0,
                  LMEM__MOVEABLE,       (*  1 *)
                  LMEM__2,
                  LMEM__3,
                  LMEM__NOCOMPACT,      (*  4 *)
                  LMEM__NODISCARD,      (*  5 *)
                  LMEM__ZEROINIT,       (*  6 *)
                  LMEM__MODIFY,         (*  7 *)
                  LMEM__DISCARDABLE_8,  (*  8 *)
                  LMEM__DISCARDABLE_9,  (*  8 *)
                  LMEM__DISCARDABLE_10, (*  8 *)
                  LMEM__DISCARDABLE_11, (*  8 *)
                  LMEM__12,             (* 12 *)
                  LMEM__13,             (* 13 *)
                  LMEM__DISCARDED,      (* 14 *)
                  LMEM__INVALID_HANDLE);(* 15 *)

TYPE LMEM_SET = SET OF LMEM_ENUM;

CONST LMEM_FIXED          = LMEM_SET {};                     (* 0x0000 *)
      LMEM_MOVEABLE       = LMEM_SET {LMEM__MOVEABLE};       (* 0x0002 *)
      LMEM_NOCOMPACT      = LMEM_SET {LMEM__NOCOMPACT};      (* 0x0010 *)
      LMEM_NODISCARD      = LMEM_SET {LMEM__NODISCARD};      (* 0x0020 *)
      LMEM_ZEROINIT       = LMEM_SET {LMEM__ZEROINIT};       (* 0x0040 *)
      LMEM_MODIFY         = LMEM_SET {LMEM__MODIFY};         (* 0x0080 *)
      LMEM_DISCARDABLE    = LMEM_SET {LMEM__DISCARDABLE_8..
                                      LMEM__DISCARDABLE_11}; (* 0x0100 *)
      LMEM_INVALID_HANDLE = LMEM_SET {LMEM__INVALID_HANDLE}; (* 0x8000 *)

      LMEM_VALID_FLAGS    = LMEM_MOVEABLE  +
                            LMEM_NOCOMPACT +
                            LMEM_NODISCARD +
                            LMEM_ZEROINIT  +
                            LMEM_MODIFY    +
                            LMEM_DISCARDABLE; (* 0x0F72 *)

      LHND                = LMEM_MOVEABLE + LMEM_ZEROINIT;
      LPTR                = LMEM_FIXED + LMEM_ZEROINIT;

      NONZEROLHND         = LMEM_MOVEABLE;
      NONZEROLPTR         = LMEM_FIXED;

PROCEDURE LocalDiscard (h : HLOCAL) : HLOCAL; (* was a macro; now in RTL *)

(* Flags returned by LocalFlags (in addition to LMEM_DISCARDABLE) *)

CONST LMEM_DISCARDED = LMEM_SET {LMEM__DISCARDED}; (* 0x4000 *)
      LMEM_LOCKCOUNT = SYSTEM.CAST (LMEM_SET, VAL (DWORD, 00FFh));

(* dwCreationFlag values *)

TYPE CREATE_ENUM = (CREATE__0,  CREATE__1,  CREATE__2,  CREATE__3,
                    CREATE__4,  CREATE__5,  CREATE__6,  CREATE__7,
                    CREATE__8,  CREATE__9,  CREATE__10, CREATE__11,
                    CREATE__12, CREATE__13, CREATE__14, CREATE__15,
                    CREATE__16, CREATE__17, CREATE__18, CREATE__19,
                    CREATE__20, CREATE__21, CREATE__22, CREATE__23,
                    CREATE__24, CREATE__25, CREATE__26, CREATE__27,
                    CREATE__28, CREATE__29, CREATE__30);

     CREATE_SET = SET OF CREATE_ENUM;
     PRIORITY_CLASS = CREATE_SET;

CONST DEBUG_PROCESS               = CREATE_SET {CREATE__0}; (* 00000001h *)
      DEBUG_ONLY_THIS_PROCESS     = CREATE_SET {CREATE__1}; (* 00000002h *)

      CREATE_SUSPENDED            = CREATE_SET {CREATE__2}; (* 00000004h *)

      DETACHED_PROCESS            = CREATE_SET {CREATE__3}; (* 00000008h *)

      CREATE_NEW_CONSOLE          = CREATE_SET {CREATE__4}; (* 00000010h *)

      NORMAL_PRIORITY_CLASS       = PRIORITY_CLASS {CREATE__5}; (* 00000020h *)
      IDLE_PRIORITY_CLASS         = PRIORITY_CLASS {CREATE__6}; (* 00000040h *)
      HIGH_PRIORITY_CLASS         = PRIORITY_CLASS {CREATE__7}; (* 00000080h *)
      REALTIME_PRIORITY_CLASS     = PRIORITY_CLASS {CREATE__8}; (* 00000100h *)

      CREATE_NEW_PROCESS_GROUP    = CREATE_SET {CREATE__9};     (* 00000200h *)
      CREATE_UNICODE_ENVIRONMENT  = CREATE_SET {CREATE__10};    (* 00000400h *)

      CREATE_SEPARATE_WOW_VDM     = CREATE_SET {CREATE__11};    (* 00000800h *)
      CREATE_SHARED_WOW_VDM       = CREATE_SET {CREATE__12};    (* 00001000h *)
      CREATE_FORCEDOS             = CREATE_SET {CREATE__13};    (* 00002000h *)

      CREATE_DEFAULT_ERROR_MODE   = CREATE_SET {CREATE__26};    (* 04000000h *)
      CREATE_NO_WINDOW            = CREATE_SET {CREATE__27};    (* 08000000h *)

      PROFILE_USER                = CREATE_SET {CREATE__28};    (* 10000000h *)
      PROFILE_KERNEL              = CREATE_SET {CREATE__29};    (* 20000000h *)
      PROFILE_SERVER              = CREATE_SET {CREATE__30};    (* 40000000h *)


CONST THREAD_PRIORITY_LOWEST        = THREAD_BASE_PRIORITY_MIN;
      THREAD_PRIORITY_BELOW_NORMAL  = THREAD_PRIORITY_LOWEST + 1;
      THREAD_PRIORITY_NORMAL        = 0;
      THREAD_PRIORITY_HIGHEST       = THREAD_BASE_PRIORITY_MAX;
      THREAD_PRIORITY_ABOVE_NORMAL  = THREAD_PRIORITY_HIGHEST - 1;
      THREAD_PRIORITY_ERROR_RETURN  = MAX (LONG);

      THREAD_PRIORITY_TIME_CRITICAL = THREAD_BASE_PRIORITY_LOWRT;
      THREAD_PRIORITY_IDLE          = THREAD_BASE_PRIORITY_IDLE;

(* Debug APIs *)

TYPE DEBUG_EVENT_TYPE = (DEBUG_EVENT_0,
                         EXCEPTION_DEBUG_EVENT,       (* 1 *)
                         CREATE_THREAD_DEBUG_EVENT,   (* 2 *)
                         CREATE_PROCESS_DEBUG_EVENT,  (* 3 *)
                         EXIT_THREAD_DEBUG_EVENT,     (* 4 *)
                         EXIT_PROCESS_DEBUG_EVENT,    (* 5 *)
                         LOAD_DLL_DEBUG_EVENT,        (* 6 *)
                         UNLOAD_DLL_DEBUG_EVENT,      (* 7 *)
                         OUTPUT_DEBUG_STRING_EVENT,   (* 8 *)
                         RIP_EVENT);                  (* 9 *)

TYPE EXCEPTION_DEBUG_INFO =
     RECORD
           ExceptionRecord : EXCEPTION_RECORD;
           dwFirstChance : DWORD;
     END;
     PEXCEPTION_DEBUG_INFO = POINTER TO EXCEPTION_DEBUG_INFO;

TYPE CREATE_THREAD_DEBUG_INFO =
     RECORD
            hThread : HANDLE;
            lpThreadLocalBase : PVOID;
            lpStartAddress: PTHREAD_START_ROUTINE;
     END;
     PCREATE_THREAD_DEBUG_INFO = POINTER TO CREATE_THREAD_DEBUG_INFO;

TYPE CREATE_PROCESS_DEBUG_INFO =
     RECORD
            hFile                 : HANDLE;
            hProcess              : HANDLE;
            hThread               : HANDLE;
            lpBaseOfImage         : PVOID;
            dwDebugInfoFileOffset : DWORD;
            nDebugInfoSize        : DWORD;
            lpThreadLocalBase     : PVOID;
            lpStartAddress        : PTHREAD_START_ROUTINE;
            lpImageName           : PVOID;
            fUnicode              : WORD;
     END;
     PCREATE_PROCESS_DEBUG_INFO = POINTER TO CREATE_PROCESS_DEBUG_INFO;

TYPE EXIT_THREAD_DEBUG_INFO = RECORD
                                     dwExitCode : DWORD;
                              END;
    PEXIT_THREAD_DEBUG_INFO = POINTER TO EXIT_THREAD_DEBUG_INFO;

TYPE EXIT_PROCESS_DEBUG_INFO = RECORD
                                      dwExitCode : DWORD;
                               END;
    PEXIT_PROCESS_DEBUG_INFO = POINTER TO EXIT_PROCESS_DEBUG_INFO;

TYPE LOAD_DLL_DEBUG_INFO = RECORD
                                  hFile                 : HANDLE;
                                  lpBaseOfDll           : PVOID;
                                  dwDebugInfoFileOffset : DWORD;
                                  nDebugInfoSize        : DWORD;
                                  lpImageName           : PVOID;
                                  fUnicode              : WORD;
                           END;
   PLOAD_DLL_DEBUG_INFO = POINTER TO LOAD_DLL_DEBUG_INFO;

TYPE UNLOAD_DLL_DEBUG_INFO = RECORD
                                    lpBaseOfDll : PVOID;
                             END;
    PUNLOAD_DLL_DEBUG_INFO = POINTER TO UNLOAD_DLL_DEBUG_INFO;

TYPE OUTPUT_DEBUG_STRING_INFO = RECORD
                                       lpDebugStringData  : PSTR;
                                       fUnicode           : WORD;
                                       nDebugStringLength : WORD;
     END;
    POUTPUT_DEBUG_STRING_INFO = POINTER TO OUTPUT_DEBUG_STRING_INFO;

(*
 * SetLastErrorEx() and RIP_INFO types.
 *)

TYPE SLE_ENUM = (SLE_0,
                 SLE_ERROR,       (* 1 *)
                 SLE_MINORERROR,  (* 2 *)
                 SLE_WARNING);    (* 3 *)

TYPE RIP_INFO = RECORD
                       dwError : DWORD;
                       dwType  : SLE_ENUM;
                END;
    PRIP_INFO = POINTER TO RIP_INFO;

TYPE DEBUG_EVENT =
     RECORD
           dwDebugEventCode : DEBUG_EVENT_TYPE;
           dwProcessId      : DWORD;
           dwThreadId       : DWORD;
           CASE : DEBUG_EVENT_TYPE OF
           | EXCEPTION_DEBUG_EVENT      : Exception         : EXCEPTION_DEBUG_INFO;
           | CREATE_THREAD_DEBUG_EVENT  : CreateThread      : CREATE_THREAD_DEBUG_INFO;
           | CREATE_PROCESS_DEBUG_EVENT : CreateProcessInfo : CREATE_PROCESS_DEBUG_INFO;
           | EXIT_THREAD_DEBUG_EVENT    : ExitThread        : EXIT_THREAD_DEBUG_INFO;
           | EXIT_PROCESS_DEBUG_EVENT   : ExitProcess       : EXIT_PROCESS_DEBUG_INFO;
           | LOAD_DLL_DEBUG_EVENT       : LoadDll           : LOAD_DLL_DEBUG_INFO;
           | UNLOAD_DLL_DEBUG_EVENT     : UnloadDll         : UNLOAD_DLL_DEBUG_INFO;
           | OUTPUT_DEBUG_STRING_EVENT  : DebugString       : OUTPUT_DEBUG_STRING_INFO;
           | RIP_EVENT                  : RipInfo           : RIP_INFO;
           END;
     END;
     PDEBUG_EVENT = POINTER TO DEBUG_EVENT;

TYPE DRIVE_TYPE = (DRIVE_UNKNOWN,     (* 0 *)
                   DRIVE_NO_ROOT_DIR, (* 1 *)
                   DRIVE_REMOVABLE,   (* 2 *)
                   DRIVE_FIXED,       (* 3 *)
                   DRIVE_REMOTE,      (* 4 *)
                   DRIVE_CDROM,       (* 5 *)
                   DRIVE_RAMDISK);    (* 6 *)

(* File types are actually enumeration types; they are represented as set
   values for sole reason that one bit (8000) is allocated for REMOTE flag,
   and should be masked out using set operations
*)

TYPE FILE_TYPE_ENUM = (FILE_TYPE_0,  FILE_TYPE_1,  FILE_TYPE_2,  FILE_TYPE_3,
                       FILE_TYPE_4,  FILE_TYPE_5,  FILE_TYPE_6,  FILE_TYPE_7,
                       FILE_TYPE_8,  FILE_TYPE_9,  FILE_TYPE_10, FILE_TYPE_11,
                       FILE_TYPE_12, FILE_TYPE_13, FILE_TYPE_14,
                       FILE_TYPE__REMOTE); (* 15 *)

TYPE FILE_TYPE = SET OF FILE_TYPE_ENUM;

CONST FILE_TYPE_UNKNOWN = FILE_TYPE {};                         (* 0000h *)
      FILE_TYPE_DISK    = FILE_TYPE {FILE_TYPE_0};              (* 0001h *)
      FILE_TYPE_CHAR    = FILE_TYPE {FILE_TYPE_1};              (* 0002h *)
      FILE_TYPE_PIPE    = FILE_TYPE {FILE_TYPE_1, FILE_TYPE_0}; (* 0003h *)
      FILE_TYPE_REMOTE  = FILE_TYPE {FILE_TYPE__REMOTE};        (* 8000h *)

TYPE STD_HANDLE_TYPE = DWORD;

CONST STD_INPUT_HANDLE  = SYSTEM.CAST (STD_HANDLE_TYPE, VAL (LONG, -10));
      STD_OUTPUT_HANDLE = SYSTEM.CAST (STD_HANDLE_TYPE, VAL (LONG, -11));
      STD_ERROR_HANDLE  = SYSTEM.CAST (STD_HANDLE_TYPE, VAL (LONG, -12));

CONST IGNORE            = 0;           (* Ignore signal *)
      INFINITE          = 0FFFFFFFFh;  (* Infinite timeout *)

(*
** Baud rates at which the communication device operates
*)

CONST CBR_110           = 110;
      CBR_300           = 300;
      CBR_600           = 600;
      CBR_1200          = 1200;
      CBR_2400          = 2400;
      CBR_4800          = 4800;
      CBR_9600          = 9600;
      CBR_14400         = 14400;
      CBR_19200         = 19200;
      CBR_38400         = 38400;
      CBR_56000         = 56000;
      CBR_57600         = 57600;
      CBR_115200        = 115200;
      CBR_128000        = 128000;
      CBR_256000        = 256000;

(*
** Error Flags
*)

TYPE CE_ENUM = (CE__RXOVER,         (*  0 - Receive Queue overflow *)
                CE__OVERRUN,        (*  1 - Receive Overrun Error *)
                CE__RXPARITY,       (*  2 - Receive Parity Error *)
                CE__FRAME,          (*  3 - Receive Framing error *)
                CE__BREAK,          (*  4 - Break Detected *)
                CE__5, CE__6, CE__7,
                CE__TXFULL,         (*  8 - TX Queue is full *)
                CE__PTO,            (*  9 - LPTx Timeout *)
                CE__IOE,            (* 10 - LPTx I/O Error *)
                CE__DNS,            (* 11 - LPTx Device not selected *)
                CE__OOP,            (* 12 - LPTx Out-Of-Paper *)
                CE__13, CE__14,
                CE__MODE);          (* 15 - Requested mode unsupported *)
     CE_SET = SET OF CE_ENUM;

CONST CE_RXOVER         = CE_SET {CE__RXOVER  }; (* 0x0001 *)
      CE_OVERRUN        = CE_SET {CE__OVERRUN }; (* 0x0002 *)
      CE_RXPARITY       = CE_SET {CE__RXPARITY}; (* 0x0004 *)
      CE_FRAME          = CE_SET {CE__FRAME   }; (* 0x0008 *)
      CE_BREAK          = CE_SET {CE__BREAK   }; (* 0x0010 *)
      CE_TXFULL         = CE_SET {CE__TXFULL  }; (* 0x0100 *)
      CE_PTO            = CE_SET {CE__PTO     }; (* 0x0200 *)
      CE_IOE            = CE_SET {CE__IOE     }; (* 0x0400 *)
      CE_DNS            = CE_SET {CE__DNS     }; (* 0x0800 *)
      CE_OOP            = CE_SET {CE__OOP     }; (* 0x1000 *)
      CE_MODE           = CE_SET {CE__MODE    }; (* 0x8000 *)

      IE_BADID          = -1;  (* Invalid or unsupported id *)
      IE_OPEN           = -2;  (* Device Already Open *)
      IE_NOPEN          = -3;  (* Device Not Open *)
      IE_MEMORY         = -4;  (* Unable to allocate queues *)
      IE_DEFAULT        = -5;  (* Error in default parameters *)
      IE_HARDWARE       = -10; (* Hardware Not Present *)
      IE_BYTESIZE       = -11; (* Illegal Byte Size *)
      IE_BAUDRATE       = -12; (* Unsupported BaudRate *)

(*
** Events
*)

TYPE EV_ENUM = (EV__RXCHAR,   (*  0 - Any Character received *)
                EV__RXFLAG,   (*  1 - Received certain character *)
                EV__TXEMPTY,  (*  2 - Transmitt Queue Empty *)
                EV__CTS,      (*  3 - CTS changed state *)
                EV__DSR,      (*  4 - DSR changed state *)
                EV__RLSD,     (*  5 - RLSD changed state *)
                EV__BREAK,    (*  6 - BREAK received *)
                EV__ERR,      (*  7 - Line status error occurred *)
                EV__RING,     (*  8 - Ring signal detected *)
                EV__PERR,     (*  9 - Printer error occured *)
                EV__RX80FULL, (* 10 - Receive buffer is 80 percent full *)
                EV__EVENT1,   (* 11 - Provider specific event 1 *)
                EV__EVENT2);  (* 12 - Provider specific event 2 *)

      EV_SET = SET OF EV_ENUM;

CONST EV_RXCHAR         = EV_SET {EV__RXCHAR  }; (* 0001h; *)
      EV_RXFLAG         = EV_SET {EV__RXFLAG  }; (* 0002h; *)
      EV_TXEMPTY        = EV_SET {EV__TXEMPTY }; (* 0004h; *)
      EV_CTS            = EV_SET {EV__CTS     }; (* 0008h; *)
      EV_DSR            = EV_SET {EV__DSR     }; (* 0010h; *)
      EV_RLSD           = EV_SET {EV__RLSD    }; (* 0020h; *)
      EV_BREAK          = EV_SET {EV__BREAK   }; (* 0040h; *)
      EV_ERR            = EV_SET {EV__ERR     }; (* 0080h; *)
      EV_RING           = EV_SET {EV__RING    }; (* 0100h; *)
      EV_PERR           = EV_SET {EV__PERR    }; (* 0200h; *)
      EV_RX80FULL       = EV_SET {EV__RX80FULL}; (* 0400h; *)
      EV_EVENT1         = EV_SET {EV__EVENT1  }; (* 0800h; *)
      EV_EVENT2         = EV_SET {EV__EVENT2  }; (* 1000h; *)

(*
** Escape Functions
*)

TYPE ESCAPE_TYPE = (ESCAPE_0,
                    SETXOFF,   (* 1 *)   (* Simulate XOFF received *)
                    SETXON,    (* 2 *)   (* Simulate XON received *)
                    SETRTS,    (* 3 *)   (* Set RTS high *)
                    CLRRTS,    (* 4 *)   (* Set RTS low *)
                    SETDTR,    (* 5 *)   (* Set DTR high *)
                    CLRDTR,    (* 6 *)   (* Set DTR low *)
                    RESETDEV,  (* 7 *)   (* Reset device if possible *)
                    SETBREAK,  (* 8 *)   (* Set the device break line. *)
                    CLRBREAK); (* 9 *)   (* Clear the device break line. *)

(*
** PURGE function flags.
*)

TYPE PURGE_ENUM = (PURGE__TXABORT,  (* 0 - Kill the pending/current writes to the comm port. *)
                   PURGE__RXABORT,  (* 1 - Kill the pending/current reads to the comm port. *)
                   PURGE__TXCLEAR,  (* 2 - Kill the transmit queue if there. *)
                   PURGE__RXCLEAR); (* 3 - Kill the typeahead buffer if there. *)
     PURGE_SET = SET OF PURGE_ENUM;

CONST PURGE_TXABORT     = PURGE_SET {PURGE__TXABORT}; (* 0x0001 *)
      PURGE_RXABORT     = PURGE_SET {PURGE__RXABORT}; (* 0x0002 *)
      PURGE_TXCLEAR     = PURGE_SET {PURGE__TXCLEAR}; (* 0x0004 *)
      PURGE_RXCLEAR     = PURGE_SET {PURGE__RXCLEAR}; (* 0x0008 *)

CONST LPTx              = 80h;   (* Set if ID is for LPT device *)

(*
** Modem Status Flags
*)

TYPE MS_ENUM = (MS__0, MS__1,
                MS__2, MS__3,
                MS__CTS_ON,  (* 4 *)
                MS__DSR_ON,   (* 5 *)
                MS__RING_ON,  (* 6 *)
                MS__RLSD_ON); (* 7 *)

     MS_SET = SET OF MS_ENUM;

CONST MS_CTS_ON         = MS_SET {MS__CTS_ON};  (* 0010h *)
      MS_DSR_ON         = MS_SET {MS__DSR_ON};  (* 0020h *)
      MS_RING_ON        = MS_SET {MS__RING_ON}; (* 0040h *)
      MS_RLSD_ON        = MS_SET {MS__RLSD_ON}; (* 0080h *)

(* Special timeout values for WaitNamedPipe *)

CONST NMPWAIT_WAIT_FOREVER     = 0ffffffffh;
      NMPWAIT_NOWAIT           = 000000001h;
      NMPWAIT_USE_DEFAULT_WAIT = 000000000h;


CONST FS_CASE_IS_PRESERVED      = FILE_CASE_PRESERVED_NAMES;
      FS_CASE_SENSITIVE         = FILE_CASE_SENSITIVE_SEARCH;
      FS_UNICODE_STORED_ON_DISK = FILE_UNICODE_ON_DISK;
      FS_PERSISTENT_ACLS        = FILE_PERSISTENT_ACLS;
      FS_VOL_IS_COMPRESSED      = FILE_VOLUME_IS_COMPRESSED;
      FS_FILE_COMPRESSION       = FILE_FILE_COMPRESSION;

      FILE_MAP_COPY       = SECTION_QUERY;
      FILE_MAP_WRITE      = SECTION_MAP_WRITE;
      FILE_MAP_READ       = SECTION_MAP_READ;
      FILE_MAP_ALL_ACCESS = SECTION_ALL_ACCESS;

(* OpenFIle flags *)

TYPE OF_ENUM = (OF__WRITE,            (*  0 *)
                OF__READWRITE,        (*  1 *)
                OF__2, OF__3,
                OF__SHARE_EXCLUSIVE,  (*  4 *)
                OF__SHARE_DENY_WRITE, (*  5 *)
                OF__SHARE_DENY_NONE,  (*  6 *)
                OF__7,
                OF__PARSE,            (*  8 *)
                OF__DELETE,           (*  9 *)
                OF__VERIFY,           (* 10 *)
                OF__CANCEL,           (* 11 *)
                OF__CREATE,           (* 12 *)
                OF__PROMPT,           (* 13 *)
                OF__EXIST,            (* 14 *)
                OF__REOPEN);          (* 15 *)
      OF_FLAGS = SET OF OF_ENUM;

CONST OF_READ             = OF_FLAGS {                    }; (* 00000000h; *)
      OF_WRITE            = OF_FLAGS {OF__WRITE           }; (* 00000001h; *)
      OF_READWRITE        = OF_FLAGS {OF__READWRITE       }; (* 00000002h; *)
      OF_SHARE_COMPAT     = OF_FLAGS {                    }; (* 00000000h; *)
      OF_SHARE_EXCLUSIVE  = OF_FLAGS {OF__SHARE_EXCLUSIVE }; (* 00000010h; *)
      OF_SHARE_DENY_WRITE = OF_FLAGS {OF__SHARE_DENY_WRITE}; (* 00000020h; *)
      OF_SHARE_DENY_READ  = OF_FLAGS {OF__SHARE_EXCLUSIVE,
                                      OF__SHARE_DENY_WRITE}; (* 00000030h; *)
      OF_SHARE_DENY_NONE  = OF_FLAGS {OF__SHARE_DENY_NONE }; (* 00000040h; *)
      OF_PARSE            = OF_FLAGS {OF__PARSE           }; (* 00000100h; *)
      OF_DELETE           = OF_FLAGS {OF__DELETE          }; (* 00000200h; *)
      OF_VERIFY           = OF_FLAGS {OF__VERIFY          }; (* 00000400h; *)
      OF_CANCEL           = OF_FLAGS {OF__CANCEL          }; (* 00000800h; *)
      OF_CREATE           = OF_FLAGS {OF__CREATE          }; (* 00001000h; *)
      OF_PROMPT           = OF_FLAGS {OF__PROMPT          }; (* 00002000h; *)
      OF_EXIST            = OF_FLAGS {OF__EXIST           }; (* 00004000h; *)
      OF_REOPEN           = OF_FLAGS {OF__REOPEN          }; (* 00008000h; *)

      OFS_MAXPATHNAME = 128;

TYPE OFSTRUCT = RECORD
                       cBytes     : BYTE;
                       fFixedDisk : BYTE;
                       nErrCode   : WORD;
                       Reserved1  : WORD;
                       Reserved2  : WORD;
                       szPathName : ARRAY [0..OFS_MAXPATHNAME-1] OF CHAR;
                END;
    POFSTRUCT = POINTER TO OFSTRUCT;

PROCEDURE InterlockedIncrement (VAR Addend : LONG) : LONG;
PROCEDURE InterlockedDecrement (VAR Addend : LONG) : LONG;
PROCEDURE InterlockedExchange  (VAR Target : LONG; Value : LONG) : LONG;

PROCEDURE InterlockedCompareExchange (VAR Destination : PVOID;
                                      Exchange        : PVOID;
                                      Comperand       : PVOID) : PVOID;

PROCEDURE InterlockedExchangeAdd (VAR Addend : LONG; Value : LONG) : LONG;

PROCEDURE FreeResource (hResData : HGLOBAL) : BOOL;
PROCEDURE LockResource (hResData : HGLOBAL) : PVOID;

CONST MAXINTATOM   = 0C000h;
      INVALID_ATOM = SYSTEM.CAST (ATOM, 0);

PROCEDURE MAKEINTATOM (i : INTEGER) : ATOMSTR; (* in RTL; was macro *)

(* PROCEDURE WinMain has been deleted because main module is used instead *)

PROCEDURE FreeLibrary (hLibModul : HMODULE) : BOOL;

CONST FreeModule = FreeLibrary;

PROCEDURE FreeLibraryAndExitThread (hLibModule : HMODULE;
                                    dwExitCode : DWORD);

PROCEDURE DisableThreadLibraryCalls (hLibModule : HMODULE) : BOOL;
PROCEDURE GetProcAddress (hModule    : HMODULE;
                          lpProcName : PCSTR)   (* lpProcName can receive ordinal value *)
                                              : PROC;
PROCEDURE GetVersion () : DWORD;
PROCEDURE GlobalAlloc (uFlags  : GMEM_SET;
                       dwBytes : DWORD) : HGLOBAL;

PROCEDURE GlobalReAlloc (hMem    : HGLOBAL;
                         dwBytes : DWORD;
                         uFlags  : GMEM_SET) : HGLOBAL;

PROCEDURE GlobalSize  (hMem : HGLOBAL) : DWORD;
PROCEDURE GlobalFlags (hMem : HGLOBAL) : GMEM_SET;
PROCEDURE GlobalLock  (hMem : HGLOBAL) : PVOID;

PROCEDURE GlobalHandle  (pMem : LPCVOID) : HGLOBAL;
PROCEDURE GlobalUnlock  (hMem : HGLOBAL) : BOOL;
PROCEDURE GlobalFree    (hMem : HGLOBAL) : HGLOBAL;
PROCEDURE GlobalCompact (dwMinFree : DWORD) : UINT;
PROCEDURE GlobalFix     (hMem : HGLOBAL);
PROCEDURE GlobalUnfix   (hMem : HGLOBAL);
PROCEDURE GlobalWire    (hMem : HGLOBAL) : PVOID;
PROCEDURE GlobalUnWire  (hMem : HGLOBAL) : BOOL;
PROCEDURE GlobalMemoryStatus (VAR Buffer : MEMORYSTATUS);
PROCEDURE LocalAlloc    (uFlags : LMEM_SET; uByte : UINT) : HLOCAL;
PROCEDURE LocalReAlloc  (hMem : HLOCAL; uBytes : UINT; uFlags : LMEM_SET) : HLOCAL;
PROCEDURE LocalLock     (hMem : HLOCAL) : PVOID;
PROCEDURE LocalHandle   (pMem : LPCVOID) : HLOCAL;
PROCEDURE LocalUnlock   (hMem : HLOCAL) : BOOL;
PROCEDURE LocalSize     (hMem : HLOCAL) : UINT;
PROCEDURE LocalFlags    (hMem : HLOCAL) : LMEM_SET;
PROCEDURE LocalFree     (hMem : HLOCAL) : HLOCAL;
PROCEDURE LocalShrink (hMem : HLOCAL; cbNewSize : UINT) : UINT;
PROCEDURE LocalCompact (uMinFree : UINT) : UINT;
PROCEDURE FlushInstructionCache (hProcess      : HANDLE;
                                 lpBaseAddress : LPCVOID;
                                 dwSize        : DWORD) : BOOL;

PROCEDURE VirtualAlloc (lpAddress        : PVOID;
                        dwSize           : DWORD;
                        flAllocationType : PROTECT_SET;
                        flProtect        : PROTECT_SET) : PVOID;

PROCEDURE VirtualFree (lpAddress  : LPCVOID;
                       dwSize     : DWORD;
                       dwFreeType : PROTECT_SET) : BOOL;

PROCEDURE VirtualProtect (lpAddress      : PVOID;
                          dwSize         : DWORD;
                          flNewProtect   : PROTECT_SET;
                          VAR OldProtect : PROTECT_SET) : BOOL;

PROCEDURE VirtualQuery (lpAddress  : LPCVOID;
                        VAR Buffer : MEMORY_BASIC_INFORMATION;
                        dwLength   : DWORD) : DWORD;

PROCEDURE VirtualProtectEx (hProcess       : HANDLE;
                            lpAddress      : PVOID;
                            dwSize         : DWORD;
                            flNewProtect   : PROTECT_SET;
                            VAR OldProtect : PROTECT_SET) : BOOL;

PROCEDURE VirtualQueryEx (hProcess  : HANDLE;
                          lpAddress : LPCVOID;
                          VAR Buffer: MEMORY_BASIC_INFORMATION;
                          dwLength  : DWORD) : DWORD;

PROCEDURE HeapCreate (flOptions     : HEAP_SET;
                      dwInitialSize : DWORD;
                      dwMaximumSize : DWORD) : HANDLE;

PROCEDURE HeapDestroy (hHeap : HANDLE) : BOOL;
PROCEDURE HeapAlloc   (hHeap : HANDLE; dwFlags : HEAP_SET; dwBytes : DWORD) : PVOID;
PROCEDURE HeapReAlloc (hHeap : HANDLE; dwFlags : HEAP_SET;
                       lpMem : PVOID;  dwBytes : DWORD) : PVOID;

PROCEDURE HeapFree     (hHeap : HANDLE; dwFlags : HEAP_SET; lpMem : PVOID) : BOOL;
PROCEDURE HeapSize     (hHeap : HANDLE; dwFlags : HEAP_SET; lpMem : LPCVOID) : DWORD;
PROCEDURE HeapValidate (hHeap : HANDLE; dwFlags : HEAP_SET; lpMem : LPCVOID) : BOOL;
PROCEDURE HeapCompact  (hHeap : HANDLE; dwFlags : HEAP_SET) : UINT;
PROCEDURE GetProcessHeap () : HANDLE;
PROCEDURE GetProcessHeaps (NumberOfHeaps    : DWORD;
                           VAR ProcessHeaps : ARRAY OF HANDLE) : DWORD;

(* PROCESS_HEAP_ENTRY wFlags values *)

TYPE PROCESS_HEAP_ENUM = (PROCESS_HEAP__REGION,            (* 0 *)
                          PROCESS_HEAP__UNCOMMITTED_RANGE, (* 1 *)
                          PROCESS_HEAP__ENTRY_BUSY,        (* 2 *)
                          PROCESS_HEAP__3,
                          PROCESS_HEAP__ENTRY_MOVEABLE,    (* 4 *)
                          PROCESS_HEAP__ENTRY_DDESHARE);   (* 5 *)

<* PUSH *> <* SETSIZE = "2" *>

TYPE PROCESS_HEAP_SET = SET OF PROCESS_HEAP_ENUM;

CONST PROCESS_HEAP_REGION             = PROCESS_HEAP_SET {PROCESS_HEAP__REGION};            (* 0001h *)
      PROCESS_HEAP_UNCOMMITTED_RANGE  = PROCESS_HEAP_SET {PROCESS_HEAP__UNCOMMITTED_RANGE}; (* 0002h *)
      PROCESS_HEAP_ENTRY_BUSY         = PROCESS_HEAP_SET {PROCESS_HEAP__ENTRY_BUSY};        (* 0004h *)
      PROCESS_HEAP_ENTRY_MOVEABLE     = PROCESS_HEAP_SET {PROCESS_HEAP__ENTRY_MOVEABLE};    (* 0010h *)
      PROCESS_HEAP_ENTRY_DDESHARE     = PROCESS_HEAP_SET {PROCESS_HEAP__ENTRY_DDESHARE};    (* 0020h *)

<* POP *>

TYPE PROCESS_HEAP_ENTRY =
          RECORD
                 lpData       : PVOID;
                 cbData       : DWORD;
                 cbOverhead   : BYTE;
                 iRegionIndex : BYTE;
                 wFlags       : PROCESS_HEAP_SET;
                 CASE : BOOLEAN OF
                 | TRUE  : Block : RECORD
                                         hMem : HANDLE;
                                         dwReserved : ARRAY [0..2] OF DWORD;
                                   END;
                 | FALSE : Region : RECORD
                                         dwCommittedSize   : DWORD;
                                         dwUnCommittedSize : DWORD;
                                         lpFirstBlock      : PVOID;
                                         lpLastBlock       : PVOID;
                                    END;
                 END;
          END;
    PPROCESS_HEAP_ENTRY = POINTER TO PROCESS_HEAP_ENTRY;

PROCEDURE HeapLock   (hHeap : HANDLE) : BOOL;
PROCEDURE HeapUnlock (hHeap : HANDLE) : BOOL;
PROCEDURE HeapWalk   (hHeap : HANDLE; VAR Entry : PROCESS_HEAP_ENTRY) : BOOL;

(* GetBinaryType return values. *)

TYPE SCS_TYPE = (SCS_32BIT_BINARY,  (* 0 *)
                 SCS_DOS_BINARY,    (* 1 *)
                 SCS_WOW_BINARY,    (* 2 *)
                 SCS_PIF_BINARY,    (* 3 *)
                 SCS_POSIX_BINARY,  (* 4 *)
                 SCS_OS216_BINARY); (* 5 *)

PROCEDURE GetBinaryTypeA (ApplicationName : ARRAY OF CHAR;
                          VAR BinaryType  : SCS_TYPE) : BOOL;


PROCEDURE GetBinaryTypeW (ApplicationName : ARRAY OF WCHAR;
                          VAR BinaryType  : SCS_TYPE) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetBinaryType = GetBinaryTypeW;
<* ELSE *>
      CONST GetBinaryType = GetBinaryTypeA;
<* END *>

PROCEDURE GetShortPathNameA (LongPath      : ARRAY OF CHAR;
                             VAR ShortPath : ARRAY OF CHAR;
                             cchBuffer     : DWORD) : DWORD;

PROCEDURE GetShortPathNameW (LongPath      : ARRAY OF WCHAR;
                             VAR ShortPath : ARRAY OF WCHAR;
                             cchBuffer     : DWORD) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetShortPathName = GetShortPathNameW;
<* ELSE *>
      CONST GetShortPathName = GetShortPathNameA;
<* END *>

PROCEDURE GetProcessAffinityMask (hProcess                : HANDLE;
                                  VAR ProcessAffinityMask : BITSET;
                                  VAR SystemAffinityMask  : BITSET) : BOOL;

PROCEDURE GetProcessTimes (hProcess         : HANDLE;
                           VAR CreationTime : FILETIME;
                           VAR ExitTime     : FILETIME;
                           VAR KernelTime   : FILETIME;
                           VAR UserTime     : FILETIME) : BOOL;

PROCEDURE GetProcessWorkingSetSize (hProcess                  : HANDLE;
                                    VAR MinimumWorkingSetSize : DWORD;
                                    VAR MaximumWorkingSetSize : DWORD) : BOOL;

PROCEDURE SetProcessWorkingSetSize (hProcess                : HANDLE;
                                    dwMinimumWorkingSetSize : DWORD;
                                    dwMaximumWorkingSetSize : DWORD) : BOOL;

PROCEDURE OpenProcess (dwDesiredAccess : ACCESS_MASK;
                       bInheritHandle  : BOOL;
                       dwProcessId     : DWORD) : HANDLE;

PROCEDURE GetCurrentProcess () : HANDLE;
PROCEDURE GetCurrentProcessId () : DWORD;
PROCEDURE ExitProcess (uExitCode : UINT);
PROCEDURE TerminateProcess (hProcess : HANDLE; uExitCode : UINT) : BOOL;
PROCEDURE GetExitCodeProcess (hProcess : HANDLE; VAR ExitCode : DWORD) : BOOL;
PROCEDURE FatalExit (ExitCode : INTEGER);

PROCEDURE GetEnvironmentStringsA () : PSTR;
PROCEDURE GetEnvironmentStringsW () : PWSTR;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetEnvironmentStrings = GetEnvironmentStringsW;
<* ELSE *>
      CONST GetEnvironmentStrings = GetEnvironmentStringsA;
<* END *>

PROCEDURE FreeEnvironmentStringsA (str :  PSTR) : BOOL;
PROCEDURE FreeEnvironmentStringsW (str : PWSTR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST FreeEnvironmentStrings = FreeEnvironmentStringsW;
<* ELSE *>
      CONST FreeEnvironmentStrings = FreeEnvironmentStringsA;
<* END *>

PROCEDURE RaiseException (dwExceptionCode    : DWORD;
                          dwExceptionFlags   : DWORD; (* only EXCEPTION_NONCONTINUABLE allowed *)
                          nNumberOfArguments : DWORD;
                          lpArguments        : PCDWORD); (* actually ARRAY OF DWORD but can accept NIL *)

PROCEDURE UnhandledExceptionFilter (VAR ExceptionInfo : EXCEPTION_POINTERS) : LONG;

TYPE PTOP_LEVEL_EXCEPTION_FILTER = PROCEDURE (
        VAR (* ExceptionInfo : *) EXCEPTION_POINTERS) : LONG;


PROCEDURE SetUnhandledExceptionFilter (
                    TopLevelExceptionFilter : PTOP_LEVEL_EXCEPTION_FILTER
          ) : PTOP_LEVEL_EXCEPTION_FILTER;

PROCEDURE CreateFiber (dwStackSize    : DWORD;
                       lpStartAddress : PFIBER_START_ROUTINE;
                       lpParameter    : PVOID)
                                               : PVOID;

PROCEDURE DeleteFiber (lpFiber : PVOID);
PROCEDURE ConvertThreadToFiber (lpParameter : PVOID) : PVOID;
PROCEDURE SwitchToFiber (lpFiber : PVOID);
PROCEDURE SwitchToThread () : BOOL;

PROCEDURE CreateThread (lpThreadAttributes : PSECURITY_ATTRIBUTES;  (* IN NIL *)
                        dwStackSize        : DWORD;
                        lpStartAddress     : PTHREAD_START_ROUTINE;
                        lpParameter        : PVOID;
                        dwCreationFlags    : CREATE_SET;
                        VAR ThreadId       : DWORD) : HANDLE;

PROCEDURE CreateRemoteThread (hProcess           : HANDLE;
                              lpThreadAttributes : PSECURITY_ATTRIBUTES;  (* IN NIL *)
                              dwStackSize        : DWORD;
                              lpStartAddress     : PTHREAD_START_ROUTINE;
                              lpParameter        : PVOID;
                              dwCreationFlags    : CREATE_SET;
                              VAR [NIL] ThreadId : DWORD) : HANDLE;

PROCEDURE GetCurrentThread   (): HANDLE;
PROCEDURE GetCurrentThreadId () : DWORD;
PROCEDURE SetThreadAffinityMask (hThread              : HANDLE;
                                 dwThreadAffinityMask : BITSET) : BITSET;

PROCEDURE SetThreadIdealProcessor (hThread          : HANDLE;
                                   dwIdealProcessor : DWORD) : DWORD;

PROCEDURE SetProcessPriorityBoost (hProcess             : HANDLE;
                                   DisablePriorityBoost : BOOL) : BOOL;

PROCEDURE GetProcessPriorityBoost (hProcess                 : HANDLE;
                                   VAR DisablePriorityBoost : BOOL) : BOOL;

PROCEDURE SetThreadPriority (hThread   : HANDLE;
                             nPriority : INTEGER) : BOOL;

PROCEDURE SetThreadPriorityBoost (hThread               : HANDLE;
                                  bDisablePriorityBoost : BOOL) : BOOL;

PROCEDURE GetThreadPriorityBoost (hThread                  : HANDLE;
                                  VAR DisablePriorityBoost : BOOL) : BOOL;

PROCEDURE GetThreadPriority (hThread : HANDLE) : INTEGER;

PROCEDURE GetThreadTimes (hThread          : HANDLE;
                          VAR CreationTime : FILETIME;
                          VAR ExitTime     : FILETIME;
                          VAR KernelTime   : FILETIME;
                          VAR UserTime     : FILETIME) : BOOL;

PROCEDURE ExitThread (dwExitCode : DWORD);
PROCEDURE TerminateThread (hThread : HANDLE; dwExitCode : DWORD) : BOOL;
PROCEDURE GetExitCodeThread (hThread : HANDLE; VAR ExitCode : DWORD) : BOOL;
PROCEDURE GetThreadSelectorEntry (hThread : HANDLE; dwSelector : DWORD;
                                  VAR SelectorEntry : LDT_ENTRY) : BOOL;
PROCEDURE GetLastError () : DWORD;
PROCEDURE SetLastError (dwErrCode : DWORD);

PROCEDURE HasOverlappedIoCompleted (VAR Overlapped : OVERLAPPED) : BOOL; (* IN RTL *)

PROCEDURE GetOverlappedResult (hFile                        : HANDLE;
                               VAR Overlapped               : OVERLAPPED;
                               VAR NumberOfBytesTransferred : DWORD;
                               bWait                        : BOOL)
                                                                    : BOOL;

PROCEDURE CreateIoCompletionPort (FileHandle                : HANDLE;
                                  ExistingCompletionPort    : HANDLE;
                                  CompletionKey             : DWORD;
                                  NumberOfConcurrentThreads : DWORD) : HANDLE;

PROCEDURE GetQueuedCompletionStatus (CompletionPort           : HANDLE;
                                     NumberOfBytesTransferred : DWORD;
                                     VAR CompletionKey        : DWORD;
                                     VAR Overlapped           : OVERLAPPED;
                                     dwMilliseconds           : DWORD)
                                                                       : BOOL;

PROCEDURE PostQueuedCompletionStatus (CompletionPort             : HANDLE;
                                      dwNumberOfBytesTransferred : DWORD;
                                      dwCompletionKey            : DWORD;
                                      VAR Overlapped             : OVERLAPPED) : BOOL;

TYPE SEM_ENUM = (SEM__FAILCRITICALERRORS,      (* 0 *)
                 SEM__NOGPFAULTERRORBOX,       (* 1 *)
                 SEM__NOALIGNMENTFAULTEXCEPT,  (* 2 *)
                 SEM__3,  SEM__4,  SEM__5,
                 SEM__6,  SEM__7,  SEM__8,
                 SEM__9,  SEM__10, SEM__11,
                 SEM__12, SEM__13, SEM__14,
                 SEM__NOOPENFILEERRORBOX);     (* 15 *)
     SEM_SET = SET OF SEM_ENUM;

CONST SEM_FAILCRITICALERRORS     = SEM_SET {SEM__FAILCRITICALERRORS};     (* 0x0001 *)
      SEM_NOGPFAULTERRORBOX      = SEM_SET {SEM__NOGPFAULTERRORBOX};      (* 0x0002 *)
      SEM_NOALIGNMENTFAULTEXCEPT = SEM_SET {SEM__NOALIGNMENTFAULTEXCEPT}; (* 0x0004 *)
      SEM_NOOPENFILEERRORBOX     = SEM_SET {SEM__NOOPENFILEERRORBOX};     (* 0x8000 *)

PROCEDURE SetErrorMode (uMode : SEM_SET) : SEM_SET;

PROCEDURE ReadProcessMemory (hProcess                    : HANDLE;
                             lpBaseAddress               : LPCVOID;
                             lpBuffer                    : PVOID;
                             nSize                       : DWORD;
                             VAR [NIL] NumberOfBytesRead : DWORD) : BOOL;

PROCEDURE WriteProcessMemory (hProcess                       : HANDLE;
                              lpBaseAddress                  : PVOID;
                              lpBuffer                       : PVOID;
                              nSize                          : DWORD;
                              VAR [NIL] NumberOfBytesWritten : DWORD) : BOOL;

PROCEDURE GetThreadContext (hThread : HANDLE; VAR Context : CONTEXT) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE SetThreadContext (hThread : HANDLE; Context : CONTEXT) : BOOL;
<* ELSE *>
PROCEDURE SetThreadContext (hThread : HANDLE; Context : PCONTEXT) : BOOL;
<* END *> (*!*)

PROCEDURE SuspendThread (hThread : HANDLE) : DWORD;
PROCEDURE ResumeThread  (hThread : HANDLE) : DWORD;

TYPE PAPCFUNC = PROCEDURE ((* dwParam : *) DWORD);

PROCEDURE QueueUserAPC (pfnAPC  : PAPCFUNC;
                        hThread : HANDLE;
                        dwData  : DWORD) : DWORD;

PROCEDURE DebugBreak;

PROCEDURE DebugBreakProcess(hProcess : HANDLE) : BOOL;

PROCEDURE WaitForDebugEvent (VAR DebugEvent : DEBUG_EVENT;
                             dwMilliseconds : DWORD)
                                                     : BOOL;

PROCEDURE ContinueDebugEvent (dwProcessId      : DWORD;
                              dwThreadId       : DWORD;
                              dwContinueStatus : DWORD) : BOOL;

PROCEDURE DebugActiveProcess (dwProcessId : DWORD) : BOOL;
PROCEDURE InitializeCriticalSection (VAR CriticalSection : CRITICAL_SECTION);
PROCEDURE EnterCriticalSection      (VAR CriticalSection : CRITICAL_SECTION);
PROCEDURE LeaveCriticalSection      (VAR CriticalSection : CRITICAL_SECTION);
PROCEDURE TryEnterCriticalSection   (VAR CriticalSection : CRITICAL_SECTION);
PROCEDURE DeleteCriticalSection     (VAR CriticalSection : CRITICAL_SECTION);
PROCEDURE SetEvent   (hEvent : HANDLE) : BOOL;
PROCEDURE ResetEvent (hEvent : HANDLE) : BOOL;
PROCEDURE PulseEvent (hEvent : HANDLE) : BOOL;
PROCEDURE ReleaseSemaphore (hSemaphore              : HANDLE;
                            lReleaseCount           : LONG;
                            VAR [NIL] PreviousCount : LONG) : BOOL;

PROCEDURE ReleaseMutex (hMutex : HANDLE) : BOOL;
PROCEDURE WaitForSingleObject (hHandle        : HANDLE;
                               dwMilliseconds : DWORD) : DWORD;

PROCEDURE WaitForMultipleObjects (nCount         : DWORD;
                                  Handles        : ARRAY OF HANDLE;
                                  bWaitAll       : BOOL;
                                  dwMilliseconds : DWORD) : DWORD;

PROCEDURE Sleep (dwMilliseconds : DWORD);

PROCEDURE LoadResource (hModule  : HMODULE;
                        hResInfo : HRSRC) : HGLOBAL;

PROCEDURE SizeofResource (hModule  : HMODULE;
                          hResInfo : HRSRC) : DWORD;

PROCEDURE GlobalDeleteAtom (nAtom : ATOM) : ATOM;
PROCEDURE InitAtomTable    (nSize : DWORD) : BOOL;
PROCEDURE DeleteAtom       (nAtom : ATOM) : ATOM;
PROCEDURE SetHandleCount   (uNumber : UINT) : UINT;
PROCEDURE GetLogicalDrives () : BITSET;
PROCEDURE LockFile (hFile                    : HANDLE;
                    dwFileOffsetLow          : DWORD;
                    dwFileOffsetHigh         : DWORD;
                    nNumberOfBytesToLockLow  : DWORD;
                    nNumberOfBytesToLockHigh : DWORD) : BOOL;

PROCEDURE UnlockFile (hFile                      : HANDLE;
                      dwFileOffsetLow            : DWORD;
                      dwFileOffsetHigh           : DWORD;
                      nNumberOfBytesToUnlockLow  : DWORD;
                      nNumberOfBytesToUnlockHigh : DWORD) : BOOL;

TYPE LOCKFILE_ENUM = (LOCKFILE__FAIL_IMMEDIATELY,         (* 0 *)
                      LOCKFILE__EXCLUSIVE_LOCK);          (* 1 *)

     LOCKFILE_SET = SET OF LOCKFILE_ENUM;

CONST LOCKFILE_FAIL_IMMEDIATELY = LOCKFILE_SET {LOCKFILE__FAIL_IMMEDIATELY}; (* 0x00000001 *)
      LOCKFILE_EXCLUSIVE_LOCK   = LOCKFILE_SET {LOCKFILE__EXCLUSIVE_LOCK};   (* 0x00000002 *)

PROCEDURE LockFileEx (hFile                    : HANDLE;
                      dwFlags                  : LOCKFILE_SET;
                      dwReserved               : DWORD;
                      nNumberOfBytesToLockLow  : DWORD;
                      nNumberOfBytesToLockHigh : DWORD;
                      VAR Overlapped           : OVERLAPPED) : BOOL;

PROCEDURE UnlockFileEx (hFile                      : HANDLE;
                        dwReserved                 : DWORD;
                        nNumberOfBytesToUnlockLow  : DWORD;
                        nNumberOfBytesToUnlockHigh : DWORD;
                        VAR Overlapped             : OVERLAPPED) : BOOL;

TYPE BY_HANDLE_FILE_INFORMATION = RECORD
                                         dwFileAttributes     : FILE_ATTRIBUTE_SET;
                                         ftCreationTime       : FILETIME;
                                         ftLastAccessTime     : FILETIME;
                                         ftLastWriteTime      : FILETIME;
                                         dwVolumeSerialNumber : DWORD;
                                         nFileSizeHigh        : DWORD;
                                         nFileSizeLow         : DWORD;
                                         nNumberOfLinks       : DWORD;
                                         nFileIndexHigh       : DWORD;
                                         nFileIndexLow        : DWORD;
                                  END;
    PBY_HANDLE_FILE_INFORMATION = POINTER TO BY_HANDLE_FILE_INFORMATION;

PROCEDURE GetFileInformationByHandle (hFile : HANDLE;
                                      VAR FileInformation : BY_HANDLE_FILE_INFORMATION) : BOOL;

PROCEDURE GetFileType  (hFile : HANDLE) : FILE_TYPE;
PROCEDURE GetFileSize  (hFile : HANDLE; VAR [NIL] FileSizeHigh : DWORD) : DWORD;
PROCEDURE GetStdHandle (nStdHandle : STD_HANDLE_TYPE) : HANDLE;
PROCEDURE SetStdHandle (nStdHandle : STD_HANDLE_TYPE;
                        hHandle    : HANDLE)
                                             : BOOL;

PROCEDURE WriteFile (hFile                          : HANDLE;
                     lpBuffer                       : LPCVOID;
                     nNumberOfBytesToWrite          : DWORD;
                     VAR [NIL] NumberOfBytesWritten : DWORD;
                     VAR [NIL] Overlapped           : OVERLAPPED) : BOOL;

PROCEDURE ReadFile (hFile                       : HANDLE;
                    lpBuffer                    : PVOID;
                    nNumberOfBytesToRead        : DWORD;
                    VAR [NIL] NumberOfBytesRead : DWORD;
                    VAR [NIL] Overlapped        : OVERLAPPED) : BOOL;

PROCEDURE FlushFileBuffers (hFile : HANDLE) : BOOL;

PROCEDURE DeviceIoControl (hDevice                 : HANDLE;
                           dwIoControlCode         : DWORD;
                           lpInBuffer              : PVOID;
                           nInBufferSize           : DWORD;
                           lpOutBuffer             : PVOID;
                           nOutBufferSize          : DWORD;
                           VAR [NIL] BytesReturned : DWORD;
                           VAR [NIL] Overlapped    : OVERLAPPED) : BOOL;

PROCEDURE SetEndOfFile (hFile : HANDLE) : BOOL;

PROCEDURE SetFilePointer (hFile                        : HANDLE;
                          DistanceToMove               : LONG;
                          VAR [NIL] DistanceToMoveHigh : LONG;
                          dwMoveMethod                 : MOVE_TYPE)
                                                                    : DWORD;

PROCEDURE FindClose (hFindFile : HANDLE) : BOOL;

PROCEDURE GetFileTime (hFile                    : HANDLE;
                       VAR [NIL] CreationTime   : FILETIME;
                       VAR [NIL] LastAccessTime : FILETIME;
                       VAR [NIL] LastWriteTim   : FILETIME) : BOOL;

PROCEDURE SetFileTime (hFile            : HANDLE;
                       lpCreationTime   : PFILETIME;  (* IN NIL *)
                       lpLastAccessTime : PFILETIME;  (* IN NIL *)
                       lpLastWriteTime  : PFILETIME)  (* IN NIL *)
                                                     : BOOL;

PROCEDURE CloseHandle (hObject : HANDLE) : BOOL;
PROCEDURE DuplicateHandle (hSourceProcessHandle   : HANDLE;
                           hSourceHandle          : HANDLE;
                           hTargetProcessHandle   : HANDLE;
                           VAR [NIL] TargetHandle : HANDLE;
                           dwDesiredAccess        : ACCESS_MASK;
                           bInheritHandle         : BOOL;
                           dwOptions              : DUPLICATE_TYPE) : BOOL;

TYPE HANDLE_FLAG_ENUM = (HANDLE_FLAG__INHERIT,             (* 0x00000001 *)
                         HANDLE_FLAG__PROTECT_FROM_CLOSE); (* 0x00000002 *)
     HANDLE_FLAG_SET = SET OF HANDLE_FLAG_ENUM;

CONST HANDLE_FLAG_INHERIT            = HANDLE_FLAG_SET {HANDLE_FLAG__INHERIT};            (* 0x00000001 *)
      HANDLE_FLAG_PROTECT_FROM_CLOSE = HANDLE_FLAG_SET {HANDLE_FLAG__PROTECT_FROM_CLOSE}; (* 0x00000002 *)

PROCEDURE GetHandleInformation (hObject   : HANDLE;
                                VAR Flags : HANDLE_FLAG_SET) : BOOL;

PROCEDURE SetHandleInformation (hObject : HANDLE;
                                dwMask  : HANDLE_FLAG_SET;
                                dwFlags : HANDLE_FLAG_SET) : BOOL;

CONST HINSTANCE_ERROR = 32;

PROCEDURE LoadModule (ModuleName       : ARRAY OF CHAR;
                      lpParameterBlock : PVOID)
                                                : DWORD;

PROCEDURE WinExec (CmdLine : ARRAY OF CHAR; uCmdShow : UINT) : UINT; (* CmdShow is actually SW_ENUM *)
PROCEDURE ClearCommBreak (hFile : HANDLE) : BOOL;

PROCEDURE ClearCommError (hFile          : HANDLE;
                          VAR Errors     : CE_SET;
                          VAR [NIL] Stat : COMSTAT) : BOOL;

PROCEDURE SetupComm (hFile      : HANDLE;
                     dwInQueue  : DWORD;
                     dwOutQueue : DWORD) : BOOL;

PROCEDURE EscapeCommFunction (hFile  : HANDLE;
                              dwFunc : ESCAPE_TYPE) : BOOL;

PROCEDURE GetCommConfig (hCommDev : HANDLE;
                         VAR CC   : COMMCONFIG;
                         VAR Size : DWORD) : BOOL;

PROCEDURE GetCommMask (hFile       : HANDLE;
                       VAR EvtMask : EV_SET) : BOOL;

PROCEDURE GetCommProperties (hFile        : HANDLE;
                             VAR CommProp : COMMPROP) : BOOL;

PROCEDURE GetCommModemStatus (hFile         : HANDLE;
                              VAR ModemStat : MS_SET) : BOOL;

PROCEDURE GetCommState (hFile : HANDLE; VAR DCB : DCB) : BOOL;
PROCEDURE GetCommTimeouts (hFile : HANDLE; VAR CommTimeouts : COMMTIMEOUTS) : BOOL;
PROCEDURE PurgeComm (hFile : HANDLE; dwFlags : PURGE_SET) : BOOL;
PROCEDURE SetCommBreak (hFile : HANDLE) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE SetCommConfig (hCommDev : HANDLE;
                         CC       : COMMCONFIG; (*!*)
                         dwSize   : DWORD) : BOOL;
<* ELSE *>
PROCEDURE SetCommConfig (hCommDev : HANDLE;
                         CC       : PCOMMCONFIG; (*!*)
                         dwSize   : DWORD) : BOOL;
<* END *>

PROCEDURE SetCommMask  (hFile : HANDLE; EvtMask : EV_SET) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE SetCommState (hFile : HANDLE; DCB : DCB) : BOOL;
<* ELSE *>
PROCEDURE SetCommState (hFile : HANDLE; DCB : PDCB) : BOOL;
<* END *>  (*!*)
<* IF BACKEND # "C" THEN *>
PROCEDURE SetCommTimeouts (hFile        : HANDLE;
                           CommTimeouts : COMMTIMEOUTS) : BOOL;
<* ELSE *>
PROCEDURE SetCommTimeouts (hFile        : HANDLE;
                           CommTimeouts : PCOMMTIMEOUTS) : BOOL;
<* END *>  (*!*)

PROCEDURE TransmitCommChar (hFile : HANDLE; cChar : CHAR) : BOOL;

PROCEDURE WaitCommEvent (hFile                : HANDLE;
                         VAR EvtMask          : EV_SET;
                         VAR [NIL] Overlapped : OVERLAPPED) : BOOL;

PROCEDURE SetTapePosition (hDevice          : HANDLE;
                           dwPositionMethod : TAPE_SET_POSITION_TYPE;
                           dwPartition      : DWORD;
                           dwOffsetLow      : DWORD;
                           dwOffsetHigh     : DWORD;
                           bImmediate       : BOOL) : DWORD;

PROCEDURE GetTapePosition (hDevice              : HANDLE;
                           dwPositionType       : TAPE_GET_POSITION_TYPE;
                           VAR dwPartition      : DWORD;
                           VAR dwOffsetLow      : DWORD;
                           VAR [NIL] OffsetHigh : DWORD) : DWORD;

PROCEDURE PrepareTape (hDevice     : HANDLE;
                       dwOperation : TAPE_OPERATION;
                       bImmediate  : BOOL) : DWORD;

PROCEDURE EraseTape (hDevice     : HANDLE;
                     dwEraseType : TAPE_ERASE_TYPE;
                     bImmediate  : BOOL) : DWORD;

PROCEDURE CreateTapePartition (hDevice           : HANDLE;
                               dwPartitionMethod : TAPE_PARTITION_TYPE;
                               dwCount           : DWORD;
                               dwSize            : DWORD) : DWORD;

PROCEDURE WriteTapemark (hDevice         : HANDLE;
                         dwTapemarkType  : TAPE_MARK_TYPE;
                         dwTapemarkCount : DWORD;
                         bImmediate      : BOOL) : DWORD;

PROCEDURE GetTapeStatus (hDevice : HANDLE) : DWORD;

TYPE GET_TAPE_PARAMETERS_TYPE = (GET_TAPE_MEDIA_INFORMATION,  (* 0 *)
                                 GET_TAPE_DRIVE_INFORMATION); (* 1 *)

PROCEDURE GetTapeParameters (hDevice           : HANDLE;
                             dwOperation       : GET_TAPE_PARAMETERS_TYPE;
                             VAR Size          : DWORD;
                             lpTapeInformation : PVOID) : DWORD;

(* lpTapeInformation points to TAPE_GET_MEDIA_PARAMETERS or
   TAPE_GET_DRIVE_PARAMETERS structure depending on dwOperation *)

TYPE SET_TAPE_PARAMETERS_TYPE = (SET_TAPE_MEDIA_INFORMATION,  (* 0 *)
                                 SET_TAPE_DRIVE_INFORMATION); (* 1 *)

PROCEDURE SetTapeParameters (hDevice           : HANDLE;
                             dwOperation       : SET_TAPE_PARAMETERS_TYPE;
                             lpTapeInformation : PVOID) : DWORD;

(* lpTapeInformation points to TAPE_SET_MEDIA_PARAMETERS or
   TAPE_SET_DRIVE_PARAMETERS structure depending on dwOperation *)

PROCEDURE Beep (dwFreq : DWORD; dwDuration : DWORD) : BOOL;

PROCEDURE MulDiv (nNumber      : INTEGER;
                  nNumerator   : INTEGER;
                  nDenominator : INTEGER) : INTEGER;

PROCEDURE GetSystemTime (VAR SystemTime : SYSTEMTIME);
PROCEDURE GetSystemTimeAsFileTime (VAR SystemTimeAsFileTime : FILETIME);
<* IF BACKEND # "C" THEN *>
PROCEDURE SetSystemTime (SystemTime : SYSTEMTIME) : BOOL;
<* ELSE *>
PROCEDURE SetSystemTime (SystemTime : PSYSTEMTIME) : BOOL;
<* END *>  (*!*)
PROCEDURE GetLocalTime  (VAR SystemTime : SYSTEMTIME);
<* IF BACKEND # "C" THEN *>
PROCEDURE SetLocalTime  (SystemTime : SYSTEMTIME) : BOOL;
<* ELSE *>
PROCEDURE SetLocalTime  (SystemTime : PSYSTEMTIME) : BOOL;
<* END *>  (*!*)
PROCEDURE GetSystemInfo (VAR SystemInfo : SYSTEM_INFO);

TYPE TIME_ZONE_INFORMATION = RECORD
                                    Bias         : LONG;
                                    StandardName : ARRAY [0..31] OF WCHAR;
                                    StandardDate : SYSTEMTIME;
                                    StandardBias : LONG;
                                    DaylightName : ARRAY [0..31] OF WCHAR;
                                    DaylightDate : SYSTEMTIME;
                                    DaylightBias : LONG;
                             END;
    PTIME_ZONE_INFORMATION = POINTER TO TIME_ZONE_INFORMATION;

<* IF BACKEND # "C" THEN *>
PROCEDURE SystemTimeToTzSpecificLocalTime (
                        TimeZoneInformation : PTIME_ZONE_INFORMATION; (* IN NIL *)
                        UniversalTime : SYSTEMTIME; (*!*)
                        VAR LocalTime : SYSTEMTIME) : BOOL;
<* ELSE *>
PROCEDURE SystemTimeToTzSpecificLocalTime (
                        TimeZoneInformation : PTIME_ZONE_INFORMATION; (* IN NIL *)
                        UniversalTime : PSYSTEMTIME; (*!*)
                        VAR LocalTime : SYSTEMTIME) : BOOL;
<* END *>

PROCEDURE GetTimeZoneInformation
           (VAR TimeZoneInformation : TIME_ZONE_INFORMATION) : DWORD;

<* IF BACKEND # "C" THEN *>
PROCEDURE SetTimeZoneInformation
           (TimeZoneInformation : TIME_ZONE_INFORMATION) : BOOL;
<* ELSE *>
PROCEDURE SetTimeZoneInformation
           (TimeZoneInformation : PTIME_ZONE_INFORMATION) : BOOL;
<* END *>  (*!*)

(*
** Routines to convert back and forth between system time and file time
*)

<* IF BACKEND # "C" THEN *>
PROCEDURE SystemTimeToFileTime (SystemTime  : SYSTEMTIME; (*!*)
                                VAR FileTim : FILETIME) : BOOL;
<* ELSE *>
PROCEDURE SystemTimeToFileTime (SystemTime  : PSYSTEMTIME; (*!*)
                                VAR FileTim : FILETIME) : BOOL;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE FileTimeToLocalFileTime (FileTime          : FILETIME; (*!*)
                                   VAR LocalFileTime : FILETIME) : BOOL;
<* ELSE *>
PROCEDURE FileTimeToLocalFileTime (FileTime          : PFILETIME; (*!*)
                                   VAR LocalFileTime : FILETIME) : BOOL;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE LocalFileTimeToFileTime (LocalFileTime  : FILETIME; (*!*)
                                   VAR lpFileTime : FILETIME) : BOOL;
<* ELSE *>
PROCEDURE LocalFileTimeToFileTime (LocalFileTime  : PFILETIME; (*!*)
                                   VAR lpFileTime : FILETIME) : BOOL;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE FileTimeToSystemTime (FileTime       : FILETIME; (*!*)
                                VAR SystemTime : SYSTEMTIME) : BOOL;
<* ELSE *>
PROCEDURE FileTimeToSystemTime (FileTime       : PFILETIME; (*!*)
                                VAR SystemTime : SYSTEMTIME) : BOOL;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE CompareFileTime (FileTime1, FileTime2 : FILETIME) : LONG;
<* ELSE *>
PROCEDURE CompareFileTime (FileTime1, FileTime2 : PFILETIME) : LONG;
<* END *> (*!*)

<* IF BACKEND # "C" THEN *>
PROCEDURE FileTimeToDosDateTime (FileTime    : FILETIME; (*!*)
                                 VAR FatDate : WORD;
                                 VAR FatTime : WORD) : BOOL;
<* ELSE *>
PROCEDURE FileTimeToDosDateTime (FileTime    : PFILETIME; (*!*)
                                 VAR FatDate : WORD;
                                 VAR FatTime : WORD) : BOOL;
<* END *>

PROCEDURE DosDateTimeToFileTime (wFatDate     : WORD;
                                 wFatTime     : WORD;
                                 VAR FileTime : FILETIME) : BOOL;

PROCEDURE GetTickCount () : DWORD;
CONST GetCurrentTime = GetTickCount;

PROCEDURE SetSystemTimeAdjustment (dwTimeAdjustment        : DWORD;
                                   bTimeAdjustmentDisabled : BOOL) : BOOL;

PROCEDURE GetSystemTimeAdjustment (VAR TimeAdjustment         : DWORD;
                                   VAR TimeIncrement          : DWORD;
                                   VAR TimeAdjustmentDisabled : BOOL) : BOOL;

TYPE FORMAT_MESSAGE_SET = DWORD;
(* was not converted into bitset because small integral constants
   can be used in the low-order byte; so use arithmetic + when combining
   this all together and be careful not to use same flag twice *)

CONST FORMAT_MESSAGE_ALLOCATE_BUFFER = FORMAT_MESSAGE_SET (00000100h);
      FORMAT_MESSAGE_IGNORE_INSERTS  = FORMAT_MESSAGE_SET (00000200h);
      FORMAT_MESSAGE_FROM_STRING     = FORMAT_MESSAGE_SET (00000400h);
      FORMAT_MESSAGE_FROM_HMODULE    = FORMAT_MESSAGE_SET (00000800h);
      FORMAT_MESSAGE_FROM_SYSTEM     = FORMAT_MESSAGE_SET (00001000h);
      FORMAT_MESSAGE_ARGUMENT_ARRAY  = FORMAT_MESSAGE_SET (00002000h);
      FORMAT_MESSAGE_MAX_WIDTH_MASK  = FORMAT_MESSAGE_SET (000000FFh);

PROCEDURE FormatMessageA (dwFlags      : FORMAT_MESSAGE_SET;
                          lpSource     : LPCVOID;
                          dwMessageId  : DWORD;
                          dwLanguageId : DWORD;
                          lpBuffer     : PSTR;
                          nSize        : DWORD;
                          Arguments    : SYSTEM.ADDRESS) : DWORD;

PROCEDURE FormatMessageW (dwFlags      : FORMAT_MESSAGE_SET;
                          lpSource     : LPCVOID;
                          dwMessageId  : DWORD;
                          dwLanguageId : DWORD;
                          lpBuffer     : PWSTR;
                          nSize        : DWORD;
                          Arguments    : SYSTEM.ADDRESS) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST FormatMessage = FormatMessageW;
<* ELSE *>
      CONST FormatMessage = FormatMessageA;
<* END *>

PROCEDURE CreatePipe (VAR hReadPipe    : HANDLE;
                      VAR hWritePipe   : HANDLE;
                      lpPipeAttributes : PSECURITY_ATTRIBUTES; (* IN NIL *)
                      nSize            : DWORD) : BOOL;

PROCEDURE ConnectNamedPipe (hNamedPipe           : HANDLE;
                            VAR [NIL] Overlapped : OVERLAPPED) : BOOL;

PROCEDURE DisconnectNamedPipe (hNamedPipe : HANDLE) : BOOL;

PROCEDURE SetNamedPipeHandleState (hNamedPipe                   : HANDLE;
                                   VAR [NIL] Mode               : PIPE_MODE_SET;
                                   VAR [NIL] MaxCollectionCount : DWORD;
                                   VAR [NIL] CollectDataTimeout : DWORD)
                                                                         : BOOL;

PROCEDURE GetNamedPipeInfo (hNamedPipe                : HANDLE;
                            VAR [NIL] Flags           : PIPE_MODE_SET;
                            VAR [NIL] lpOutBufferSize : DWORD;
                            VAR [NIL] lpInBufferSize  : DWORD;
                            VAR [NIL] lpMaxInstances  : DWORD) : BOOL;

PROCEDURE PeekNamedPipe (hNamedPipe                     : HANDLE;
                         lpBuffer                       : PVOID;
                         nBufferSize                    : DWORD;
                         VAR [NIL] BytesRead            : DWORD;
                         VAR [NIL] TotalBytesAvail      : DWORD;
                         VAR [NIL] BytesLeftThisMessage : DWORD) : BOOL;

PROCEDURE TransactNamedPipe (hNamedPipe           : HANDLE;
                             lpInBuffer           : PVOID;
                             nInBufferSize        : DWORD;
                             lpOutBuffer          : PVOID;
                             nOutBufferSize       : DWORD;
                             VAR lpBytesRead      : DWORD;
                             VAR [NIL] Overlapped : OVERLAPPED) : BOOL;

PROCEDURE CreateMailslotA (Name                 : ARRAY OF CHAR;
                           nMaxMessageSize      : DWORD;
                           lReadTimeout         : DWORD;
                           lpSecurityAttributes : PSECURITY_ATTRIBUTES) (*!*)
                                                                       : HANDLE;

PROCEDURE CreateMailslotW (Name                 : ARRAY OF WCHAR;
                           nMaxMessageSize      : DWORD;
                           lReadTimeout         : DWORD;
                           lpSecurityAttributes : PSECURITY_ATTRIBUTES) (*!*)
                                                                       : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateMailslot = CreateMailslotW;
<* ELSE *>
      CONST CreateMailslot = CreateMailslotA;
<* END *>

PROCEDURE GetMailslotInfo (hMailslot                : HANDLE;
                           VAR [NIL] MaxMessageSize : DWORD;
                           VAR [NIL] NextSize       : DWORD;
                           VAR [NIL] MessageCount   : DWORD;
                           VAR [NIL] ReadTimeout    : DWORD) : BOOL;

PROCEDURE SetMailslotInfo (hMailslot    : HANDLE;
                           lReadTimeout : DWORD) : BOOL;

PROCEDURE MapViewOfFile (hFileMappingObject   : HANDLE;
                         dwDesiredAccess      : ACCESS_MASK;
                         dwFileOffsetHigh     : DWORD;
                         dwFileOffsetLow      : DWORD;
                         dwNumberOfBytesToMap : DWORD) : PVOID;

PROCEDURE FlushViewOfFile (lpBaseAddress          : LPCVOID;
                           dwNumberOfBytesToFlush : DWORD) : BOOL;

PROCEDURE UnmapViewOfFile (lpBaseAddress : LPCVOID) : BOOL;

(*
** _l Compat Functions
*)

(* arguments were not converted to ARRAY OF CHAR for convinience
   of operations with parts of arrays *)

PROCEDURE lstrcmpA (lpString1, lpString2 : PCSTR ) : INTEGER;
PROCEDURE lstrcmpW (lpString1, lpString2 : PCWSTR) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST lstrcmp = lstrcmpW;
<* ELSE *>
      CONST lstrcmp = lstrcmpA;
<* END *>

PROCEDURE lstrcmpiA (String1, String2 : PCSTR ) : INTEGER;
PROCEDURE lstrcmpiW (String1, String2 : PCWSTR) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST lstrcmpi = lstrcmpiW;
<* ELSE *>
      CONST lstrcmpi = lstrcmpiA;
<* END *>

PROCEDURE lstrcpynA (String1 : PSTR;  String2 : PCSTR;  MaxLength : INTEGER) : PSTR;
PROCEDURE lstrcpynW (String1 : PWSTR; String2 : PCWSTR; MaxLength : INTEGER) : PWSTR;

<* IF DEFINED (UNICODE) THEN *>
      CONST lstrcpyn = lstrcpynW;
<* ELSE *>
      CONST lstrcpyn = lstrcpynA;
<* END *>

PROCEDURE lstrcpyA (lpString1 : PSTR;  lpString2 : PCSTR)  : PSTR;
PROCEDURE lstrcpyW (lpString1 : PWSTR; lpString2 : PCWSTR) : PWSTR;

<* IF DEFINED (UNICODE) THEN *>
      CONST lstrcpy = lstrcpyW;
<* ELSE *>
      CONST lstrcpy = lstrcpyA;
<* END *>

PROCEDURE lstrcatA (lpString1 : PSTR;  lpString2 : PCSTR)  : PSTR;
PROCEDURE lstrcatW (lpString1 : PWSTR; lpString2 : PCWSTR) : PWSTR;

<* IF DEFINED (UNICODE) THEN *>
      CONST lstrcat = lstrcatW;
<* ELSE *>
      CONST lstrcat = lstrcatA;
<* END *>

PROCEDURE lstrlenA (lpString : PCSTR ) : INTEGER;
PROCEDURE lstrlenW (lpString : PCWSTR) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST lstrlen = lstrlenW;
<* ELSE *>
      CONST lstrlen = lstrlenA;
<* END *>

PROCEDURE OpenFile (FileName             : ARRAY OF CHAR;
                    VAR [NIL] ReOpenBuff : OFSTRUCT;
                    uStyle               : OF_FLAGS) : HFILE;

PROCEDURE _lopen  (PathName : ARRAY OF CHAR; iReadWrite : OF_FLAGS) : HFILE;
PROCEDURE _lcreat (PathName : ARRAY OF CHAR; iAttribute : OF_FLAGS) : HFILE;
PROCEDURE _lread  (hFile : HFILE; lpBuffer : PVOID; uBytes : UINT) : UINT;
PROCEDURE _lwrite (hFile : HFILE; lpBuffer : PCSTR; uBytes : UINT) : UINT;
PROCEDURE _hread  (hFile : HFILE; lpBuffer : PVOID; lBytes : LONG) : LONG;
PROCEDURE _hwrite (hFile : HFILE; lpBuffer : LPCVOID; lBytes : LONG) : LONG;
PROCEDURE _lclose (hFile : HFILE) : HFILE;
PROCEDURE _llseek (hFile : HFILE; lOffset : LONG; iOrigin : MOVE_TYPE) : LONG;

PROCEDURE IsTextUnicode (lpBuffer : LPCVOID;
                         cb       : INTEGER;
                         lpi      : IS_TEXT_UNICODE_SET) : BOOL;

PROCEDURE TlsAlloc () : DWORD;

CONST TLS_OUT_OF_INDEXES = 0FFFFFFFFh;

PROCEDURE TlsGetValue (dwTlsIndex : DWORD) : PVOID;
PROCEDURE TlsSetValue (dwTlsIndex : DWORD; lpTlsValue : PVOID) : BOOL;
PROCEDURE TlsFree (dwTlsIndex : DWORD) : BOOL;

TYPE POVERLAPPED_COMPLETION_ROUTINE = PROCEDURE (
                (* dwErrorCode : *)               DWORD,
                (* dwNumberOfBytesTransfered : *) DWORD,
                VAR (* Overlapped : *)            OVERLAPPED);

PROCEDURE SleepEx (dwMilliseconds : DWORD; bAlertable : BOOL) : DWORD;

PROCEDURE WaitForSingleObjectEx (hHandle        : HANDLE;
                                 dwMilliseconds : DWORD;
                                 bAlertable     : BOOL) : DWORD;

PROCEDURE WaitForMultipleObjectsEx (nCount         : DWORD;
                                    Handles        : ARRAY OF HANDLE;
                                    bWaitAll       : BOOL;
                                    dwMilliseconds : DWORD;
                                    bAlertable     : BOOL) : DWORD;

PROCEDURE SignalObjectAndWait (hObjectToSignal : HANDLE;
                               hObjectToWaitOn : HANDLE;
                               dwMilliseconds  : DWORD;
                               bAlertable      : BOOL) : DWORD;

PROCEDURE ReadFileEx (hFile                : HANDLE;
                      lpBuffer             : PVOID;
                      nNumberOfBytesToRead : DWORD;
                      VAR Overlapped       : OVERLAPPED;
                      lpCompletionRoutine  : POVERLAPPED_COMPLETION_ROUTINE
                                                                      ) : BOOL;
PROCEDURE WriteFileEx (hFile                 : HANDLE;
                       lpBuffer              : LPCVOID;
                       nNumberOfBytesToWrite : DWORD;
                       VAR Overlapped        : OVERLAPPED;
                       lpCompletionRoutine   : POVERLAPPED_COMPLETION_ROUTINE
                                                                     ) : BOOL;
PROCEDURE BackupRead (hFile                   : HANDLE;
                      lpBuffer                : PBYTE;
                      nNumberOfBytesToRead    : DWORD;
                      VAR lpNumberOfBytesRead : DWORD;
                      bAbort                  : BOOL;
                      bProcessSecurity        : BOOL;
                      VAR lpContext           : PVOID) : BOOL;

PROCEDURE BackupSeek (hFile                : HANDLE;
                      dwLowBytesToSeek     : DWORD;
                      dwHighBytesToSeek    : DWORD;
                      VAR dwLowByteSeeked  : DWORD;
                      VAR dwHighByteSeeked : DWORD;
                      VAR lpContext        : PVOID) : BOOL;

PROCEDURE BackupWrite (hFile                    : HANDLE;
                       lpBuffer                 : PBYTE;
                       nNumberOfBytesToWrite    : DWORD;
                       VAR NumberOfBytesWritten : DWORD;
                       bAbort                   : BOOL;
                       bProcessSecurity         : BOOL;
                       VAR lpContext            : PVOID) : BOOL;

(*
**  Stream Ids
*)

TYPE STREAM_ID = (BACKUP_INVALID,        (* 00000000 *)
                  BACKUP_DATA,           (* 00000001 *)
                  BACKUP_EA_DATA,        (* 00000002 *)
                  BACKUP_SECURITY_DATA,  (* 00000003 *)
                  BACKUP_ALTERNATE_DATA, (* 00000004 *)
                  BACKUP_LINK,           (* 00000005 *)
                  BACKUP_PROPERTY_DATA); (* 00000006 *)

(*
**  Stream Attributes
*)

TYPE STREAM_ATTR_ENUM = (STREAM__MODIFIED_WHEN_READ,   (* 0 *)
                         STREAM__CONTAINS_SECURITY,    (* 1 *)
                         STREAM__CONTAINS_PROPERTIES); (* 2 *)

     STREAM_ATTR_SET = SET OF STREAM_ATTR_ENUM;

CONST STREAM_NORMAL_ATTRIBUTE    = STREAM_ATTR_SET {};                            (* 0x00000000 *)
      STREAM_MODIFIED_WHEN_READ  = STREAM_ATTR_SET {STREAM__MODIFIED_WHEN_READ};  (* 0x00000001 *)
      STREAM_CONTAINS_SECURITY   = STREAM_ATTR_SET {STREAM__CONTAINS_SECURITY};   (* 0x00000002 *)
      STREAM_CONTAINS_PROPERTIES = STREAM_ATTR_SET {STREAM__CONTAINS_PROPERTIES}; (* 0x00000004 *)

(*
**  Stream id structure
*)

TYPE WIN32_STREAM_ID = RECORD
                              dwStreamId         : STREAM_ID;
                              dwStreamAttributes : STREAM_ATTR_SET;
                              Size               : LARGE_INTEGER;
                              dwStreamNameSize   : DWORD;
                              cStreamName        : ARRAY [0..0] OF WCHAR;
                       END;
    PWIN32_STREAM_ID = POINTER TO WIN32_STREAM_ID;

(*
** Dual Mode API below this line. Dual Mode Structures also included.
*)

TYPE STARTF_ENUM = (STARTF__USESHOWWINDOW,    (* 0 *)
                    STARTF__USESIZE,          (* 1 *)
                    STARTF__USEPOSITION,      (* 2 *)
                    STARTF__USECOUNTCHARS,    (* 3 *)
                    STARTF__USEFILLATTRIBUTE, (* 4 *)
                    STARTF__RUNFULLSCREEN,    (* 5 *) (* ignored for non-x86 platforms *)
                    STARTF__FORCEONFEEDBACK,  (* 6 *)
                    STARTF__FORCEOFFFEEDBACK, (* 7 *)
                    STARTF__USESTDHANDLES,    (* 8 *)
                    STARTF__USEHOTKEY);       (* 9 *)

     STARTF_SET = SET OF STARTF_ENUM;

CONST STARTF_USESHOWWINDOW    = STARTF_SET {STARTF__USESHOWWINDOW    }; (* 0x00000001 *)
      STARTF_USESIZE          = STARTF_SET {STARTF__USESIZE          }; (* 0x00000002 *)
      STARTF_USEPOSITION      = STARTF_SET {STARTF__USEPOSITION      }; (* 0x00000004 *)
      STARTF_USECOUNTCHARS    = STARTF_SET {STARTF__USECOUNTCHARS    }; (* 0x00000008 *)
      STARTF_USEFILLATTRIBUTE = STARTF_SET {STARTF__USEFILLATTRIBUTE }; (* 0x00000010 *)
      STARTF_RUNFULLSCREEN    = STARTF_SET {STARTF__RUNFULLSCREEN    }; (* 0x00000020 *)
      STARTF_FORCEONFEEDBACK  = STARTF_SET {STARTF__FORCEONFEEDBACK  }; (* 0x00000040 *)
      STARTF_FORCEOFFFEEDBACK = STARTF_SET {STARTF__FORCEOFFFEEDBACK }; (* 0x00000080 *)
      STARTF_USESTDHANDLES    = STARTF_SET {STARTF__USESTDHANDLES    }; (* 0x00000100 *)
      STARTF_USEHOTKEY        = STARTF_SET {STARTF__USEHOTKEY        }; (* 0x00000200 *)

TYPE STARTUPINFOA = RECORD
                           cb              : DWORD;
                           lpReserved      : PSTR;
                           lpDesktop       : PSTR;
                           lpTitle         : PSTR;
                           dwX             : DWORD;
                           dwY             : DWORD;
                           dwXSize         : DWORD;
                           dwYSize         : DWORD;
                           dwXCountChars   : DWORD;
                           dwYCountChars   : DWORD;
                           dwFillAttribute : DWORD;  (* actually CHAR_ATTRIBUTES_SET from WinCon.def *)
                           dwFlags         : STARTF_SET;
                           wShowWindow     : WORD;   (* actually SW_ENUM *)
                           cbReserved2     : WORD;
                           lpReserved2     : PBYTE;
                           hStdInput       : HANDLE;
                           hStdOutput      : HANDLE;
                           hStdError       : HANDLE;
                    END;
    PSTARTUPINFOA = POINTER TO STARTUPINFOA;

TYPE STARTUPINFOW = RECORD
                           cb              : DWORD;
                           lpReserved      : PWSTR;
                           lpDesktop       : PWSTR;
                           lpTitle         : PWSTR;
                           dwX             : DWORD;
                           dwY             : DWORD;
                           dwXSize         : DWORD;
                           dwYSize         : DWORD;
                           dwXCountChars   : DWORD;
                           dwYCountChars   : DWORD;
                           dwFillAttribute : DWORD;  (* actually CHAR_ATTRIBUTES_SET from WinCon.def *)
                           dwFlags         : STARTF_SET;
                           wShowWindow     : WORD;   (* actually SW_ENUM *)
                           cbReserved2     : WORD;
                           lpReserved2     : PBYTE;
                           hStdInput       : HANDLE;
                           hStdOutput      : HANDLE;
                           hStdError       : HANDLE;
                    END;
    PSTARTUPINFOW = POINTER TO STARTUPINFOW;

<* IF DEFINED (UNICODE) THEN *>
       TYPE  STARTUPINFO =  STARTUPINFOW;
            PSTARTUPINFO = PSTARTUPINFOW;
<* ELSE *>
       TYPE  STARTUPINFO  =  STARTUPINFOA;
            PSTARTUPINFO  = PSTARTUPINFOA;
<* END *>

CONST SHUTDOWN_NORETRY = 1;

TYPE WIN32_FIND_DATAA = RECORD
                               dwFileAttributes   : FILE_ATTRIBUTE_SET;
                               ftCreationTime     : FILETIME;
                               ftLastAccessTime   : FILETIME;
                               ftLastWriteTime    : FILETIME;
                               nFileSizeHigh      : DWORD;
                               nFileSizeLow       : DWORD;
                               dwReserved0        : DWORD;
                               dwReserved1        : DWORD;
                               cFileName          : ARRAY [0..MAX_PATH-1] OF CHAR;
                               cAlternateFileName : ARRAY [0..13] OF CHAR;
                        END;
    PWIN32_FIND_DATAA = POINTER TO WIN32_FIND_DATA;

     WIN32_FIND_DATAW = RECORD
                               dwFileAttributes   : FILE_ATTRIBUTE_SET;
                               ftCreationTime     : FILETIME;
                               ftLastAccessTime   : FILETIME;
                               ftLastWriteTime    : FILETIME;
                               nFileSizeHigh      : DWORD;
                               nFileSizeLow       : DWORD;
                               dwReserved0        : DWORD;
                               dwReserved1        : DWORD;
                               cFileName          : ARRAY [0..MAX_PATH-1] OF WCHAR;
                               cAlternateFileName : ARRAY [0..13] OF WCHAR;
                        END;
    PWIN32_FIND_DATAW = POINTER TO WIN32_FIND_DATAW;

<* IF DEFINED (UNICODE) THEN *>
       TYPE  WIN32_FIND_DATA =  WIN32_FIND_DATAW;
            PWIN32_FIND_DATA = PWIN32_FIND_DATAW;
<* ELSE *>
       TYPE  WIN32_FIND_DATA =  WIN32_FIND_DATAA;
            PWIN32_FIND_DATA = PWIN32_FIND_DATAA;
<* END *>

TYPE WIN32_FILE_ATTRIBUTE_DATA =
     RECORD
          dwFileAttributes : FILE_ATTRIBUTE_SET;
          ftCreationTime : FILETIME;
          ftLastAccessTime : FILETIME;
          ftLastWriteTime : FILETIME;
          nFileSizeHigh : DWORD;
          nFileSizeLow : DWORD;
     END;
     PWIN32_FILE_ATTRIBUTE_DATA = POINTER TO WIN32_FILE_ATTRIBUTE_DATA;

PROCEDURE CreateMutexA (lpMutexAttributes : PSECURITY_ATTRIBUTES;
                        bInitialOwner     : BOOL;
                        lpName            : PCSTR)                    (* IN NIL *)
                                                   : HANDLE;

PROCEDURE CreateMutexW (lpMutexAttributes : PSECURITY_ATTRIBUTES;
                        bInitialOwner     : BOOL;
                        lpName            : PCWSTR)                   (* IN NIL *)
                                                   : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateMutex = CreateMutexW;
<* ELSE *>
      CONST CreateMutex = CreateMutexA;
<* END *>

PROCEDURE OpenMutexA (DesiredAccess  : ACCESS_MASK;
                      bInheritHandle : BOOL;
                      Name           : ARRAY OF CHAR) : HANDLE;

PROCEDURE OpenMutexW (DesiredAccess  : ACCESS_MASK;
                      bInheritHandle : BOOL;
                      Name           : ARRAY OF WCHAR) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST OpenMutex = OpenMutexW;
<* ELSE *>
      CONST OpenMutex = OpenMutexA;
<* END *>

PROCEDURE CreateEventA (lpEventAttributes : PSECURITY_ATTRIBUTES;
                        bManualReset      : BOOL;
                        bInitialState     : BOOL;
                        lpName            : PCSTR)             (* IN NIL *)
                                                   : HANDLE;

PROCEDURE CreateEventW (lpEventAttributes : PSECURITY_ATTRIBUTES;
                        bManualReset      : BOOL;
                        bInitialState     : BOOL;
                        lpName            : PCWSTR)            (* IN NIL *)
                                                    : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateEvent = CreateEventW;
<* ELSE *>
      CONST CreateEvent = CreateEventA;
<* END *>

PROCEDURE OpenEventA (dwDesiredAccess : ACCESS_MASK;
                      bInheritHandle  : BOOL;
                      Name            : ARRAY OF CHAR) : HANDLE;

PROCEDURE OpenEventW (dwDesiredAccess : ACCESS_MASK;
                      bInheritHandle  : BOOL;
                      Name            : ARRAY OF WCHAR) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST OpenEvent = OpenEventW;
<* ELSE *>
      CONST OpenEvent = OpenEventA;
<* END *>

PROCEDURE CreateSemaphoreA (lpSemaphoreAttributes : PSECURITY_ATTRIBUTES;
                           lInitialCount          : LONG;
                           lMaximumCount          : LONG;
                           lpName                 : PCSTR)           (* IN NIL *)
                                                           : HANDLE;

PROCEDURE CreateSemaphoreW (lpSemaphoreAttributes : PSECURITY_ATTRIBUTES;
                            lInitialCount         : LONG;
                            lMaximumCount         : LONG;
                            lpName                : PCWSTR)           (* IN NIL *)
                                                            : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateSemaphore = CreateSemaphoreW;
<* ELSE *>
      CONST CreateSemaphore = CreateSemaphoreA;
<* END *>

PROCEDURE OpenSemaphoreA (dwDesiredAccess : ACCESS_MASK;
                          bInheritHandle  : BOOL;
                          Name            : ARRAY OF CHAR) : HANDLE;

PROCEDURE OpenSemaphoreW (dwDesiredAccess : ACCESS_MASK;
                          bInheritHandle  : BOOL;
                          Name            : ARRAY OF WCHAR) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST OpenSemaphore = OpenSemaphoreW;
<* ELSE *>
      CONST OpenSemaphore = OpenSemaphoreA;
<* END *>

TYPE PTIMERAPCROUTINE = PROCEDURE ((* lpArgToCompletionRoutine : *) PVOID,
                                   (* dwTimerLowValue          : *) DWORD,
                                   (* dwTimerHighValue         : *) DWORD);

PROCEDURE CreateWaitableTimerA (lpTimerAttributes : PSECURITY_ATTRIBUTES;
                                bManualReset      : BOOL;
                                lpTimerName       : PCSTR)           (* IN NIL *)
                                                           : HANDLE;

PROCEDURE CreateWaitableTimerW (lpTimerAttributes : PSECURITY_ATTRIBUTES;
                                bManualReset      : BOOL;
                                lpTimerName       : PCWSTR)           (* IN NIL *)
                                                           : HANDLE;
<* IF DEFINED (UNICODE) THEN *>
      CONST CreateWaitableTimer = CreateWaitableTimerW;
<* ELSE *>
      CONST CreateWaitableTimer = CreateWaitableTimerA;
<* END *>

PROCEDURE OpenWaitableTimerA (dwDesiredAccess : DWORD;
                              bInheritHandle  : BOOL;
                              TimerName       : ARRAY OF CHAR) : HANDLE;

PROCEDURE OpenWaitableTimerW (dwDesiredAccess : DWORD;
                              bInheritHandle  : BOOL;
                              TimerName       : ARRAY OF WCHAR) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST OpenWaitableTimer = OpenWaitableTimerW;
<* ELSE *>
      CONST OpenWaitableTimer = OpenWaitableTimerA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE SetWaitableTimer (hTimer                   : HANDLE;
                            DueTime                  : LARGE_INTEGER; (* IN *)
                            lPeriod                  : LONG;
                            pfnCompletionRoutine     : PTIMERAPCROUTINE;
                            lpArgToCompletionRoutine : PVOID;
                            fResume                  : BOOL) : BOOL;
<* ELSE *>
PROCEDURE SetWaitableTimer (hTimer                   : HANDLE;
                            DueTime                  : PLARGE_INTEGER; (* IN *)
                            lPeriod                  : LONG;
                            pfnCompletionRoutine     : PTIMERAPCROUTINE;
                            lpArgToCompletionRoutine : PVOID;
                            fResume                  : BOOL) : BOOL;
<* END *>

PROCEDURE CancelWaitableTimer (hTimer : HANDLE) : BOOL;

PROCEDURE CreateFileMappingA (hFile                   : HANDLE;
                              lpFileMappingAttributes : PSECURITY_ATTRIBUTES;
                              flProtect               : PROTECT_SET;
                              dwMaximumSizeHigh       : DWORD;
                              dwMaximumSizeLow        : DWORD;
                              lpName                  : PCSTR)           (* IN NIL *)
                                                               : HANDLE;

PROCEDURE CreateFileMappingW (hFile                   : HANDLE;
                              lpFileMappingAttributes : PSECURITY_ATTRIBUTES;
                              flProtect               : PROTECT_SET;
                              dwMaximumSizeHigh       : DWORD;
                              dwMaximumSizeLow        : DWORD;
                              lpName                  : PCWSTR)           (* IN NIL *)
                                                                : HANDLE ;
<* IF DEFINED (UNICODE) THEN *>
      CONST CreateFileMapping = CreateFileMappingW;
<* ELSE *>
      CONST CreateFileMapping = CreateFileMappingA;
<* END *>

PROCEDURE OpenFileMappingA (dwDesiredAccess : ACCESS_MASK;
                            bInheritHandle  : BOOL;
                            Name            : ARRAY OF CHAR) : HANDLE;

PROCEDURE OpenFileMappingW (dwDesiredAccess : ACCESS_MASK;
                            bInheritHandle  : BOOL;
                            Name            : ARRAY OF WCHAR) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST OpenFileMapping = OpenFileMappingW;
<* ELSE *>
      CONST OpenFileMapping = OpenFileMappingA;
<* END *>

PROCEDURE GetLogicalDriveStringsA (nBufferLength : DWORD;
                                   VAR Buffer    : ARRAY OF CHAR) : DWORD;

PROCEDURE GetLogicalDriveStringsW (nBufferLength : DWORD;
                                   VAR Buffer    : ARRAY OF WCHAR) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetLogicalDriveStrings = GetLogicalDriveStringsW;
<* ELSE *>
      CONST GetLogicalDriveStrings = GetLogicalDriveStringsA;
<* END *>

PROCEDURE LoadLibraryA (LibFileName : ARRAY OF CHAR)  : HMODULE;
PROCEDURE LoadLibraryW (LibFileName : ARRAY OF WCHAR) : HMODULE;

<* IF DEFINED (UNICODE) THEN *>
      CONST LoadLibrary = LoadLibraryW;
<* ELSE *>
      CONST LoadLibrary = LoadLibraryA;
<* END *>

TYPE LOAD_LIB_ENUM  = (LLE__0, LLE__1, LLE__2, LLE__3);
     LOAD_LIB_FLAGS = SET OF LOAD_LIB_ENUM;

CONST DONT_RESOLVE_DLL_REFERENCES     = LOAD_LIB_FLAGS {LLE__0}; (* 0x00000001 *)
      LOAD_LIBRARY_AS_DATAFILE        = LOAD_LIB_FLAGS {LLE__1}; (* 0x00000002 *)
      LOAD_WITH_ALTERED_SEARCH_PATH   = LOAD_LIB_FLAGS {LLE__3}; (* 0x00000008 *)

PROCEDURE LoadLibraryExA (LibFileName : ARRAY OF CHAR;
                          hFile       : HANDLE;
                          dwFlags     : LOAD_LIB_FLAGS) : HMODULE;

PROCEDURE LoadLibraryExW (LibFileName : ARRAY OF WCHAR;
                          hFile       : HANDLE;
                          dwFlags     : LOAD_LIB_FLAGS) : HMODULE;

<* IF DEFINED (UNICODE) THEN *>
      CONST LoadLibraryEx = LoadLibraryExW;
<* ELSE *>
      CONST LoadLibraryEx = LoadLibraryExA;
<* END *>

PROCEDURE GetModuleFileNameA (hModule      : HMODULE;
                              VAR Filename : ARRAY OF CHAR;
                              nSize        : DWORD) : DWORD;

PROCEDURE GetModuleFileNameW (hModule      : HMODULE;
                              VAR Filename : ARRAY OF WCHAR;
                              nSize        : DWORD) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetModuleFileName = GetModuleFileNameW;
<* ELSE *>
      CONST GetModuleFileName = GetModuleFileNameA;
<* END *>

PROCEDURE GetModuleHandleA (ModuleName : PCSTR)  : HMODULE; (* NIL *)
PROCEDURE GetModuleHandleW (ModuleName : PCWSTR) : HMODULE; (* NIL *)

<* IF DEFINED (UNICODE) THEN *>
      CONST GetModuleHandle = GetModuleHandleW;
<* ELSE *>
      CONST GetModuleHandle = GetModuleHandleA;
<* END *>

PROCEDURE CreateProcessA (lpApplicationName      : PCSTR; (* IN NIL *)
                          lpCommandLine          : PCSTR; (* IN NIL *)
                          lpProcessAttributes    : PSECURITY_ATTRIBUTES; (* IN NIL *)
                          lpThreadAttributes     : PSECURITY_ATTRIBUTES; (* IN NIL *)
                          bInheritHandles        : BOOL;
                          dwCreationFlags        : CREATE_SET;
                          lpEnvironment          : PVOID;
                          lpCurrentDirectory     : PCSTR; (* IN NIL *)
                          VAR StartupInfo        : STARTUPINFOA; (* IN *)
                          VAR ProcessInformation : PROCESS_INFORMATION) : BOOL;

PROCEDURE CreateProcessW (lpApplicationName      : PCWSTR; (* IN NIL *)
                          lpCommandLine          : PCWSTR; (* IN NIL *)
                          lpProcessAttributes    : PSECURITY_ATTRIBUTES; (* IN NIL *)
                          lpThreadAttributes     : PSECURITY_ATTRIBUTES; (* IN NIL *)
                          bInheritHandles        : BOOL;
                          dwCreationFlags        : CREATE_SET;
                          lpEnvironment          : PVOID;
                          lpCurrentDirectory     : PCWSTR; (* IN NIL *)
                          VAR StartupInfo        : STARTUPINFOW; (* IN *)
                          VAR ProcessInformation : PROCESS_INFORMATION) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateProcess = CreateProcessW;
<* ELSE *>
      CONST CreateProcess = CreateProcessA;
<* END *>

PROCEDURE SetProcessShutdownParameters (dwLevel : DWORD;
                                        dwFlags : DWORD) : BOOL;

PROCEDURE GetProcessShutdownParameters (VAR Level : DWORD;
                                        VAR Flags : DWORD) : BOOL;

PROCEDURE GetProcessVersion (ProcessId : DWORD) : DWORD;
PROCEDURE FatalAppExitA (uAction : UINT; MessageText : ARRAY OF CHAR);
PROCEDURE FatalAppExitW (uAction : UINT; MessageText : ARRAY OF WCHAR);

<* IF DEFINED (UNICODE) THEN *>
      CONST FatalAppExit = FatalAppExitW;
<* ELSE *>
      CONST FatalAppExit = FatalAppExitA;
<* END *>

PROCEDURE GetStartupInfoA (VAR StartupInfo : STARTUPINFOA);
PROCEDURE GetStartupInfoW (VAR StartupInfo : STARTUPINFOW);

<* IF DEFINED (UNICODE) THEN *>
      CONST GetStartupInfo = GetStartupInfoW;
<* ELSE *>
      CONST GetStartupInfo = GetStartupInfoA;
<* END *>

PROCEDURE GetCommandLineA () : PSTR;
PROCEDURE GetCommandLineW () : PWSTR;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetCommandLine = GetCommandLineW;
<* ELSE *>
      CONST GetCommandLine = GetCommandLineA;
<* END *>

PROCEDURE GetEnvironmentVariableA (Name       : ARRAY OF CHAR;
                                   VAR Buffer : ARRAY OF CHAR;
                                   nSize      : DWORD)
                                                       : DWORD;

PROCEDURE GetEnvironmentVariableW (Name       : ARRAY OF WCHAR;
                                   VAR Buffer : ARRAY OF WCHAR;
                                   nSize      : DWORD)
                                                       : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetEnvironmentVariable = GetEnvironmentVariableW;
<* ELSE *>
      CONST GetEnvironmentVariable = GetEnvironmentVariableA;
<* END *>

PROCEDURE SetEnvironmentVariableA (Name  : ARRAY OF CHAR;
                                   Value : ARRAY OF CHAR) : BOOL;

PROCEDURE SetEnvironmentVariableW (Name  : ARRAY OF WCHAR;
                                   Value : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetEnvironmentVariable = SetEnvironmentVariableW;
<* ELSE *>
      CONST SetEnvironmentVariable = SetEnvironmentVariableA;
<* END *>

PROCEDURE ExpandEnvironmentStringsA (Src     : ARRAY OF CHAR;
                                     VAR Dst : ARRAY OF CHAR;
                                     nSize   : DWORD)
                                                      : DWORD;

PROCEDURE ExpandEnvironmentStringsW (Src     : ARRAY OF WCHAR;
                                     VAR Dst : ARRAY OF WCHAR;
                                     nSize   : DWORD)
                                                      : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST ExpandEnvironmentStrings = ExpandEnvironmentStringsW;
<* ELSE *>
      CONST ExpandEnvironmentStrings = ExpandEnvironmentStringsA;
<* END *>

PROCEDURE OutputDebugStringA (OutputString : ARRAY OF CHAR);
PROCEDURE OutputDebugStringW (OutputString : ARRAY OF WCHAR);

<* IF DEFINED (UNICODE) THEN *>
      CONST OutputDebugString = OutputDebugStringW;
<* ELSE *>
      CONST OutputDebugString = OutputDebugStringA;
<* END *>

PROCEDURE FindResourceA (hModule : HMODULE;
                         lpName  : RESOURCESTRA;
                         lpType  : RESOURCESTRA) : HRSRC;

PROCEDURE FindResourceW (hModule : HMODULE;
                         lpName  : RESOURCESTRW;
                         lpType  : RESOURCESTRW) : HRSRC;

<* IF DEFINED (UNICODE) THEN *>
      CONST FindResource = FindResourceW;
<* ELSE *>
      CONST FindResource = FindResourceA;
<* END *>

PROCEDURE FindResourceExA (hModule   : HMODULE;
                           lpType    : RESOURCESTRA;
                           lpName    : RESOURCESTRA;
                           wLanguage : WORD) : HRSRC;

PROCEDURE FindResourceExW (hModule   : HMODULE;
                           lpType    : RESOURCESTRW;
                           lpName    : RESOURCESTRW;
                           wLanguage : WORD) : HRSRC;

<* IF DEFINED (UNICODE) THEN *>
      CONST FindResourceEx = FindResourceExW;
<* ELSE *>
      CONST FindResourceEx = FindResourceExA;
<* END *>

TYPE ENUMRESTYPEPROCA = PROCEDURE ((* hModule : *) HMODULE,
                                   (* lpType  : *) RESOURCESTRA,
                                   (* lParam  : *) LONG) : BOOL;

TYPE ENUMRESTYPEPROCW = PROCEDURE ((* hModule : *) HMODULE,
                                   (* lpType  : *) RESOURCESTRW,
                                   (* lParam  : *) LONG) : BOOL;


TYPE ENUMRESNAMEPROCA = PROCEDURE ((* hModule : *) HMODULE,
                                   (* lpType  : *) RESOURCESTRA,
                                   (* lpName  : *) RESOURCESTRA,
                                   (* lParam  : *) LONG) : BOOL;

TYPE ENUMRESNAMEPROCW = PROCEDURE ((* hModule : *) HMODULE,
                                   (* lpType  : *) RESOURCESTRW,
                                   (* lpName  : *) RESOURCESTRW,
                                   (* lParam  : *) LONG) : BOOL;


TYPE ENUMRESLANGPROCA = PROCEDURE ((* hModule   : *) HMODULE,
                                   (* lpType    : *) RESOURCESTRA,
                                   (* lpName    : *) RESOURCESTRA,
                                   (* wLanguage : *) WORD,
                                   (* lParam    : *) LONG) : BOOL;

TYPE ENUMRESLANGPROCW = PROCEDURE ((* hModule   : *) HMODULE,
                                   (* lpType    : *) RESOURCESTRW,
                                   (* lpName    : *) RESOURCESTRW,
                                   (* wLanguage : *) WORD,
                                   (* lParam    : *) LONG) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      TYPE ENUMRESTYPEPROC = ENUMRESTYPEPROCW;
           ENUMRESNAMEPROC = ENUMRESNAMEPROCW;
           ENUMRESLANGPROC = ENUMRESLANGPROCW;
<* ELSE *>
      TYPE ENUMRESTYPEPROC = ENUMRESTYPEPROCA;
           ENUMRESNAMEPROC = ENUMRESNAMEPROCA;
           ENUMRESLANGPROC = ENUMRESLANGPROCA;
<* END *>

PROCEDURE EnumResourceTypesA (hModule   : HMODULE;
                             lpEnumFunc : ENUMRESTYPEPROCA;
                             lParam     : LONG) : BOOL;

PROCEDURE EnumResourceTypesW (hModule    : HMODULE;
                              lpEnumFunc : ENUMRESTYPEPROCW;
                              lParam     : LONG) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumResourceTypes = EnumResourceTypesW;
<* ELSE *>
      CONST EnumResourceTypes = EnumResourceTypesA;
<* END *>

PROCEDURE EnumResourceNamesA (hModule    : HMODULE;
                              lpType     : RESOURCESTRA;
                              lpEnumFunc : ENUMRESNAMEPROCA;
                              lParam     : LONG) : BOOL;

PROCEDURE EnumResourceNamesW (hModule    : HMODULE;
                              lpType     : RESOURCESTRW;
                              lpEnumFunc : ENUMRESNAMEPROCW;
                              lParam     : LONG) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumResourceNames = EnumResourceNamesW;
<* ELSE *>
      CONST EnumResourceNames = EnumResourceNamesA;
<* END *>

PROCEDURE EnumResourceLanguagesA (hModule    : HMODULE;
                                  lpType     : RESOURCESTRA;
                                  lpName     : RESOURCESTRA;
                                  lpEnumFunc : ENUMRESLANGPROCA;
                                  lParam     : LONG) : BOOL;

PROCEDURE EnumResourceLanguagesW (hModule    : HMODULE;
                                  lpType     : RESOURCESTRW;
                                  lpName     : RESOURCESTRW;
                                  lpEnumFunc : ENUMRESLANGPROCW;
                                  lParam     : LONG) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumResourceLanguages = EnumResourceLanguagesW;
<* ELSE *>
      CONST EnumResourceLanguages = EnumResourceLanguagesA;
<* END *>

PROCEDURE BeginUpdateResourceA (FileName                 : ARRAY OF CHAR;
                                bDeleteExistingResources : BOOL)
                                                                 : HANDLE;

PROCEDURE BeginUpdateResourceW (FileName                 : ARRAY OF WCHAR;
                                bDeleteExistingResources : BOOL)
                                                                 : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST BeginUpdateResource = BeginUpdateResourceW;
<* ELSE *>
      CONST BeginUpdateResource = BeginUpdateResourceA;
<* END *>

PROCEDURE UpdateResourceA (hUpdate   : HANDLE;
                           lpType    : RESOURCESTRA;
                           lpName    : RESOURCESTRA;
                           wLanguage : WORD;
                           lpData    : PVOID;
                           cbData    : DWORD) : BOOL;

PROCEDURE UpdateResourceW (hUpdate   : HANDLE;
                           lpType    : RESOURCESTRW;
                           lpName    : RESOURCESTRW;
                           wLanguage : WORD;
                           lpData    : PVOID;
                           cbData    : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST UpdateResource = UpdateResourceW;
<* ELSE *>
      CONST UpdateResource = UpdateResourceA;
<* END *>

PROCEDURE EndUpdateResourceA (hUpdate  : HANDLE;
                              fDiscard : BOOL) : BOOL;

PROCEDURE EndUpdateResourceW (hUpdate  : HANDLE;
                              fDiscard : BOOL) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EndUpdateResource = EndUpdateResourceW;
<* ELSE *>
      CONST EndUpdateResource = EndUpdateResourceA;
<* END *>

PROCEDURE GlobalAddAtomA (String : ARRAY OF CHAR)  : ATOM;
PROCEDURE GlobalAddAtomW (String : ARRAY OF WCHAR) : ATOM;

<* IF DEFINED (UNICODE) THEN *>
      CONST GlobalAddAtom = GlobalAddAtomW;
<* ELSE *>
      CONST GlobalAddAtom = GlobalAddAtomA;
<* END *>

PROCEDURE GlobalFindAtomA (String : ARRAY OF CHAR)  : ATOM;
PROCEDURE GlobalFindAtomW (String : ARRAY OF WCHAR) : ATOM;

<* IF DEFINED (UNICODE) THEN *>
      CONST GlobalFindAtom = GlobalFindAtomW;
<* ELSE *>
      CONST GlobalFindAtom = GlobalFindAtomA;
<* END *>

PROCEDURE GlobalGetAtomNameA (nAtom      : ATOM;
                              VAR Buffer : ARRAY OF CHAR;
                              nSize      : INTEGER)
                                                    : UINT;

PROCEDURE GlobalGetAtomNameW (nAtom      : ATOM;
                              VAR Buffer : ARRAY OF WCHAR;
                              nSize      : INTEGER)
                                                    : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST GlobalGetAtomName = GlobalGetAtomNameW;
<* ELSE *>
      CONST GlobalGetAtomName = GlobalGetAtomNameA;
<* END *>

PROCEDURE AddAtomA (String : ARRAY OF CHAR)  : ATOM;
PROCEDURE AddAtomW (String : ARRAY OF WCHAR) : ATOM;

<* IF DEFINED (UNICODE) THEN *>
      CONST AddAtom = AddAtomW;
<* ELSE *>
      CONST AddAtom = AddAtomA;
<* END *>

PROCEDURE FindAtomA (String : ARRAY OF CHAR)  : ATOM;
PROCEDURE FindAtomW (String : ARRAY OF WCHAR) : ATOM;

<* IF DEFINED (UNICODE) THEN *>
      CONST FindAtom = FindAtomW;
<* ELSE *>
      CONST FindAtom = FindAtomA;
<* END *>

PROCEDURE GetAtomNameA (nAtom      : ATOM;
                        VAR Buffer : ARRAY OF CHAR;
                        nSize      : INTEGER)
                                              : UINT;

PROCEDURE GetAtomNameW (nAtom      : ATOM;
                        VAR Buffer : ARRAY OF WCHAR;
                        nSize      : INTEGER)
                                              : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetAtomName = GetAtomNameW;
<* ELSE *>
      CONST GetAtomName = GetAtomNameA;
<* END *>

PROCEDURE GetProfileIntA (AppName  : ARRAY OF CHAR;
                          KeyName  : ARRAY OF CHAR;
                          nDefault : INTEGER)
                                               : UINT;

PROCEDURE GetProfileIntW (AppName  : ARRAY OF WCHAR;
                          KeyName  : ARRAY OF WCHAR;
                          nDefault : INTEGER)
                                              : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetProfileInt = GetProfileIntW;
<* ELSE *>
      CONST GetProfileInt = GetProfileIntA;
<* END *>

PROCEDURE GetProfileStringA (AppName            : ARRAY OF CHAR;
                             KeyName            : ARRAY OF CHAR;
                             Default            : ARRAY OF CHAR;
                             VAR ReturnedString : ARRAY OF CHAR;
                             nSize              : DWORD)
                                                         : DWORD;

PROCEDURE GetProfileStringW (AppName            : ARRAY OF WCHAR;
                             KeyName            : ARRAY OF WCHAR;
                             Default            : ARRAY OF WCHAR;
                             VAR ReturnedString : ARRAY OF WCHAR;
                             nSize              : DWORD)
                                                         : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetProfileString = GetProfileStringW;
<* ELSE *>
      CONST GetProfileString = GetProfileStringA;
<* END *>

PROCEDURE WriteProfileStringA (AppName : ARRAY OF CHAR;
                               KeyName : ARRAY OF CHAR;
                               String  : ARRAY OF CHAR) : BOOL;

PROCEDURE WriteProfileStringW (AppName : ARRAY OF WCHAR;
                               KeyName : ARRAY OF WCHAR;
                               String  : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST WriteProfileString = WriteProfileStringW;
<* ELSE *>
      CONST WriteProfileString = WriteProfileStringA;
<* END *>

PROCEDURE GetProfileSectionA (AppName            : ARRAY OF CHAR;
                              VAR ReturnedString : ARRAY OF CHAR;
                              nSize              : DWORD) : DWORD;

PROCEDURE GetProfileSectionW (AppName            : ARRAY OF WCHAR;
                              VAR ReturnedString : ARRAY OF WCHAR;
                              nSize              : DWORD) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetProfileSection = GetProfileSectionW;
<* ELSE *>
      CONST GetProfileSection = GetProfileSectionA;
<* END *>

PROCEDURE WriteProfileSectionA (AppName : ARRAY OF CHAR;
                                String  : ARRAY OF CHAR)  : BOOL;

PROCEDURE WriteProfileSectionW (AppName : ARRAY OF WCHAR;
                                String  : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST WriteProfileSection = WriteProfileSectionW;
<* ELSE *>
      CONST WriteProfileSection = WriteProfileSectionA;
<* END *>

PROCEDURE GetPrivateProfileIntA (AppName  : ARRAY OF CHAR;
                                 KeyName  : ARRAY OF CHAR;
                                 nDefault : INTEGER;
                                 FileName : ARRAY OF CHAR) : UINT;

PROCEDURE GetPrivateProfileIntW (AppName  : ARRAY OF WCHAR;
                                 KeyName  : ARRAY OF WCHAR;
                                 nDefault : INTEGER;
                                 FileName : ARRAY OF WCHAR) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetPrivateProfileInt = GetPrivateProfileIntW;
<* ELSE *>
      CONST GetPrivateProfileInt = GetPrivateProfileIntA;
<* END *>

PROCEDURE GetPrivateProfileStringA (AppName            : ARRAY OF CHAR;
                                    KeyName            : ARRAY OF CHAR;
                                    Default            : ARRAY OF CHAR;
                                    VAR ReturnedString : ARRAY OF CHAR;
                                    nSize              : DWORD;
                                    FileName           : ARRAY OF CHAR) : DWORD;

PROCEDURE GetPrivateProfileStringW (AppName            : ARRAY OF WCHAR;
                                    KeyName            : ARRAY OF WCHAR;
                                    Default            : ARRAY OF WCHAR;
                                    VAR ReturnedString : ARRAY OF WCHAR;
                                    nSize              : DWORD;
                                    FileName           : ARRAY OF WCHAR) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetPrivateProfileString = GetPrivateProfileStringW;
<* ELSE *>
      CONST GetPrivateProfileString = GetPrivateProfileStringA;
<* END *>

PROCEDURE WritePrivateProfileStringA (AppName  : ARRAY OF CHAR;
                                      KeyName  : ARRAY OF CHAR;
                                      String   : ARRAY OF CHAR;
                                      FileName : ARRAY OF CHAR) : BOOL;

PROCEDURE WritePrivateProfileStringW (AppName  : ARRAY OF WCHAR;
                                      KeyName  : ARRAY OF WCHAR;
                                      String   : ARRAY OF WCHAR;
                                      FileName : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST WritePrivateProfileString = WritePrivateProfileStringW;
<* ELSE *>
      CONST WritePrivateProfileString = WritePrivateProfileStringA;
<* END *>

PROCEDURE GetPrivateProfileSectionA (AppName            : ARRAY OF CHAR;
                                     VAR ReturnedString : ARRAY OF CHAR;
                                     nSize              : DWORD;
                                     FileName           : ARRAY OF CHAR) : DWORD;

PROCEDURE GetPrivateProfileSectionW (AppName            : ARRAY OF WCHAR;
                                     VAR ReturnedString : ARRAY OF WCHAR;
                                     nSize              : DWORD;
                                     FileName           : ARRAY OF WCHAR) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetPrivateProfileSection = GetPrivateProfileSectionW;
<* ELSE *>
      CONST GetPrivateProfileSection = GetPrivateProfileSectionA;
<* END *>

PROCEDURE WritePrivateProfileSectionA (AppName  : ARRAY OF CHAR;
                                       String   : ARRAY OF CHAR;
                                       FileName : ARRAY OF CHAR) : BOOL;

PROCEDURE WritePrivateProfileSectionW (AppName  : ARRAY OF WCHAR;
                                       String   : ARRAY OF WCHAR;
                                       FileName : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST WritePrivateProfileSection = WritePrivateProfileSectionW;
<* ELSE *>
      CONST WritePrivateProfileSection = WritePrivateProfileSectionA;
<* END *>

PROCEDURE GetPrivateProfileSectionNamesA (VAR ReturnBuffer : ARRAY OF CHAR;
                                          nSize            : DWORD;
                                          FileName         : ARRAY OF CHAR) : DWORD;

PROCEDURE GetPrivateProfileSectionNamesW (VAR ReturnBuffer : ARRAY OF WCHAR;
                                          nSize            : DWORD;
                                          lpFileName       : ARRAY OF WCHAR) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetPrivateProfileSectionNames = GetPrivateProfileSectionNamesW;
<* ELSE *>
      CONST GetPrivateProfileSectionNames = GetPrivateProfileSectionNamesA;
<* END *>

PROCEDURE GetPrivateProfileStructA (Section     : ARRAY OF CHAR;
                                    Key         : ARRAY OF CHAR;
                                    lpStruct    : PVOID;
                                    uSizeStruct : UINT;
                                    File        : ARRAY OF CHAR) : BOOL;

PROCEDURE GetPrivateProfileStructW (Section     : ARRAY OF WCHAR;
                                    Key         : ARRAY OF WCHAR;
                                    lpStruct    : PVOID;
                                    uSizeStruct : UINT;
                                    File        : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetPrivateProfileStruct = GetPrivateProfileStructW;
<* ELSE *>
      CONST GetPrivateProfileStruct = GetPrivateProfileStructA;
<* END *>

PROCEDURE WritePrivateProfileStructA (Section     : ARRAY OF CHAR;
                                      Key         : ARRAY OF CHAR;
                                      lpStruct    : PVOID;
                                      uSizeStruct : UINT;
                                      File        : ARRAY OF CHAR) : BOOL;

PROCEDURE WritePrivateProfileStructW (Section     : ARRAY OF WCHAR;
                                      Key         : ARRAY OF WCHAR;
                                      lpStruct    : PVOID;
                                      uSizeStruct : UINT;
                                      File        : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST WritePrivateProfileStruct = WritePrivateProfileStructW;
<* ELSE *>
      CONST WritePrivateProfileStruct = WritePrivateProfileStructA;
<* END *>

PROCEDURE GetDriveTypeA (lpRootPathName : PCSTR)  : DRIVE_TYPE; (* IN NIL *)
PROCEDURE GetDriveTypeW (lpRootPathName : PCWSTR) : DRIVE_TYPE; (* IN NIL *)

<* IF DEFINED (UNICODE) THEN *>
      CONST GetDriveType = GetDriveTypeW;
<* ELSE *>
      CONST GetDriveType = GetDriveTypeA;
<* END *>

PROCEDURE GetSystemDirectoryA (VAR Buffer : ARRAY OF CHAR;  uSize : UINT) : UINT;
PROCEDURE GetSystemDirectoryW (VAR Buffer : ARRAY OF WCHAR; uSize : UINT) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetSystemDirectory = GetSystemDirectoryW;
<* ELSE *>
      CONST GetSystemDirectory = GetSystemDirectoryA;
<* END *>

PROCEDURE GetTempPathA (nBufferLength : DWORD; VAR Buffer : ARRAY OF CHAR)  : DWORD;
PROCEDURE GetTempPathW (nBufferLength : DWORD; VAR Buffer : ARRAY OF WCHAR) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetTempPath = GetTempPathW;
<* ELSE *>
      CONST GetTempPath = GetTempPathA;
<* END *>

PROCEDURE GetTempFileNameA (PathName         : ARRAY OF CHAR;
                            PrefixString     : ARRAY OF CHAR;
                            uUnique          : UINT;
                            VAR TempFileName : ARRAY OF CHAR) : UINT;

PROCEDURE GetTempFileNameW (PathName         : ARRAY OF WCHAR;
                            PrefixString     : ARRAY OF WCHAR;
                            uUnique          : UINT;
                            VAR TempFileName : ARRAY OF WCHAR) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetTempFileName = GetTempFileNameW;
<* ELSE *>
      CONST GetTempFileName = GetTempFileNameA;
<* END *>

PROCEDURE GetWindowsDirectoryA (VAR Buffer : ARRAY OF CHAR;  uSize : UINT) : UINT;
PROCEDURE GetWindowsDirectoryW (VAR Buffer : ARRAY OF WCHAR; uSize : UINT) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetWindowsDirectory = GetWindowsDirectoryW;
<* ELSE *>
      CONST GetWindowsDirectory = GetWindowsDirectoryA;
<* END *>

PROCEDURE SetCurrentDirectoryA (PathName : ARRAY OF CHAR)  : BOOL;
PROCEDURE SetCurrentDirectoryW (PathName : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetCurrentDirectory = SetCurrentDirectoryW;
<* ELSE *>
      CONST SetCurrentDirectory = SetCurrentDirectoryA;
<* END *>

PROCEDURE GetCurrentDirectoryA (nBufferLength : DWORD; VAR Buffer : ARRAY OF CHAR)  : DWORD;
PROCEDURE GetCurrentDirectoryW (nBufferLength : DWORD; VAR Buffer : ARRAY OF WCHAR) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetCurrentDirectory = GetCurrentDirectoryW;
<* ELSE *>
      CONST GetCurrentDirectory = GetCurrentDirectoryA;
<* END *>

PROCEDURE GetDiskFreeSpaceA (lpRootPathName            : PCSTR; (* IN NIL *)
                             VAR SectorsPerCluster     : DWORD;
                             VAR BytesPerSector        : DWORD;
                             VAR NumberOfFreeClusters  : DWORD;
                             VAR TotalNumberOfClusters : DWORD) : BOOL;

PROCEDURE GetDiskFreeSpaceW (lpRootPathName            : PCWSTR; (* IN NIL *)
                             VAR SectorsPerCluster     : DWORD;
                             VAR BytesPerSector        : DWORD;
                             VAR NumberOfFreeClusters  : DWORD;
                             VAR TotalNumberOfClusters : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetDiskFreeSpace = GetDiskFreeSpaceW;
<* ELSE *>
      CONST GetDiskFreeSpace = GetDiskFreeSpaceA;
<* END *>

PROCEDURE GetDiskFreeSpaceExA (DirectoryName                    : PCSTR;          (* IN NIL *)
                               VAR lpFreeBytesAvailableToCaller : ULARGE_INTEGER;
                               VAR lpTotalNumberOfBytes         : ULARGE_INTEGER;
                               VAR lpTotalNumberOfFreeBytes     : ULARGE_INTEGER) : BOOL;

PROCEDURE GetDiskFreeSpaceExW (DirectoryName                    : PCWSTR;         (* IN NIL *)
                               VAR lpFreeBytesAvailableToCaller : ULARGE_INTEGER;
                               VAR lpTotalNumberOfBytes         : ULARGE_INTEGER;
                               VAR lpTotalNumberOfFreeBytes     : ULARGE_INTEGER) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetDiskFreeSpaceEx = GetDiskFreeSpaceExW;
<* ELSE *>
      CONST GetDiskFreeSpaceEx = GetDiskFreeSpaceExA;
<* END *>

PROCEDURE CreateDirectoryA (PathName             : ARRAY OF CHAR;
                            lpSecurityAttributes : PSECURITY_ATTRIBUTES) : BOOL;

PROCEDURE CreateDirectoryW (lpPathName           : ARRAY OF WCHAR;
                            lpSecurityAttributes : PSECURITY_ATTRIBUTES) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateDirectory = CreateDirectoryW;
<* ELSE *>
      CONST CreateDirectory = CreateDirectoryA;
<* END *>

PROCEDURE CreateDirectoryExA (TemplateDirectory    : ARRAY OF CHAR;
                              NewDirectory         : ARRAY OF CHAR;
                              lpSecurityAttributes : PSECURITY_ATTRIBUTES) : BOOL;

PROCEDURE CreateDirectoryExW (TemplateDirectory    : ARRAY OF WCHAR;
                              NewDirectory         : ARRAY OF WCHAR;
                              lpSecurityAttributes : PSECURITY_ATTRIBUTES) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateDirectoryEx = CreateDirectoryExW;
<* ELSE *>
      CONST CreateDirectoryEx = CreateDirectoryExA;
<* END *>

PROCEDURE RemoveDirectoryA (PathName : ARRAY OF CHAR)  : BOOL;
PROCEDURE RemoveDirectoryW (PathName : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST RemoveDirectory = RemoveDirectoryW;
<* ELSE *>
      CONST RemoveDirectory = RemoveDirectoryA;
<* END *>

PROCEDURE GetFullPathNameA (FileName       : ARRAY OF CHAR;
                            nBufferLength  : DWORD;
                            VAR Buffer     : ARRAY OF CHAR;
                            VAR lpFilePart : PSTR)
                                                   : DWORD;

PROCEDURE GetFullPathNameW (FileName       : ARRAY OF WCHAR;
                            nBufferLength  : DWORD;
                            VAR Buffer     : ARRAY OF WCHAR;
                            VAR lpFilePart : PWSTR)
                                                    : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetFullPathName = GetFullPathNameW;
<* ELSE *>
      CONST GetFullPathName = GetFullPathNameA;
<* END *>


TYPE DDD_ENUM = (DDD__RAW_TARGET_PATH,        (* 0 *)
                 DDD__REMOVE_DEFINITION,      (* 1 *)
                 DDD__EXACT_MATCH_ON_REMOVE,  (* 2 *)
                 DDD__NO_BROADCAST_SYSTEM);   (* 3 *)

     DDD_SET = SET OF DDD_ENUM;

CONST DDD_RAW_TARGET_PATH       = DDD_SET {DDD__RAW_TARGET_PATH};       (* 0x00000001 *)
      DDD_REMOVE_DEFINITION     = DDD_SET {DDD__REMOVE_DEFINITION};     (* 0x00000002 *)
      DDD_EXACT_MATCH_ON_REMOVE = DDD_SET {DDD__EXACT_MATCH_ON_REMOVE}; (* 0x00000004 *)
      DDD_NO_BROADCAST_SYSTEM   = DDD_SET {DDD__NO_BROADCAST_SYSTEM};   (* 0x00000008 *)

PROCEDURE DefineDosDeviceA (dwFlags      : DDD_SET;
                            lpDeviceName : ARRAY OF CHAR;
                            lpTargetPath : ARRAY OF CHAR) : BOOL;

PROCEDURE DefineDosDeviceW (dwFlags      : DDD_SET;
                            lpDeviceName : ARRAY OF WCHAR;
                            lpTargetPath : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST DefineDosDevice = DefineDosDeviceW;
<* ELSE *>
      CONST DefineDosDevice = DefineDosDeviceA;
<* END *>

PROCEDURE QueryDosDeviceA (DeviceName     : ARRAY OF CHAR;
                           VAR TargetPath : ARRAY OF CHAR;
                           ucchMax        : DWORD)
                                                   : DWORD;

PROCEDURE QueryDosDeviceW (DeviceName     : ARRAY OF WCHAR;
                           VAR TargetPath : ARRAY OF WCHAR;
                           ucchMax        : DWORD)
                                                   : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST QueryDosDevice = QueryDosDeviceW;
<* ELSE *>
      CONST QueryDosDevice = QueryDosDeviceA;
<* END *>

PROCEDURE CreateFileA (FileName              : ARRAY OF CHAR;
                       dwDesiredAccess       : ACCESS_MASK;
                       dwShareMode           : FILE_SHARE_MODE;
                       lpSecurityAttributes  : PSECURITY_ATTRIBUTES;
                       dwCreationDisposition : CREATION_DISTRIBUTION;
                       dwFlagsAndAttributes  : FILE_BIT_SET;
                       hTemplateFile         : HANDLE
                                                      ) : HANDLE;

PROCEDURE CreateFileW (lpFileName            : ARRAY OF WCHAR;
                       dwDesiredAccess       : ACCESS_MASK;
                       dwShareMode           : FILE_SHARE_MODE;
                       lpSecurityAttributes  : PSECURITY_ATTRIBUTES;
                       dwCreationDisposition : CREATION_DISTRIBUTION;
                       dwFlagsAndAttributes  : FILE_BIT_SET;
                       hTemplateFile         : HANDLE
                                                      ) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateFile = CreateFileW;
<* ELSE *>
      CONST CreateFile = CreateFileA;
<* END *>

PROCEDURE SetFileAttributesA (lpFileName       : ARRAY OF CHAR;
                              dwFileAttributes : FILE_ATTRIBUTE_SET) : BOOL;

PROCEDURE SetFileAttributesW (lpFileName       : ARRAY OF WCHAR;
                              dwFileAttributes : FILE_ATTRIBUTE_SET) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetFileAttributes = SetFileAttributesW;
<* ELSE *>
      CONST SetFileAttributes = SetFileAttributesA;
<* END *>

PROCEDURE GetFileAttributesA (FileName : ARRAY OF CHAR)  : DWORD;
PROCEDURE GetFileAttributesW (FileName : ARRAY OF WCHAR) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetFileAttributes = GetFileAttributesW;
<* ELSE *>
      CONST GetFileAttributes = GetFileAttributesA;
<* END *>

TYPE GET_FILEEX_INFO_LEVELS = (GetFileExInfoStandard,
                               GetFileExMaxInfoLevel);

PROCEDURE GetFileAttributesExA (FileName          : ARRAY OF CHAR;
                                fInfoLevelId      : GET_FILEEX_INFO_LEVELS;
                                lpFileInformation : PVOID)
                                                           : BOOL;

PROCEDURE GetFileAttributesExW (FileName          : ARRAY OF WCHAR;
                                fInfoLevelId      : GET_FILEEX_INFO_LEVELS;
                                lpFileInformation : PVOID)
                                                           : BOOL;
<* IF DEFINED (UNICODE) THEN *>
      CONST GetFileAttributesEx = GetFileAttributesExW;
<* ELSE *>
      CONST GetFileAttributesEx = GetFileAttributesExA;
<* END *>

PROCEDURE GetCompressedFileSizeA (FileName               : ARRAY OF CHAR;
                                  VAR [NIL] FileSizeHigh : DWORD)
                                                                  : DWORD;

PROCEDURE GetCompressedFileSizeW (FileName               : ARRAY OF WCHAR;
                                  VAR [NIL] FileSizeHigh : DWORD)
                                                                   : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetCompressedFileSize = GetCompressedFileSizeW;
<* ELSE *>
      CONST GetCompressedFileSize = GetCompressedFileSizeA;
<* END *>

PROCEDURE DeleteFileA (FileName : ARRAY OF CHAR)  : BOOL;
PROCEDURE DeleteFileW (FileName : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST DeleteFile = DeleteFileW;
<* ELSE *>
      CONST DeleteFile = DeleteFileA;
<* END *>

TYPE FINDEX_INFO_LEVELS = (FindExInfoStandard,
                           FindExInfoMaxInfoLevel);

TYPE FINDEX_SEARCH_OPS = (FindExSearchNameMatch,
                          FindExSearchLimitToDirectories,
                          FindExSearchLimitToDevices,
                          FindExSearchMaxSearchOp);

CONST FIND_FIRST_EX_CASE_SENSITIVE = 1;

PROCEDURE FindFirstFileExA (FileName          : ARRAY OF CHAR;
                            fInfoLevelId      : FINDEX_INFO_LEVELS;
                            lpFindFileData    : PVOID;
                            fSearchOp         : FINDEX_SEARCH_OPS;
                            lpSearchFilter    : PVOID;
                            dwAdditionalFlags : DWORD) : HANDLE;

PROCEDURE FindFirstFileExW (FileName          : ARRAY OF WCHAR;
                            fInfoLevelId      : FINDEX_INFO_LEVELS;
                            lpFindFileData    : PVOID;
                            fSearchOp         : FINDEX_SEARCH_OPS;
                            lpSearchFilter    : PVOID;
                            dwAdditionalFlags : DWORD) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST FindFirstFileEx = FindFirstFileExW;
<* ELSE *>
      CONST FindFirstFileEx = FindFirstFileExA;
<* END *>

PROCEDURE FindFirstFileA (FileName         : ARRAY OF CHAR;
                          VAR FindFileData : WIN32_FIND_DATAA) : HANDLE;

PROCEDURE FindFirstFileW (FileName         : ARRAY OF WCHAR;
                          VAR FindFileData : WIN32_FIND_DATAW) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST FindFirstFile = FindFirstFileW;
<* ELSE *>
      CONST FindFirstFile = FindFirstFileA;
<* END *>

PROCEDURE FindNextFileA (hFindFile        : HANDLE;
                         VAR FindFileData : WIN32_FIND_DATAA) : BOOL;

PROCEDURE FindNextFileW (hFindFile        : HANDLE;
                         VAR FindFileData : WIN32_FIND_DATAW) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST FindNextFile = FindNextFileW;
<* ELSE *>
      CONST FindNextFile = FindNextFileA;
<* END *>

PROCEDURE SearchPathA (Path           : PCSTR;
                       FileName       : ARRAY OF CHAR;
                       Extension      : PCSTR;
                       nBufferLength  : DWORD;
                       VAR Buffer     : ARRAY OF CHAR;
                       VAR lpFilePart : PSTR)
                                              : DWORD;

PROCEDURE SearchPathW (Path           : PCSTR;
                       FileName       : ARRAY OF WCHAR;
                       Extension      : PCWSTR;
                       nBufferLength  : DWORD;
                       VAR Buffer     : ARRAY OF WCHAR;
                       VAR lpFilePart : PWSTR)
                                               : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST SearchPath = SearchPathW;
<* ELSE *>
      CONST SearchPath = SearchPathA;
<* END *>

PROCEDURE CopyFileA (ExistingFileName : ARRAY OF CHAR;
                     NewFileName      : ARRAY OF CHAR;
                     bFailIfExists    : BOOL)
                                              : BOOL;

PROCEDURE CopyFileW (ExistingFileName : ARRAY OF WCHAR;
                     NewFileName      : ARRAY OF WCHAR;
                     bFailIfExists    : BOOL)
                                              : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST CopyFile = CopyFileW;
<* ELSE *>
      CONST CopyFile = CopyFileA;
<* END *>

(* Attention!
   Orinnally this callback function took LARGE_INTEGER parameters.
   For example, originally two firstparameters were declared as
       (* TotalFileSize          : *) LARGE_INTEGER,
       (* TotalBytesTransferred  : *) LARGE_INTEGER
   Unfortunately, XDS Modula-2 does not support structures being
   passed by value to STACALL functions.
   So pair of parameters, high and low parts, provided instead of each
   LARGE_INTEGER. The STDCALL calling convention ensures that LARGE_INTEGER
   structure passed by the system will be received properly by callback
   function
*)

TYPE LPPROGRESS_ROUTINE = PROCEDURE ((* TotalFileSizeLow           : *) DWORD,
                                     (* TotalFileSizeHigh          : *) DWORD,
                                     (* TotalBytesTransferredLow   : *) DWORD,
                                     (* TotalBytesTransferredHigh  : *) DWORD,
                                     (* StreamSizeLow              : *) DWORD,
                                     (* StreamSizeHigh             : *) DWORD,
                                     (* StreamBytesTransferredLow  : *) DWORD,
                                     (* StreamBytesTransferredHigh : *) DWORD,
                                     (* dwStreamNumber             : *) DWORD,
                                     (* dwCallbackReason           : *) COPYFILEEX_CALLBACK_ENUM,
                                     (* hSourceFile                : *) HANDLE,
                                     (* hDestinationFile           : *) HANDLE,
                                     (* lpData                     : *) PVOID) : PROGRESS_ENUM;

PROCEDURE CopyFileExA (ExistingFileName  : ARRAY OF CHAR;
                       NewFileName       : ARRAY OF CHAR;
                       lpProgressRoutine : LPPROGRESS_ROUTINE;
                       lpData            : PVOID;
                       VAR pbCancel      : BOOL;
                       dwCopyFlags       : COPY_FILE_SET) : BOOL;

PROCEDURE CopyFileExW (ExistingFileName  : ARRAY OF WCHAR;
                       NewFileName       : ARRAY OF WCHAR;
                       lpProgressRoutine : LPPROGRESS_ROUTINE;
                       lpData            : PVOID;
                       VAR pbCancel      : BOOL;
                       dwCopyFlags       : COPY_FILE_SET) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST CopyFileEx = CopyFileExW;
<* ELSE *>
      CONST CopyFileEx = CopyFileExA;
<* END *>

PROCEDURE MoveFileA (ExistingFileName : ARRAY OF CHAR;
                     NewFileName      : ARRAY OF CHAR) : BOOL;

PROCEDURE MoveFileW (ExistingFileName : ARRAY OF WCHAR;
                     NewFileName      : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST MoveFile = MoveFileW;
<* ELSE *>
      CONST MoveFile = MoveFileA;
<* END *>

TYPE MOVEFILE_ENUM = (MOVEFILE__REPLACE_EXISTING,    (* 0 *)
                      MOVEFILE__COPY_ALLOWED,        (* 1 *)
                      MOVEFILE__DELAY_UNTIL_REBOOT,  (* 2 *)
                      MOVEFILE__WRITE_THROUGH);      (* 3 *)

     MOVEFILE_SET = SET OF MOVEFILE_ENUM;


CONST MOVEFILE_REPLACE_EXISTING   = MOVEFILE_SET {MOVEFILE__REPLACE_EXISTING  }; (* 0x00000001 *)
      MOVEFILE_COPY_ALLOWED       = MOVEFILE_SET {MOVEFILE__COPY_ALLOWED      }; (* 0x00000002 *)
      MOVEFILE_DELAY_UNTIL_REBOOT = MOVEFILE_SET {MOVEFILE__DELAY_UNTIL_REBOOT}; (* 0x00000004 *)
      MOVEFILE_WRITE_THROUGH      = MOVEFILE_SET {MOVEFILE__WRITE_THROUGH     }; (* 0x00000008 *)

PROCEDURE MoveFileExA (ExistingFileName : ARRAY OF CHAR;
                       NewFileName      : ARRAY OF CHAR;
                       dwFlags          : MOVEFILE_SET) : BOOL;

PROCEDURE MoveFileExW (ExistingFileName : ARRAY OF WCHAR;
                       NewFileName      : ARRAY OF WCHAR;
                       dwFlags          : MOVEFILE_SET) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST MoveFileEx = MoveFileExW;
<* ELSE *>
      CONST MoveFileEx = MoveFileExA;
<* END *>

PROCEDURE CreateNamedPipeA (Name                 : ARRAY OF CHAR;
                            dwOpenMode           : FILE_BIT_SET;
                            dwPipeMode           : PIPE_MODE_SET;
                            nMaxInstances        : DWORD;
                            nOutBufferSize       : DWORD;
                            nInBufferSize        : DWORD;
                            nDefaultTimeOut      : DWORD;
                            lpSecurityAttributes : PSECURITY_ATTRIBUTES
                ) : HANDLE;

PROCEDURE CreateNamedPipeW (Name                 : ARRAY OF WCHAR;
                            dwOpenMode           : FILE_BIT_SET;
                            dwPipeMode           : PIPE_MODE_SET;
                            nMaxInstances        : DWORD;
                            nOutBufferSize       : DWORD;
                            nInBufferSize        : DWORD;
                            nDefaultTimeOut      : DWORD;
                            lpSecurityAttributes : PSECURITY_ATTRIBUTES
                ) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateNamedPipe = CreateNamedPipeW;
<* ELSE *>
      CONST CreateNamedPipe = CreateNamedPipeA;
<* END *>

PROCEDURE GetNamedPipeHandleStateA (hNamedPipe                   : HANDLE;
                                    VAR [NIL] State              : PIPE_MODE_SET;
                                    VAR [NIL] CurInstances       : DWORD;
                                    VAR [NIL] MaxCollectionCount : DWORD;
                                    VAR [NIL] CollectDataTimeout : DWORD;
                                    VAR [NIL] UserName           : ARRAY OF CHAR;
                                    nMaxUserNameSize             : DWORD) : BOOL;

PROCEDURE GetNamedPipeHandleStateW (hNamedPipe                   : HANDLE;
                                    VAR [NIL] State              : PIPE_MODE_SET;
                                    VAR [NIL] CurInstances       : DWORD;
                                    VAR [NIL] MaxCollectionCount : DWORD;
                                    VAR [NIL] CollectDataTimeout : DWORD;
                                    VAR [NIL] UserName           : ARRAY OF WCHAR;
                                    nMaxUserNameSize             : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetNamedPipeHandleState = GetNamedPipeHandleStateW;
<* ELSE *>
      CONST GetNamedPipeHandleState = GetNamedPipeHandleStateA;
<* END *>

PROCEDURE CallNamedPipeA (lpNamedPipeName : ARRAY OF CHAR;
                          lpInBuffer      : PVOID;
                          nInBufferSize   : DWORD;
                          lpOutBuffer     : PVOID;
                          nOutBufferSize  : DWORD;
                          VAR lpBytesRead : DWORD;
                          nTimeOut        : DWORD) : BOOL;

PROCEDURE CallNamedPipeW (lpNamedPipeName : ARRAY OF WCHAR;
                          lpInBuffer      : PVOID;
                          nInBufferSize   : DWORD;
                          lpOutBuffer     : PVOID;
                          nOutBufferSize  : DWORD;
                          VAR lpBytesRead : DWORD;
                          nTimeOut        : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST CallNamedPipe = CallNamedPipeW;
<* ELSE *>
      CONST CallNamedPipe = CallNamedPipeA;
<* END *>

PROCEDURE WaitNamedPipeA (NamedPipeName : ARRAY OF CHAR;
                          nTimeOut      : DWORD) : BOOL;

PROCEDURE WaitNamedPipeW (NamedPipeName : ARRAY OF WCHAR;
                          nTimeOut      : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST WaitNamedPipe = WaitNamedPipeW;
<* ELSE *>
      CONST WaitNamedPipe = WaitNamedPipeA;
<* END *>

PROCEDURE SetVolumeLabelA (lpRootPathName : PCSTR;          (* IN NIL *)
                           lpVolumeName   : PCSTR) : BOOL;  (* IN NIL *)

PROCEDURE SetVolumeLabelW (lpRootPathName : PCWSTR;         (* IN NIL *)
                           lpVolumeName   : PCWSTR) : BOOL; (* IN NIL *)

<* IF DEFINED (UNICODE) THEN *>
      CONST SetVolumeLabel = SetVolumeLabelW;
<* ELSE *>
      CONST SetVolumeLabel = SetVolumeLabelA;
<* END *>

PROCEDURE SetFileApisToOEM;
PROCEDURE SetFileApisToANSI;
PROCEDURE AreFileApisANSI () : BOOL;

PROCEDURE GetVolumeInformationA (lpRootPathName               : PCSTR; (* IN NIL *)
                                 VAR VolumeNameBuffer         : ARRAY OF CHAR;
                                 nVolumeNameSize              : DWORD;
                                 VAR [NIL] VolumeSerialNumber : DWORD;
                                 VAR MaximumComponentLength   : DWORD;
                                 VAR FileSystemFlags          : FILESYSTEM_FLAGS;
                                 VAR FileSystemNameBuffer     : ARRAY OF CHAR;
                                 nFileSystemNameSize          : DWORD) : BOOL;

PROCEDURE GetVolumeInformationW (lpRootPathName               : PCWSTR; (* IN NIL *)
                                 VAR VolumeNameBuffer         : ARRAY OF WCHAR;
                                 nVolumeNameSize              : DWORD;
                                 VAR [NIL] VolumeSerialNumber : DWORD;
                                 VAR MaximumComponentLength   : DWORD;
                                 VAR FileSystemFlags          : FILESYSTEM_FLAGS;
                                 VAR FileSystemNameBuffe      : ARRAY OF WCHAR;
                                 nFileSystemNameSize          : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetVolumeInformation = GetVolumeInformationW;
<* ELSE *>
      CONST GetVolumeInformation = GetVolumeInformationA;
<* END *>

PROCEDURE CancelIo (hFile : HANDLE) : BOOL;

(*
** Event logging APIs
*)

PROCEDURE ClearEventLogA (hEventLog        : HANDLE;
                          lpBackupFileName : PCSTR) : BOOL;  (* IN NIL *)

PROCEDURE ClearEventLogW (hEventLog        : HANDLE;
                          lpBackupFileName : PCWSTR) : BOOL; (* IN NIL *)

<* IF DEFINED (UNICODE) THEN *>
      CONST ClearEventLog = ClearEventLogW;
<* ELSE *>
      CONST ClearEventLog = ClearEventLogA;
<* END *>

PROCEDURE BackupEventLogA (hEventLog        : HANDLE;
                           lpBackupFileName : ARRAY OF CHAR) : BOOL;

PROCEDURE BackupEventLogW (hEventLog        : HANDLE;
                           lpBackupFileName : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST BackupEventLog = BackupEventLogW;
<* ELSE *>
      CONST BackupEventLog = BackupEventLogA;
<* END *>

PROCEDURE CloseEventLog (hEventLog : HANDLE) : BOOL;
PROCEDURE DeregisterEventSource (hEventLog : HANDLE) : BOOL;

PROCEDURE NotifyChangeEventLog (hEventLog : HANDLE;
                                hEvent    : HANDLE) : BOOL;

PROCEDURE GetNumberOfEventLogRecords (hEventLog           : HANDLE;
                                      VAR NumberOfRecords : DWORD) : BOOL;

PROCEDURE GetOldestEventLogRecord (hEventLog : HANDLE;
                                   VAR OldestRecord : DWORD) : BOOL;

PROCEDURE OpenEventLogA (lpUNCServerName : PCSTR; (* IN NIL *)
                         SourceName      : ARRAY OF CHAR) : HANDLE;

PROCEDURE OpenEventLogW (lpUNCServerName : PCWSTR; (* IN NIL *)
                         lpSourceName    : ARRAY OF WCHAR) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST OpenEventLog = OpenEventLogW;
<* ELSE *>
      CONST OpenEventLog = OpenEventLogA;
<* END *>

PROCEDURE RegisterEventSourceA (lpUNCServerName : PCSTR; (* NIL *)
                                lpSourceName    : ARRAY OF CHAR) : HANDLE;

PROCEDURE RegisterEventSourceW (lpUNCServerName : PCWSTR; (* NIL *)
                                lpSourceName    : ARRAY OF WCHAR) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegisterEventSource = RegisterEventSourceW;
<* ELSE *>
      CONST RegisterEventSource = RegisterEventSourceA;
<* END *>

PROCEDURE OpenBackupEventLogA (lpUNCServerName : PCSTR;  (* NIL *)
                               lpFileName      : ARRAY OF CHAR) : HANDLE;

PROCEDURE OpenBackupEventLogW (lpUNCServerName : PCWSTR;  (* NIL *)
                               lpFileName      : ARRAY OF WCHAR) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST OpenBackupEventLog = OpenBackupEventLogW;
<* ELSE *>
      CONST OpenBackupEventLog = OpenBackupEventLogA;
<* END *>

PROCEDURE ReadEventLogA (hEventLog                  : HANDLE;
                         dwReadFlags                : EVENTLOG_READ_SET;
                         dwRecordOffset             : DWORD;
                         lpBuffer                   : PVOID;
                         nNumberOfBytesToRead       : DWORD;
                         VAR BytesRead              : DWORD;
                         VAR MinNumberOfBytesNeeded : DWORD) : BOOL;

PROCEDURE ReadEventLogW (hEventLog                  : HANDLE;
                         dwReadFlags                : EVENTLOG_READ_SET;
                         dwRecordOffset             : DWORD;
                         lpBuffer                   : PVOID;
                         nNumberOfBytesToRead       : DWORD;
                         VAR BytesRead              : DWORD;
                         VAR MinNumberOfBytesNeeded : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ReadEventLog = ReadEventLogW;
<* ELSE *>
      CONST ReadEventLog = ReadEventLogA;
<* END *>

PROCEDURE ReportEventA (hEventLog   : HANDLE;
                        wType       : EVENTLOG_TYPE;
                        wCategory   : WORD;
                        dwEventID   : DWORD;
                        lpUserSid   : PSID;
                        wNumStrings : WORD;
                        dwDataSize  : DWORD;
                        Strings     : ARRAY OF PCSTR;
                        lpRawData   : PVOID)
                                             : BOOL;

PROCEDURE ReportEventW (hEventLog   : HANDLE;
                        wType       : EVENTLOG_TYPE;
                        wCategory   : WORD;
                        dwEventID   : DWORD;
                        lpUserSid   : PSID;
                        wNumStrings : WORD;
                        dwDataSize  : DWORD;
                        Strings     : ARRAY OF PCWSTR;
                        lpRawData   : PVOID)
                                             : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ReportEvent = ReportEventW;
<* ELSE *>
      CONST ReportEvent = ReportEventA;
<* END *>

(*
** Security APIs
*)

PROCEDURE DuplicateToken (ExistingTokenHandle      : HANDLE;
                          ImpersonationLevel       : SECURITY_IMPERSONATION_LEVEL;
                          VAR DuplicateTokenHandle : HANDLE) : BOOL;

PROCEDURE GetKernelObjectSecurity (Handle               : HANDLE;
                                   RequestedInformation : SECURITY_INFORMATION;
                                   pSecurityDescriptor  : PSECURITY_DESCRIPTOR;
                                   nLength              : DWORD;
                                   VAR lpnLengthNeeded  : DWORD) : BOOL;

PROCEDURE ImpersonateNamedPipeClient (hNamedPipe : HANDLE) : BOOL;
PROCEDURE ImpersonateSelf (ImpersonationLevel : SECURITY_IMPERSONATION_LEVEL) : BOOL;
PROCEDURE RevertToSelf () : BOOL;
PROCEDURE SetThreadToken (VAR [NIL] Thread : HANDLE;         (* IN *)
                          Token            : HANDLE) : BOOL;

<* IF BACKEND # "C" THEN *>
PROCEDURE AccessCheck (pSecurityDescriptor    : PSECURITY_DESCRIPTOR;
                       ClientToken            : HANDLE;
                       DesiredAccess          : ACCESS_MASK;
                       GenericMapping         : GENERIC_MAPPING; (*!*)
                       VAR PrivilegeSet       : PRIVILEGE_SET;   (*!*)
                       VAR PrivilegeSetLength : DWORD;
                       VAR GrantedAccess      : ACCESS_MASK;
                       VAR AccessStatus       : BOOL)
                                                      : BOOL;
<* ELSE *>
PROCEDURE AccessCheck (pSecurityDescriptor    : PSECURITY_DESCRIPTOR;
                       ClientToken            : HANDLE;
                       DesiredAccess          : ACCESS_MASK;
                       GenericMapping         : PGENERIC_MAPPING; (*!*)
                       VAR PrivilegeSet       : PRIVILEGE_SET;   (*!*)
                       VAR PrivilegeSetLength : DWORD;
                       VAR GrantedAccess      : ACCESS_MASK;
                       VAR AccessStatus       : BOOL)
                                                      : BOOL;
<* END *>

PROCEDURE OpenProcessToken (ProcessHandle   : HANDLE;
                            DesiredAccess   : ACCESS_MASK;
                            VAR TokenHandle : HANDLE) : BOOL;

PROCEDURE OpenThreadToken (ThreadHandle    : HANDLE;
                           DesiredAccess   : ACCESS_MASK;
                           OpenAsSelf      : BOOL;
                           VAR TokenHandle : HANDLE) : BOOL;

PROCEDURE GetTokenInformation (TokenHandle            : HANDLE;
                               TokenInformationClass  : TOKEN_INFORMATION_CLASS;
                               TokenInformation       : PVOID;
                               TokenInformationLength : DWORD;
                               VAR ReturnLength       : DWORD) : BOOL;

PROCEDURE SetTokenInformation (TokenHandle            : HANDLE;
                               TokenInformationClass  : TOKEN_INFORMATION_CLASS;
                               TokenInformation       : PVOID;
                               TokenInformationLength : DWORD)
                                                               : BOOL;

PROCEDURE AdjustTokenPrivileges (TokenHandle             : HANDLE;
                                 DisableAllPrivileges    : BOOL;
                                 VAR [NIL] NewState      : TOKEN_PRIVILEGES;
                                 BufferLength            : DWORD;
                                 VAR [NIL] PreviousState : TOKEN_PRIVILEGES;
                                 VAR [NIL] ReturnLength  : DWORD)
                                                                  : BOOL;

PROCEDURE AdjustTokenGroups (TokenHandle             : HANDLE;
                             ResetToDefault          : BOOL;
                             VAR [NIL] NewState      : TOKEN_GROUPS;
                             BufferLength            : DWORD;
                             VAR [NIL] PreviousState : TOKEN_GROUPS;
                             VAR [NIL] ReturnLength  : DWORD) : BOOL;

PROCEDURE PrivilegeCheck (ClientToken            : HANDLE;
                          VAR RequiredPrivileges : PRIVILEGE_SET;
                          VAR Result             : BOOL)
                                                         : BOOL;

<* IF BACKEND # "C" THEN *>
PROCEDURE AccessCheckAndAuditAlarmA (SubsystemName      : ARRAY OF CHAR;
                                     HandleId           : PVOID;
                                     ObjectTypeName     : ARRAY OF CHAR;
                                     ObjectName         : ARRAY OF CHAR;
                                     SecurityDescriptor : PSECURITY_DESCRIPTOR;
                                     DesiredAccess      : ACCESS_MASK;
                                     GenericMapping     : GENERIC_MAPPING; (*!*)
                                     ObjectCreation     : BOOL;
                                     VAR GrantedAccess  : ACCESS_MASK;
                                     VAR AccessStatus   : BOOL;
                                     VAR GenerateOnClose: BOOL) : BOOL;
<* ELSE *>
PROCEDURE AccessCheckAndAuditAlarmA (SubsystemName      : ARRAY OF CHAR;
                                     HandleId           : PVOID;
                                     ObjectTypeName     : ARRAY OF CHAR;
                                     ObjectName         : ARRAY OF CHAR;
                                     SecurityDescriptor : PSECURITY_DESCRIPTOR;
                                     DesiredAccess      : ACCESS_MASK;
                                     GenericMapping     : PGENERIC_MAPPING; (*!*)
                                     ObjectCreation     : BOOL;
                                     VAR GrantedAccess  : ACCESS_MASK;
                                     VAR AccessStatus   : BOOL;
                                     VAR GenerateOnClose: BOOL) : BOOL;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE AccessCheckAndAuditAlarmW (SubsystemName      : ARRAY OF WCHAR;
                                     HandleId           : PVOID;
                                     ObjectTypeName     : ARRAY OF WCHAR;
                                     ObjectName         : ARRAY OF WCHAR;
                                     SecurityDescriptor : PSECURITY_DESCRIPTOR;
                                     DesiredAccess      : ACCESS_MASK;
                                     GenericMapping     : GENERIC_MAPPING; (*!*)
                                     ObjectCreation     : BOOL;
                                     VAR GrantedAccess  : ACCESS_MASK;
                                     VAR AccessStatus   : BOOL;
                                     VAR GenerateOnClose: BOOL) : BOOL;
<* ELSE *>
PROCEDURE AccessCheckAndAuditAlarmW (SubsystemName      : ARRAY OF WCHAR;
                                     HandleId           : PVOID;
                                     ObjectTypeName     : ARRAY OF WCHAR;
                                     ObjectName         : ARRAY OF WCHAR;
                                     SecurityDescriptor : PSECURITY_DESCRIPTOR;
                                     DesiredAccess      : ACCESS_MASK;
                                     GenericMapping     : PGENERIC_MAPPING; (*!*)
                                     ObjectCreation     : BOOL;
                                     VAR GrantedAccess  : ACCESS_MASK;
                                     VAR AccessStatus   : BOOL;
                                     VAR GenerateOnClose: BOOL) : BOOL;
<* END *>

<* IF DEFINED (UNICODE) THEN *>
      CONST AccessCheckAndAuditAlarm = AccessCheckAndAuditAlarmW;
<* ELSE *>
      CONST AccessCheckAndAuditAlarm = AccessCheckAndAuditAlarmA;
<* END *>

PROCEDURE ObjectOpenAuditAlarmA (SubsystemName       : ARRAY OF CHAR;
                                 HandleId            : PVOID;
                                 ObjectTypeName      : ARRAY OF CHAR;
                                 ObjectName          : ARRAY OF CHAR;
                                 pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                 ClientToken         : HANDLE;
                                 DesiredAccess       : ACCESS_MASK;
                                 GrantedAccess       : ACCESS_MASK;
                                 Privileges          : PPRIVILEGE_SET; (* IN NIL *)
                                 ObjectCreation      : BOOL;
                                 AccessGranted       : BOOL;
                                 VAR GenerateOnClose : BOOL) : BOOL;

PROCEDURE ObjectOpenAuditAlarmW (SubsystemName       : ARRAY OF WCHAR;
                                 HandleId            : PVOID;
                                 ObjectTypeName      : ARRAY OF WCHAR;
                                 ObjectName          : ARRAY OF WCHAR;
                                 pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                 ClientToken         : HANDLE;
                                 DesiredAccess       : ACCESS_MASK;
                                 GrantedAccess       : ACCESS_MASK;
                                 Privileges          : PPRIVILEGE_SET; (* IN NIL *)
                                 ObjectCreation      : BOOL;
                                 AccessGranted       : BOOL;
                                 VAR GenerateOnClose : BOOL) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ObjectOpenAuditAlarm = ObjectOpenAuditAlarmW;
<* ELSE *>
      CONST ObjectOpenAuditAlarm = ObjectOpenAuditAlarmA;
<* END *>

PROCEDURE ObjectPrivilegeAuditAlarmA (SubsystemName : ARRAY OF CHAR;
                                      HandleId      : PVOID;
                                      ClientToken   : HANDLE;
                                      DesiredAccess : ACCESS_MASK;
                                      Privileges    : PPRIVILEGE_SET; (* IN NIL *)
                                      AccessGranted : BOOL) : BOOL;

PROCEDURE ObjectPrivilegeAuditAlarmW (SubsystemName : ARRAY OF WCHAR;
                                      HandleId      : PVOID;
                                      ClientToken   : HANDLE;
                                      DesiredAccess : ACCESS_MASK;
                                      Privileges    : PPRIVILEGE_SET; (* IN NIL *)
                                      AccessGranted : BOOL) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ObjectPrivilegeAuditAlarm = ObjectPrivilegeAuditAlarmW;
<* ELSE *>
      CONST ObjectPrivilegeAuditAlarm = ObjectPrivilegeAuditAlarmA;
<* END *>

PROCEDURE ObjectCloseAuditAlarmA (SubsystemName   : ARRAY OF CHAR;
                                  HandleId        : PVOID;
                                  GenerateOnClose : BOOL) : BOOL;

PROCEDURE ObjectCloseAuditAlarmW (SubsystemName   : ARRAY OF WCHAR;
                                  HandleId        : PVOID;
                                  GenerateOnClose : BOOL) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ObjectCloseAuditAlarm = ObjectCloseAuditAlarmW;
<* ELSE *>
      CONST ObjectCloseAuditAlarm = ObjectCloseAuditAlarmA;
<* END *>

PROCEDURE ObjectDeleteAuditAlarmA (SubsystemName   : ARRAY OF CHAR;
                                   HandleId        : PVOID;
                                   GenerateOnClose : BOOL) : BOOL;

PROCEDURE ObjectDeleteAuditAlarmW (SubsystemName   : ARRAY OF WCHAR;
                                   HandleId        : PVOID;
                                   GenerateOnClose : BOOL) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ObjectDeleteAuditAlarm = ObjectDeleteAuditAlarmW;
<* ELSE *>
      CONST ObjectDeleteAuditAlarm = ObjectDeleteAuditAlarmA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE PrivilegedServiceAuditAlarmA (SubsystemName : ARRAY OF CHAR;
                                        ServiceName   : ARRAY OF CHAR;
                                        ClientToken   : HANDLE;
                                        Privileges    : PRIVILEGE_SET; (*!*)
                                        AccessGranted : BOOL) : BOOL;
<* ELSE *>
PROCEDURE PrivilegedServiceAuditAlarmA (SubsystemName : ARRAY OF CHAR;
                                        ServiceName   : ARRAY OF CHAR;
                                        ClientToken   : HANDLE;
                                        Privileges    : PPRIVILEGE_SET; (*!*)
                                        AccessGranted : BOOL) : BOOL;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE PrivilegedServiceAuditAlarmW (SubsystemName : ARRAY OF WCHAR;
                                        ServiceName   : ARRAY OF WCHAR;
                                        ClientToken   : HANDLE;
                                        Privileges    : PRIVILEGE_SET; (*!*)
                                        AccessGranted : BOOL) : BOOL;
<* ELSE *>
PROCEDURE PrivilegedServiceAuditAlarmW (SubsystemName : ARRAY OF WCHAR;
                                        ServiceName   : ARRAY OF WCHAR;
                                        ClientToken   : HANDLE;
                                        Privileges    : PPRIVILEGE_SET; (*!*)
                                        AccessGranted : BOOL) : BOOL;
<* END *>

<* IF DEFINED (UNICODE) THEN *>
      CONST PrivilegedServiceAuditAlarm = PrivilegedServiceAuditAlarmW;
<* ELSE *>
      CONST PrivilegedServiceAuditAlarm = PrivilegedServiceAuditAlarmA;
<* END *>

PROCEDURE IsValidSid (pSid : PSID) : BOOL;
PROCEDURE EqualSid (pSid1, pSid2 : PSID) : BOOL;
PROCEDURE EqualPrefixSid (pSid1, pSid2 : PSID) : BOOL;
PROCEDURE GetSidLengthRequired (nSubAuthorityCount : CARD8) : DWORD;

<* IF BACKEND # "C" THEN *>
PROCEDURE AllocateAndInitializeSid (IdentifierAuthority : SID_IDENTIFIER_AUTHORITY; (*!*)
                                    nSubAuthorityCount  : CARD8;
                                    nSubAuthority0      : DWORD;
                                    nSubAuthority1      : DWORD;
                                    nSubAuthority2      : DWORD;
                                    nSubAuthority3      : DWORD;
                                    nSubAuthority4      : DWORD;
                                    nSubAuthority5      : DWORD;
                                    nSubAuthority6      : DWORD;
                                    nSubAuthority7      : DWORD;
                                    VAR pSid            : PSID) : BOOL;
<* ELSE *>
PROCEDURE AllocateAndInitializeSid (IdentifierAuthority : PSID_IDENTIFIER_AUTHORITY; (*!*)
                                    nSubAuthorityCount  : CARD8;
                                    nSubAuthority0      : DWORD;
                                    nSubAuthority1      : DWORD;
                                    nSubAuthority2      : DWORD;
                                    nSubAuthority3      : DWORD;
                                    nSubAuthority4      : DWORD;
                                    nSubAuthority5      : DWORD;
                                    nSubAuthority6      : DWORD;
                                    nSubAuthority7      : DWORD;
                                    VAR pSid            : PSID) : BOOL;
<* END *>

PROCEDURE FreeSid (pSid : PSID) : PVOID;

<* IF BACKEND # "C" THEN *>
PROCEDURE InitializeSid (Sid                 : PSID;
                         IdentifierAuthority : SID_IDENTIFIER_AUTHORITY; (*!*)
                         nSubAuthorityCount  : CARD8) : BOOL;
<* ELSE *>
PROCEDURE InitializeSid (Sid                 : PSID;
                         IdentifierAuthority : PSID_IDENTIFIER_AUTHORITY; (*!*)
                         nSubAuthorityCount  : CARD8) : BOOL;
<* END *>
PROCEDURE GetSidIdentifierAuthority (pSid : PSID) : PSID_IDENTIFIER_AUTHORITY;
PROCEDURE GetSidSubAuthority (pSid : PSID; nSubAuthority : DWORD) : PDWORD;
PROCEDURE GetSidSubAuthorityCount (pSid : PSID) : PCARD8;
PROCEDURE GetLengthSid (pSid : PSID) : DWORD;
PROCEDURE CopySid (nDestinationSidLength : DWORD;
                   pDestinationSid       : PSID;
                   pSourceSid            : PSID) : BOOL;

PROCEDURE AreAllAccessesGranted (GrantedAccess, DesiredAccess : ACCESS_MASK) : BOOL;
PROCEDURE AreAnyAccessesGranted (GrantedAccess, DesiredAccess : ACCESS_MASK) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE MapGenericMask (VAR AccessMask : ACCESS_MASK;
                          GenericMapping : GENERIC_MAPPING);
<* ELSE *>
PROCEDURE MapGenericMask (VAR AccessMask : ACCESS_MASK;
                          GenericMapping : PGENERIC_MAPPING);
<* END *> (*!*)

PROCEDURE IsValidAcl (VAR Acl : ACL) : BOOL;

PROCEDURE InitializeAcl (VAR Acl       : ACL;
                         nAclLength    : DWORD;
                         dwAclRevision : DWORD) : BOOL;

<* IF BACKEND # "C" THEN *>
PROCEDURE GetAclInformation (Acl                   : ACL; (*!*)
                             pAclInformation       : PVOID;
                             nAclInformationLength : DWORD;
                             dwAclInformationClass : ACL_INFORMATION_CLASS) : BOOL;
<* ELSE *>
PROCEDURE GetAclInformation (Acl                   : PACL; (*!*)
                             pAclInformation       : PVOID;
                             nAclInformationLength : DWORD;
                             dwAclInformationClass : ACL_INFORMATION_CLASS) : BOOL;
<* END *>

PROCEDURE SetAclInformation (VAR Acl               : ACL; (*!*)
                             pAclInformation       : PVOID;
                             nAclInformationLength : DWORD;
                             dwAclInformationClass : ACL_INFORMATION_CLASS) : BOOL;


PROCEDURE AddAce (VAR Acl            : ACL;
                  dwAceRevision      : DWORD;
                  dwStartingAceIndex : DWORD;
                  pAceList           : PVOID;
                  nAceListLength     : DWORD) : BOOL;

PROCEDURE DeleteAce (VAR Acl : ACL; dwAceIndex : DWORD) : BOOL;

PROCEDURE GetAce (VAR Acl    : ACL;
                  dwAceIndex : DWORD;
                  VAR Ace    : PVOID) : BOOL;

PROCEDURE AddAccessAllowedAce (VAR Acl       : ACL;
                               dwAceRevision : DWORD;
                               AccessMask    : ACCESS_MASK;
                               pSid          : PSID) : BOOL;

PROCEDURE AddAccessDeniedAce (VAR Acl       : ACL;
                              dwAceRevision : DWORD;
                              AccessMask    : ACCESS_MASK;
                              pSid          : PSID) : BOOL;

PROCEDURE AddAuditAccessAce (VAR pAcl      : ACL;
                             dwAceRevision : DWORD;
                             dwAccessMask  : ACCESS_MASK;
                             pSid          : PSID;
                             bAuditSuccess : BOOL;
                             bAuditFailure : BOOL) : BOOL;

PROCEDURE FindFirstFreeAce (VAR Acl : ACL; VAR pAce : PVOID) : BOOL;

PROCEDURE InitializeSecurityDescriptor (pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                        dwRevision : DWORD) : BOOL;

PROCEDURE IsValidSecurityDescriptor    (pSecurityDescriptor : PSECURITY_DESCRIPTOR) : BOOL;
PROCEDURE GetSecurityDescriptorLength  (pSecurityDescriptor : PSECURITY_DESCRIPTOR) : DWORD;
PROCEDURE GetSecurityDescriptorControl (pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                        VAR Control         : SECURITY_DESCRIPTOR_CONTROL;
                                        VAR dwRevision      : DWORD) : BOOL;

PROCEDURE SetSecurityDescriptorDacl (pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                     bDaclPresent        : BOOL;
                                     VAR [NIL] Dacl      : ACL;
                                     bDaclDefaulted      : BOOL) : BOOL;

PROCEDURE GetSecurityDescriptorDacl (pSecurityDescriptor  : PSECURITY_DESCRIPTOR;
                                     VAR bDaclPresent     : BOOL;
                                     VAR pDacl            : PACL;
                                     VAR lpbDaclDefaulted : BOOL) : BOOL;

PROCEDURE SetSecurityDescriptorSacl (pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                     bSaclPresent        : BOOL;
                                     VAR [NIL] Sacl      : ACL;
                                     bSaclDefaulted      : BOOL) : BOOL;

PROCEDURE GetSecurityDescriptorSacl (pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                     VAR lpbSaclPresent  : BOOL;
                                     VAR pSacl           : PACL;
                                     VAR bSaclDefaulted  : BOOL) : BOOL;

PROCEDURE SetSecurityDescriptorOwner (pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                      pOwner              : PSID;
                                      bOwnerDefaulted     : BOOL) : BOOL;

PROCEDURE GetSecurityDescriptorOwner (pSecurityDescriptor   : PSECURITY_DESCRIPTOR;
                                      VAR pOwner            : PSID;
                                      VAR lpbOwnerDefaulted : BOOL) : BOOL;

PROCEDURE SetSecurityDescriptorGroup (pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                      pGroup              : PSID;
                                      bGroupDefaulted     : BOOL) : BOOL;

PROCEDURE GetSecurityDescriptorGroup (pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                      VAR pGroup          : PSID;
                                      VAR bGroupDefaulted : BOOL) : BOOL;

<* IF BACKEND # "C" THEN *>
PROCEDURE CreatePrivateObjectSecurity (ParentDescriptor  : PSECURITY_DESCRIPTOR;
                                       CreatorDescriptor : PSECURITY_DESCRIPTOR;
                                       VAR NewDescriptor : PSECURITY_DESCRIPTOR;
                                       IsDirectoryObject : BOOL;
                                       Token             : HANDLE;
                                       GenericMapping    : GENERIC_MAPPING) : BOOL;
<* ELSE *>
PROCEDURE CreatePrivateObjectSecurity (ParentDescriptor  : PSECURITY_DESCRIPTOR;
                                       CreatorDescriptor : PSECURITY_DESCRIPTOR;
                                       VAR NewDescriptor : PSECURITY_DESCRIPTOR;
                                       IsDirectoryObject : BOOL;
                                       Token             : HANDLE;
                                       GenericMapping    : PGENERIC_MAPPING) : BOOL;
<* END *> (*!*)

<* IF BACKEND # "C" THEN *>
PROCEDURE SetPrivateObjectSecurity (SecurityInformation           : SECURITY_INFORMATION;
                                    ModificationDescriptor        : PSECURITY_DESCRIPTOR;
                                    VAR ObjectsSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                    GenericMapping                : GENERIC_MAPPING; (*!*)
                                    Token                         : HANDLE) : BOOL;
<* ELSE *>
PROCEDURE SetPrivateObjectSecurity (SecurityInformation           : SECURITY_INFORMATION;
                                    ModificationDescriptor        : PSECURITY_DESCRIPTOR;
                                    VAR ObjectsSecurityDescriptor : PSECURITY_DESCRIPTOR;
                                    GenericMapping                : PGENERIC_MAPPING; (*!*)
                                    Token                         : HANDLE) : BOOL;
<* END *>

PROCEDURE GetPrivateObjectSecurity (ObjectDescriptor    : PSECURITY_DESCRIPTOR;
                                    SecurityInformation : SECURITY_INFORMATION;
                                    ResultantDescriptor : PSECURITY_DESCRIPTOR;
                                    DescriptorLength    : DWORD;
                                    VAR ReturnLength    : DWORD) : BOOL;

PROCEDURE DestroyPrivateObjectSecurity (VAR ObjectDescriptor : PSECURITY_DESCRIPTOR) : BOOL;

PROCEDURE MakeSelfRelativeSD (pAbsoluteSecurityDescriptor     : PSECURITY_DESCRIPTOR;
                              pSelfRelativeSecurityDescriptor : PSECURITY_DESCRIPTOR;
                              VAR dwBufferLength              : DWORD) : BOOL;

PROCEDURE MakeAbsoluteSD (pSelfRelativeSecurityDescriptor      : PSECURITY_DESCRIPTOR;
                          pAbsoluteSecurityDescriptor          : PSECURITY_DESCRIPTOR;
                          VAR dwAbsoluteSecurityDescriptorSize : DWORD;
                          VAR Dacl                             : ACL;
                          VAR dwDaclSize                       : DWORD;
                          VAR Sacl                             : ACL;
                          VAR dwSaclSize                       : DWORD;
                          pOwner                               : PSID;
                          VAR dwOwnerSize                      : DWORD;
                          pPrimaryGroup                        : PSID;
                          VAR dwPrimaryGroupSize               : DWORD) : BOOL;

PROCEDURE SetFileSecurityA (FileName            : ARRAY OF CHAR;
                            SecurityInformation : SECURITY_INFORMATION;
                            pSecurityDescriptor : PSECURITY_DESCRIPTOR) : BOOL;

PROCEDURE SetFileSecurityW (FileName            : ARRAY OF WCHAR;
                            SecurityInformation : SECURITY_INFORMATION;
                            pSecurityDescriptor : PSECURITY_DESCRIPTOR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetFileSecurity = SetFileSecurityW;
<* ELSE *>
      CONST SetFileSecurity = SetFileSecurityA;
<* END *>

PROCEDURE GetFileSecurityA (lpFileName           : ARRAY OF CHAR;
                            RequestedInformation : SECURITY_INFORMATION;
                            pSecurityDescriptor  : PSECURITY_DESCRIPTOR;
                            nLength              : DWORD;
                            VAR LengthNeeded     : DWORD) : BOOL;

PROCEDURE GetFileSecurityW (lpFileName           : ARRAY OF WCHAR;
                            RequestedInformation : SECURITY_INFORMATION;
                            pSecurityDescriptor  : PSECURITY_DESCRIPTOR;
                            nLength              : DWORD;
                            VAR LengthNeeded     : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetFileSecurity = GetFileSecurityW;
<* ELSE *>
      CONST GetFileSecurity = GetFileSecurityA;
<* END *>

PROCEDURE SetKernelObjectSecurity (Handle              : HANDLE;
                                   SecurityInformation : SECURITY_INFORMATION;
                                   SecurityDescriptor  : PSECURITY_DESCRIPTOR) : BOOL;

PROCEDURE FindFirstChangeNotificationA (lpPathName     : ARRAY OF CHAR;
                                        bWatchSubtree  : BOOL;
                                        dwNotifyFilter : FILE_NOTIFY_SET) : HANDLE;

PROCEDURE FindFirstChangeNotificationW (lpPathName     : ARRAY OF WCHAR;
                                        bWatchSubtree  : BOOL;
                                        dwNotifyFilter : FILE_NOTIFY_SET) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST FindFirstChangeNotification = FindFirstChangeNotificationW;
<* ELSE *>
      CONST FindFirstChangeNotification = FindFirstChangeNotificationA;
<* END *>

PROCEDURE FindNextChangeNotification  (hChangeHandle : HANDLE) : BOOL;
PROCEDURE FindCloseChangeNotification (hChangeHandle : HANDLE) : BOOL;

PROCEDURE ReadDirectoryChangesW (hDirectory           : HANDLE;
                                 lpBuffer             : PVOID;
                                 nBufferLength        : DWORD;
                                 bWatchSubtree        : BOOL;
                                 dwNotifyFilter       : FILE_NOTIFY_SET;
                                 VAR BytesReturned    : DWORD;
                                 VAR [NIL] Overlapped : OVERLAPPED;
                                 lpCompletionRoutine  : POVERLAPPED_COMPLETION_ROUTINE) : BOOL;

PROCEDURE VirtualLock   (lpAddress : PVOID; dwSize : DWORD) : BOOL;
PROCEDURE VirtualUnlock (lpAddress : PVOID; dwSize : DWORD) : BOOL;

PROCEDURE MapViewOfFileEx (hFileMappingObject   : HANDLE;
                           dwDesiredAccess      : ACCESS_MASK;
                           dwFileOffsetHigh     : DWORD;
                           dwFileOffsetLow      : DWORD;
                           dwNumberOfBytesToMap : DWORD;
                           lpBaseAddress        : PVOID) : PVOID;

PROCEDURE SetPriorityClass (hProcess        : HANDLE;
                            dwPriorityClass : PRIORITY_CLASS) : BOOL;

PROCEDURE GetPriorityClass (hProcess : HANDLE) : PRIORITY_CLASS;

PROCEDURE IsBadReadPtr      (lp : LPCVOID; ucb : UINT) : BOOL;
PROCEDURE IsBadWritePtr     (lp : PVOID;  ucb : UINT) : BOOL;
PROCEDURE IsBadHugeReadPtr  (lp : LPCVOID; ucb : UINT) : BOOL;
PROCEDURE IsBadHugeWritePtr (lp : PVOID; ucb : UINT) : BOOL;
PROCEDURE IsBadCodePtr      (lpfn : PROC) : BOOL;
PROCEDURE IsBadStringPtrA (lpsz : PCSTR;  ucchMax : UINT) : BOOL;
PROCEDURE IsBadStringPtrW (lpsz : PCWSTR; ucchMax : UINT) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST IsBadStringPtr = IsBadStringPtrW;
<* ELSE *>
      CONST IsBadStringPtr = IsBadStringPtrA;
<* END *>

PROCEDURE LookupAccountSidA (lpSystemName               : PCSTR;  (* NIL *)
                             Sid                        : PSID;
                             VAR Name                   : ARRAY OF CHAR;
                             VAR cbName                 : DWORD;
                             VAR ReferencedDomainName   : ARRAY OF CHAR;
                             VAR cbReferencedDomainName : DWORD;
                             VAR Use                    : SID_NAME_USE) : BOOL;

PROCEDURE LookupAccountSidW (lpSystemName               : PCWSTR; (* NIL *)
                             Sid                        : PSID;
                             VAR Name                   : ARRAY OF WCHAR;
                             VAR cbName                 : DWORD;
                             VAR ReferencedDomainName   : ARRAY OF WCHAR;
                             VAR cbReferencedDomainName : DWORD;
                             VAR Use                    : SID_NAME_USE) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST LookupAccountSid = LookupAccountSidW;
<* ELSE *>
      CONST LookupAccountSid = LookupAccountSidA;
<* END *>

PROCEDURE LookupAccountNameA (lpSystemName               : PCSTR; (*!*)
                              lpAccountName              : ARRAY OF CHAR;
                              Sid                        : PSID;
                              VAR cbSid                  : DWORD;
                              VAR ReferencedDomainName   : ARRAY OF CHAR;
                              VAR cbReferencedDomainName : DWORD;
                              VAR Use                    : SID_NAME_USE) : BOOL;

PROCEDURE LookupAccountNameW (lpSystemName               : PCWSTR; (*!*)
                              lpAccountName              : ARRAY OF WCHAR;
                              Sid                        : PSID;
                              VAR cbSid                  : DWORD;
                              VAR ReferencedDomainName   : ARRAY OF WCHAR;
                              VAR cbReferencedDomainName : DWORD;
                              VAR Use                    : SID_NAME_USE) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST LookupAccountName = LookupAccountNameW;
<* ELSE *>
      CONST LookupAccountName = LookupAccountNameA;
<* END *>

PROCEDURE LookupPrivilegeValueA (lpSystemName : ARRAY OF CHAR;
                                 lpName       : ARRAY OF CHAR;
                                 VAR Luid     : LUID)
                                                      : BOOL;

PROCEDURE LookupPrivilegeValueW (lpSystemName : ARRAY OF WCHAR;
                                 lpName       : ARRAY OF WCHAR;
                                 VAR Luid     : LUID)
                                                      : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST LookupPrivilegeValue = LookupPrivilegeValueW;
<* ELSE *>
      CONST LookupPrivilegeValue = LookupPrivilegeValueA;
<* END *>

PROCEDURE LookupPrivilegeNameA (lpSystemName : ARRAY OF CHAR;
                                VAR Luid     : LUID;
                                VAR Name     : ARRAY OF CHAR;
                                VAR cbName   : DWORD) : BOOL;

PROCEDURE LookupPrivilegeNameW (lpSystemName : ARRAY OF WCHAR;
                                VAR Luid     : LUID;
                                VAR Name     : ARRAY OF WCHAR;
                                VAR cbName   : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST LookupPrivilegeName = LookupPrivilegeNameW;
<* ELSE *>
      CONST LookupPrivilegeName = LookupPrivilegeNameA;
<* END *>

PROCEDURE LookupPrivilegeDisplayNameA (SystemName        : ARRAY OF CHAR;
                                       Name              : ARRAY OF CHAR;
                                       VAR DisplayName   : ARRAY OF CHAR;
                                       VAR cbDisplayName : DWORD;
                                       VAR lpLanguageId  : DWORD) : BOOL;

PROCEDURE LookupPrivilegeDisplayNameW (VAR SystemName    : ARRAY OF WCHAR;
                                       VAR Name          : ARRAY OF WCHAR;
                                       VAR DisplayName   : ARRAY OF WCHAR;
                                       VAR cbDisplayName : DWORD;
                                       VAR lpLanguageId  : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST LookupPrivilegeDisplayName = LookupPrivilegeDisplayNameW;
<* ELSE *>
      CONST LookupPrivilegeDisplayName = LookupPrivilegeDisplayNameA;
<* END *>


PROCEDURE AllocateLocallyUniqueId (VAR uid : LUID) : BOOL;

PROCEDURE BuildCommDCBA (Def : ARRAY OF CHAR;  VAR DCB : DCB) : BOOL;
PROCEDURE BuildCommDCBW (Def : ARRAY OF WCHAR; VAR DCB : DCB) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST BuildCommDCB = BuildCommDCBW;
<* ELSE *>
      CONST BuildCommDCB = BuildCommDCBA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE BuildCommDCBAndTimeoutsA (Def          : ARRAY OF CHAR;
                                    VAR DCB      : DCB;
                                    CommTimeouts : COMMTIMEOUTS) : BOOL;
<* ELSE *>
PROCEDURE BuildCommDCBAndTimeoutsA (Def          : ARRAY OF CHAR;
                                    VAR DCB      : DCB;
                                    CommTimeouts : PCOMMTIMEOUTS) : BOOL;
<* END *>  (*!*)

<* IF BACKEND # "C" THEN *>
PROCEDURE BuildCommDCBAndTimeoutsW (Def          : ARRAY OF CHAR;
                                    VAR DCB      : DCB;
                                    CommTimeouts : COMMTIMEOUTS) : BOOL;
<* ELSE *>
PROCEDURE BuildCommDCBAndTimeoutsW (Def          : ARRAY OF CHAR;
                                    VAR DCB      : DCB;
                                    CommTimeouts : PCOMMTIMEOUTS) : BOOL;
<* END *>  (*!*)

<* IF DEFINED (UNICODE) THEN *>
      CONST BuildCommDCBAndTimeouts = BuildCommDCBAndTimeoutsW;
<* ELSE *>
      CONST BuildCommDCBAndTimeouts = BuildCommDCBAndTimeoutsA;
<* END *>

PROCEDURE CommConfigDialogA (Name   : ARRAY OF CHAR;
                             hWnd   : HWND;
                             VAR CC : COMMCONFIG) : BOOL;

PROCEDURE CommConfigDialogW (Name   : ARRAY OF WCHAR;
                             hWnd   : HWND;
                             VAR CC : COMMCONFIG) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST CommConfigDialog = CommConfigDialogW;
<* ELSE *>
      CONST CommConfigDialog = CommConfigDialogA;
<* END *>

PROCEDURE GetDefaultCommConfigA (Name       : ARRAY OF CHAR;
                                 VAR CC     : COMMCONFIG;
                                 VAR dwSize : DWORD)
                                                     : BOOL;

PROCEDURE GetDefaultCommConfigW (Name       : ARRAY OF WCHAR;
                                 VAR CC     : COMMCONFIG;
                                 VAR dwSize : DWORD)
                                                     : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetDefaultCommConfig = GetDefaultCommConfigW;
<* ELSE *>
      CONST GetDefaultCommConfig = GetDefaultCommConfigA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE SetDefaultCommConfigA (Name   : ARRAY OF CHAR;
                                 CC     : COMMCONFIG;  (*!*)
                                 dwSize : DWORD)
                                                   : BOOL;
<* ELSE *>
PROCEDURE SetDefaultCommConfigA (Name   : ARRAY OF CHAR;
                                 CC     : PCOMMCONFIG;  (*!*)
                                 dwSize : DWORD)
                                                   : BOOL;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE SetDefaultCommConfigW (Name   : ARRAY OF WCHAR;
                                 CC     : COMMCONFIG;  (*!*)
                                 dwSize : DWORD)
                                                   : BOOL;
<* ELSE *>
PROCEDURE SetDefaultCommConfigW (Name   : ARRAY OF WCHAR;
                                 CC     : PCOMMCONFIG;  (*!*)
                                 dwSize : DWORD)
                                                   : BOOL;
<* END *>

<* IF DEFINED (UNICODE) THEN *>
      CONST SetDefaultCommConfig = SetDefaultCommConfigW;
<* ELSE *>
      CONST SetDefaultCommConfig = SetDefaultCommConfigA;
<* END *>

CONST MAX_COMPUTERNAME_LENGTH = 15;

PROCEDURE GetComputerNameA (VAR Buffer : ARRAY OF CHAR; VAR Size : DWORD) : BOOL;
PROCEDURE GetComputerNameW (VAR Buffer : ARRAY OF CHAR; VAR Size : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetComputerName = GetComputerNameW;
<* ELSE *>
      CONST GetComputerName = GetComputerNameA;
<* END *>

PROCEDURE SetComputerNameA (ComputerName : ARRAY OF CHAR)  : BOOL;
PROCEDURE SetComputerNameW (ComputerName : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetComputerName = SetComputerNameW;
<* ELSE *>
      CONST SetComputerName = SetComputerNameA;
<* END *>

PROCEDURE GetUserNameA (VAR Buffer : ARRAY OF CHAR;  VAR Size : DWORD) : BOOL;
PROCEDURE GetUserNameW (VAR Buffer : ARRAY OF WCHAR; VAR Size : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetUserName = GetUserNameW;
<* ELSE *>
      CONST GetUserName = GetUserNameA;
<* END *>

(*
** Logon Support APIs
*)

TYPE LOGON_TYPE = (LOGON32_0,
                   LOGON32_1,
                   LOGON32_LOGON_INTERACTIVE, (* 2 *)
                   LOGON32_LOGON_NETWORK,     (* 3 *)
                   LOGON32_LOGON_BATCH,       (* 4 *)
                   LOGON32_LOGON_SERVICE);    (* 5 *)


TYPE LOGON_PROVIDER_TYPE = (LOGON32_PROVIDER_DEFAULT,  (* 0 *)
                            LOGON32_PROVIDER_WINNT35,  (* 1 *)
                            LOGON32_PROVIDER_WINNT40); (* 2 *)

PROCEDURE LogonUserA (lpszUsername    : ARRAY OF CHAR;
                      lpszDomain      : ARRAY OF CHAR;
                      lpszPassword    : ARRAY OF CHAR;
                      dwLogonType     : LOGON_TYPE;
                      dwLogonProvider : LOGON_PROVIDER_TYPE;
                      VAR Token       : HANDLE)
                                                : BOOL;

PROCEDURE LogonUserW (lpszUsername    : ARRAY OF WCHAR;
                      lpszDomain      : ARRAY OF WCHAR;
                      lpszPassword    : ARRAY OF WCHAR;
                      dwLogonType     : LOGON_TYPE;
                      dwLogonProvider : LOGON_PROVIDER_TYPE;
                      VAR Token       : HANDLE)
                                                : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST LogonUser = LogonUserW;
<* ELSE *>
      CONST LogonUser = LogonUserA;
<* END *>

PROCEDURE ImpersonateLoggedOnUser (hToken : HANDLE) : BOOL;

PROCEDURE CreateProcessAsUserA (hToken                 : HANDLE;
                                lpApplicationName      : PCSTR; (* IN NIL *)
                                lpCommandLine          : PCSTR; (* IN NIL *)
                                lpProcessAttributes    : PSECURITY_ATTRIBUTES;
                                lpThreadAttributes     : PSECURITY_ATTRIBUTES;
                                bInheritHandles        : BOOL;
                                dwCreationFlags        : CREATE_SET;
                                lpEnvironment          : PVOID;
                                lpCurrentDirectory     : PCSTR; (* IN NIL *)
                                VAR StartupInfo        : STARTUPINFOA; (* IN *)
                                VAR ProcessInformation : PROCESS_INFORMATION) : BOOL;

PROCEDURE CreateProcessAsUserW (hToken                 : HANDLE;
                                lpApplicationName      : PCWSTR; (* IN NIL *)
                                lpCommandLine          : PCWSTR; (* IN NIL *)
                                lpProcessAttributes    : PSECURITY_ATTRIBUTES;
                                lpThreadAttributes     : PSECURITY_ATTRIBUTES;
                                bInheritHandles        : BOOL;
                                dwCreationFlags        : CREATE_SET;
                                lpEnvironment          : PVOID;
                                lpCurrentDirectory     : PCWSTR; (* IN NIL *)
                                VAR StartupInfo        : STARTUPINFOA; (* IN *)
                                VAR ProcessInformation : PROCESS_INFORMATION) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateProcessAsUser = CreateProcessAsUserW;
<* ELSE *>
      CONST CreateProcessAsUser = CreateProcessAsUserA;
<* END *>

PROCEDURE DuplicateTokenEx (hExistingToken     : HANDLE;
                            dwDesiredAccess    : ACCESS_MASK;
                            lpTokenAttributes  : PSECURITY_ATTRIBUTES;
                            ImpersonationLevel : SECURITY_IMPERSONATION_LEVEL;
                            TokenType          : TOKEN_TYPE;
                            VAR NewToken       : HANDLE)
                                                         : BOOL;

(*
** Plug-and-Play API's
*)

CONST HW_PROFILE_GUIDLEN = 39;  (* 36-characters plus NULL terminator *)
CONST MAX_PROFILE_LEN    = 80;


TYPE DOCKINFO_ENUM = (DOCKINFO__UNDOCKED,        (* 0 *)
                      DOCKINFO__DOCKED,          (* 1 *)
                      DOCKINFO__USER_SUPPLIED);  (* 2 *)

     DOCKINFO_SET = SET OF DOCKINFO_ENUM;

CONST DOCKINFO_UNDOCKED      = DOCKINFO_SET {DOCKINFO__UNDOCKED};      (* 0x1 *)
      DOCKINFO_DOCKED        = DOCKINFO_SET {DOCKINFO__DOCKED};        (* 0x2 *)
      DOCKINFO_USER_SUPPLIED = DOCKINFO_SET {DOCKINFO__USER_SUPPLIED}; (* 0x4 *)

      DOCKINFO_USER_UNDOCKED = DOCKINFO_USER_SUPPLIED + DOCKINFO_UNDOCKED;
      DOCKINFO_USER_DOCKED   = DOCKINFO_USER_SUPPLIED + DOCKINFO_DOCKED;

TYPE HW_PROFILE_INFOA = RECORD
                               dwDockInfo      : DOCKINFO_SET;
                               szHwProfileGuid : ARRAY [0..HW_PROFILE_GUIDLEN-1] OF CHAR;
                               szHwProfileName : ARRAY [0..MAX_PROFILE_LEN-1] OF CHAR;
                        END;
    PHW_PROFILE_INFOA = POINTER TO HW_PROFILE_INFOA;

     HW_PROFILE_INFOW = RECORD
                               dwDockInfo      : DOCKINFO_SET;
                               szHwProfileGuid : ARRAY [0..HW_PROFILE_GUIDLEN-1] OF WCHAR;
                               szHwProfileName : ARRAY [0..MAX_PROFILE_LEN-1] OF WCHAR;
                        END;
    PHW_PROFILE_INFOW = POINTER TO HW_PROFILE_INFOW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  HW_PROFILE_INFO =  HW_PROFILE_INFOW;
           PHW_PROFILE_INFO = PHW_PROFILE_INFOW;
<* ELSE *>
      TYPE  HW_PROFILE_INFO =  HW_PROFILE_INFOA;
           PHW_PROFILE_INFO = PHW_PROFILE_INFOA;
<* END *>

PROCEDURE GetCurrentHwProfileA (VAR HwProfileInfo : HW_PROFILE_INFOA) : BOOL;
PROCEDURE GetCurrentHwProfileW (VAR HwProfileInfo : HW_PROFILE_INFOW) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetCurrentHwProfile = GetCurrentHwProfileW;
<* ELSE *>
      CONST GetCurrentHwProfile = GetCurrentHwProfileA;
<* END *>

(*
** Performance counter API's
*)

PROCEDURE QueryPerformanceCounter   (VAR PerformanceCount : LARGE_INTEGER) : BOOL;
PROCEDURE QueryPerformanceFrequency (VAR Frequency : LARGE_INTEGER) : BOOL;

(*
** RtlVerifyVersionInfo() os product type values
*)

CONST VER_NT_WORKSTATION       = 1;
      VER_NT_DOMAIN_CONTROLLER = 2;
      VER_NT_SERVER            = 3;

(*
** dwPlatformId defines:
*)

TYPE VER_PLATFORM_TYPE = (VER_PLATFORM_WIN32s,        (* 0 *)
                          VER_PLATFORM_WIN32_WINDOWS, (* 1 *)
                          VER_PLATFORM_WIN32_NT);     (* 2 *)

TYPE OSVERSIONINFOA = RECORD
                             dwOSVersionInfoSize : DWORD;
                             dwMajorVersion      : DWORD;
                             dwMinorVersion      : DWORD;
                             dwBuildNumber       : DWORD;
                             dwPlatformId        : VER_PLATFORM_TYPE;
                             szCSDVersion        : ARRAY [0..127] OF CHAR; (* Maintenance string for PSS usage *)
                      END;
    POSVERSIONINFOA = POINTER TO OSVERSIONINFOA;

TYPE OSVERSIONINFOW = RECORD
                             dwOSVersionInfoSize : DWORD;
                             dwMajorVersion      : DWORD;
                             dwMinorVersion      : DWORD;
                             dwBuildNumber       : DWORD;
                             dwPlatformId        : VER_PLATFORM_TYPE;
                             szCSDVersion        : ARRAY [0..127] OF WCHAR; (* Maintenance string for PSS usage *)
                      END;
    POSVERSIONINFOW = POINTER TO OSVERSIONINFOW;

<* IF DEFINED (UNICODE) THEN *>
       TYPE OSVERSIONINFO =  OSVERSIONINFOW;
           POSVERSIONINFO = POSVERSIONINFOW;
<* ELSE *>
       TYPE OSVERSIONINFO =  OSVERSIONINFOA;
           POSVERSIONINFO = POSVERSIONINFOA;
<* END *>

TYPE OSVERSIONINFOEXA = RECORD
                             dwOSVersionInfoSize : DWORD;
                             dwMajorVersion      : DWORD;
                             dwMinorVersion      : DWORD;
                             dwBuildNumber       : DWORD;
                             dwPlatformId        : VER_PLATFORM_TYPE;
                             szCSDVersion        : ARRAY [0..127] OF CHAR; (* Maintenance string for PSS usage *)
                             wServicePackMajor   : WORD;
                             wServicePackMinor   : WORD;
                             wSuiteMask          : WORD;
                             wProductType        : BYTE;
                             wReserved           : BYTE;
                      END;
    POSVERSIONINFOEXA = POINTER TO OSVERSIONINFOEXA;

TYPE OSVERSIONINFOEXW = RECORD
                             dwOSVersionInfoSize : DWORD;
                             dwMajorVersion      : DWORD;
                             dwMinorVersion      : DWORD;
                             dwBuildNumber       : DWORD;
                             dwPlatformId        : VER_PLATFORM_TYPE;
                             szCSDVersion        : ARRAY [0..127] OF WCHAR; (* Maintenance string for PSS usage *)
                             wServicePackMajor   : WORD;
                             wServicePackMinor   : WORD;
                             wSuiteMask          : WORD;
                             wProductType        : BYTE;
                             wReserved           : BYTE;
                      END;
    POSVERSIONINFOEXW = POINTER TO OSVERSIONINFOEXW;

<* IF DEFINED (UNICODE) THEN *>
       TYPE OSVERSIONINFOEX =  OSVERSIONINFOEXW;
           POSVERSIONINFOEX = POSVERSIONINFOEXW;
<* ELSE *>
       TYPE OSVERSIONINFOEX =  OSVERSIONINFOEXA;
           POSVERSIONINFOEX = POSVERSIONINFOEXA;
<* END *>

PROCEDURE GetVersionExA (VAR VersionInformation : OSVERSIONINFOA) : BOOL;
PROCEDURE GetVersionExW (VAR VersionInformation : OSVERSIONINFOW) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetVersionEx = GetVersionExW;
<* ELSE *>
      CONST GetVersionEx = GetVersionExA;
<* END *>

(* DOS and OS/2 Compatible Error Code definitions returned by the Win32 Base
** API functions.
*)

(* Abnormal termination codes *)

CONST TC_NORMAL  = 0;
      TC_HARDERR = 1;
      TC_GP_TRAP = 2;
      TC_SIGNAL  = 3;

(*
** Power Management APIs
*)

TYPE AC_LINE_TYPE = INT8;

CONST AC_LINE_OFFLINE               = VAL (AC_LINE_TYPE,  0);
      AC_LINE_ONLINE                = VAL (AC_LINE_TYPE,  1);
      AC_LINE_BACKUP_POWER          = VAL (AC_LINE_TYPE,  2);
      AC_LINE_UNKNOWN               = VAL (AC_LINE_TYPE, -1);

TYPE BATTERY_FLAG_ENUM = (BATTERY_FLAG__HIGH,        (* 0 *)
                          BATTERY_FLAG__LOW,         (* 1 *)
                          BATTERY_FLAG__CRITICAL,    (* 2 *)
                          BATTERY_FLAG__CHARGING,    (* 3 *)
                          BATTERY_FLAG__4,
                          BATTERY_FLAG__5,
                          BATTERY_FLAG__6,
                          BATTERY_FLAG__NO_BATTERY); (* 7 *)

<* PUSH *> <* SETSIZE = "1" *>

TYPE BATTERY_FLAG_SET = SET OF BATTERY_FLAG_ENUM;

CONST BATTERY_FLAG_HIGH       = BATTERY_FLAG_SET {BATTERY_FLAG__HIGH};       (* 01h *)
      BATTERY_FLAG_LOW        = BATTERY_FLAG_SET {BATTERY_FLAG__LOW};        (* 02h *)
      BATTERY_FLAG_CRITICAL   = BATTERY_FLAG_SET {BATTERY_FLAG__CRITICAL};   (* 04h *)
      BATTERY_FLAG_CHARGING   = BATTERY_FLAG_SET {BATTERY_FLAG__CHARGING};   (* 08h *)
      BATTERY_FLAG_NO_BATTERY = BATTERY_FLAG_SET {BATTERY_FLAG__NO_BATTERY}; (* 80h *)

      BATTERY_FLAG_UNKNOWN    = BATTERY_FLAG_SET {MIN (BATTERY_FLAG_ENUM)..
                                                  MAX (BATTERY_FLAG_ENUM)};  (* 0FFh *)

<* POP *>

      BATTERY_PERCENTAGE_UNKNOWN    = 0FFh;

      BATTERY_LIFE_UNKNOWN          = 0FFFFFFFFh;

TYPE SYSTEM_POWER_STATUS = RECORD
                                  ACLineStatus        : AC_LINE_TYPE;
                                  BatteryFlag         : BATTERY_FLAG_SET;
                                  BatteryLifePercent  : BYTE;
                                  Reserved1           : BYTE;
                                  BatteryLifeTime     : DWORD;
                                  BatteryFullLifeTime : DWORD;
                           END;
    PSYSTEM_POWER_STATUS = POINTER TO SYSTEM_POWER_STATUS;

PROCEDURE GetSystemPowerStatus (VAR SystemPowerStatus : SYSTEM_POWER_STATUS) : BOOL;
PROCEDURE SetSystemPowerState  (fSuspend : BOOL; fForce : BOOL) : BOOL;


(*************************************************************)
(*                                                           *)
(*      Win Certificate API and Structures                   *)
(*                                                           *)
(*************************************************************)

(*
** Structures
*)

(*
** Possible certificate types are specified by the following values
*)

<* PUSH *> <* ENUMSIZE = "2" *>

TYPE WIN_CERT_TYPE  = (WIN_CERT_TYPE_0,
                       WIN_CERT_TYPE_X509,             (* 0x0001 bCertificate contains an X.509 Certificate *)
                       WIN_CERT_TYPE_PKCS_SIGNED_DATA, (* 0x0002 bCertificate contains a PKCS SignedData structure *)
                       WIN_CERT_TYPE_RESERVED_1);      (* 0x0003 Reserved *)
<* POP *>

TYPE WIN_CERTIFICATE = RECORD
                              dwLength         : DWORD;
                              wRevision        : WORD;
                              wCertificateType : WIN_CERT_TYPE;
                              bCertificate     : ARRAY [0..0] OF BYTE;
                       END;

    PWIN_CERTIFICATE = POINTER TO WIN_CERTIFICATE;

(*
** Currently, the only defined certificate revision is WIN_CERT_REVISION_1_0
*)

CONST WIN_CERT_REVISION_1_0  = 0100h;

(*
** API
*)

PROCEDURE WinSubmitCertificate (VAR Certificate : WIN_CERTIFICATE) : BOOL;


(*************************************************************)
(*                                                           *)
(*             Trust API and Structures                      *)
(*                                                           *)
(*************************************************************)

PROCEDURE WinVerifyTrust (hwnd         : HWND;
                          VAR ActionID : GUID;
                          ActionData   : PVOID) : LONG;

PROCEDURE WinLoadTrustProvider (VAR ActionID : GUID) : BOOL;


(*************************************************************)
(*                                                           *)
(*             Common Trust API Data Structures              *)
(*                                                           *)
(*************************************************************)


(*
** Data type commonly used in ActionData structures
*)

TYPE WIN_TRUST_SUBJECT = PVOID;

(*
** Two commonly used ActionData structures
*)

TYPE WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT =
     RECORD
          hClientToken : HANDLE;
          SubjectType  : PGUID;
          Subject      : WIN_TRUST_SUBJECT;
     END;
     PWIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT = POINTER TO WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT;

TYPE WIN_TRUST_ACTDATA_SUBJECT_ONLY =
     RECORD
            SubjectType : PGUID;
            Subject     : WIN_TRUST_SUBJECT;
     END;
     PWIN_TRUST_ACTDATA_SUBJECT_ONLY = POINTER TO WIN_TRUST_ACTDATA_SUBJECT_ONLY;


(*****************************************************************)
(*                                                               *)
(*      SUBJECT FORM DEFINITIONS                                 *)
(*                                                               *)
(*****************************************************************)

(*****************************************************************)
(*                                                               *)
(* Currently defined Subject Type Identifiers.  All of the below *)
(* use the WIN_TRUST_SUBJECT_FILE subject form, defined below.   *)
(*                                                               *)
(*****************************************************************)

(* RawFile == 959dc450-8d9e-11cf-8736-00aa00a485eb *)

CONST WIN_TRUST_SUBJTYPE_RAW_FILE =
      GUID {
            959dc450h,
            8d9eh,
            11cfh,
            BYTEARRAY8 {87h, 36h, 00h, 0aah, 00h, 0a4h, 085h, 0ebh}
      };

(* PeImage == 43c9a1e0-8da0-11cf-8736-00aa00a485eb *)

CONST WIN_TRUST_SUBJTYPE_PE_IMAGE =
      GUID {
            43c9a1e0h,
            8da0h,
            11cfh,
            BYTEARRAY8 {87h, 36h, 00h, 0aah, 00h, 0a4h, 085h, 0ebh}
      };

(* JavaClass = 08ad3990-8da1-11cf-8736-00aa00a485eb *)

CONST WIN_TRUST_SUBJTYPE_JAVA_CLASS =
      GUID {
            08ad3990h,
            8da1h,
            11cfh,
            BYTEARRAY8 {87h, 36h, 00h, 0aah, 00h, 0a4h, 085h, 0ebh}
      };

(* Cabinet = d17c5374-a392-11cf-9df5-00aa00c184e0 *)

CONST WIN_TRUST_SUBJTYPE_CABINET =
      GUID {
            0d17c5374h,
            0a392h,
            011cfh,
            BYTEARRAY8 {9dh, 0f5h, 0, 0aah, 0, 0c1h, 084h, 0e0h}
      };

(*
** Associated Subject Data Structure:
*)

TYPE WIN_TRUST_SUBJECT_FILE = RECORD
                                     hFile  : HANDLE;
                                     lpPath : PCWSTR;
                              END;
    PWIN_TRUST_SUBJECT_FILE = POINTER TO WIN_TRUST_SUBJECT_FILE;


(******************************************************************)
(*                                                                *)
(* The following subject types use the                            *)
(* WIN_TRUST_SUBJECT_FILE_AND_DISPLAY subject type, defined       *)
(* below.                                                         *)
(*                                                                *)
(******************************************************************)

CONST WIN_TRUST_SUBJTYPE_RAW_FILEEX =
      GUID {
            6f458111h,
            0c2f1h,
            011cfh,
            BYTEARRAY8 {8ah, 69h, 0, 0aah, 0, 6ch, 37h, 6}
      };

CONST WIN_TRUST_SUBJTYPE_PE_IMAGEEX =
      GUID {
            6f458110h,
            0c2f1h,
            011cfh,
            BYTEARRAY8 {8ah, 69h, 0, 0aah, 0, 6ch, 37h, 6}
      };

CONST WIN_TRUST_SUBJTYPE_JAVA_CLASSEX =
      GUID {
            6f458113h,
            0c2f1h,
            011cfh,
            BYTEARRAY8 {8ah, 69h, 0, 0aah, 0, 6ch, 37h, 6}
      };

CONST WIN_TRUST_SUBJTYPE_CABINETEX =
      GUID {
            6f458114h,
            0c2f1h,
            011cfh,
            BYTEARRAY8 {8ah, 69h, 0, 0aah, 0, 6ch, 37h, 6}
      };

(*
** Associated Subject Data Structure:
*)

TYPE WIN_TRUST_SUBJECT_FILE_AND_DISPLAY =
     RECORD
            hFile         : HANDLE;  (* handle to the open file if you got it *)
            lpPath        : PCWSTR;  (* the path to open if you don't *)
            lpDisplayName : PCWSTR;  (* (optional) display name to show to user
                                        in place of path
                                     *)
     END;
     PWIN_TRUST_SUBJECT_FILE_AND_DISPLAY = POINTER TO WIN_TRUST_SUBJECT_FILE_AND_DISPLAY;

(******************************************************************)
(*                                                                *)
(* Other subject types:                                           *)
(*                                                                *)
(******************************************************************)

(* OleStorage == c257e740-8da0-11cf-8736-00aa00a485eb *)

CONST WIN_TRUST_SUBJTYPE_OLE_STORAGE =
      GUID {
            0c257e740h,
            08da0h,
            11cfh,
            BYTEARRAY8 {087h, 36h, 0, 0aah, 0, 0a4h, 85h, 0ebh}
      };


(******************************************************************)
(*                                                                *)
(*      TRUST PROVIDER SPECIFIC DEFINITIONS                       *)
(*                                                                *)
(*                                                                *)
(*      Each trust provider will have the following               *)
(*      sections defined:                                         *)
(*                                                                *)
(*      Actions - What actions are supported by the trust         *)
(*          provider.                                             *)
(*                                                                *)
(*      SubjectForms - Subjects that may be evaluated by this     *)
(*          trust provider.                                       *)
(*                                                                *)
(*                     and                                        *)
(*                                                                *)
(*      Data structures to support the subject forms.             *)
(*                                                                *)
(*                                                                *)
(******************************************************************)


(******************************************************************)
(*                                                                *)
(*             Software Publisher Trust Provider                  *)
(*                                                                *)
(******************************************************************)

(*
** Actions:
*)

(* TrustedPublisher == 66426730-8da1-11cf-8736-00aa00a485eb *)

CONST WIN_SPUB_ACTION_TRUSTED_PUBLISHER =
      GUID {
            66426730h,
            8da1h,
            11cfh,
            BYTEARRAY8 {87h, 36h, 0, 0aah, 0, 0a4h, 085h, 0ebh}
      };

(* NtActivateImage == 8bc96b00-8da1-11cf-8736-00aa00a485eb *)

CONST WIN_SPUB_ACTION_NT_ACTIVATE_IMAGE =
      GUID {
            8bc96b00h,
            8da1h,
            11cfh,
            BYTEARRAY8 {87h, 36h, 0, 0aah, 0, 0a4h, 085h, 0ebh}
      };

(* PublishedSoftware == 64b9d180-8da2-11cf-8736-00aa00a485eb *)

CONST WIN_SPUB_ACTION_PUBLISHED_SOFTWARE =
      GUID {
            64b9d180h,
            8da2h,
            11cfh,
            BYTEARRAY8 {87h, 36h, 0, 0aah, 0, 0a4h, 085h, 0ebh}
      };

(*
** Data Structures:
**
** WIN_SPUB_ACTION_TRUSTED_PUBLISHER:
**
**      Uses WIN_SPUB_TRUSTED_PUBLISHER_DATA
**
** WIN_SPUB_ACTION_NT_ACTIVATE_IMAGE:
**
**      Uses WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT
**
** WIN_SPUB_ACTION_PUBLISHED_SOFTWARE:
**
**      Uses WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT
*)

TYPE WIN_SPUB_TRUSTED_PUBLISHER_DATA =
     RECORD
            hClientToken  : HANDLE;
            lpCertificate : PWIN_CERTIFICATE;
     END;
     PWIN_SPUB_TRUSTED_PUBLISHER_DATA = POINTER TO WIN_SPUB_TRUSTED_PUBLISHER_DATA;




(**************************************************************************
*                                                                         *
*   WinError.DEF --  error code definitions for the Win32 API functions   *
*                                                                         *
***************************************************************************)


CONST

(*
**  Values are 32 bit values layed out as follows:
**
**   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
**   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
**  +---+-+-+-----------------------+-------------------------------+
**  |Sev|C|R|     Facility          |               Code            |
**  +---+-+-+-----------------------+-------------------------------+
**
**  where
**
**      Sev - is the severity code
**
**          00 - Success
**          01 - Informational
**          10 - Warning
**          11 - Error
**
**      C - is the Customer code flag
**
**      R - is a reserved bit
**
**      Facility - is the facility code
**
**      Code - is the facility's status code
**
**
** Define the facility codes
*)
        FACILITY_WINDOWS                 = 8;
        FACILITY_STORAGE                 = 3;
        FACILITY_RPC                     = 1;
        FACILITY_WIN32                   = 7;
        FACILITY_CONTROL                 = 10;
        FACILITY_NULL                    = 0;
        FACILITY_ITF                     = 4;
        FACILITY_DISPATCH                = 2;


(*
** Define the severity codes
*)


(*
** MessageId: ERROR_SUCCESS
**
** MessageText:
**
**  The operation completed successfully.
*)
        ERROR_SUCCESS                    = 0;

        NO_ERROR = 0;                             (* dderror; *)

(*
** MessageId: ERROR_INVALID_FUNCTION
**
** MessageText:
**
**  Incorrect function.
*)
        ERROR_INVALID_FUNCTION           = 1;    (* dderror; *)

(*
** MessageId: ERROR_FILE_NOT_FOUND
**
** MessageText:
**
**  The system cannot find the file specified.
*)
        ERROR_FILE_NOT_FOUND             = 2;

(*
** MessageId: ERROR_PATH_NOT_FOUND
**
** MessageText:
**
**  The system cannot find the path specified.
*)
        ERROR_PATH_NOT_FOUND             = 3;

(*
** MessageId: ERROR_TOO_MANY_OPEN_FILES
**
** MessageText:
**
**  The system cannot open the file.
*)
        ERROR_TOO_MANY_OPEN_FILES        = 4;

(*
** MessageId: ERROR_ACCESS_DENIED
**
** MessageText:
**
**  Access is denied.
*)
        ERROR_ACCESS_DENIED              = 5;

(*
** MessageId: ERROR_INVALID_HANDLE
**
** MessageText:
**
**  The handle is invalid.
*)
        ERROR_INVALID_HANDLE             = 6;

(*
** MessageId: ERROR_ARENA_TRASHED
**
** MessageText:
**
**  The storage control blocks were destroyed.
*)
        ERROR_ARENA_TRASHED              = 7;

(*
** MessageId: ERROR_NOT_ENOUGH_MEMORY
**
** MessageText:
**
**  Not enough storage is available to process this command.
*)
        ERROR_NOT_ENOUGH_MEMORY          = 8;    (* dderror; *)

(*
** MessageId: ERROR_INVALID_BLOCK
**
** MessageText:
**
**  The storage control block address is invalid.
*)
        ERROR_INVALID_BLOCK              = 9;

(*
** MessageId: ERROR_BAD_ENVIRONMENT
**
** MessageText:
**
**  The environment is incorrect.
*)
        ERROR_BAD_ENVIRONMENT            = 10;

(*
** MessageId: ERROR_BAD_FORMAT
**
** MessageText:
**
**  An attempt was made to load a program with an
**  incorrect format.
*)
        ERROR_BAD_FORMAT                 = 11;

(*
** MessageId: ERROR_INVALID_ACCESS
**
** MessageText:
**
**  The access code is invalid.
*)
        ERROR_INVALID_ACCESS             = 12;

(*
** MessageId: ERROR_INVALID_DATA
**
** MessageText:
**
**  The data is invalid.
*)
        ERROR_INVALID_DATA               = 13;

(*
** MessageId: ERROR_OUTOFMEMORY
**
** MessageText:
**
**  Not enough storage is available to complete this operation.
*)
        ERROR_OUTOFMEMORY                = 14;

(*
** MessageId: ERROR_INVALID_DRIVE
**
** MessageText:
**
**  The system cannot find the drive specified.
*)
        ERROR_INVALID_DRIVE              = 15;

(*
** MessageId: ERROR_CURRENT_DIRECTORY
**
** MessageText:
**
**  The directory cannot be removed.
*)
        ERROR_CURRENT_DIRECTORY          = 16;

(*
** MessageId: ERROR_NOT_SAME_DEVICE
**
** MessageText:
**
**  The system cannot move the file
**  to a different disk drive.
*)
        ERROR_NOT_SAME_DEVICE            = 17;

(*
** MessageId: ERROR_NO_MORE_FILES
**
** MessageText:
**
**  There are no more files.
*)
        ERROR_NO_MORE_FILES              = 18;

(*
** MessageId: ERROR_WRITE_PROTECT
**
** MessageText:
**
**  The media is write protected.
*)
        ERROR_WRITE_PROTECT              = 19;

(*
** MessageId: ERROR_BAD_UNIT
**
** MessageText:
**
**  The system cannot find the device specified.
*)
        ERROR_BAD_UNIT                   = 20;

(*
** MessageId: ERROR_NOT_READY
**
** MessageText:
**
**  The device is not ready.
*)
        ERROR_NOT_READY                  = 21;

(*
** MessageId: ERROR_BAD_COMMAND
**
** MessageText:
**
**  The device does not recognize the command.
*)
        ERROR_BAD_COMMAND                = 22;

(*
** MessageId: ERROR_CRC
**
** MessageText:
**
**  Data error (cyclic redundancy check)
*)
        ERROR_CRC                        = 23;

(*
** MessageId: ERROR_BAD_LENGTH
**
** MessageText:
**
**  The program issued a command but the
**  command length is incorrect.
*)
        ERROR_BAD_LENGTH                 = 24;

(*
** MessageId: ERROR_SEEK
**
** MessageText:
**
**  The drive cannot locate a specific
**  area or track on the disk.
*)
        ERROR_SEEK                       = 25;

(*
** MessageId: ERROR_NOT_DOS_DISK
**
** MessageText:
**
**  The specified disk or diskette cannot be accessed.
*)
        ERROR_NOT_DOS_DISK               = 26;

(*
** MessageId: ERROR_SECTOR_NOT_FOUND
**
** MessageText:
**
**  The drive cannot find the sector requested.
*)
        ERROR_SECTOR_NOT_FOUND           = 27;

(*
** MessageId: ERROR_OUT_OF_PAPER
**
** MessageText:
**
**  The printer is out of paper.
*)
        ERROR_OUT_OF_PAPER               = 28;

(*
** MessageId: ERROR_WRITE_FAULT
**
** MessageText:
**
**  The system cannot write to the specified device.
*)
        ERROR_WRITE_FAULT                = 29;

(*
** MessageId: ERROR_READ_FAULT
**
** MessageText:
**
**  The system cannot read from the specified device.
*)
        ERROR_READ_FAULT                 = 30;

(*
** MessageId: ERROR_GEN_FAILURE
**
** MessageText:
**
**  A device attached to the system is not functioning.
*)
        ERROR_GEN_FAILURE                = 31;

(*
** MessageId: ERROR_SHARING_VIOLATION
**
** MessageText:
**
**  The process cannot access the file because
**  it is being used by another process.
*)
        ERROR_SHARING_VIOLATION          = 32;

(*
** MessageId: ERROR_LOCK_VIOLATION
**
** MessageText:
**
**  The process cannot access the file because
**  another process has locked a portion of the file.
*)
        ERROR_LOCK_VIOLATION             = 33;

(*
** MessageId: ERROR_WRONG_DISK
**
** MessageText:
**
**  The wrong diskette is in the drive.
**  Insert %2 (Volume Serial Number: %3)
**  into drive %1.
*)
        ERROR_WRONG_DISK                 = 34;

(*
** MessageId: ERROR_SHARING_BUFFER_EXCEEDED
**
** MessageText:
**
**  Too many files opened for sharing.
*)
        ERROR_SHARING_BUFFER_EXCEEDED    = 36;

(*
** MessageId: ERROR_HANDLE_EOF
**
** MessageText:
**
**  Reached end of file.
*)
        ERROR_HANDLE_EOF                 = 38;

(*
** MessageId: ERROR_HANDLE_DISK_FULL
**
** MessageText:
**
**  The disk is full.
*)
        ERROR_HANDLE_DISK_FULL           = 39;

(*
** MessageId: ERROR_NOT_SUPPORTED
**
** MessageText:
**
**  The network request is not supported.
*)
        ERROR_NOT_SUPPORTED              = 50;

(*
** MessageId: ERROR_REM_NOT_LIST
**
** MessageText:
**
**  The remote computer is not available.
*)
        ERROR_REM_NOT_LIST               = 51;

(*
** MessageId: ERROR_DUP_NAME
**
** MessageText:
**
**  A duplicate name exists on the network.
*)
        ERROR_DUP_NAME                   = 52;

(*
** MessageId: ERROR_BAD_NETPATH
**
** MessageText:
**
**  The network path was not found.
*)
        ERROR_BAD_NETPATH                = 53;

(*
** MessageId: ERROR_NETWORK_BUSY
**
** MessageText:
**
**  The network is busy.
*)
        ERROR_NETWORK_BUSY               = 54;

(*
** MessageId: ERROR_DEV_NOT_EXIST
**
** MessageText:
**
**  The specified network resource or device is no longer
**  available.
*)
        ERROR_DEV_NOT_EXIST              = 55;    (* dderror; *)

(*
** MessageId: ERROR_TOO_MANY_CMDS
**
** MessageText:
**
**  The network BIOS command limit has been reached.
*)
        ERROR_TOO_MANY_CMDS              = 56;

(*
** MessageId: ERROR_ADAP_HDW_ERR
**
** MessageText:
**
**  A network adapter hardware error occurred.
*)
        ERROR_ADAP_HDW_ERR               = 57;

(*
** MessageId: ERROR_BAD_NET_RESP
**
** MessageText:
**
**  The specified server cannot perform the requested
**  operation.
*)
        ERROR_BAD_NET_RESP               = 58;

(*
** MessageId: ERROR_UNEXP_NET_ERR
**
** MessageText:
**
**  An unexpected network error occurred.
*)
        ERROR_UNEXP_NET_ERR              = 59;

(*
** MessageId: ERROR_BAD_REM_ADAP
**
** MessageText:
**
**  The remote adapter is not compatible.
*)
        ERROR_BAD_REM_ADAP               = 60;

(*
** MessageId: ERROR_PRINTQ_FULL
**
** MessageText:
**
**  The printer queue is full.
*)
        ERROR_PRINTQ_FULL                = 61;

(*
** MessageId: ERROR_NO_SPOOL_SPACE
**
** MessageText:
**
**  Space to store the file waiting to be printed is
**  not available on the server.
*)
        ERROR_NO_SPOOL_SPACE             = 62;

(*
** MessageId: ERROR_PRINT_CANCELLED
**
** MessageText:
**
**  Your file waiting to be printed was deleted.
*)
        ERROR_PRINT_CANCELLED            = 63;

(*
** MessageId: ERROR_NETNAME_DELETED
**
** MessageText:
**
**  The specified network name is no longer available.
*)
        ERROR_NETNAME_DELETED            = 64;

(*
** MessageId: ERROR_NETWORK_ACCESS_DENIED
**
** MessageText:
**
**  Network access is denied.
*)
        ERROR_NETWORK_ACCESS_DENIED      = 65;

(*
** MessageId: ERROR_BAD_DEV_TYPE
**
** MessageText:
**
**  The network resource type is not correct.
*)
        ERROR_BAD_DEV_TYPE               = 66;

(*
** MessageId: ERROR_BAD_NET_NAME
**
** MessageText:
**
**  The network name cannot be found.
*)
        ERROR_BAD_NET_NAME               = 67;

(*
** MessageId: ERROR_TOO_MANY_NAMES
**
** MessageText:
**
**  The name limit for the local computer network
**  adapter card was exceeded.
*)
        ERROR_TOO_MANY_NAMES             = 68;

(*
** MessageId: ERROR_TOO_MANY_SESS
**
** MessageText:
**
**  The network BIOS session limit was exceeded.
*)
        ERROR_TOO_MANY_SESS              = 69;

(*
** MessageId: ERROR_SHARING_PAUSED
**
** MessageText:
**
**  The remote server has been paused or is in the
**  process of being started.
*)
        ERROR_SHARING_PAUSED             = 70;

(*
** MessageId: ERROR_REQ_NOT_ACCEP
**
** MessageText:
**
**  No more connections can be made to this remote computer at this time
**  because there are already as many connections as the computer can accept.
*)
        ERROR_REQ_NOT_ACCEP              = 71;

(*
** MessageId: ERROR_REDIR_PAUSED
**
** MessageText:
**
**  The specified printer or disk device has been paused.
*)
        ERROR_REDIR_PAUSED               = 72;

(*
** MessageId: ERROR_FILE_EXISTS
**
** MessageText:
**
**  The file exists.
*)
        ERROR_FILE_EXISTS                = 80;

(*
** MessageId: ERROR_CANNOT_MAKE
**
** MessageText:
**
**  The directory or file cannot be created.
*)
        ERROR_CANNOT_MAKE                = 82;

(*
** MessageId: ERROR_FAIL_I24
**
** MessageText:
**
**  Fail on INT 24
*)
        ERROR_FAIL_I24                   = 83;

(*
** MessageId: ERROR_OUT_OF_STRUCTURES
**
** MessageText:
**
**  Storage to process this request is not available.
*)
        ERROR_OUT_OF_STRUCTURES          = 84;

(*
** MessageId: ERROR_ALREADY_ASSIGNED
**
** MessageText:
**
**  The local device name is already in use.
*)
        ERROR_ALREADY_ASSIGNED           = 85;

(*
** MessageId: ERROR_INVALID_PASSWORD
**
** MessageText:
**
**  The specified network password is not correct.
*)
        ERROR_INVALID_PASSWORD           = 86;

(*
** MessageId: ERROR_INVALID_PARAMETER
**
** MessageText:
**
**  The parameter is incorrect.
*)
        ERROR_INVALID_PARAMETER          = 87;    (* dderror; *)

(*
** MessageId: ERROR_NET_WRITE_FAULT
**
** MessageText:
**
**  A write fault occurred on the network.
*)
        ERROR_NET_WRITE_FAULT            = 88;

(*
** MessageId: ERROR_NO_PROC_SLOTS
**
** MessageText:
**
**  The system cannot start another process at
**  this time.
*)
        ERROR_NO_PROC_SLOTS              = 89;

(*
** MessageId: ERROR_TOO_MANY_SEMAPHORES
**
** MessageText:
**
**  Cannot create another system semaphore.
*)
        ERROR_TOO_MANY_SEMAPHORES        = 100;

(*
** MessageId: ERROR_EXCL_SEM_ALREADY_OWNED
**
** MessageText:
**
**  The exclusive semaphore is owned by another process.
*)
        ERROR_EXCL_SEM_ALREADY_OWNED     = 101;

(*
** MessageId: ERROR_SEM_IS_SET
**
** MessageText:
**
**  The semaphore is set and cannot be closed.
*)
        ERROR_SEM_IS_SET                 = 102;

(*
** MessageId: ERROR_TOO_MANY_SEM_REQUESTS
**
** MessageText:
**
**  The semaphore cannot be set again.
*)
        ERROR_TOO_MANY_SEM_REQUESTS      = 103;

(*
** MessageId: ERROR_INVALID_AT_INTERRUPT_TIME
**
** MessageText:
**
**  Cannot request exclusive semaphores at interrupt time.
*)
        ERROR_INVALID_AT_INTERRUPT_TIME  = 104;

(*
** MessageId: ERROR_SEM_OWNER_DIED
**
** MessageText:
**
**  The previous ownership of this semaphore has ended.
*)
        ERROR_SEM_OWNER_DIED             = 105;

(*
** MessageId: ERROR_SEM_USER_LIMIT
**
** MessageText:
**
**  Insert the diskette for drive %1.
*)
        ERROR_SEM_USER_LIMIT             = 106;

(*
** MessageId: ERROR_DISK_CHANGE
**
** MessageText:
**
**  Program stopped because alternate diskette was not inserted.
*)
        ERROR_DISK_CHANGE                = 107;

(*
** MessageId: ERROR_DRIVE_LOCKED
**
** MessageText:
**
**  The disk is in use or locked by
**  another process.
*)
        ERROR_DRIVE_LOCKED               = 108;

(*
** MessageId: ERROR_BROKEN_PIPE
**
** MessageText:
**
**  The pipe has been ended.
*)
        ERROR_BROKEN_PIPE                = 109;

(*
** MessageId: ERROR_OPEN_FAILED
**
** MessageText:
**
**  The system cannot open the
**  device or file specified.
*)
        ERROR_OPEN_FAILED                = 110;

(*
** MessageId: ERROR_BUFFER_OVERFLOW
**
** MessageText:
**
**  The file name is too long.
*)
        ERROR_BUFFER_OVERFLOW            = 111;

(*
** MessageId: ERROR_DISK_FULL
**
** MessageText:
**
**  There is not enough space on the disk.
*)
        ERROR_DISK_FULL                  = 112;

(*
** MessageId: ERROR_NO_MORE_SEARCH_HANDLES
**
** MessageText:
**
**  No more internal file identifiers available.
*)
        ERROR_NO_MORE_SEARCH_HANDLES     = 113;

(*
** MessageId: ERROR_INVALID_TARGET_HANDLE
**
** MessageText:
**
**  The target internal file identifier is incorrect.
*)
        ERROR_INVALID_TARGET_HANDLE      = 114;

(*
** MessageId: ERROR_INVALID_CATEGORY
**
** MessageText:
**
**  The IOCTL call made by the application program is
**  not correct.
*)
        ERROR_INVALID_CATEGORY           = 117;

(*
** MessageId: ERROR_INVALID_VERIFY_SWITCH
**
** MessageText:
**
**  The verify-on-write switch parameter value is not
**  correct.
*)
        ERROR_INVALID_VERIFY_SWITCH      = 118;

(*
** MessageId: ERROR_BAD_DRIVER_LEVEL
**
** MessageText:
**
**  The system does not support the command requested.
*)
        ERROR_BAD_DRIVER_LEVEL           = 119;

(*
** MessageId: ERROR_CALL_NOT_IMPLEMENTED
**
** MessageText:
**
**  This function is only valid in Win32 mode.
*)
        ERROR_CALL_NOT_IMPLEMENTED       = 120;

(*
** MessageId: ERROR_SEM_TIMEOUT
**
** MessageText:
**
**  The semaphore timeout period has expired.
*)
        ERROR_SEM_TIMEOUT                = 121;

(*
** MessageId: ERROR_INSUFFICIENT_BUFFER
**
** MessageText:
**
**  The data area passed to a system call is too
**  small.
*)
        ERROR_INSUFFICIENT_BUFFER        = 122;    (* dderror; *)

(*
** MessageId: ERROR_INVALID_NAME
**
** MessageText:
**
**  The filename, directory name, or volume label syntax is incorrect.
*)
        ERROR_INVALID_NAME               = 123;

(*
** MessageId: ERROR_INVALID_LEVEL
**
** MessageText:
**
**  The system call level is not correct.
*)
        ERROR_INVALID_LEVEL              = 124;

(*
** MessageId: ERROR_NO_VOLUME_LABEL
**
** MessageText:
**
**  The disk has no volume label.
*)
        ERROR_NO_VOLUME_LABEL            = 125;

(*
** MessageId: ERROR_MOD_NOT_FOUND
**
** MessageText:
**
**  The specified module could not be found.
*)
        ERROR_MOD_NOT_FOUND              = 126;

(*
** MessageId: ERROR_PROC_NOT_FOUND
**
** MessageText:
**
**  The specified procedure could not be found.
*)
        ERROR_PROC_NOT_FOUND             = 127;

(*
** MessageId: ERROR_WAIT_NO_CHILDREN
**
** MessageText:
**
**  There are no child processes to wait for.
*)
        ERROR_WAIT_NO_CHILDREN           = 128;

(*
** MessageId: ERROR_CHILD_NOT_COMPLETE
**
** MessageText:
**
**  The %1 application cannot be run in Win32 mode.
*)
        ERROR_CHILD_NOT_COMPLETE         = 129;

(*
** MessageId: ERROR_DIRECT_ACCESS_HANDLE
**
** MessageText:
**
**  Attempt to use a file handle to an open disk partition for an
**  operation other than raw disk I/O.
*)
        ERROR_DIRECT_ACCESS_HANDLE       = 130;

(*
** MessageId: ERROR_NEGATIVE_SEEK
**
** MessageText:
**
**  An attempt was made to move the file pointer before the beginning of the file.
*)
        ERROR_NEGATIVE_SEEK              = 131;

(*
** MessageId: ERROR_SEEK_ON_DEVICE
**
** MessageText:
**
**  The file pointer cannot be set on the specified device or file.
*)
        ERROR_SEEK_ON_DEVICE             = 132;

(*
** MessageId: ERROR_IS_JOIN_TARGET
**
** MessageText:
**
**  A JOIN or SUBST command
**  cannot be used for a drive that
**  contains previously joined drives.
*)
        ERROR_IS_JOIN_TARGET             = 133;

(*
** MessageId: ERROR_IS_JOINED
**
** MessageText:
**
**  An attempt was made to use a
**  JOIN or SUBST command on a drive that has
**  already been joined.
*)
        ERROR_IS_JOINED                  = 134;

(*
** MessageId: ERROR_IS_SUBSTED
**
** MessageText:
**
**  An attempt was made to use a
**  JOIN or SUBST command on a drive that has
**  already been substituted.
*)
        ERROR_IS_SUBSTED                 = 135;

(*
** MessageId: ERROR_NOT_JOINED
**
** MessageText:
**
**  The system tried to delete
**  the JOIN of a drive that is not joined.
*)
        ERROR_NOT_JOINED                 = 136;

(*
** MessageId: ERROR_NOT_SUBSTED
**
** MessageText:
**
**  The system tried to delete the
**  substitution of a drive that is not substituted.
*)
        ERROR_NOT_SUBSTED                = 137;

(*
** MessageId: ERROR_JOIN_TO_JOIN
**
** MessageText:
**
**  The system tried to join a drive
**  to a directory on a joined drive.
*)
        ERROR_JOIN_TO_JOIN               = 138;

(*
** MessageId: ERROR_SUBST_TO_SUBST
**
** MessageText:
**
**  The system tried to substitute a
**  drive to a directory on a substituted drive.
*)
        ERROR_SUBST_TO_SUBST             = 139;

(*
** MessageId: ERROR_JOIN_TO_SUBST
**
** MessageText:
**
**  The system tried to join a drive to
**  a directory on a substituted drive.
*)
        ERROR_JOIN_TO_SUBST              = 140;

(*
** MessageId: ERROR_SUBST_TO_JOIN
**
** MessageText:
**
**  The system tried to SUBST a drive
**  to a directory on a joined drive.
*)
        ERROR_SUBST_TO_JOIN              = 141;

(*
** MessageId: ERROR_BUSY_DRIVE
**
** MessageText:
**
**  The system cannot perform a JOIN or SUBST at this time.
*)
        ERROR_BUSY_DRIVE                 = 142;

(*
** MessageId: ERROR_SAME_DRIVE
**
** MessageText:
**
**  The system cannot join or substitute a
**  drive to or for a directory on the same drive.
*)
        ERROR_SAME_DRIVE                 = 143;

(*
** MessageId: ERROR_DIR_NOT_ROOT
**
** MessageText:
**
**  The directory is not a subdirectory of the root directory.
*)
        ERROR_DIR_NOT_ROOT               = 144;

(*
** MessageId: ERROR_DIR_NOT_EMPTY
**
** MessageText:
**
**  The directory is not empty.
*)
        ERROR_DIR_NOT_EMPTY              = 145;

(*
** MessageId: ERROR_IS_SUBST_PATH
**
** MessageText:
**
**  The path specified is being used in
**  a substitute.
*)
        ERROR_IS_SUBST_PATH              = 146;

(*
** MessageId: ERROR_IS_JOIN_PATH
**
** MessageText:
**
**  Not enough resources are available to
**  process this command.
*)
        ERROR_IS_JOIN_PATH               = 147;

(*
** MessageId: ERROR_PATH_BUSY
**
** MessageText:
**
**  The path specified cannot be used at this time.
*)
        ERROR_PATH_BUSY                  = 148;

(*
** MessageId: ERROR_IS_SUBST_TARGET
**
** MessageText:
**
**  An attempt was made to join
**  or substitute a drive for which a directory
**  on the drive is the target of a previous
**  substitute.
*)
        ERROR_IS_SUBST_TARGET            = 149;

(*
** MessageId: ERROR_SYSTEM_TRACE
**
** MessageText:
**
**  System trace information was not specified in your
**  CONFIG.SYS file, or tracing is disallowed.
*)
        ERROR_SYSTEM_TRACE               = 150;

(*
** MessageId: ERROR_INVALID_EVENT_COUNT
**
** MessageText:
**
**  The number of specified semaphore events for
**  DosMuxSemWait is not correct.
*)
        ERROR_INVALID_EVENT_COUNT        = 151;

(*
** MessageId: ERROR_TOO_MANY_MUXWAITERS
**
** MessageText:
**
**  DosMuxSemWait did not execute; too many semaphores
**  are already set.
*)
        ERROR_TOO_MANY_MUXWAITERS        = 152;

(*
** MessageId: ERROR_INVALID_LIST_FORMAT
**
** MessageText:
**
**  The DosMuxSemWait list is not correct.
*)
        ERROR_INVALID_LIST_FORMAT        = 153;

(*
** MessageId: ERROR_LABEL_TOO_LONG
**
** MessageText:
**
**  The volume label you entered exceeds the label character
**  limit of the target file system.
*)
        ERROR_LABEL_TOO_LONG             = 154;

(*
** MessageId: ERROR_TOO_MANY_TCBS
**
** MessageText:
**
**  Cannot create another thread.
*)
        ERROR_TOO_MANY_TCBS              = 155;

(*
** MessageId: ERROR_SIGNAL_REFUSED
**
** MessageText:
**
**  The recipient process has refused the signal.
*)
        ERROR_SIGNAL_REFUSED             = 156;

(*
** MessageId: ERROR_DISCARDED
**
** MessageText:
**
**  The segment is already discarded and cannot be locked.
*)
        ERROR_DISCARDED                  = 157;

(*
** MessageId: ERROR_NOT_LOCKED
**
** MessageText:
**
**  The segment is already unlocked.
*)
        ERROR_NOT_LOCKED                 = 158;

(*
** MessageId: ERROR_BAD_THREADID_ADDR
**
** MessageText:
**
**  The address for the thread ID is not correct.
*)
        ERROR_BAD_THREADID_ADDR          = 159;

(*
** MessageId: ERROR_BAD_ARGUMENTS
**
** MessageText:
**
**  The argument string passed to DosExecPgm is not correct.
*)
        ERROR_BAD_ARGUMENTS              = 160;

(*
** MessageId: ERROR_BAD_PATHNAME
**
** MessageText:
**
**  The specified path is invalid.
*)
        ERROR_BAD_PATHNAME               = 161;

(*
** MessageId: ERROR_SIGNAL_PENDING
**
** MessageText:
**
**  A signal is already pending.
*)
        ERROR_SIGNAL_PENDING             = 162;

(*
** MessageId: ERROR_MAX_THRDS_REACHED
**
** MessageText:
**
**  No more threads can be created in the system.
*)
        ERROR_MAX_THRDS_REACHED          = 164;

(*
** MessageId: ERROR_LOCK_FAILED
**
** MessageText:
**
**  Unable to lock a region of a file.
*)
        ERROR_LOCK_FAILED                = 167;

(*
** MessageId: ERROR_BUSY
**
** MessageText:
**
**  The requested resource is in use.
*)
        ERROR_BUSY                       = 170;

(*
** MessageId: ERROR_CANCEL_VIOLATION
**
** MessageText:
**
**  A lock request was not outstanding for the supplied cancel region.
*)
        ERROR_CANCEL_VIOLATION           = 173;

(*
** MessageId: ERROR_ATOMIC_LOCKS_NOT_SUPPORTED
**
** MessageText:
**
**  The file system does not support atomic changes to the lock type.
*)
        ERROR_ATOMIC_LOCKS_NOT_SUPPORTED = 174;

(*
** MessageId: ERROR_INVALID_SEGMENT_NUMBER
**
** MessageText:
**
**  The system detected a segment number that was not correct.
*)
        ERROR_INVALID_SEGMENT_NUMBER     = 180;

(*
** MessageId: ERROR_INVALID_ORDINAL
**
** MessageText:
**
**  The operating system cannot run %1.
*)
        ERROR_INVALID_ORDINAL            = 182;

(*
** MessageId: ERROR_ALREADY_EXISTS
**
** MessageText:
**
**  Cannot create a file when that file already exists.
*)
        ERROR_ALREADY_EXISTS             = 183;

(*
** MessageId: ERROR_INVALID_FLAG_NUMBER
**
** MessageText:
**
**  The flag passed is not correct.
*)
        ERROR_INVALID_FLAG_NUMBER        = 186;

(*
** MessageId: ERROR_SEM_NOT_FOUND
**
** MessageText:
**
**  The specified system semaphore name was not found.
*)
        ERROR_SEM_NOT_FOUND              = 187;

(*
** MessageId: ERROR_INVALID_STARTING_CODESEG
**
** MessageText:
**
**  The operating system cannot run %1.
*)
        ERROR_INVALID_STARTING_CODESEG   = 188;

(*
** MessageId: ERROR_INVALID_STACKSEG
**
** MessageText:
**
**  The operating system cannot run %1.
*)
        ERROR_INVALID_STACKSEG           = 189;

(*
** MessageId: ERROR_INVALID_MODULETYPE
**
** MessageText:
**
**  The operating system cannot run %1.
*)
        ERROR_INVALID_MODULETYPE         = 190;

(*
** MessageId: ERROR_INVALID_EXE_SIGNATURE
**
** MessageText:
**
**  Cannot run %1 in Win32 mode.
*)
        ERROR_INVALID_EXE_SIGNATURE      = 191;

(*
** MessageId: ERROR_EXE_MARKED_INVALID
**
** MessageText:
**
**  The operating system cannot run %1.
*)
        ERROR_EXE_MARKED_INVALID         = 192;

(*
** MessageId: ERROR_BAD_EXE_FORMAT
**
** MessageText:
**
**  %1 is not a valid Win32 application.
*)
        ERROR_BAD_EXE_FORMAT             = 193;

(*
** MessageId: ERROR_ITERATED_DATA_EXCEEDS_64k
**
** MessageText:
**
**  The operating system cannot run %1.
*)
        ERROR_ITERATED_DATA_EXCEEDS_64k  = 194;

(*
** MessageId: ERROR_INVALID_MINALLOCSIZE
**
** MessageText:
**
**  The operating system cannot run %1.
*)
        ERROR_INVALID_MINALLOCSIZE       = 195;

(*
** MessageId: ERROR_DYNLINK_FROM_INVALID_RING
**
** MessageText:
**
**  The operating system cannot run this
**  application program.
*)
        ERROR_DYNLINK_FROM_INVALID_RING  = 196;

(*
** MessageId: ERROR_IOPL_NOT_ENABLED
**
** MessageText:
**
**  The operating system is not presently
**  configured to run this application.
*)
        ERROR_IOPL_NOT_ENABLED           = 197;

(*
** MessageId: ERROR_INVALID_SEGDPL
**
** MessageText:
**
**  The operating system cannot run %1.
*)
        ERROR_INVALID_SEGDPL             = 198;

(*
** MessageId: ERROR_AUTODATASEG_EXCEEDS_64k
**
** MessageText:
**
**  The operating system cannot run this
**  application program.
*)
        ERROR_AUTODATASEG_EXCEEDS_64k    = 199;

(*
** MessageId: ERROR_RING2SEG_MUST_BE_MOVABLE
**
** MessageText:
**
**  The code segment cannot be greater than or equal to 64KB.
*)
        ERROR_RING2SEG_MUST_BE_MOVABLE   = 200;

(*
** MessageId: ERROR_RELOC_CHAIN_XEEDS_SEGLIM
**
** MessageText:
**
**  The operating system cannot run %1.
*)
        ERROR_RELOC_CHAIN_XEEDS_SEGLIM   = 201;

(*
** MessageId: ERROR_INFLOOP_IN_RELOC_CHAIN
**
** MessageText:
**
**  The operating system cannot run %1.
*)
        ERROR_INFLOOP_IN_RELOC_CHAIN     = 202;

(*
** MessageId: ERROR_ENVVAR_NOT_FOUND
**
** MessageText:
**
**  The system could not find the environment
**  option that was entered.
*)
        ERROR_ENVVAR_NOT_FOUND           = 203;

(*
** MessageId: ERROR_NO_SIGNAL_SENT
**
** MessageText:
**
**  No process in the command subtree has a
**  signal handler.
*)
        ERROR_NO_SIGNAL_SENT             = 205;

(*
** MessageId: ERROR_FILENAME_EXCED_RANGE
**
** MessageText:
**
**  The filename or extension is too long.
*)
        ERROR_FILENAME_EXCED_RANGE       = 206;

(*
** MessageId: ERROR_RING2_STACK_IN_USE
**
** MessageText:
**
**  The ring 2 stack is in use.
*)
        ERROR_RING2_STACK_IN_USE         = 207;

(*
** MessageId: ERROR_META_EXPANSION_TOO_LONG
**
** MessageText:
**
**  The global filename characters, * or ?, are entered
**  incorrectly or too many global filename characters are specified.
*)
        ERROR_META_EXPANSION_TOO_LONG    = 208;

(*
** MessageId: ERROR_INVALID_SIGNAL_NUMBER
**
** MessageText:
**
**  The signal being posted is not correct.
*)
        ERROR_INVALID_SIGNAL_NUMBER      = 209;

(*
** MessageId: ERROR_THREAD_1_INACTIVE
**
** MessageText:
**
**  The signal handler cannot be set.
*)
        ERROR_THREAD_1_INACTIVE          = 210;

(*
** MessageId: ERROR_LOCKED
**
** MessageText:
**
**  The segment is locked and cannot be reallocated.
*)
        ERROR_LOCKED                     = 212;

(*
** MessageId: ERROR_TOO_MANY_MODULES
**
** MessageText:
**
**  Too many dynamic link modules are attached to this
**  program or dynamic link module.
*)
        ERROR_TOO_MANY_MODULES           = 214;

(*
** MessageId: ERROR_NESTING_NOT_ALLOWED
**
** MessageText:
**
**  Can't nest calls to LoadModule.
*)
        ERROR_NESTING_NOT_ALLOWED        = 215;

(*
** MessageId: ERROR_BAD_PIPE
**
** MessageText:
**
**  The pipe state is invalid.
*)
        ERROR_BAD_PIPE                   = 230;

(*
** MessageId: ERROR_PIPE_BUSY
**
** MessageText:
**
**  All pipe instances are busy.
*)
        ERROR_PIPE_BUSY                  = 231;

(*
** MessageId: ERROR_NO_DATA
**
** MessageText:
**
**  The pipe is being closed.
*)
        ERROR_NO_DATA                    = 232;

(*
** MessageId: ERROR_PIPE_NOT_CONNECTED
**
** MessageText:
**
**  No process is on the other end of the pipe.
*)
        ERROR_PIPE_NOT_CONNECTED         = 233;

(*
** MessageId: ERROR_MORE_DATA
**
** MessageText:
**
**  More data is available.
*)
        ERROR_MORE_DATA                  = 234;    (* dderror; *)

(*
** MessageId: ERROR_VC_DISCONNECTED
**
** MessageText:
**
**  The session was cancelled.
*)
        ERROR_VC_DISCONNECTED            = 240;

(*
** MessageId: ERROR_INVALID_EA_NAME
**
** MessageText:
**
**  The specified extended attribute name was invalid.
*)
        ERROR_INVALID_EA_NAME            = 254;

(*
** MessageId: ERROR_EA_LIST_INCONSISTENT
**
** MessageText:
**
**  The extended attributes are inconsistent.
*)
        ERROR_EA_LIST_INCONSISTENT       = 255;

(*
** MessageId: ERROR_NO_MORE_ITEMS
**
** MessageText:
**
**  No more data is available.
*)
        ERROR_NO_MORE_ITEMS              = 259;

(*
** MessageId: ERROR_CANNOT_COPY
**
** MessageText:
**
**  The Copy API cannot be used.
*)
        ERROR_CANNOT_COPY                = 266;

(*
** MessageId: ERROR_DIRECTORY
**
** MessageText:
**
**  The directory name is invalid.
*)
        ERROR_DIRECTORY                  = 267;

(*
** MessageId: ERROR_EAS_DIDNT_FIT
**
** MessageText:
**
**  The extended attributes did not fit in the buffer.
*)
        ERROR_EAS_DIDNT_FIT              = 275;

(*
** MessageId: ERROR_EA_FILE_CORRUPT
**
** MessageText:
**
**  The extended attribute file on the mounted file system is corrupt.
*)
        ERROR_EA_FILE_CORRUPT            = 276;

(*
** MessageId: ERROR_EA_TABLE_FULL
**
** MessageText:
**
**  The extended attribute table file is full.
*)
        ERROR_EA_TABLE_FULL              = 277;

(*
** MessageId: ERROR_INVALID_EA_HANDLE
**
** MessageText:
**
**  The specified extended attribute handle is invalid.
*)
        ERROR_INVALID_EA_HANDLE          = 278;

(*
** MessageId: ERROR_EAS_NOT_SUPPORTED
**
** MessageText:
**
**  The mounted file system does not support extended attributes.
*)
        ERROR_EAS_NOT_SUPPORTED          = 282;

(*
** MessageId: ERROR_NOT_OWNER
**
** MessageText:
**
**  Attempt to release mutex not owned by caller.
*)
        ERROR_NOT_OWNER                  = 288;

(*
** MessageId: ERROR_TOO_MANY_POSTS
**
** MessageText:
**
**  Too many posts were made to a semaphore.
*)
        ERROR_TOO_MANY_POSTS             = 298;

(*
** MessageId: ERROR_PARTIAL_COPY
**
** MessageText:
**
**  Only part of a Read/WriteProcessMemory request was completed.
*)
        ERROR_PARTIAL_COPY               = 299;

(*
** MessageId: ERROR_MR_MID_NOT_FOUND
**
** MessageText:
**
**  The system cannot find message for message number 0x%1
**  in message file for %2.
*)
        ERROR_MR_MID_NOT_FOUND           = 317;

(*
** MessageId: ERROR_INVALID_ADDRESS
**
** MessageText:
**
**  Attempt to access invalid address.
*)
        ERROR_INVALID_ADDRESS            = 487;

(*
** MessageId: ERROR_ARITHMETIC_OVERFLOW
**
** MessageText:
**
**  Arithmetic result exceeded 32 bits.
*)
        ERROR_ARITHMETIC_OVERFLOW        = 534;

(*
** MessageId: ERROR_PIPE_CONNECTED
**
** MessageText:
**
**  There is a process on other end of the pipe.
*)
        ERROR_PIPE_CONNECTED             = 535;

(*
** MessageId: ERROR_PIPE_LISTENING
**
** MessageText:
**
**  Waiting for a process to open the other end of the pipe.
*)
        ERROR_PIPE_LISTENING             = 536;

(*
** MessageId: ERROR_EA_ACCESS_DENIED
**
** MessageText:
**
**  Access to the extended attribute was denied.
*)
        ERROR_EA_ACCESS_DENIED           = 994;

(*
** MessageId: ERROR_OPERATION_ABORTED
**
** MessageText:
**
**  The I/O operation has been aborted because of either a thread exit
**  or an application request.
*)
        ERROR_OPERATION_ABORTED          = 995;

(*
** MessageId: ERROR_IO_INCOMPLETE
**
** MessageText:
**
**  Overlapped I/O event is not in a signalled state.
*)
        ERROR_IO_INCOMPLETE              = 996;

(*
** MessageId: ERROR_IO_PENDING
**
** MessageText:
**
**  Overlapped I/O operation is in progress.
*)
        ERROR_IO_PENDING                 = 997;    (* dderror; *)

(*
** MessageId: ERROR_NOACCESS
**
** MessageText:
**
**  Invalid access to memory location.
*)
        ERROR_NOACCESS                   = 998;

(*
** MessageId: ERROR_SWAPERROR
**
** MessageText:
**
**  Error performing inpage operation.
*)
        ERROR_SWAPERROR                  = 999;

(*
** MessageId: ERROR_STACK_OVERFLOW
**
** MessageText:
**
**  Recursion too deep, stack overflowed.
*)
        ERROR_STACK_OVERFLOW             = 1001;

(*
** MessageId: ERROR_INVALID_MESSAGE
**
** MessageText:
**
**  The window cannot act on the sent message.
*)
        ERROR_INVALID_MESSAGE            = 1002;

(*
** MessageId: ERROR_CAN_NOT_COMPLETE
**
** MessageText:
**
**  Cannot complete this function.
*)
        ERROR_CAN_NOT_COMPLETE           = 1003;

(*
** MessageId: ERROR_INVALID_FLAGS
**
** MessageText:
**
**  Invalid flags.
*)
        ERROR_INVALID_FLAGS              = 1004;

(*
** MessageId: ERROR_UNRECOGNIZED_VOLUME
**
** MessageText:
**
**  The volume does not contain a recognized file system.
**  Please make sure that all required file system drivers are loaded and that the
**  volume is not corrupt.
*)
        ERROR_UNRECOGNIZED_VOLUME        = 1005;

(*
** MessageId: ERROR_FILE_INVALID
**
** MessageText:
**
**  The volume for a file has been externally altered such that the
**  opened file is no longer valid.
*)
        ERROR_FILE_INVALID               = 1006;

(*
** MessageId: ERROR_FULLSCREEN_MODE
**
** MessageText:
**
**  The requested operation cannot be performed in full-screen mode.
*)
        ERROR_FULLSCREEN_MODE            = 1007;

(*
** MessageId: ERROR_NO_TOKEN
**
** MessageText:
**
**  An attempt was made to reference a token that does not exist.
*)
        ERROR_NO_TOKEN                   = 1008;

(*
** MessageId: ERROR_BADDB
**
** MessageText:
**
**  The configuration registry database is corrupt.
*)
        ERROR_BADDB                      = 1009;

(*
** MessageId: ERROR_BADKEY
**
** MessageText:
**
**  The configuration registry key is invalid.
*)
        ERROR_BADKEY                     = 1010;

(*
** MessageId: ERROR_CANTOPEN
**
** MessageText:
**
**  The configuration registry key could not be opened.
*)
        ERROR_CANTOPEN                   = 1011;

(*
** MessageId: ERROR_CANTREAD
**
** MessageText:
**
**  The configuration registry key could not be read.
*)
        ERROR_CANTREAD                   = 1012;

(*
** MessageId: ERROR_CANTWRITE
**
** MessageText:
**
**  The configuration registry key could not be written.
*)
        ERROR_CANTWRITE                  = 1013;

(*
** MessageId: ERROR_REGISTRY_RECOVERED
**
** MessageText:
**
**  One of the files in the Registry database had to be recovered
**  by use of a log or alternate copy.  The recovery was successful.
*)
        ERROR_REGISTRY_RECOVERED         = 1014;

(*
** MessageId: ERROR_REGISTRY_CORRUPT
**
** MessageText:
**
**  The Registry is corrupt. The structure of one of the files that contains
**  Registry data is corrupt, or the system's image of the file in memory
**  is corrupt, or the file could not be recovered because the alternate
**  copy or log was absent or corrupt.
*)
        ERROR_REGISTRY_CORRUPT           = 1015;

(*
** MessageId: ERROR_REGISTRY_IO_FAILED
**
** MessageText:
**
**  An I/O operation initiated by the Registry failed unrecoverably.
**  The Registry could not read in, or write out, or flush, one of the files
**  that contain the system's image of the Registry.
*)
        ERROR_REGISTRY_IO_FAILED         = 1016;

(*
** MessageId: ERROR_NOT_REGISTRY_FILE
**
** MessageText:
**
**  The system has attempted to load or restore a file into the Registry, but the
**  specified file is not in a Registry file format.
*)
        ERROR_NOT_REGISTRY_FILE          = 1017;

(*
** MessageId: ERROR_KEY_DELETED
**
** MessageText:
**
**  Illegal operation attempted on a Registry key which has been marked for deletion.
*)
        ERROR_KEY_DELETED                = 1018;

(*
** MessageId: ERROR_NO_LOG_SPACE
**
** MessageText:
**
**  System could not allocate the required space in a Registry log.
*)
        ERROR_NO_LOG_SPACE               = 1019;

(*
** MessageId: ERROR_KEY_HAS_CHILDREN
**
** MessageText:
**
**  Cannot create a symbolic link in a Registry key that already
**  has subkeys or values.
*)
        ERROR_KEY_HAS_CHILDREN           = 1020;

(*
** MessageId: ERROR_CHILD_MUST_BE_VOLATILE
**
** MessageText:
**
**  Cannot create a stable subkey under a volatile parent key.
*)
        ERROR_CHILD_MUST_BE_VOLATILE     = 1021;

(*
** MessageId: ERROR_NOTIFY_ENUM_DIR
**
** MessageText:
**
**  A notify change request is being completed and the information
**  is not being returned in the caller's buffer. The caller now
**  needs to enumerate the files to find the changes.
*)
        ERROR_NOTIFY_ENUM_DIR            = 1022;

(*
** MessageId: ERROR_DEPENDENT_SERVICES_RUNNING
**
** MessageText:
**
**  A stop control has been sent to a service which other running services
**  are dependent on.
*)
        ERROR_DEPENDENT_SERVICES_RUNNING = 1051;

(*
** MessageId: ERROR_INVALID_SERVICE_CONTROL
**
** MessageText:
**
**  The requested control is not valid for this service
*)
        ERROR_INVALID_SERVICE_CONTROL    = 1052;

(*
** MessageId: ERROR_SERVICE_REQUEST_TIMEOUT
**
** MessageText:
**
**  The service did not respond to the start or control request in a timely
**  fashion.
*)
        ERROR_SERVICE_REQUEST_TIMEOUT    = 1053;

(*
** MessageId: ERROR_SERVICE_NO_THREAD
**
** MessageText:
**
**  A thread could not be created for the service.
*)
        ERROR_SERVICE_NO_THREAD          = 1054;

(*
** MessageId: ERROR_SERVICE_DATABASE_LOCKED
**
** MessageText:
**
**  The service database is locked.
*)
        ERROR_SERVICE_DATABASE_LOCKED    = 1055;

(*
** MessageId: ERROR_SERVICE_ALREADY_RUNNING
**
** MessageText:
**
**  An instance of the service is already running.
*)
        ERROR_SERVICE_ALREADY_RUNNING    = 1056;

(*
** MessageId: ERROR_INVALID_SERVICE_ACCOUNT
**
** MessageText:
**
**  The account name is invalid or does not exist.
*)
        ERROR_INVALID_SERVICE_ACCOUNT    = 1057;

(*
** MessageId: ERROR_SERVICE_DISABLED
**
** MessageText:
**
**  The specified service is disabled and cannot be started.
*)
        ERROR_SERVICE_DISABLED           = 1058;

(*
** MessageId: ERROR_CIRCULAR_DEPENDENCY
**
** MessageText:
**
**  Circular service dependency was specified.
*)
        ERROR_CIRCULAR_DEPENDENCY        = 1059;

(*
** MessageId: ERROR_SERVICE_DOES_NOT_EXIST
**
** MessageText:
**
**  The specified service does not exist as an installed service.
*)
        ERROR_SERVICE_DOES_NOT_EXIST     = 1060;

(*
** MessageId: ERROR_SERVICE_CANNOT_ACCEPT_CTRL
**
** MessageText:
**
**  The service cannot accept control messages at this time.
*)
        ERROR_SERVICE_CANNOT_ACCEPT_CTRL = 1061;

(*
** MessageId: ERROR_SERVICE_NOT_ACTIVE
**
** MessageText:
**
**  The service has not been started.
*)
        ERROR_SERVICE_NOT_ACTIVE         = 1062;

(*
** MessageId: ERROR_FAILED_SERVICE_CONTROLLER_CONNECT
**
** MessageText:
**
**  The service process could not connect to the service controller.
*)
        ERROR_FAILED_SERVICE_CONTROLLER_CONNECT = 1063;

(*
** MessageId: ERROR_EXCEPTION_IN_SERVICE
**
** MessageText:
**
**  An exception occurred in the service when handling the control request.
*)
        ERROR_EXCEPTION_IN_SERVICE       = 1064;

(*
** MessageId: ERROR_DATABASE_DOES_NOT_EXIST
**
** MessageText:
**
**  The database specified does not exist.
*)
        ERROR_DATABASE_DOES_NOT_EXIST    = 1065;

(*
** MessageId: ERROR_SERVICE_SPECIFIC_ERROR
**
** MessageText:
**
**  The service has returned a service-specific error code.
*)
        ERROR_SERVICE_SPECIFIC_ERROR     = 1066;

(*
** MessageId: ERROR_PROCESS_ABORTED
**
** MessageText:
**
**  The process terminated unexpectedly.
*)
        ERROR_PROCESS_ABORTED            = 1067;

(*
** MessageId: ERROR_SERVICE_DEPENDENCY_FAIL
**
** MessageText:
**
**  The dependency service or group failed to start.
*)
        ERROR_SERVICE_DEPENDENCY_FAIL    = 1068;

(*
** MessageId: ERROR_SERVICE_LOGON_FAILED
**
** MessageText:
**
**  The service did not start due to a logon failure.
*)
        ERROR_SERVICE_LOGON_FAILED       = 1069;

(*
** MessageId: ERROR_SERVICE_START_HANG
**
** MessageText:
**
**  After starting, the service hung in a start-pending state.
*)
        ERROR_SERVICE_START_HANG         = 1070;

(*
** MessageId: ERROR_INVALID_SERVICE_LOCK
**
** MessageText:
**
**  The specified service database lock is invalid.
*)
        ERROR_INVALID_SERVICE_LOCK       = 1071;

(*
** MessageId: ERROR_SERVICE_MARKED_FOR_DELETE
**
** MessageText:
**
**  The specified service has been marked for deletion.
*)
        ERROR_SERVICE_MARKED_FOR_DELETE  = 1072;

(*
** MessageId: ERROR_SERVICE_EXISTS
**
** MessageText:
**
**  The specified service already exists.
*)
        ERROR_SERVICE_EXISTS             = 1073;

(*
** MessageId: ERROR_ALREADY_RUNNING_LKG
**
** MessageText:
**
**  The system is currently running with the last-known-good configuration.
*)
        ERROR_ALREADY_RUNNING_LKG        = 1074;

(*
** MessageId: ERROR_SERVICE_DEPENDENCY_DELETED
**
** MessageText:
**
**  The dependency service does not exist or has been marked for
**  deletion.
*)
        ERROR_SERVICE_DEPENDENCY_DELETED = 1075;

(*
** MessageId: ERROR_BOOT_ALREADY_ACCEPTED
**
** MessageText:
**
**  The current boot has already been accepted for use as the
**  last-known-good control set.
*)
        ERROR_BOOT_ALREADY_ACCEPTED      = 1076;

(*
** MessageId: ERROR_SERVICE_NEVER_STARTED
**
** MessageText:
**
**  No attempts to start the service have been made since the last boot.
*)
        ERROR_SERVICE_NEVER_STARTED      = 1077;

(*
** MessageId: ERROR_DUPLICATE_SERVICE_NAME
**
** MessageText:
**
**  The name is already in use as either a service name or a service display
**  name.
*)
        ERROR_DUPLICATE_SERVICE_NAME     = 1078;

(*
** MessageId: ERROR_END_OF_MEDIA
**
** MessageText:
**
**  The physical end of the tape has been reached.
*)
        ERROR_END_OF_MEDIA               = 1100;

(*
** MessageId: ERROR_FILEMARK_DETECTED
**
** MessageText:
**
**  A tape access reached a filemark.
*)
        ERROR_FILEMARK_DETECTED          = 1101;

(*
** MessageId: ERROR_BEGINNING_OF_MEDIA
**
** MessageText:
**
**  Beginning of tape or partition was encountered.
*)
        ERROR_BEGINNING_OF_MEDIA         = 1102;

(*
** MessageId: ERROR_SETMARK_DETECTED
**
** MessageText:
**
**  A tape access reached the end of a set of files.
*)
        ERROR_SETMARK_DETECTED           = 1103;

(*
** MessageId: ERROR_NO_DATA_DETECTED
**
** MessageText:
**
**  No more data is on the tape.
*)
        ERROR_NO_DATA_DETECTED           = 1104;

(*
** MessageId: ERROR_PARTITION_FAILURE
**
** MessageText:
**
**  Tape could not be partitioned.
*)
        ERROR_PARTITION_FAILURE          = 1105;

(*
** MessageId: ERROR_INVALID_BLOCK_LENGTH
**
** MessageText:
**
**  When accessing a new tape of a multivolume partition, the current
**  blocksize is incorrect.
*)
        ERROR_INVALID_BLOCK_LENGTH       = 1106;

(*
** MessageId: ERROR_DEVICE_NOT_PARTITIONED
**
** MessageText:
**
**  Tape partition information could not be found when loading a tape.
*)
        ERROR_DEVICE_NOT_PARTITIONED     = 1107;

(*
** MessageId: ERROR_UNABLE_TO_LOCK_MEDIA
**
** MessageText:
**
**  Unable to lock the media eject mechanism.
*)
        ERROR_UNABLE_TO_LOCK_MEDIA       = 1108;

(*
** MessageId: ERROR_UNABLE_TO_UNLOAD_MEDIA
**
** MessageText:
**
**  Unable to unload the media.
*)
        ERROR_UNABLE_TO_UNLOAD_MEDIA     = 1109;

(*
** MessageId: ERROR_MEDIA_CHANGED
**
** MessageText:
**
**  Media in drive may have changed.
*)
        ERROR_MEDIA_CHANGED              = 1110;

(*
** MessageId: ERROR_BUS_RESET
**
** MessageText:
**
**  The I/O bus was reset.
*)
        ERROR_BUS_RESET                  = 1111;

(*
** MessageId: ERROR_NO_MEDIA_IN_DRIVE
**
** MessageText:
**
**  No media in drive.
*)
        ERROR_NO_MEDIA_IN_DRIVE          = 1112;

(*
** MessageId: ERROR_NO_UNICODE_TRANSLATION
**
** MessageText:
**
**  No mapping for the Unicode character exists in the target multi-byte code page.
*)
        ERROR_NO_UNICODE_TRANSLATION     = 1113;

(*
** MessageId: ERROR_DLL_INIT_FAILED
**
** MessageText:
**
**  A dynamic link library (DLL) initialization routine failed.
*)
        ERROR_DLL_INIT_FAILED            = 1114;

(*
** MessageId: ERROR_SHUTDOWN_IN_PROGRESS
**
** MessageText:
**
**  A system shutdown is in progress.
*)
        ERROR_SHUTDOWN_IN_PROGRESS       = 1115;

(*
** MessageId: ERROR_NO_SHUTDOWN_IN_PROGRESS
**
** MessageText:
**
**  Unable to abort the system shutdown because no shutdown was in progress.
*)
        ERROR_NO_SHUTDOWN_IN_PROGRESS    = 1116;

(*
** MessageId: ERROR_IO_DEVICE
**
** MessageText:
**
**  The request could not be performed because of an I/O device error.
*)
        ERROR_IO_DEVICE                  = 1117;

(*
** MessageId: ERROR_SERIAL_NO_DEVICE
**
** MessageText:
**
**  No serial device was successfully initialized.  The serial driver will unload.
*)
        ERROR_SERIAL_NO_DEVICE           = 1118;

(*
** MessageId: ERROR_IRQ_BUSY
**
** MessageText:
**
**  Unable to open a device that was sharing an interrupt request (IRQ)
**  with other devices. At least one other device that uses that IRQ
**  was already opened.
*)
        ERROR_IRQ_BUSY                   = 1119;

(*
** MessageId: ERROR_MORE_WRITES
**
** MessageText:
**
**  A serial I/O operation was completed by another write to the serial port.
**  (The IOCTL_SERIAL_XOFF_COUNTER reached zero.)
*)
        ERROR_MORE_WRITES                = 1120;

(*
** MessageId: ERROR_COUNTER_TIMEOUT
**
** MessageText:
**
**  A serial I/O operation completed because the time-out period expired.
**  (The IOCTL_SERIAL_XOFF_COUNTER did not reach zero.)
*)
        ERROR_COUNTER_TIMEOUT            = 1121;

(*
** MessageId: ERROR_FLOPPY_ID_MARK_NOT_FOUND
**
** MessageText:
**
**  No ID address mark was found on the floppy disk.
*)
        ERROR_FLOPPY_ID_MARK_NOT_FOUND   = 1122;

(*
** MessageId: ERROR_FLOPPY_WRONG_CYLINDER
**
** MessageText:
**
**  Mismatch between the floppy disk sector ID field and the floppy disk
**  controller track address.
*)
        ERROR_FLOPPY_WRONG_CYLINDER      = 1123;

(*
** MessageId: ERROR_FLOPPY_UNKNOWN_ERROR
**
** MessageText:
**
**  The floppy disk controller reported an error that is not recognized
**  by the floppy disk driver.
*)
        ERROR_FLOPPY_UNKNOWN_ERROR       = 1124;

(*
** MessageId: ERROR_FLOPPY_BAD_REGISTERS
**
** MessageText:
**
**  The floppy disk controller returned inconsistent results in its registers.
*)
        ERROR_FLOPPY_BAD_REGISTERS       = 1125;

(*
** MessageId: ERROR_DISK_RECALIBRATE_FAILED
**
** MessageText:
**
**  While accessing the hard disk, a recalibrate operation failed, even after retries.
*)
        ERROR_DISK_RECALIBRATE_FAILED    = 1126;

(*
** MessageId: ERROR_DISK_OPERATION_FAILED
**
** MessageText:
**
**  While accessing the hard disk, a disk operation failed even after retries.
*)
        ERROR_DISK_OPERATION_FAILED      = 1127;

(*
** MessageId: ERROR_DISK_RESET_FAILED
**
** MessageText:
**
**  While accessing the hard disk, a disk controller reset was needed, but
**  even that failed.
*)
        ERROR_DISK_RESET_FAILED          = 1128;

(*
** MessageId: ERROR_EOM_OVERFLOW
**
** MessageText:
**
**  Physical end of tape encountered.
*)
        ERROR_EOM_OVERFLOW               = 1129;

(*
** MessageId: ERROR_NOT_ENOUGH_SERVER_MEMORY
**
** MessageText:
**
**  Not enough server storage is available to process this command.
*)
        ERROR_NOT_ENOUGH_SERVER_MEMORY   = 1130;

(*
** MessageId: ERROR_POSSIBLE_DEADLOCK
**
** MessageText:
**
**  A potential deadlock condition has been detected.
*)
        ERROR_POSSIBLE_DEADLOCK          = 1131;

(*
** MessageId: ERROR_MAPPED_ALIGNMENT
**
** MessageText:
**
**  The base address or the file offset specified does not have the proper
**  alignment.
*)
        ERROR_MAPPED_ALIGNMENT           = 1132;

(*
** MessageId: ERROR_SET_POWER_STATE_VETOED
**
** MessageText:
**
**  An attempt to change the system power state was vetoed by another
**  application or driver.
*)
        ERROR_SET_POWER_STATE_VETOED     = 1140;

(*
** MessageId: ERROR_SET_POWER_STATE_FAILED
**
** MessageText:
**
**  The system BIOS failed an attempt to change the system power state.
*)
        ERROR_SET_POWER_STATE_FAILED     = 1141;

(*
** MessageId: ERROR_OLD_WIN_VERSION
**
** MessageText:
**
**  The specified program requires a newer version of Windows.
*)
        ERROR_OLD_WIN_VERSION            = 1150;

(*
** MessageId: ERROR_APP_WRONG_OS
**
** MessageText:
**
**  The specified program is not a Windows or MS-DOS program.
*)
        ERROR_APP_WRONG_OS               = 1151;

(*
** MessageId: ERROR_SINGLE_INSTANCE_APP
**
** MessageText:
**
**  Cannot start more than one instance of the specified program.
*)
        ERROR_SINGLE_INSTANCE_APP        = 1152;

(*
** MessageId: ERROR_RMODE_APP
**
** MessageText:
**
**  The specified program was written for an older version of Windows.
*)
        ERROR_RMODE_APP                  = 1153;

(*
** MessageId: ERROR_INVALID_DLL
**
** MessageText:
**
**  One of the library files needed to run this application is damaged.
*)
        ERROR_INVALID_DLL                = 1154;

(*
** MessageId: ERROR_NO_ASSOCIATION
**
** MessageText:
**
**  No application is associated with the specified file for this operation.
*)
        ERROR_NO_ASSOCIATION             = 1155;

(*
** MessageId: ERROR_DDE_FAIL
**
** MessageText:
**
**  An error occurred in sending the command to the application.
*)
        ERROR_DDE_FAIL                   = 1156;

(*
** MessageId: ERROR_DLL_NOT_FOUND
**
** MessageText:
**
**  One of the library files needed to run this application cannot be found.
*)
        ERROR_DLL_NOT_FOUND              = 1157;




(**************************
**                       **
** Winnet32 Status Codes **
**                       **
**************************)


(*
** MessageId: ERROR_BAD_USERNAME
**
** MessageText:
**
**  The specified username is invalid.
*)
        ERROR_BAD_USERNAME               = 2202;

(*
** MessageId: ERROR_NOT_CONNECTED
**
** MessageText:
**
**  This network connection does not exist.
*)
        ERROR_NOT_CONNECTED              = 2250;

(*
** MessageId: ERROR_OPEN_FILES
**
** MessageText:
**
**  This network connection has files open or requests pending.
*)
        ERROR_OPEN_FILES                 = 2401;

(*
** MessageId: ERROR_ACTIVE_CONNECTIONS
**
** MessageText:
**
**  Active connections still exist.
*)
        ERROR_ACTIVE_CONNECTIONS         = 2402;

(*
** MessageId: ERROR_DEVICE_IN_USE
**
** MessageText:
**
**  The device is in use by an active process and cannot be disconnected.
*)
        ERROR_DEVICE_IN_USE              = 2404;

(*
** MessageId: ERROR_BAD_DEVICE
**
** MessageText:
**
**  The specified device name is invalid.
*)
        ERROR_BAD_DEVICE                 = 1200;

(*
** MessageId: ERROR_CONNECTION_UNAVAIL
**
** MessageText:
**
**  The device is not currently connected but it is a remembered connection.
*)
        ERROR_CONNECTION_UNAVAIL         = 1201;

(*
** MessageId: ERROR_DEVICE_ALREADY_REMEMBERED
**
** MessageText:
**
**  An attempt was made to remember a device that had previously been remembered.
*)
        ERROR_DEVICE_ALREADY_REMEMBERED  = 1202;

(*
** MessageId: ERROR_NO_NET_OR_BAD_PATH
**
** MessageText:
**
**  No network provider accepted the given network path.
*)
        ERROR_NO_NET_OR_BAD_PATH         = 1203;

(*
** MessageId: ERROR_BAD_PROVIDER
**
** MessageText:
**
**  The specified network provider name is invalid.
*)
        ERROR_BAD_PROVIDER               = 1204;

(*
** MessageId: ERROR_CANNOT_OPEN_PROFILE
**
** MessageText:
**
**  Unable to open the network connection profile.
*)
        ERROR_CANNOT_OPEN_PROFILE        = 1205;

(*
** MessageId: ERROR_BAD_PROFILE
**
** MessageText:
**
**  The network connection profile is corrupt.
*)
        ERROR_BAD_PROFILE                = 1206;

(*
** MessageId: ERROR_NOT_CONTAINER
**
** MessageText:
**
**  Cannot enumerate a non-container.
*)
        ERROR_NOT_CONTAINER              = 1207;

(*
** MessageId: ERROR_EXTENDED_ERROR
**
** MessageText:
**
**  An extended error has occurred.
*)
        ERROR_EXTENDED_ERROR             = 1208;

(*
** MessageId: ERROR_INVALID_GROUPNAME
**
** MessageText:
**
**  The format of the specified group name is invalid.
*)
        ERROR_INVALID_GROUPNAME          = 1209;

(*
** MessageId: ERROR_INVALID_COMPUTERNAME
**
** MessageText:
**
**  The format of the specified computer name is invalid.
*)
        ERROR_INVALID_COMPUTERNAME       = 1210;

(*
** MessageId: ERROR_INVALID_EVENTNAME
**
** MessageText:
**
**  The format of the specified event name is invalid.
*)
        ERROR_INVALID_EVENTNAME          = 1211;

(*
** MessageId: ERROR_INVALID_DOMAINNAME
**
** MessageText:
**
**  The format of the specified domain name is invalid.
*)
        ERROR_INVALID_DOMAINNAME         = 1212;

(*
** MessageId: ERROR_INVALID_SERVICENAME
**
** MessageText:
**
**  The format of the specified service name is invalid.
*)
        ERROR_INVALID_SERVICENAME        = 1213;

(*
** MessageId: ERROR_INVALID_NETNAME
**
** MessageText:
**
**  The format of the specified network name is invalid.
*)
        ERROR_INVALID_NETNAME            = 1214;

(*
** MessageId: ERROR_INVALID_SHARENAME
**
** MessageText:
**
**  The format of the specified share name is invalid.
*)
        ERROR_INVALID_SHARENAME          = 1215;

(*
** MessageId: ERROR_INVALID_PASSWORDNAME
**
** MessageText:
**
**  The format of the specified password is invalid.
*)
        ERROR_INVALID_PASSWORDNAME       = 1216;

(*
** MessageId: ERROR_INVALID_MESSAGENAME
**
** MessageText:
**
**  The format of the specified message name is invalid.
*)
        ERROR_INVALID_MESSAGENAME        = 1217;

(*
** MessageId: ERROR_INVALID_MESSAGEDEST
**
** MessageText:
**
**  The format of the specified message destination is invalid.
*)
        ERROR_INVALID_MESSAGEDEST        = 1218;

(*
** MessageId: ERROR_SESSION_CREDENTIAL_CONFLICT
**
** MessageText:
**
**  The credentials supplied conflict with an existing set of credentials.
*)
        ERROR_SESSION_CREDENTIAL_CONFLICT = 1219;

(*
** MessageId: ERROR_REMOTE_SESSION_LIMIT_EXCEEDED
**
** MessageText:
**
**  An attempt was made to establish a session to a network server, but there
**  are already too many sessions established to that server.
*)
        ERROR_REMOTE_SESSION_LIMIT_EXCEEDED = 1220;

(*
** MessageId: ERROR_DUP_DOMAINNAME
**
** MessageText:
**
**  The workgroup or domain name is already in use by another computer on the
**  network.
*)
        ERROR_DUP_DOMAINNAME             = 1221;

(*
** MessageId: ERROR_NO_NETWORK
**
** MessageText:
**
**  The network is not present or not started.
*)
        ERROR_NO_NETWORK                 = 1222;

(*
** MessageId: ERROR_CANCELLED
**
** MessageText:
**
**  The operation was cancelled by the user.
*)
        ERROR_CANCELLED                  = 1223;

(*
** MessageId: ERROR_USER_MAPPED_FILE
**
** MessageText:
**
**  The requested operation cannot be performed on a file with a user mapped section open.
*)
        ERROR_USER_MAPPED_FILE           = 1224;

(*
** MessageId: ERROR_CONNECTION_REFUSED
**
** MessageText:
**
**  The remote system refused the network connection.
*)
        ERROR_CONNECTION_REFUSED         = 1225;

(*
** MessageId: ERROR_GRACEFUL_DISCONNECT
**
** MessageText:
**
**  The network connection was gracefully closed.
*)
        ERROR_GRACEFUL_DISCONNECT        = 1226;

(*
** MessageId: ERROR_ADDRESS_ALREADY_ASSOCIATED
**
** MessageText:
**
**  The network transport endpoint already has an address associated with it.
*)
        ERROR_ADDRESS_ALREADY_ASSOCIATED = 1227;

(*
** MessageId: ERROR_ADDRESS_NOT_ASSOCIATED
**
** MessageText:
**
**  An address has not yet been associated with the network endpoint.
*)
        ERROR_ADDRESS_NOT_ASSOCIATED     = 1228;

(*
** MessageId: ERROR_CONNECTION_INVALID
**
** MessageText:
**
**  An operation was attempted on a non-existent network connection.
*)
        ERROR_CONNECTION_INVALID         = 1229;

(*
** MessageId: ERROR_CONNECTION_ACTIVE
**
** MessageText:
**
**  An invalid operation was attempted on an active network connection.
*)
        ERROR_CONNECTION_ACTIVE          = 1230;

(*
** MessageId: ERROR_NETWORK_UNREACHABLE
**
** MessageText:
**
**  The remote network is not reachable by the transport.
*)
        ERROR_NETWORK_UNREACHABLE        = 1231;

(*
** MessageId: ERROR_HOST_UNREACHABLE
**
** MessageText:
**
**  The remote system is not reachable by the transport.
*)
        ERROR_HOST_UNREACHABLE           = 1232;

(*
** MessageId: ERROR_PROTOCOL_UNREACHABLE
**
** MessageText:
**
**  The remote system does not support the transport protocol.
*)
        ERROR_PROTOCOL_UNREACHABLE       = 1233;

(*
** MessageId: ERROR_PORT_UNREACHABLE
**
** MessageText:
**
**  No service is operating at the destination network endpoint
**  on the remote system.
*)
        ERROR_PORT_UNREACHABLE           = 1234;

(*
** MessageId: ERROR_REQUEST_ABORTED
**
** MessageText:
**
**  The request was aborted.
*)
        ERROR_REQUEST_ABORTED            = 1235;

(*
** MessageId: ERROR_CONNECTION_ABORTED
**
** MessageText:
**
**  The network connection was aborted by the local system.
*)
        ERROR_CONNECTION_ABORTED         = 1236;

(*
** MessageId: ERROR_RETRY
**
** MessageText:
**
**  The operation could not be completed.  A retry should be performed.
*)
        ERROR_RETRY                      = 1237;

(*
** MessageId: ERROR_CONNECTION_COUNT_LIMIT
**
** MessageText:
**
**  A connection to the server could not be made because the limit on the number of
**  concurrent connections for this account has been reached.
*)
        ERROR_CONNECTION_COUNT_LIMIT     = 1238;

(*
** MessageId: ERROR_LOGIN_TIME_RESTRICTION
**
** MessageText:
**
**  Attempting to login during an unauthorized time of day for this account.
*)
        ERROR_LOGIN_TIME_RESTRICTION     = 1239;

(*
** MessageId: ERROR_LOGIN_WKSTA_RESTRICTION
**
** MessageText:
**
**  The account is not authorized to login from this station.
*)
        ERROR_LOGIN_WKSTA_RESTRICTION    = 1240;

(*
** MessageId: ERROR_INCORRECT_ADDRESS
**
** MessageText:
**
**  The network address could not be used for the operation requested.
*)
        ERROR_INCORRECT_ADDRESS          = 1241;

(*
** MessageId: ERROR_ALREADY_REGISTERED
**
** MessageText:
**
**  The service is already registered.
*)
        ERROR_ALREADY_REGISTERED         = 1242;

(*
** MessageId: ERROR_SERVICE_NOT_FOUND
**
** MessageText:
**
**  The specified service does not exist.
*)
        ERROR_SERVICE_NOT_FOUND          = 1243;

(*
** MessageId: ERROR_NOT_AUTHENTICATED
**
** MessageText:
**
**  The operation being requested was not performed because the user
**  has not been authenticated.
*)
        ERROR_NOT_AUTHENTICATED          = 1244;

(*
** MessageId: ERROR_NOT_LOGGED_ON
**
** MessageText:
**
**  The operation being requested was not performed because the user
**  has not logged on to the network.
**  The specified service does not exist.
*)
        ERROR_NOT_LOGGED_ON              = 1245;

(*
** MessageId: ERROR_CONTINUE
**
** MessageText:
**
**  Return that wants caller to continue with work in progress.
*)
        ERROR_CONTINUE                   = 1246;

(*
** MessageId: ERROR_ALREADY_INITIALIZED
**
** MessageText:
**
**  An attempt was made to perform an initialization operation when
**  initialization has already been completed.
*)
        ERROR_ALREADY_INITIALIZED        = 1247;

(*
** MessageId: ERROR_NO_MORE_DEVICES
**
** MessageText:
**
**  No more local devices.
*)
        ERROR_NO_MORE_DEVICES            = 1248;




(**************************
**                       **
** Security Status Codes **
**                       **
**************************)


(*
** MessageId: ERROR_NOT_ALL_ASSIGNED
**
** MessageText:
**
**  Not all privileges referenced are assigned to the caller.
*)
        ERROR_NOT_ALL_ASSIGNED           = 1300;

(*
** MessageId: ERROR_SOME_NOT_MAPPED
**
** MessageText:
**
**  Some mapping between account names and security IDs was not done.
*)
        ERROR_SOME_NOT_MAPPED            = 1301;

(*
** MessageId: ERROR_NO_QUOTAS_FOR_ACCOUNT
**
** MessageText:
**
**  No system quota limits are specifically set for this account.
*)
        ERROR_NO_QUOTAS_FOR_ACCOUNT      = 1302;

(*
** MessageId: ERROR_LOCAL_USER_SESSION_KEY
**
** MessageText:
**
**  No encryption key is available.  A well-known encryption key was returned.
*)
        ERROR_LOCAL_USER_SESSION_KEY     = 1303;

(*
** MessageId: ERROR_NULL_LM_PASSWORD
**
** MessageText:
**
**  The NT password is too complex to be converted to a LAN Manager
**  password.  The LAN Manager password returned is a NULL string.
*)
        ERROR_NULL_LM_PASSWORD           = 1304;

(*
** MessageId: ERROR_UNKNOWN_REVISION
**
** MessageText:
**
**  The revision level is unknown.
*)
        ERROR_UNKNOWN_REVISION           = 1305;

(*
** MessageId: ERROR_REVISION_MISMATCH
**
** MessageText:
**
**  Indicates two revision levels are incompatible.
*)
        ERROR_REVISION_MISMATCH          = 1306;

(*
** MessageId: ERROR_INVALID_OWNER
**
** MessageText:
**
**  This security ID may not be assigned as the owner of this object.
*)
        ERROR_INVALID_OWNER              = 1307;

(*
** MessageId: ERROR_INVALID_PRIMARY_GROUP
**
** MessageText:
**
**  This security ID may not be assigned as the primary group of an object.
*)
        ERROR_INVALID_PRIMARY_GROUP      = 1308;

(*
** MessageId: ERROR_NO_IMPERSONATION_TOKEN
**
** MessageText:
**
**  An attempt has been made to operate on an impersonation token
**  by a thread that is not currently impersonating a client.
*)
        ERROR_NO_IMPERSONATION_TOKEN     = 1309;

(*
** MessageId: ERROR_CANT_DISABLE_MANDATORY
**
** MessageText:
**
**  The group may not be disabled.
*)
        ERROR_CANT_DISABLE_MANDATORY     = 1310;

(*
** MessageId: ERROR_NO_LOGON_SERVERS
**
** MessageText:
**
**  There are currently no logon servers available to service the logon
**  request.
*)
        ERROR_NO_LOGON_SERVERS           = 1311;

(*
** MessageId: ERROR_NO_SUCH_LOGON_SESSION
**
** MessageText:
**
**   A specified logon session does not exist.  It may already have
**   been terminated.
*)
        ERROR_NO_SUCH_LOGON_SESSION      = 1312;

(*
** MessageId: ERROR_NO_SUCH_PRIVILEGE
**
** MessageText:
**
**   A specified privilege does not exist.
*)
        ERROR_NO_SUCH_PRIVILEGE          = 1313;

(*
** MessageId: ERROR_PRIVILEGE_NOT_HELD
**
** MessageText:
**
**   A required privilege is not held by the client.
*)
        ERROR_PRIVILEGE_NOT_HELD         = 1314;

(*
** MessageId: ERROR_INVALID_ACCOUNT_NAME
**
** MessageText:
**
**  The name provided is not a properly formed account name.
*)
        ERROR_INVALID_ACCOUNT_NAME       = 1315;

(*
** MessageId: ERROR_USER_EXISTS
**
** MessageText:
**
**  The specified user already exists.
*)
        ERROR_USER_EXISTS                = 1316;

(*
** MessageId: ERROR_NO_SUCH_USER
**
** MessageText:
**
**  The specified user does not exist.
*)
        ERROR_NO_SUCH_USER               = 1317;

(*
** MessageId: ERROR_GROUP_EXISTS
**
** MessageText:
**
**  The specified group already exists.
*)
        ERROR_GROUP_EXISTS               = 1318;

(*
** MessageId: ERROR_NO_SUCH_GROUP
**
** MessageText:
**
**  The specified group does not exist.
*)
        ERROR_NO_SUCH_GROUP              = 1319;

(*
** MessageId: ERROR_MEMBER_IN_GROUP
**
** MessageText:
**
**  Either the specified user account is already a member of the specified
**  group, or the specified group cannot be deleted because it contains
**  a member.
*)
        ERROR_MEMBER_IN_GROUP            = 1320;

(*
** MessageId: ERROR_MEMBER_NOT_IN_GROUP
**
** MessageText:
**
**  The specified user account is not a member of the specified group account.
*)
        ERROR_MEMBER_NOT_IN_GROUP        = 1321;

(*
** MessageId: ERROR_LAST_ADMIN
**
** MessageText:
**
**  The last remaining administration account cannot be disabled
**  or deleted.
*)
        ERROR_LAST_ADMIN                 = 1322;

(*
** MessageId: ERROR_WRONG_PASSWORD
**
** MessageText:
**
**  Unable to update the password.  The value provided as the current
**  password is incorrect.
*)
        ERROR_WRONG_PASSWORD             = 1323;

(*
** MessageId: ERROR_ILL_FORMED_PASSWORD
**
** MessageText:
**
**  Unable to update the password.  The value provided for the new password
**  contains values that are not allowed in passwords.
*)
        ERROR_ILL_FORMED_PASSWORD        = 1324;

(*
** MessageId: ERROR_PASSWORD_RESTRICTION
**
** MessageText:
**
**  Unable to update the password because a password update rule has been
**  violated.
*)
        ERROR_PASSWORD_RESTRICTION       = 1325;

(*
** MessageId: ERROR_LOGON_FAILURE
**
** MessageText:
**
**  Logon failure: unknown user name or bad password.
*)
        ERROR_LOGON_FAILURE              = 1326;

(*
** MessageId: ERROR_ACCOUNT_RESTRICTION
**
** MessageText:
**
**  Logon failure: user account restriction.
*)
        ERROR_ACCOUNT_RESTRICTION        = 1327;

(*
** MessageId: ERROR_INVALID_LOGON_HOURS
**
** MessageText:
**
**  Logon failure: account logon time restriction violation.
*)
        ERROR_INVALID_LOGON_HOURS        = 1328;

(*
** MessageId: ERROR_INVALID_WORKSTATION
**
** MessageText:
**
**  Logon failure: user not allowed to log on to this computer.
*)
        ERROR_INVALID_WORKSTATION        = 1329;

(*
** MessageId: ERROR_PASSWORD_EXPIRED
**
** MessageText:
**
**  Logon failure: the specified account password has expired.
*)
        ERROR_PASSWORD_EXPIRED           = 1330;

(*
** MessageId: ERROR_ACCOUNT_DISABLED
**
** MessageText:
**
**  Logon failure: account currently disabled.
*)
        ERROR_ACCOUNT_DISABLED           = 1331;

(*
** MessageId: ERROR_NONE_MAPPED
**
** MessageText:
**
**  No mapping between account names and security IDs was done.
*)
        ERROR_NONE_MAPPED                = 1332;

(*
** MessageId: ERROR_TOO_MANY_LUIDS_REQUESTED
**
** MessageText:
**
**  Too many local user identifiers (LUIDs) were requested at one time.
*)
        ERROR_TOO_MANY_LUIDS_REQUESTED   = 1333;

(*
** MessageId: ERROR_LUIDS_EXHAUSTED
**
** MessageText:
**
**  No more local user identifiers (LUIDs) are available.
*)
        ERROR_LUIDS_EXHAUSTED            = 1334;

(*
** MessageId: ERROR_INVALID_SUB_AUTHORITY
**
** MessageText:
**
**  The subauthority part of a security ID is invalid for this particular use.
*)
        ERROR_INVALID_SUB_AUTHORITY      = 1335;

(*
** MessageId: ERROR_INVALID_ACL
**
** MessageText:
**
**  The access control list (ACL) structure is invalid.
*)
        ERROR_INVALID_ACL                = 1336;

(*
** MessageId: ERROR_INVALID_SID
**
** MessageText:
**
**  The security ID structure is invalid.
*)
        ERROR_INVALID_SID                = 1337;

(*
** MessageId: ERROR_INVALID_SECURITY_DESCR
**
** MessageText:
**
**  The security descriptor structure is invalid.
*)
        ERROR_INVALID_SECURITY_DESCR     = 1338;

(*
** MessageId: ERROR_BAD_INHERITANCE_ACL
**
** MessageText:
**
**  The inherited access control list (ACL) or access control entry (ACE)
**  could not be built.
*)
        ERROR_BAD_INHERITANCE_ACL        = 1340;

(*
** MessageId: ERROR_SERVER_DISABLED
**
** MessageText:
**
**  The server is currently disabled.
*)
        ERROR_SERVER_DISABLED            = 1341;

(*
** MessageId: ERROR_SERVER_NOT_DISABLED
**
** MessageText:
**
**  The server is currently enabled.
*)
        ERROR_SERVER_NOT_DISABLED        = 1342;

(*
** MessageId: ERROR_INVALID_ID_AUTHORITY
**
** MessageText:
**
**  The value provided was an invalid value for an identifier authority.
*)
        ERROR_INVALID_ID_AUTHORITY       = 1343;

(*
** MessageId: ERROR_ALLOTTED_SPACE_EXCEEDED
**
** MessageText:
**
**  No more memory is available for security information updates.
*)
        ERROR_ALLOTTED_SPACE_EXCEEDED    = 1344;

(*
** MessageId: ERROR_INVALID_GROUP_ATTRIBUTES
**
** MessageText:
**
**  The specified attributes are invalid, or incompatible with the
**  attributes for the group as a whole.
*)
        ERROR_INVALID_GROUP_ATTRIBUTES   = 1345;

(*
** MessageId: ERROR_BAD_IMPERSONATION_LEVEL
**
** MessageText:
**
**  Either a required impersonation level was not provided, or the
**  provided impersonation level is invalid.
*)
        ERROR_BAD_IMPERSONATION_LEVEL    = 1346;

(*
** MessageId: ERROR_CANT_OPEN_ANONYMOUS
**
** MessageText:
**
**  Cannot open an anonymous level security token.
*)
        ERROR_CANT_OPEN_ANONYMOUS        = 1347;

(*
** MessageId: ERROR_BAD_VALIDATION_CLASS
**
** MessageText:
**
**  The validation information class requested was invalid.
*)
        ERROR_BAD_VALIDATION_CLASS       = 1348;

(*
** MessageId: ERROR_BAD_TOKEN_TYPE
**
** MessageText:
**
**  The type of the token is inappropriate for its attempted use.
*)
        ERROR_BAD_TOKEN_TYPE             = 1349;

(*
** MessageId: ERROR_NO_SECURITY_ON_OBJECT
**
** MessageText:
**
**  Unable to perform a security operation on an object
**  which has no associated security.
*)
        ERROR_NO_SECURITY_ON_OBJECT      = 1350;

(*
** MessageId: ERROR_CANT_ACCESS_DOMAIN_INFO
**
** MessageText:
**
**  Indicates a Windows NT Server could not be contacted or that
**  objects within the domain are protected such that necessary
**  information could not be retrieved.
*)
        ERROR_CANT_ACCESS_DOMAIN_INFO    = 1351;

(*
** MessageId: ERROR_INVALID_SERVER_STATE
**
** MessageText:
**
**  The security account manager (SAM) or local security
**  authority (LSA) server was in the wrong state to perform
**  the security operation.
*)
        ERROR_INVALID_SERVER_STATE       = 1352;

(*
** MessageId: ERROR_INVALID_DOMAIN_STATE
**
** MessageText:
**
**  The domain was in the wrong state to perform the security operation.
*)
        ERROR_INVALID_DOMAIN_STATE       = 1353;

(*
** MessageId: ERROR_INVALID_DOMAIN_ROLE
**
** MessageText:
**
**  This operation is only allowed for the Primary Domain Controller of the domain.
*)
        ERROR_INVALID_DOMAIN_ROLE        = 1354;

(*
** MessageId: ERROR_NO_SUCH_DOMAIN
**
** MessageText:
**
**  The specified domain did not exist.
*)
        ERROR_NO_SUCH_DOMAIN             = 1355;

(*
** MessageId: ERROR_DOMAIN_EXISTS
**
** MessageText:
**
**  The specified domain already exists.
*)
        ERROR_DOMAIN_EXISTS              = 1356;

(*
** MessageId: ERROR_DOMAIN_LIMIT_EXCEEDED
**
** MessageText:
**
**  An attempt was made to exceed the limit on the number of domains per server.
*)
        ERROR_DOMAIN_LIMIT_EXCEEDED      = 1357;

(*
** MessageId: ERROR_INTERNAL_DB_CORRUPTION
**
** MessageText:
**
**  Unable to complete the requested operation because of either a
**  catastrophic media failure or a data structure corruption on the disk.
*)
        ERROR_INTERNAL_DB_CORRUPTION     = 1358;

(*
** MessageId: ERROR_INTERNAL_ERROR
**
** MessageText:
**
**  The security account database contains an internal inconsistency.
*)
        ERROR_INTERNAL_ERROR             = 1359;

(*
** MessageId: ERROR_GENERIC_NOT_MAPPED
**
** MessageText:
**
**  Generic access types were contained in an access mask which should
**  already be mapped to non-generic types.
*)
        ERROR_GENERIC_NOT_MAPPED         = 1360;

(*
** MessageId: ERROR_BAD_DESCRIPTOR_FORMAT
**
** MessageText:
**
**  A security descriptor is not in the right format (absolute or self-relative).
*)
        ERROR_BAD_DESCRIPTOR_FORMAT      = 1361;

(*
** MessageId: ERROR_NOT_LOGON_PROCESS
**
** MessageText:
**
**  The requested action is restricted for use by logon processes
**  only.  The calling process has not registered as a logon process.
*)
        ERROR_NOT_LOGON_PROCESS          = 1362;

(*
** MessageId: ERROR_LOGON_SESSION_EXISTS
**
** MessageText:
**
**  Cannot start a new logon session with an ID that is already in use.
*)
        ERROR_LOGON_SESSION_EXISTS       = 1363;

(*
** MessageId: ERROR_NO_SUCH_PACKAGE
**
** MessageText:
**
**  A specified authentication package is unknown.
*)
        ERROR_NO_SUCH_PACKAGE            = 1364;

(*
** MessageId: ERROR_BAD_LOGON_SESSION_STATE
**
** MessageText:
**
**  The logon session is not in a state that is consistent with the
**  requested operation.
*)
        ERROR_BAD_LOGON_SESSION_STATE    = 1365;

(*
** MessageId: ERROR_LOGON_SESSION_COLLISION
**
** MessageText:
**
**  The logon session ID is already in use.
*)
        ERROR_LOGON_SESSION_COLLISION    = 1366;

(*
** MessageId: ERROR_INVALID_LOGON_TYPE
**
** MessageText:
**
**  A logon request contained an invalid logon type value.
*)
        ERROR_INVALID_LOGON_TYPE         = 1367;

(*
** MessageId: ERROR_CANNOT_IMPERSONATE
**
** MessageText:
**
**  Unable to impersonate via a named pipe until data has been read
**  from that pipe.
*)
        ERROR_CANNOT_IMPERSONATE         = 1368;

(*
** MessageId: ERROR_RXACT_INVALID_STATE
**
** MessageText:
**
**  The transaction state of a Registry subtree is incompatible with the
**  requested operation.
*)
        ERROR_RXACT_INVALID_STATE        = 1369;

(*
** MessageId: ERROR_RXACT_COMMIT_FAILURE
**
** MessageText:
**
**  An internal security database corruption has been encountered.
*)
        ERROR_RXACT_COMMIT_FAILURE       = 1370;

(*
** MessageId: ERROR_SPECIAL_ACCOUNT
**
** MessageText:
**
**  Cannot perform this operation on built-in accounts.
*)
        ERROR_SPECIAL_ACCOUNT            = 1371;

(*
** MessageId: ERROR_SPECIAL_GROUP
**
** MessageText:
**
**  Cannot perform this operation on this built-in special group.
*)
        ERROR_SPECIAL_GROUP              = 1372;

(*
** MessageId: ERROR_SPECIAL_USER
**
** MessageText:
**
**  Cannot perform this operation on this built-in special user.
*)
        ERROR_SPECIAL_USER               = 1373;

(*
** MessageId: ERROR_MEMBERS_PRIMARY_GROUP
**
** MessageText:
**
**  The user cannot be removed from a group because the group
**  is currently the user's primary group.
*)
        ERROR_MEMBERS_PRIMARY_GROUP      = 1374;

(*
** MessageId: ERROR_TOKEN_ALREADY_IN_USE
**
** MessageText:
**
**  The token is already in use as a primary token.
*)
        ERROR_TOKEN_ALREADY_IN_USE       = 1375;

(*
** MessageId: ERROR_NO_SUCH_ALIAS
**
** MessageText:
**
**  The specified local group does not exist.
*)
        ERROR_NO_SUCH_ALIAS              = 1376;

(*
** MessageId: ERROR_MEMBER_NOT_IN_ALIAS
**
** MessageText:
**
**  The specified account name is not a member of the local group.
*)
        ERROR_MEMBER_NOT_IN_ALIAS        = 1377;

(*
** MessageId: ERROR_MEMBER_IN_ALIAS
**
** MessageText:
**
**  The specified account name is already a member of the local group.
*)
        ERROR_MEMBER_IN_ALIAS            = 1378;

(*
** MessageId: ERROR_ALIAS_EXISTS
**
** MessageText:
**
**  The specified local group already exists.
*)
        ERROR_ALIAS_EXISTS               = 1379;

(*
** MessageId: ERROR_LOGON_NOT_GRANTED
**
** MessageText:
**
**  Logon failure: the user has not been granted the requested
**  logon type at this computer.
*)
        ERROR_LOGON_NOT_GRANTED          = 1380;

(*
** MessageId: ERROR_TOO_MANY_SECRETS
**
** MessageText:
**
**  The maximum number of secrets that may be stored in a single system has been
**  exceeded.
*)
        ERROR_TOO_MANY_SECRETS           = 1381;

(*
** MessageId: ERROR_SECRET_TOO_LONG
**
** MessageText:
**
**  The length of a secret exceeds the maximum length allowed.
*)
        ERROR_SECRET_TOO_LONG            = 1382;

(*
** MessageId: ERROR_INTERNAL_DB_ERROR
**
** MessageText:
**
**  The local security authority database contains an internal inconsistency.
*)
        ERROR_INTERNAL_DB_ERROR          = 1383;

(*
** MessageId: ERROR_TOO_MANY_CONTEXT_IDS
**
** MessageText:
**
**  During a logon attempt, the user's security context accumulated too many
**  security IDs.
*)
        ERROR_TOO_MANY_CONTEXT_IDS       = 1384;

(*
** MessageId: ERROR_LOGON_TYPE_NOT_GRANTED
**
** MessageText:
**
**  Logon failure: the user has not been granted the requested logon type
**  at this computer.
*)
        ERROR_LOGON_TYPE_NOT_GRANTED     = 1385;

(*
** MessageId: ERROR_NT_CROSS_ENCRYPTION_REQUIRED
**
** MessageText:
**
**  A cross-encrypted password is necessary to change a user password.
*)
        ERROR_NT_CROSS_ENCRYPTION_REQUIRED = 1386;

(*
** MessageId: ERROR_NO_SUCH_MEMBER
**
** MessageText:
**
**  A new member could not be added to a local group because the member does
**  not exist.
*)
        ERROR_NO_SUCH_MEMBER             = 1387;

(*
** MessageId: ERROR_INVALID_MEMBER
**
** MessageText:
**
**  A new member could not be added to a local group because the member has the
**  wrong account type.
*)
        ERROR_INVALID_MEMBER             = 1388;

(*
** MessageId: ERROR_TOO_MANY_SIDS
**
** MessageText:
**
**  Too many security IDs have been specified.
*)
        ERROR_TOO_MANY_SIDS              = 1389;

(*
** MessageId: ERROR_LM_CROSS_ENCRYPTION_REQUIRED
**
** MessageText:
**
**  A cross-encrypted password is necessary to change this user password.
*)
        ERROR_LM_CROSS_ENCRYPTION_REQUIRED = 1390;

(*
** MessageId: ERROR_NO_INHERITANCE
**
** MessageText:
**
**  Indicates an ACL contains no inheritable components
*)
        ERROR_NO_INHERITANCE             = 1391;

(*
** MessageId: ERROR_FILE_CORRUPT
**
** MessageText:
**
**  The file or directory is corrupt and non-readable.
*)
        ERROR_FILE_CORRUPT               = 1392;

(*
** MessageId: ERROR_DISK_CORRUPT
**
** MessageText:
**
**  The disk structure is corrupt and non-readable.
*)
        ERROR_DISK_CORRUPT               = 1393;

(*
** MessageId: ERROR_NO_USER_SESSION_KEY
**
** MessageText:
**
**  There is no user session key for the specified logon session.
*)
        ERROR_NO_USER_SESSION_KEY        = 1394;

(*
** MessageId: ERROR_LICENSE_QUOTA_EXCEEDED
**
** MessageText:
**
**  The service being accessed is licensed for a particular number of
**  connections. No more connections can be made to the service at this time
**  because there are already as many connections as the service can accept.
*)
        ERROR_LICENSE_QUOTA_EXCEEDED     = 1395;

(* End of security error codes



(**************************
**                       **
** WinUser Error Codes   **
**                       **
**************************)


(*
** MessageId: ERROR_INVALID_WINDOW_HANDLE
**
** MessageText:
**
**  Invalid window handle.
*)
        ERROR_INVALID_WINDOW_HANDLE      = 1400;

(*
** MessageId: ERROR_INVALID_MENU_HANDLE
**
** MessageText:
**
**  Invalid menu handle.
*)
        ERROR_INVALID_MENU_HANDLE        = 1401;

(*
** MessageId: ERROR_INVALID_CURSOR_HANDLE
**
** MessageText:
**
**  Invalid cursor handle.
*)
        ERROR_INVALID_CURSOR_HANDLE      = 1402;

(*
** MessageId: ERROR_INVALID_ACCEL_HANDLE
**
** MessageText:
**
**  Invalid accelerator table handle.
*)
        ERROR_INVALID_ACCEL_HANDLE       = 1403;

(*
** MessageId: ERROR_INVALID_HOOK_HANDLE
**
** MessageText:
**
**  Invalid hook handle.
*)
        ERROR_INVALID_HOOK_HANDLE        = 1404;

(*
** MessageId: ERROR_INVALID_DWP_HANDLE
**
** MessageText:
**
**  Invalid handle to a multiple-window position structure.
*)
        ERROR_INVALID_DWP_HANDLE         = 1405;

(*
** MessageId: ERROR_TLW_WITH_WSCHILD
**
** MessageText:
**
**  Cannot create a top-level child window.
*)
        ERROR_TLW_WITH_WSCHILD           = 1406;

(*
** MessageId: ERROR_CANNOT_FIND_WND_CLASS
**
** MessageText:
**
**  Cannot find window class.
*)
        ERROR_CANNOT_FIND_WND_CLASS      = 1407;

(*
** MessageId: ERROR_WINDOW_OF_OTHER_THREAD
**
** MessageText:
**
**  Invalid window, belongs to other thread.
*)
        ERROR_WINDOW_OF_OTHER_THREAD     = 1408;

(*
** MessageId: ERROR_HOTKEY_ALREADY_REGISTERED
**
** MessageText:
**
**  Hot key is already registered.
*)
        ERROR_HOTKEY_ALREADY_REGISTERED  = 1409;

(*
** MessageId: ERROR_CLASS_ALREADY_EXISTS
**
** MessageText:
**
**  Class already exists.
*)
        ERROR_CLASS_ALREADY_EXISTS       = 1410;

(*
** MessageId: ERROR_CLASS_DOES_NOT_EXIST
**
** MessageText:
**
**  Class does not exist.
*)
        ERROR_CLASS_DOES_NOT_EXIST       = 1411;

(*
** MessageId: ERROR_CLASS_HAS_WINDOWS
**
** MessageText:
**
**  Class still has open windows.
*)
        ERROR_CLASS_HAS_WINDOWS          = 1412;

(*
** MessageId: ERROR_INVALID_INDEX
**
** MessageText:
**
**  Invalid index.
*)
        ERROR_INVALID_INDEX              = 1413;

(*
** MessageId: ERROR_INVALID_ICON_HANDLE
**
** MessageText:
**
**  Invalid icon handle.
*)
        ERROR_INVALID_ICON_HANDLE        = 1414;

(*
** MessageId: ERROR_PRIVATE_DIALOG_INDEX
**
** MessageText:
**
**  Using private DIALOG window words.
*)
        ERROR_PRIVATE_DIALOG_INDEX       = 1415;

(*
** MessageId: ERROR_LISTBOX_ID_NOT_FOUND
**
** MessageText:
**
**  The listbox identifier was not found.
*)
        ERROR_LISTBOX_ID_NOT_FOUND       = 1416;

(*
** MessageId: ERROR_NO_WILDCARD_CHARACTERS
**
** MessageText:
**
**  No wildcards were found.
*)
        ERROR_NO_WILDCARD_CHARACTERS     = 1417;

(*
** MessageId: ERROR_CLIPBOARD_NOT_OPEN
**
** MessageText:
**
**  Thread does not have a clipboard open.
*)
        ERROR_CLIPBOARD_NOT_OPEN         = 1418;

(*
** MessageId: ERROR_HOTKEY_NOT_REGISTERED
**
** MessageText:
**
**  Hot key is not registered.
*)
        ERROR_HOTKEY_NOT_REGISTERED      = 1419;

(*
** MessageId: ERROR_WINDOW_NOT_DIALOG
**
** MessageText:
**
**  The window is not a valid dialog window.
*)
        ERROR_WINDOW_NOT_DIALOG          = 1420;

(*
** MessageId: ERROR_CONTROL_ID_NOT_FOUND
**
** MessageText:
**
**  Control ID not found.
*)
        ERROR_CONTROL_ID_NOT_FOUND       = 1421;

(*
** MessageId: ERROR_INVALID_COMBOBOX_MESSAGE
**
** MessageText:
**
**  Invalid message for a combo box because it does not have an edit control.
*)
        ERROR_INVALID_COMBOBOX_MESSAGE   = 1422;

(*
** MessageId: ERROR_WINDOW_NOT_COMBOBOX
**
** MessageText:
**
**  The window is not a combo box.
*)
        ERROR_WINDOW_NOT_COMBOBOX        = 1423;

(*
** MessageId: ERROR_INVALID_EDIT_HEIGHT
**
** MessageText:
**
**  Height must be less than 256.
*)
        ERROR_INVALID_EDIT_HEIGHT        = 1424;

(*
** MessageId: ERROR_DC_NOT_FOUND
**
** MessageText:
**
**  Invalid device context (DC) handle.
*)
        ERROR_DC_NOT_FOUND               = 1425;

(*
** MessageId: ERROR_INVALID_HOOK_FILTER
**
** MessageText:
**
**  Invalid hook procedure type.
*)
        ERROR_INVALID_HOOK_FILTER        = 1426;

(*
** MessageId: ERROR_INVALID_FILTER_PROC
**
** MessageText:
**
**  Invalid hook procedure.
*)
        ERROR_INVALID_FILTER_PROC        = 1427;

(*
** MessageId: ERROR_HOOK_NEEDS_HMOD
**
** MessageText:
**
**  Cannot set non-local hook without a module handle.
*)
        ERROR_HOOK_NEEDS_HMOD            = 1428;

(*
** MessageId: ERROR_GLOBAL_ONLY_HOOK
**
** MessageText:
**
**  This hook procedure can only be set globally.
*)
        ERROR_GLOBAL_ONLY_HOOK           = 1429;

(*
** MessageId: ERROR_JOURNAL_HOOK_SET
**
** MessageText:
**
**  The journal hook procedure is already installed.
*)
        ERROR_JOURNAL_HOOK_SET           = 1430;

(*
** MessageId: ERROR_HOOK_NOT_INSTALLED
**
** MessageText:
**
**  The hook procedure is not installed.
*)
        ERROR_HOOK_NOT_INSTALLED         = 1431;

(*
** MessageId: ERROR_INVALID_LB_MESSAGE
**
** MessageText:
**
**  Invalid message for single-selection listbox.
*)
        ERROR_INVALID_LB_MESSAGE         = 1432;

(*
** MessageId: ERROR_SETCOUNT_ON_BAD_LB
**
** MessageText:
**
**  LB_SETCOUNT sent to non-lazy listbox.
*)
        ERROR_SETCOUNT_ON_BAD_LB         = 1433;

(*
** MessageId: ERROR_LB_WITHOUT_TABSTOPS
**
** MessageText:
**
**  This list box does not support tab stops.
*)
        ERROR_LB_WITHOUT_TABSTOPS        = 1434;

(*
** MessageId: ERROR_DESTROY_OBJECT_OF_OTHER_THREAD
**
** MessageText:
**
**  Cannot destroy object created by another thread.
*)
        ERROR_DESTROY_OBJECT_OF_OTHER_THREAD = 1435;

(*
** MessageId: ERROR_CHILD_WINDOW_MENU
**
** MessageText:
**
**  Child windows cannot have menus.
*)
        ERROR_CHILD_WINDOW_MENU          = 1436;

(*
** MessageId: ERROR_NO_SYSTEM_MENU
**
** MessageText:
**
**  The window does not have a system menu.
*)
        ERROR_NO_SYSTEM_MENU             = 1437;

(*
** MessageId: ERROR_INVALID_MSGBOX_STYLE
**
** MessageText:
**
**  Invalid message box style.
*)
        ERROR_INVALID_MSGBOX_STYLE       = 1438;

(*
** MessageId: ERROR_INVALID_SPI_VALUE
**
** MessageText:
**
**  Invalid system-wide (SPI_*) parameter.
*)
        ERROR_INVALID_SPI_VALUE          = 1439;

(*
** MessageId: ERROR_SCREEN_ALREADY_LOCKED
**
** MessageText:
**
**  Screen already locked.
*)
        ERROR_SCREEN_ALREADY_LOCKED      = 1440;

(*
** MessageId: ERROR_HWNDS_HAVE_DIFF_PARENT
**
** MessageText:
**
**  All handles to windows in a multiple-window position structure must
**  have the same parent.
*)
        ERROR_HWNDS_HAVE_DIFF_PARENT     = 1441;

(*
** MessageId: ERROR_NOT_CHILD_WINDOW
**
** MessageText:
**
**  The window is not a child window.
*)
        ERROR_NOT_CHILD_WINDOW           = 1442;

(*
** MessageId: ERROR_INVALID_GW_COMMAND
**
** MessageText:
**
**  Invalid GW_* command.
*)
        ERROR_INVALID_GW_COMMAND         = 1443;

(*
** MessageId: ERROR_INVALID_THREAD_ID
**
** MessageText:
**
**  Invalid thread identifier.
*)
        ERROR_INVALID_THREAD_ID          = 1444;

(*
** MessageId: ERROR_NON_MDICHILD_WINDOW
**
** MessageText:
**
**  Cannot process a message from a window that is not a multiple document
**  interface (MDI) window.
*)
        ERROR_NON_MDICHILD_WINDOW        = 1445;

(*
** MessageId: ERROR_POPUP_ALREADY_ACTIVE
**
** MessageText:
**
**  Popup menu already active.
*)
        ERROR_POPUP_ALREADY_ACTIVE       = 1446;

(*
** MessageId: ERROR_NO_SCROLLBARS
**
** MessageText:
**
**  The window does not have scroll bars.
*)
        ERROR_NO_SCROLLBARS              = 1447;

(*
** MessageId: ERROR_INVALID_SCROLLBAR_RANGE
**
** MessageText:
**
**  Scroll bar range cannot be greater than 0x7FFF.
*)
        ERROR_INVALID_SCROLLBAR_RANGE    = 1448;

(*
** MessageId: ERROR_INVALID_SHOWWIN_COMMAND
**
** MessageText:
**
**  Cannot show or remove the window in the way specified.
*)
        ERROR_INVALID_SHOWWIN_COMMAND    = 1449;

(*
** MessageId: ERROR_NO_SYSTEM_RESOURCES
**
** MessageText:
**
**  Insufficient system resources exist to complete the requested service.
*)
        ERROR_NO_SYSTEM_RESOURCES        = 1450;

(*
** MessageId: ERROR_NONPAGED_SYSTEM_RESOURCES
**
** MessageText:
**
**  Insufficient system resources exist to complete the requested service.
*)
        ERROR_NONPAGED_SYSTEM_RESOURCES  = 1451;

(*
** MessageId: ERROR_PAGED_SYSTEM_RESOURCES
**
** MessageText:
**
**  Insufficient system resources exist to complete the requested service.
*)
        ERROR_PAGED_SYSTEM_RESOURCES     = 1452;

(*
** MessageId: ERROR_WORKING_SET_QUOTA
**
** MessageText:
**
**  Insufficient quota to complete the requested service.
*)
        ERROR_WORKING_SET_QUOTA          = 1453;

(*
** MessageId: ERROR_PAGEFILE_QUOTA
**
** MessageText:
**
**  Insufficient quota to complete the requested service.
*)
        ERROR_PAGEFILE_QUOTA             = 1454;

(*
** MessageId: ERROR_COMMITMENT_LIMIT
**
** MessageText:
**
**  The paging file is too small for this operation to complete.
*)
        ERROR_COMMITMENT_LIMIT           = 1455;

(*
** MessageId: ERROR_MENU_ITEM_NOT_FOUND
**
** MessageText:
**
**  A menu item was not found.
*)
        ERROR_MENU_ITEM_NOT_FOUND        = 1456;

(* End of WinUser error codes *)



(**************************
**                       **
** Eventlog Status Codes **
**                       **
**************************)


(*
** MessageId: ERROR_EVENTLOG_FILE_CORRUPT
**
** MessageText:
**
**  The event log file is corrupt.
*)
        ERROR_EVENTLOG_FILE_CORRUPT      = 1500;

(*
** MessageId: ERROR_EVENTLOG_CANT_START
**
** MessageText:
**
**  No event log file could be opened, so the event logging service did not start.
*)
        ERROR_EVENTLOG_CANT_START        = 1501;

(*
** MessageId: ERROR_LOG_FILE_FULL
**
** MessageText:
**
**  The event log file is full.
*)
        ERROR_LOG_FILE_FULL              = 1502;

(*
** MessageId: ERROR_EVENTLOG_FILE_CHANGED
**
** MessageText:
**
**  The event log file has changed between reads.
*)
        ERROR_EVENTLOG_FILE_CHANGED      = 1503;

(* End of eventlog error codes *)



(**************************
**                       **
**   RPC Status Codes    **
**                       **
**************************)


(*
** MessageId: RPC_S_INVALID_STRING_BINDING
**
** MessageText:
**
**  The string binding is invalid.
*)
        RPC_S_INVALID_STRING_BINDING     = 1700;

(*
** MessageId: RPC_S_WRONG_KIND_OF_BINDING
**
** MessageText:
**
**  The binding handle is not the correct type.
*)
        RPC_S_WRONG_KIND_OF_BINDING      = 1701;

(*
** MessageId: RPC_S_INVALID_BINDING
**
** MessageText:
**
**  The binding handle is invalid.
*)
        RPC_S_INVALID_BINDING            = 1702;

(*
** MessageId: RPC_S_PROTSEQ_NOT_SUPPORTED
**
** MessageText:
**
**  The RPC protocol sequence is not supported.
*)
        RPC_S_PROTSEQ_NOT_SUPPORTED      = 1703;

(*
** MessageId: RPC_S_INVALID_RPC_PROTSEQ
**
** MessageText:
**
**  The RPC protocol sequence is invalid.
*)
        RPC_S_INVALID_RPC_PROTSEQ        = 1704;

(*
** MessageId: RPC_S_INVALID_STRING_UUID
**
** MessageText:
**
**  The string universal unique identifier (UUID) is invalid.
*)
        RPC_S_INVALID_STRING_UUID        = 1705;

(*
** MessageId: RPC_S_INVALID_ENDPOINT_FORMAT
**
** MessageText:
**
**  The endpoint format is invalid.
*)
        RPC_S_INVALID_ENDPOINT_FORMAT    = 1706;

(*
** MessageId: RPC_S_INVALID_NET_ADDR
**
** MessageText:
**
**  The network address is invalid.
*)
        RPC_S_INVALID_NET_ADDR           = 1707;

(*
** MessageId: RPC_S_NO_ENDPOINT_FOUND
**
** MessageText:
**
**  No endpoint was found.
*)
        RPC_S_NO_ENDPOINT_FOUND          = 1708;

(*
** MessageId: RPC_S_INVALID_TIMEOUT
**
** MessageText:
**
**  The timeout value is invalid.
*)
        RPC_S_INVALID_TIMEOUT            = 1709;

(*
** MessageId: RPC_S_OBJECT_NOT_FOUND
**
** MessageText:
**
**  The object universal unique identifier (UUID) was not found.
*)
        RPC_S_OBJECT_NOT_FOUND           = 1710;

(*
** MessageId: RPC_S_ALREADY_REGISTERED
**
** MessageText:
**
**  The object universal unique identifier (UUID) has already been registered.
*)
        RPC_S_ALREADY_REGISTERED         = 1711;

(*
** MessageId: RPC_S_TYPE_ALREADY_REGISTERED
**
** MessageText:
**
**  The type universal unique identifier (UUID) has already been registered.
*)
        RPC_S_TYPE_ALREADY_REGISTERED    = 1712;

(*
** MessageId: RPC_S_ALREADY_LISTENING
**
** MessageText:
**
**  The RPC server is already listening.
*)
        RPC_S_ALREADY_LISTENING          = 1713;

(*
** MessageId: RPC_S_NO_PROTSEQS_REGISTERED
**
** MessageText:
**
**  No protocol sequences have been registered.
*)
        RPC_S_NO_PROTSEQS_REGISTERED     = 1714;

(*
** MessageId: RPC_S_NOT_LISTENING
**
** MessageText:
**
**  The RPC server is not listening.
*)
        RPC_S_NOT_LISTENING              = 1715;

(*
** MessageId: RPC_S_UNKNOWN_MGR_TYPE
**
** MessageText:
**
**  The manager type is unknown.
*)
        RPC_S_UNKNOWN_MGR_TYPE           = 1716;

(*
** MessageId: RPC_S_UNKNOWN_IF
**
** MessageText:
**
**  The interface is unknown.
*)
        RPC_S_UNKNOWN_IF                 = 1717;

(*
** MessageId: RPC_S_NO_BINDINGS
**
** MessageText:
**
**  There are no bindings.
*)
        RPC_S_NO_BINDINGS                = 1718;

(*
** MessageId: RPC_S_NO_PROTSEQS
**
** MessageText:
**
**  There are no protocol sequences.
*)
        RPC_S_NO_PROTSEQS                = 1719;

(*
** MessageId: RPC_S_CANT_CREATE_ENDPOINT
**
** MessageText:
**
**  The endpoint cannot be created.
*)
        RPC_S_CANT_CREATE_ENDPOINT       = 1720;

(*
** MessageId: RPC_S_OUT_OF_RESOURCES
**
** MessageText:
**
**  Not enough resources are available to complete this operation.
*)
        RPC_S_OUT_OF_RESOURCES           = 1721;

(*
** MessageId: RPC_S_SERVER_UNAVAILABLE
**
** MessageText:
**
**  The RPC server is unavailable.
*)
        RPC_S_SERVER_UNAVAILABLE         = 1722;

(*
** MessageId: RPC_S_SERVER_TOO_BUSY
**
** MessageText:
**
**  The RPC server is too busy to complete this operation.
*)
        RPC_S_SERVER_TOO_BUSY            = 1723;

(*
** MessageId: RPC_S_INVALID_NETWORK_OPTIONS
**
** MessageText:
**
**  The network options are invalid.
*)
        RPC_S_INVALID_NETWORK_OPTIONS    = 1724;

(*
** MessageId: RPC_S_NO_CALL_ACTIVE
**
** MessageText:
**
**  There is not a remote procedure call active in this thread.
*)
        RPC_S_NO_CALL_ACTIVE             = 1725;

(*
** MessageId: RPC_S_CALL_FAILED
**
** MessageText:
**
**  The remote procedure call failed.
*)
        RPC_S_CALL_FAILED                = 1726;

(*
** MessageId: RPC_S_CALL_FAILED_DNE
**
** MessageText:
**
**  The remote procedure call failed and did not execute.
*)
        RPC_S_CALL_FAILED_DNE            = 1727;

(*
** MessageId: RPC_S_PROTOCOL_ERROR
**
** MessageText:
**
**  A remote procedure call (RPC) protocol error occurred.
*)
        RPC_S_PROTOCOL_ERROR             = 1728;

(*
** MessageId: RPC_S_UNSUPPORTED_TRANS_SYN
**
** MessageText:
**
**  The transfer syntax is not supported by the RPC server.
*)
        RPC_S_UNSUPPORTED_TRANS_SYN      = 1730;

(*
** MessageId: RPC_S_UNSUPPORTED_TYPE
**
** MessageText:
**
**  The universal unique identifier (UUID) type is not supported.
*)
        RPC_S_UNSUPPORTED_TYPE           = 1732;

(*
** MessageId: RPC_S_INVALID_TAG
**
** MessageText:
**
**  The tag is invalid.
*)
        RPC_S_INVALID_TAG                = 1733;

(*
** MessageId: RPC_S_INVALID_BOUND
**
** MessageText:
**
**  The array bounds are invalid.
*)
        RPC_S_INVALID_BOUND              = 1734;

(*
** MessageId: RPC_S_NO_ENTRY_NAME
**
** MessageText:
**
**  The binding does not contain an entry name.
*)
        RPC_S_NO_ENTRY_NAME              = 1735;

(*
** MessageId: RPC_S_INVALID_NAME_SYNTAX
**
** MessageText:
**
**  The name syntax is invalid.
*)
        RPC_S_INVALID_NAME_SYNTAX        = 1736;

(*
** MessageId: RPC_S_UNSUPPORTED_NAME_SYNTAX
**
** MessageText:
**
**  The name syntax is not supported.
*)
        RPC_S_UNSUPPORTED_NAME_SYNTAX    = 1737;

(*
** MessageId: RPC_S_UUID_NO_ADDRESS
**
** MessageText:
**
**  No network address is available to use to construct a universal
**  unique identifier (UUID).
*)
        RPC_S_UUID_NO_ADDRESS            = 1739;

(*
** MessageId: RPC_S_DUPLICATE_ENDPOINT
**
** MessageText:
**
**  The endpoint is a duplicate.
*)
        RPC_S_DUPLICATE_ENDPOINT         = 1740;

(*
** MessageId: RPC_S_UNKNOWN_AUTHN_TYPE
**
** MessageText:
**
**  The authentication type is unknown.
*)
        RPC_S_UNKNOWN_AUTHN_TYPE         = 1741;

(*
** MessageId: RPC_S_MAX_CALLS_TOO_SMALL
**
** MessageText:
**
**  The maximum number of calls is too small.
*)
        RPC_S_MAX_CALLS_TOO_SMALL        = 1742;

(*
** MessageId: RPC_S_STRING_TOO_LONG
**
** MessageText:
**
**  The string is too long.
*)
        RPC_S_STRING_TOO_LONG            = 1743;

(*
** MessageId: RPC_S_PROTSEQ_NOT_FOUND
**
** MessageText:
**
**  The RPC protocol sequence was not found.
*)
        RPC_S_PROTSEQ_NOT_FOUND          = 1744;

(*
** MessageId: RPC_S_PROCNUM_OUT_OF_RANGE
**
** MessageText:
**
**  The procedure number is out of range.
*)
        RPC_S_PROCNUM_OUT_OF_RANGE       = 1745;

(*
** MessageId: RPC_S_BINDING_HAS_NO_AUTH
**
** MessageText:
**
**  The binding does not contain any authentication information.
*)
        RPC_S_BINDING_HAS_NO_AUTH        = 1746;

(*
** MessageId: RPC_S_UNKNOWN_AUTHN_SERVICE
**
** MessageText:
**
**  The authentication service is unknown.
*)
        RPC_S_UNKNOWN_AUTHN_SERVICE      = 1747;

(*
** MessageId: RPC_S_UNKNOWN_AUTHN_LEVEL
**
** MessageText:
**
**  The authentication level is unknown.
*)
        RPC_S_UNKNOWN_AUTHN_LEVEL        = 1748;

(*
** MessageId: RPC_S_INVALID_AUTH_IDENTITY
**
** MessageText:
**
**  The security context is invalid.
*)
        RPC_S_INVALID_AUTH_IDENTITY      = 1749;

(*
** MessageId: RPC_S_UNKNOWN_AUTHZ_SERVICE
**
** MessageText:
**
**  The authorization service is unknown.
*)
        RPC_S_UNKNOWN_AUTHZ_SERVICE      = 1750;

(*
** MessageId: EPT_S_INVALID_ENTRY
**
** MessageText:
**
**  The entry is invalid.
*)
        EPT_S_INVALID_ENTRY              = 1751;

(*
** MessageId: EPT_S_CANT_PERFORM_OP
**
** MessageText:
**
**  The server endpoint cannot perform the operation.
*)
        EPT_S_CANT_PERFORM_OP            = 1752;

(*
** MessageId: EPT_S_NOT_REGISTERED
**
** MessageText:
**
**  There are no more endpoints available from the endpoint mapper.
*)
        EPT_S_NOT_REGISTERED             = 1753;

(*
** MessageId: RPC_S_NOTHING_TO_EXPORT
**
** MessageText:
**
**  No interfaces have been exported.
*)
        RPC_S_NOTHING_TO_EXPORT          = 1754;

(*
** MessageId: RPC_S_INCOMPLETE_NAME
**
** MessageText:
**
**  The entry name is incomplete.
*)
        RPC_S_INCOMPLETE_NAME            = 1755;

(*
** MessageId: RPC_S_INVALID_VERS_OPTION
**
** MessageText:
**
**  The version option is invalid.
*)
        RPC_S_INVALID_VERS_OPTION        = 1756;

(*
** MessageId: RPC_S_NO_MORE_MEMBERS
**
** MessageText:
**
**  There are no more members.
*)
        RPC_S_NO_MORE_MEMBERS            = 1757;

(*
** MessageId: RPC_S_NOT_ALL_OBJS_UNEXPORTED
**
** MessageText:
**
**  There is nothing to unexport.
*)
        RPC_S_NOT_ALL_OBJS_UNEXPORTED    = 1758;

(*
** MessageId: RPC_S_INTERFACE_NOT_FOUND
**
** MessageText:
**
**  The interface was not found.
*)
        RPC_S_INTERFACE_NOT_FOUND        = 1759;

(*
** MessageId: RPC_S_ENTRY_ALREADY_EXISTS
**
** MessageText:
**
**  The entry already exists.
*)
        RPC_S_ENTRY_ALREADY_EXISTS       = 1760;

(*
** MessageId: RPC_S_ENTRY_NOT_FOUND
**
** MessageText:
**
**  The entry is not found.
*)
        RPC_S_ENTRY_NOT_FOUND            = 1761;

(*
** MessageId: RPC_S_NAME_SERVICE_UNAVAILABLE
**
** MessageText:
**
**  The name service is unavailable.
*)
        RPC_S_NAME_SERVICE_UNAVAILABLE   = 1762;

(*
** MessageId: RPC_S_INVALID_NAF_ID
**
** MessageText:
**
**  The network address family is invalid.
*)
        RPC_S_INVALID_NAF_ID             = 1763;

(*
** MessageId: RPC_S_CANNOT_SUPPORT
**
** MessageText:
**
**  The requested operation is not supported.
*)
        RPC_S_CANNOT_SUPPORT             = 1764;

(*
** MessageId: RPC_S_NO_CONTEXT_AVAILABLE
**
** MessageText:
**
**  No security context is available to allow impersonation.
*)
        RPC_S_NO_CONTEXT_AVAILABLE       = 1765;

(*
** MessageId: RPC_S_INTERNAL_ERROR
**
** MessageText:
**
**  An internal error occurred in a remote procedure call (RPC).
*)
        RPC_S_INTERNAL_ERROR             = 1766;

(*
** MessageId: RPC_S_ZERO_DIVIDE
**
** MessageText:
**
**  The RPC server attempted an integer division by zero.
*)
        RPC_S_ZERO_DIVIDE                = 1767;

(*
** MessageId: RPC_S_ADDRESS_ERROR
**
** MessageText:
**
**  An addressing error occurred in the RPC server.
*)
        RPC_S_ADDRESS_ERROR              = 1768;

(*
** MessageId: RPC_S_FP_DIV_ZERO
**
** MessageText:
**
**  A floating-point operation at the RPC server caused a division by zero.
*)
        RPC_S_FP_DIV_ZERO                = 1769;

(*
** MessageId: RPC_S_FP_UNDERFLOW
**
** MessageText:
**
**  A floating-point underflow occurred at the RPC server.
*)
        RPC_S_FP_UNDERFLOW               = 1770;

(*
** MessageId: RPC_S_FP_OVERFLOW
**
** MessageText:
**
**  A floating-point overflow occurred at the RPC server.
*)
        RPC_S_FP_OVERFLOW                = 1771;

(*
** MessageId: RPC_X_NO_MORE_ENTRIES
**
** MessageText:
**
**  The list of RPC servers available for the binding of auto handles
**  has been exhausted.
*)
        RPC_X_NO_MORE_ENTRIES            = 1772;

(*
** MessageId: RPC_X_SS_CHAR_TRANS_OPEN_FAIL
**
** MessageText:
**
**  Unable to open the character translation table file.
*)
        RPC_X_SS_CHAR_TRANS_OPEN_FAIL    = 1773;

(*
** MessageId: RPC_X_SS_CHAR_TRANS_SHORT_FILE
**
** MessageText:
**
**  The file containing the character translation table has fewer than
**  512 bytes.
*)
        RPC_X_SS_CHAR_TRANS_SHORT_FILE   = 1774;

(*
** MessageId: RPC_X_SS_IN_NULL_CONTEXT
**
** MessageText:
**
**  A null context handle was passed from the client to the host during
**  a remote procedure call.
*)
        RPC_X_SS_IN_NULL_CONTEXT         = 1775;

(*
** MessageId: RPC_X_SS_CONTEXT_DAMAGED
**
** MessageText:
**
**  The context handle changed during a remote procedure call.
*)
        RPC_X_SS_CONTEXT_DAMAGED         = 1777;

(*
** MessageId: RPC_X_SS_HANDLES_MISMATCH
**
** MessageText:
**
**  The binding handles passed to a remote procedure call do not match.
*)
        RPC_X_SS_HANDLES_MISMATCH        = 1778;

(*
** MessageId: RPC_X_SS_CANNOT_GET_CALL_HANDLE
**
** MessageText:
**
**  The stub is unable to get the remote procedure call handle.
*)
        RPC_X_SS_CANNOT_GET_CALL_HANDLE  = 1779;

(*
** MessageId: RPC_X_NULL_REF_POINTER
**
** MessageText:
**
**  A null reference pointer was passed to the stub.
*)
        RPC_X_NULL_REF_POINTER           = 1780;

(*
** MessageId: RPC_X_ENUM_VALUE_OUT_OF_RANGE
**
** MessageText:
**
**  The enumeration value is out of range.
*)
        RPC_X_ENUM_VALUE_OUT_OF_RANGE    = 1781;

(*
** MessageId: RPC_X_BYTE_COUNT_TOO_SMALL
**
** MessageText:
**
**  The byte count is too small.
*)
        RPC_X_BYTE_COUNT_TOO_SMALL       = 1782;

(*
** MessageId: RPC_X_BAD_STUB_DATA
**
** MessageText:
**
**  The stub received bad data.
*)
        RPC_X_BAD_STUB_DATA              = 1783;

(*
** MessageId: ERROR_INVALID_USER_BUFFER
**
** MessageText:
**
**  The supplied user buffer is not valid for the requested operation.
*)
        ERROR_INVALID_USER_BUFFER        = 1784;

(*
** MessageId: ERROR_UNRECOGNIZED_MEDIA
**
** MessageText:
**
**  The disk media is not recognized.  It may not be formatted.
*)
        ERROR_UNRECOGNIZED_MEDIA         = 1785;

(*
** MessageId: ERROR_NO_TRUST_LSA_SECRET
**
** MessageText:
**
**  The workstation does not have a trust secret.
*)
        ERROR_NO_TRUST_LSA_SECRET        = 1786;

(*
** MessageId: ERROR_NO_TRUST_SAM_ACCOUNT
**
** MessageText:
**
**  The SAM database on the Windows NT Server does not have a computer
**  account for this workstation trust relationship.
*)
        ERROR_NO_TRUST_SAM_ACCOUNT       = 1787;

(*
** MessageId: ERROR_TRUSTED_DOMAIN_FAILURE
**
** MessageText:
**
**  The trust relationship between the primary domain and the trusted
**  domain failed.
*)
        ERROR_TRUSTED_DOMAIN_FAILURE     = 1788;

(*
** MessageId: ERROR_TRUSTED_RELATIONSHIP_FAILURE
**
** MessageText:
**
**  The trust relationship between this workstation and the primary
**  domain failed.
*)
        ERROR_TRUSTED_RELATIONSHIP_FAILURE = 1789;

(*
** MessageId: ERROR_TRUST_FAILURE
**
** MessageText:
**
**  The network logon failed.
*)
        ERROR_TRUST_FAILURE              = 1790;

(*
** MessageId: RPC_S_CALL_IN_PROGRESS
**
** MessageText:
**
**  A remote procedure call is already in progress for this thread.
*)
        RPC_S_CALL_IN_PROGRESS           = 1791;

(*
** MessageId: ERROR_NETLOGON_NOT_STARTED
**
** MessageText:
**
**  An attempt was made to logon, but the network logon service was not started.
*)
        ERROR_NETLOGON_NOT_STARTED       = 1792;

(*
** MessageId: ERROR_ACCOUNT_EXPIRED
**
** MessageText:
**
**  The user's account has expired.
*)
        ERROR_ACCOUNT_EXPIRED            = 1793;

(*
** MessageId: ERROR_REDIRECTOR_HAS_OPEN_HANDLES
**
** MessageText:
**
**  The redirector is in use and cannot be unloaded.
*)
        ERROR_REDIRECTOR_HAS_OPEN_HANDLES = 1794;

(*
** MessageId: ERROR_PRINTER_DRIVER_ALREADY_INSTALLED
**
** MessageText:
**
**  The specified printer driver is already installed.
*)
        ERROR_PRINTER_DRIVER_ALREADY_INSTALLED = 1795;

(*
** MessageId: ERROR_UNKNOWN_PORT
**
** MessageText:
**
**  The specified port is unknown.
*)
        ERROR_UNKNOWN_PORT               = 1796;

(*
** MessageId: ERROR_UNKNOWN_PRINTER_DRIVER
**
** MessageText:
**
**  The printer driver is unknown.
*)
        ERROR_UNKNOWN_PRINTER_DRIVER     = 1797;

(*
** MessageId: ERROR_UNKNOWN_PRINTPROCESSOR
**
** MessageText:
**
**  The print processor is unknown.
*)
        ERROR_UNKNOWN_PRINTPROCESSOR     = 1798;

(*
** MessageId: ERROR_INVALID_SEPARATOR_FILE
**
** MessageText:
**
**  The specified separator file is invalid.
*)
        ERROR_INVALID_SEPARATOR_FILE     = 1799;

(*
** MessageId: ERROR_INVALID_PRIORITY
**
** MessageText:
**
**  The specified priority is invalid.
*)
        ERROR_INVALID_PRIORITY           = 1800;

(*
** MessageId: ERROR_INVALID_PRINTER_NAME
**
** MessageText:
**
**  The printer name is invalid.
*)
        ERROR_INVALID_PRINTER_NAME       = 1801;

(*
** MessageId: ERROR_PRINTER_ALREADY_EXISTS
**
** MessageText:
**
**  The printer already exists.
*)
        ERROR_PRINTER_ALREADY_EXISTS     = 1802;

(*
** MessageId: ERROR_INVALID_PRINTER_COMMAND
**
** MessageText:
**
**  The printer command is invalid.
*)
        ERROR_INVALID_PRINTER_COMMAND    = 1803;

(*
** MessageId: ERROR_INVALID_DATATYPE
**
** MessageText:
**
**  The specified datatype is invalid.
*)
        ERROR_INVALID_DATATYPE           = 1804;

(*
** MessageId: ERROR_INVALID_ENVIRONMENT
**
** MessageText:
**
**  The Environment specified is invalid.
*)
        ERROR_INVALID_ENVIRONMENT        = 1805;

(*
** MessageId: RPC_S_NO_MORE_BINDINGS
**
** MessageText:
**
**  There are no more bindings.
*)
        RPC_S_NO_MORE_BINDINGS           = 1806;

(*
** MessageId: ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT
**
** MessageText:
**
**  The account used is an interdomain trust account.  Use your global user account or local user account to access this server.
*)
        ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT = 1807;

(*
** MessageId: ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT
**
** MessageText:
**
**  The account used is a Computer Account.  Use your global user account or local user account to access this server.
*)
        ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT = 1808;

(*
** MessageId: ERROR_NOLOGON_SERVER_TRUST_ACCOUNT
**
** MessageText:
**
**  The account used is an server trust account.  Use your global user account or local user account to access this server.
*)
        ERROR_NOLOGON_SERVER_TRUST_ACCOUNT = 1809;

(*
** MessageId: ERROR_DOMAIN_TRUST_INCONSISTENT
**
** MessageText:
**
**  The name or security ID (SID) of the domain specified is inconsistent
**  with the trust information for that domain.
*)
        ERROR_DOMAIN_TRUST_INCONSISTENT  = 1810;

(*
** MessageId: ERROR_SERVER_HAS_OPEN_HANDLES
**
** MessageText:
**
**  The server is in use and cannot be unloaded.
*)
        ERROR_SERVER_HAS_OPEN_HANDLES    = 1811;

(*
** MessageId: ERROR_RESOURCE_DATA_NOT_FOUND
**
** MessageText:
**
**  The specified image file did not contain a resource section.
*)
        ERROR_RESOURCE_DATA_NOT_FOUND    = 1812;

(*
** MessageId: ERROR_RESOURCE_TYPE_NOT_FOUND
**
** MessageText:
**
**  The specified resource type can not be found in the image file.
*)
        ERROR_RESOURCE_TYPE_NOT_FOUND    = 1813;

(*
** MessageId: ERROR_RESOURCE_NAME_NOT_FOUND
**
** MessageText:
**
**  The specified resource name can not be found in the image file.
*)
        ERROR_RESOURCE_NAME_NOT_FOUND    = 1814;

(*
** MessageId: ERROR_RESOURCE_LANG_NOT_FOUND
**
** MessageText:
**
**  The specified resource language ID cannot be found in the image file.
*)
        ERROR_RESOURCE_LANG_NOT_FOUND    = 1815;

(*
** MessageId: ERROR_NOT_ENOUGH_QUOTA
**
** MessageText:
**
**  Not enough quota is available to process this command.
*)
        ERROR_NOT_ENOUGH_QUOTA           = 1816;

(*
** MessageId: RPC_S_NO_INTERFACES
**
** MessageText:
**
**  No interfaces have been registered.
*)
        RPC_S_NO_INTERFACES              = 1817;

(*
** MessageId: RPC_S_CALL_CANCELLED
**
** MessageText:
**
**  The server was altered while processing this call.
*)
        RPC_S_CALL_CANCELLED             = 1818;

(*
** MessageId: RPC_S_BINDING_INCOMPLETE
**
** MessageText:
**
**  The binding handle does not contain all required information.
*)
        RPC_S_BINDING_INCOMPLETE         = 1819;

(*
** MessageId: RPC_S_COMM_FAILURE
**
** MessageText:
**
**  Communications failure.
*)
        RPC_S_COMM_FAILURE               = 1820;

(*
** MessageId: RPC_S_UNSUPPORTED_AUTHN_LEVEL
**
** MessageText:
**
**  The requested authentication level is not supported.
*)
        RPC_S_UNSUPPORTED_AUTHN_LEVEL    = 1821;

(*
** MessageId: RPC_S_NO_PRINC_NAME
**
** MessageText:
**
**  No principal name registered.
*)
        RPC_S_NO_PRINC_NAME              = 1822;

(*
** MessageId: RPC_S_NOT_RPC_ERROR
**
** MessageText:
**
**  The error specified is not a valid Windows RPC error code.
*)
        RPC_S_NOT_RPC_ERROR              = 1823;

(*
** MessageId: RPC_S_UUID_LOCAL_ONLY
**
** MessageText:
**
**  A UUID that is valid only on this computer has been allocated.
*)
        RPC_S_UUID_LOCAL_ONLY            = 1824;

(*
** MessageId: RPC_S_SEC_PKG_ERROR
**
** MessageText:
**
**  A security package specific error occurred.
*)
        RPC_S_SEC_PKG_ERROR              = 1825;

(*
** MessageId: RPC_S_NOT_CANCELLED
**
** MessageText:
**
**  Thread is not cancelled.
*)
        RPC_S_NOT_CANCELLED              = 1826;

(*
** MessageId: RPC_X_INVALID_ES_ACTION
**
** MessageText:
**
**  Invalid operation on the encoding/decoding handle.
*)
        RPC_X_INVALID_ES_ACTION          = 1827;

(*
** MessageId: RPC_X_WRONG_ES_VERSION
**
** MessageText:
**
**  Incompatible version of the serializing package.
*)
        RPC_X_WRONG_ES_VERSION           = 1828;

(*
** MessageId: RPC_X_WRONG_STUB_VERSION
**
** MessageText:
**
**  Incompatible version of the RPC stub.
*)
        RPC_X_WRONG_STUB_VERSION         = 1829;

(*
** MessageId: RPC_S_GROUP_MEMBER_NOT_FOUND
**
** MessageText:
**
**  The group member was not found.
*)
        RPC_S_GROUP_MEMBER_NOT_FOUND     = 1898;

(*
** MessageId: EPT_S_CANT_CREATE
**
** MessageText:
**
**  The endpoint mapper database could not be created.
*)
        EPT_S_CANT_CREATE                = 1899;

(*
** MessageId: RPC_S_INVALID_OBJECT
**
** MessageText:
**
**  The object universal unique identifier (UUID) is the nil UUID.
*)
        RPC_S_INVALID_OBJECT             = 1900;

(*
** MessageId: ERROR_INVALID_TIME
**
** MessageText:
**
**  The specified time is invalid.
*)
        ERROR_INVALID_TIME               = 1901;

(*
** MessageId: ERROR_INVALID_FORM_NAME
**
** MessageText:
**
**  The specified Form name is invalid.
*)
        ERROR_INVALID_FORM_NAME          = 1902;

(*
** MessageId: ERROR_INVALID_FORM_SIZE
**
** MessageText:
**
**  The specified Form size is invalid
*)
        ERROR_INVALID_FORM_SIZE          = 1903;

(*
** MessageId: ERROR_ALREADY_WAITING
**
** MessageText:
**
**  The specified Printer handle is already being waited on
*)
        ERROR_ALREADY_WAITING            = 1904;

(*
** MessageId: ERROR_PRINTER_DELETED
**
** MessageText:
**
**  The specified Printer has been deleted
*)
        ERROR_PRINTER_DELETED            = 1905;

(*
** MessageId: ERROR_INVALID_PRINTER_STATE
**
** MessageText:
**
**  The state of the Printer is invalid
*)
        ERROR_INVALID_PRINTER_STATE      = 1906;

(*
** MessageId: ERROR_PASSWORD_MUST_CHANGE
**
** MessageText:
**
**  The user must change his password before he logs on the first time.
*)
        ERROR_PASSWORD_MUST_CHANGE       = 1907;

(*
** MessageId: ERROR_DOMAIN_CONTROLLER_NOT_FOUND
**
** MessageText:
**
**  Could not find the domain controller for this domain.
*)
        ERROR_DOMAIN_CONTROLLER_NOT_FOUND = 1908;

(*
** MessageId: ERROR_ACCOUNT_LOCKED_OUT
**
** MessageText:
**
**  The referenced account is currently locked out and may not be logged on to.
*)
        ERROR_ACCOUNT_LOCKED_OUT         = 1909;

(*
** MessageId: ERROR_NO_BROWSER_SERVERS_FOUND
**
** MessageText:
**
**  The list of servers for this workgroup is not currently available
*)
        ERROR_NO_BROWSER_SERVERS_FOUND   = 6118;




(**************************
**                       **
**   OpenGL Error Code   **
**                       **
**************************)


(*
** MessageId: ERROR_INVALID_PIXEL_FORMAT
**
** MessageText:
**
**  The pixel format is invalid.
*)
        ERROR_INVALID_PIXEL_FORMAT       = 2000;

(*
** MessageId: ERROR_BAD_DRIVER
**
** MessageText:
**
**  The specified driver is invalid.
*)
        ERROR_BAD_DRIVER                 = 2001;

(*
** MessageId: ERROR_INVALID_WINDOW_STYLE
**
** MessageText:
**
**  The window style or class attribute is invalid for this operation.
*)
        ERROR_INVALID_WINDOW_STYLE       = 2002;

(*
** MessageId: ERROR_METAFILE_NOT_SUPPORTED
**
** MessageText:
**
**  The requested metafile operation is not supported.
*)
        ERROR_METAFILE_NOT_SUPPORTED     = 2003;

(*
** MessageId: ERROR_TRANSFORM_NOT_SUPPORTED
**
** MessageText:
**
**  The requested transformation operation is not supported.
*)
        ERROR_TRANSFORM_NOT_SUPPORTED    = 2004;

(*
** MessageId: ERROR_CLIPPING_NOT_SUPPORTED
**
** MessageText:
**
**  The requested clipping operation is not supported.
*)
        ERROR_CLIPPING_NOT_SUPPORTED     = 2005;

(* End of OpenGL error codes *)



(***********************************
**                                **
**     Win32 Spooler Error Codes  **
**                                **
************************************
**
** MessageId: ERROR_UNKNOWN_PRINT_MONITOR
**
** MessageText:
**
**  The specified print monitor is unknown.
*)
        ERROR_UNKNOWN_PRINT_MONITOR      = 3000;

(*
** MessageId: ERROR_PRINTER_DRIVER_IN_USE
**
** MessageText:
**
**  The specified printer driver is currently in use.
*)
        ERROR_PRINTER_DRIVER_IN_USE      = 3001;

(*
** MessageId: ERROR_SPOOL_FILE_NOT_FOUND
**
** MessageText:
**
**  The spool file was not found.
*)
        ERROR_SPOOL_FILE_NOT_FOUND       = 3002;

(*
** MessageId: ERROR_SPL_NO_STARTDOC
**
** MessageText:
**
**  A StartDocPrinter call was not issued.
*)
        ERROR_SPL_NO_STARTDOC            = 3003;

(*
** MessageId: ERROR_SPL_NO_ADDJOB
**
** MessageText:
**
**  An AddJob call was not issued.
*)
        ERROR_SPL_NO_ADDJOB              = 3004;

(*
** MessageId: ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED
**
** MessageText:
**
**  The specified print processor has already been installed.
*)
        ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED = 3005;

(*
** MessageId: ERROR_PRINT_MONITOR_ALREADY_INSTALLED
**
** MessageText:
**
**  The specified print monitor has already been installed.
*)
        ERROR_PRINT_MONITOR_ALREADY_INSTALLED = 3006;

(***********************************
**                                **
**     Wins Error Codes           **
**                                **
************************************
**
** MessageId: ERROR_WINS_INTERNAL
**
** MessageText:
**
**  WINS encountered an error while processing the command.
*)
        ERROR_WINS_INTERNAL              = 4000;

(*
** MessageId: ERROR_CAN_NOT_DEL_LOCAL_WINS
**
** MessageText:
**
**  The local WINS can not be deleted.
*)
        ERROR_CAN_NOT_DEL_LOCAL_WINS     = 4001;

(*
** MessageId: ERROR_STATIC_INIT
**
** MessageText:
**
**  The importation from the file failed.
*)
        ERROR_STATIC_INIT                = 4002;

(*
** MessageId: ERROR_INC_BACKUP
**
** MessageText:
**
**  The backup Failed.  Was a full backup done before ?
*)
        ERROR_INC_BACKUP                 = 4003;

(*
** MessageId: ERROR_FULL_BACKUP
**
** MessageText:
**
**  The backup Failed.  Check the directory that you are backing the database to.
*)
        ERROR_FULL_BACKUP                = 4004;

(*
** MessageId: ERROR_REC_NON_EXISTENT
**
** MessageText:
**
**  The name does not exist in the WINS database.
*)
        ERROR_REC_NON_EXISTENT           = 4005;

(*
** MessageId: ERROR_RPL_NOT_ALLOWED
**
** MessageText:
**
**  Replication with a non-configured partner is not allowed.
*)
        ERROR_RPL_NOT_ALLOWED            = 4006;

(***********************************
**                                **
**     OLE Error Codes            **
**                                **
***********************************)

(*
** OLE error definitions and values
**
** The return value of OLE APIs and methods is an HRESULT.
** This is not a handle to anything, but is merely a 32-bit value
** with several fields encoded in the value.  The parts of an 
** HRESULT are shown below.  
**
** Many of the macros and functions below were orginally defined to 
** operate on SCODEs.  SCODEs are no longer used.  The macros are 
** still present for compatibility and easy porting of Win16 code.
** Newly written code should use the HRESULT macros and functions.
*)

(*
**  HRESULTs are 32 bit values layed out as follows:
**
**   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
**   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
**  +-+-+-+-+-+---------------------+-------------------------------+
**  |S|R|C|N|r|    Facility         |               Code            |
**  +-+-+-+-+-+---------------------+-------------------------------+
**
**  where
**
**      S - Severity - indicates success/fail
**
**          0 - Success
**          1 - Fail (COERROR)
**
**      R - reserved portion of the facility code, corresponds to NT's
**              second severity bit.
**
**      C - reserved portion of the facility code, corresponds to NT's
**              C field.
**
**      N - reserved portion of the facility code. Used to indicate a
**              mapped NT status value.
**
**      r - reserved portion of the facility code. Reserved for internal
**              use. Used to indicate HRESULT values that are not status
**              values, but are instead message ids for display strings.
**
**      Facility - is the facility code
**
**      Code - is the facility's status code
*)

(*
** Severity values
*)

        SEVERITY_SUCCESS    = 0;
        SEVERITY_ERROR      = 1;


(*
** Generic test for success on any status value (non-negative numbers
** indicate success).
*)

PROCEDURE SUCCEEDED (Status : ULONG) : BOOL;

(*
** and the inverse
*)

PROCEDURE FAILED (Status : ULONG) : BOOL;


(*
** Generic test for error on any status value.
*)

PROCEDURE IS_ERROR (Status : ULONG) : BOOL;

(*
** Return the code
*)

PROCEDURE HRESULT_CODE (hr : ULONG) : ULONG;
PROCEDURE SCODE_CODE   (sc : ULONG) : ULONG;

(*
**  Return the facility
*)

PROCEDURE HRESULT_FACILITY (hr : ULONG) : ULONG;
PROCEDURE SCODE_FACILITY   (sc : ULONG) : ULONG;

(*
**  Return the severity
*)

PROCEDURE HRESULT_SEVERITY (hr : ULONG) : BOOL;
PROCEDURE SCODE_SEVERITY   (sc : ULONG) : BOOL;

(*
** Create an HRESULT value from component pieces
*)

PROCEDURE MAKE_HRESULT (sev : BOOL; fac : ULONG; code : ULONG) : ULONG;
PROCEDURE MAKE_SCODE   (sev : BOOL; fac : ULONG; code : ULONG) : ULONG;

(*
** Map a WIN32 error value into a HRESULT
** Note: This assumes that WIN32 errors fall in the range -32k to 32k.
**
** Define bits here so macros are guaranteed to work
*)

PROCEDURE HRESULT_FROM_WIN32 (x : ULONG) : ULONG;

(*
** Map an NT status value into a HRESULT
*)

PROCEDURE HRESULT_FROM_NT (x : ULONG) : ULONG;


(* ****** OBSOLETE functions *)

(* HRESULT functions
** As noted above, these functions are obsolete and should not be used.
*)

(* Extract the SCODE from a HRESULT *)

PROCEDURE GetScode (hr : ULONG) : ULONG;

(* Convert an SCODE into an HRESULT. *)

PROCEDURE ResultFromScode (sc : ULONG) : ULONG;


(* PropagateResult is a noop *)

PROCEDURE PropagateResult (hrPrevious : ULONG; scBase : ULONG) : ULONG;


(* ****** End of OBSOLETE functions. *)


(* ---------------------- HRESULT value definitions -----------------
**
** HRESULT definitions
*)

(*
** Success codes
*)
CONST  S_OK      = 00000000h;
       S_FALSE   = 00000001h;

CONST
        NOERROR             = S_OK;

(*
** Error definitions follow
*)

(*
** Codes 0x4000-0x40ff are reserved for OLE
**
**
** Error codes
**
**
** MessageId: E_UNEXPECTED
**
** MessageText:
**
**  Unexpected failure
*)
        E_UNEXPECTED                     = 8000FFFFh;

(*
** MessageId: E_NOTIMPL
**
** MessageText:
**
**  Not implemented
*)
        E_NOTIMPL                        = 80004001h;

(*
** MessageId: E_OUTOFMEMORY
**
** MessageText:
**
**  Ran out of memory
*)
        E_OUTOFMEMORY                    = 8007000Eh;

(*
** MessageId: E_INVALIDARG
**
** MessageText:
**
**  One or more arguments are invalid
*)
        E_INVALIDARG                     = 80070057h;

(*
** MessageId: E_NOINTERFACE
**
** MessageText:
**
**  No such interface supported
*)
        E_NOINTERFACE                    = 80004002h;

(*
** MessageId: E_POINTER
**
** MessageText:
**
**  Invalid pointer
*)
        E_POINTER                        = 80004003h;

(*
** MessageId: E_HANDLE
**
** MessageText:
**
**  Invalid handle
*)
        E_HANDLE                         = 80070006h;

(*
** MessageId: E_ABORT
**
** MessageText:
**
**  Operation aborted
*)
        E_ABORT                          = 80004004h;

(*
** MessageId: E_FAIL
**
** MessageText:
**
**  Unspecified error
*)
        E_FAIL                           = 80004005h;

(*
** MessageId: E_ACCESSDENIED
**
** MessageText:
**
**  General access denied error
*)
        E_ACCESSDENIED                   = 80070005h;

(*
** MessageId: CO_E_INIT_TLS
**
** MessageText:
**
**  Thread local storage failure
*)
        CO_E_INIT_TLS                    = 80004006h;

(*
** MessageId: CO_E_INIT_SHARED_ALLOCATOR
**
** MessageText:
**
**  Get shared memory allocator failure
*)
        CO_E_INIT_SHARED_ALLOCATOR       = 80004007h;

(*
** MessageId: CO_E_INIT_MEMORY_ALLOCATOR
**
** MessageText:
**
**  Get memory allocator failure
*)
        CO_E_INIT_MEMORY_ALLOCATOR       = 80004008h;

(*
** MessageId: CO_E_INIT_CLASS_CACHE
**
** MessageText:
**
**  Unable to initialize class cache
*)
        CO_E_INIT_CLASS_CACHE            = 80004009h;

(*
** MessageId: CO_E_INIT_RPC_CHANNEL
**
** MessageText:
**
**  Unable to initialize RPC services
*)
        CO_E_INIT_RPC_CHANNEL            = 8000400Ah;

(*
** MessageId: CO_E_INIT_TLS_SET_CHANNEL_CONTROL
**
** MessageText:
**
**  Cannot set thread local storage channel control
*)
        CO_E_INIT_TLS_SET_CHANNEL_CONTROL = 8000400Bh;

(*
** MessageId: CO_E_INIT_TLS_CHANNEL_CONTROL
**
** MessageText:
**
**  Could not allocate thread local storage channel control
*)
        CO_E_INIT_TLS_CHANNEL_CONTROL    = 8000400Ch;

(*
** MessageId: CO_E_INIT_UNACCEPTED_USER_ALLOCATOR
**
** MessageText:
**
**  The user supplied memory allocator is unacceptable
*)
        CO_E_INIT_UNACCEPTED_USER_ALLOCATOR = 8000400Dh;

(*
** MessageId: CO_E_INIT_SCM_MUTEX_EXISTS
**
** MessageText:
**
**  The OLE service mutex already exists
*)
        CO_E_INIT_SCM_MUTEX_EXISTS       = 8000400Eh;

(*
** MessageId: CO_E_INIT_SCM_FILE_MAPPING_EXISTS
**
** MessageText:
**
**  The OLE service file mapping already exists
*)
        CO_E_INIT_SCM_FILE_MAPPING_EXISTS = 8000400Fh;

(*
** MessageId: CO_E_INIT_SCM_MAP_VIEW_OF_FILE
**
** MessageText:
**
**  Unable to map view of file for OLE service
*)
        CO_E_INIT_SCM_MAP_VIEW_OF_FILE   = 80004010h;

(*
** MessageId: CO_E_INIT_SCM_EXEC_FAILURE
**
** MessageText:
**
**  Failure attempting to launch OLE service
*)
        CO_E_INIT_SCM_EXEC_FAILURE       = 80004011h;

(*
** MessageId: CO_E_INIT_ONLY_SINGLE_THREADED
**
** MessageText:
**
**  There was an attempt to call CoInitialize a second time while single threaded
*)
        CO_E_INIT_ONLY_SINGLE_THREADED   = 80004012h;

(* ******************
** FACILITY_ITF
** *****************)

(*
** Codes 0x0-0x01ff are reserved for the OLE group of
** interfaces.
*)


(*
** Generic OLE errors that may be returned by many inerfaces
*)

        OLE_E_FIRST = 80040000h;
        OLE_E_LAST  = 800400FFh;
        OLE_S_FIRST = 00040000h;
        OLE_S_LAST  = 000400FFh;

(*
** Old OLE errors
**
**
** MessageId: OLE_E_OLEVERB
**
** MessageText:
**
**  Invalid OLEVERB structure
*)
        OLE_E_OLEVERB                    = 80040000h;

(*
** MessageId: OLE_E_ADVF
**
** MessageText:
**
**  Invalid advise flags
*)
        OLE_E_ADVF                       = 80040001h;

(*
** MessageId: OLE_E_ENUM_NOMORE
**
** MessageText:
**
**  Can't enumerate any more, because the associated data is missing
*)
        OLE_E_ENUM_NOMORE                = 80040002h;

(*
** MessageId: OLE_E_ADVISENOTSUPPORTED
**
** MessageText:
**
**  This implementation doesn't take advises
*)
        OLE_E_ADVISENOTSUPPORTED         = 80040003h;

(*
** MessageId: OLE_E_NOCONNECTION
**
** MessageText:
**
**  There is no connection for this connection ID
*)
        OLE_E_NOCONNECTION               = 80040004h;

(*
** MessageId: OLE_E_NOTRUNNING
**
** MessageText:
**
**  Need to run the object to perform this operation
*)
        OLE_E_NOTRUNNING                 = 80040005h;

(*
** MessageId: OLE_E_NOCACHE
**
** MessageText:
**
**  There is no cache to operate on
*)
        OLE_E_NOCACHE                    = 80040006h;

(*
** MessageId: OLE_E_BLANK
**
** MessageText:
**
**  Uninitialized object
*)
        OLE_E_BLANK                      = 80040007h;

(*
** MessageId: OLE_E_CLASSDIFF
**
** MessageText:
**
**  Linked object's source class has changed
*)
        OLE_E_CLASSDIFF                  = 80040008h;

(*
** MessageId: OLE_E_CANT_GETMONIKER
**
** MessageText:
**
**  Not able to get the moniker of the object
*)
        OLE_E_CANT_GETMONIKER            = 80040009h;

(*
** MessageId: OLE_E_CANT_BINDTOSOURCE
**
** MessageText:
**
**  Not able to bind to the source
*)
        OLE_E_CANT_BINDTOSOURCE          = 8004000Ah;

(*
** MessageId: OLE_E_STATIC
**
** MessageText:
**
**  Object is static; operation not allowed
*)
        OLE_E_STATIC                     = 8004000Bh;

(*
** MessageId: OLE_E_PROMPTSAVECANCELLED
**
** MessageText:
**
**  User cancelled out of save dialog
*)
        OLE_E_PROMPTSAVECANCELLED        = 8004000Ch;

(*
** MessageId: OLE_E_INVALIDRECT
**
** MessageText:
**
**  Invalid rectangle
*)
        OLE_E_INVALIDRECT                = 8004000Dh;

(*
** MessageId: OLE_E_WRONGCOMPOBJ
**
** MessageText:
**
**  compobj.dll is too old for the ole2.dll initialized
*)
        OLE_E_WRONGCOMPOBJ               = 8004000Eh;

(*
** MessageId: OLE_E_INVALIDHWND
**
** MessageText:
**
**  Invalid window handle
*)
        OLE_E_INVALIDHWND                = 8004000Fh;

(*
** MessageId: OLE_E_NOT_INPLACEACTIVE
**
** MessageText:
**
**  Object is not in any of the inplace active states
*)
        OLE_E_NOT_INPLACEACTIVE          = 80040010h;

(*
** MessageId: OLE_E_CANTCONVERT
**
** MessageText:
**
**  Not able to convert object
*)
        OLE_E_CANTCONVERT                = 80040011h;

(*
** MessageId: OLE_E_NOSTORAGE
**
** MessageText:
**
**  Not able to perform the operation because object is not given storage yet
**
*)
        OLE_E_NOSTORAGE                  = 80040012h;

(*
** MessageId: DV_E_FORMATETC
**
** MessageText:
**
**  Invalid FORMATETC structure
*)
        DV_E_FORMATETC                   = 80040064h;

(*
** MessageId: DV_E_DVTARGETDEVICE
**
** MessageText:
**
**  Invalid DVTARGETDEVICE structure
*)
        DV_E_DVTARGETDEVICE              = 80040065h;

(*
** MessageId: DV_E_STGMEDIUM
**
** MessageText:
**
**  Invalid STDGMEDIUM structure
*)
        DV_E_STGMEDIUM                   = 80040066h;

(*
** MessageId: DV_E_STATDATA
**
** MessageText:
**
**  Invalid STATDATA structure
*)
        DV_E_STATDATA                    = 80040067h;

(*
** MessageId: DV_E_LINDEX
**
** MessageText:
**
**  Invalid lindex
*)
        DV_E_LINDEX                      = 80040068h;

(*
** MessageId: DV_E_TYMED
**
** MessageText:
**
**  Invalid tymed
*)
        DV_E_TYMED                       = 80040069h;

(*
** MessageId: DV_E_CLIPFORMAT
**
** MessageText:
**
**  Invalid clipboard format
*)
        DV_E_CLIPFORMAT                  = 8004006Ah;

(*
** MessageId: DV_E_DVASPECT
**
** MessageText:
**
**  Invalid aspect(s)
*)
        DV_E_DVASPECT                    = 8004006Bh;

(*
** MessageId: DV_E_DVTARGETDEVICE_SIZE
**
** MessageText:
**
**  tdSize parameter of the DVTARGETDEVICE structure is invalid
*)
        DV_E_DVTARGETDEVICE_SIZE         = 8004006Ch;

(*
** MessageId: DV_E_NOIVIEWOBJECT
**
** MessageText:
**
**  Object doesn't support IViewObject interface
*)
        DV_E_NOIVIEWOBJECT               = 8004006Dh;

        DRAGDROP_E_FIRST = 80040100h;
        DRAGDROP_E_LAST  = 8004010Fh;
        DRAGDROP_S_FIRST = 00040100h;
        DRAGDROP_S_LAST  = 0004010Fh;
(*
** MessageId: DRAGDROP_E_NOTREGISTERED
**
** MessageText:
**
**  Trying to revoke a drop target that has not been registered
*)
        DRAGDROP_E_NOTREGISTERED         = 80040100h;

(*
** MessageId: DRAGDROP_E_ALREADYREGISTERED
**
** MessageText:
**
**  This window has already been registered as a drop target
*)
        DRAGDROP_E_ALREADYREGISTERED     = 80040101h;

(*
** MessageId: DRAGDROP_E_INVALIDHWND
**
** MessageText:
**
**  Invalid window handle
*)
        DRAGDROP_E_INVALIDHWND           = 80040102h;

        CLASSFACTORY_E_FIRST  = 80040110h;
        CLASSFACTORY_E_LAST   = 8004011Fh;
        CLASSFACTORY_S_FIRST  = 00040110h;
        CLASSFACTORY_S_LAST   = 0004011Fh;

(*
** MessageId: CLASS_E_NOAGGREGATION
**
** MessageText:
**
**  Class does not support aggregation (or class object is remote)
*)
        CLASS_E_NOAGGREGATION            = 80040110h;

(*
** MessageId: CLASS_E_CLASSNOTAVAILABLE
**
** MessageText:
**
**  ClassFactory cannot supply requested class
*)
        CLASS_E_CLASSNOTAVAILABLE        = 80040111h;

        MARSHAL_E_FIRST  = 80040120h;
        MARSHAL_E_LAST   = 8004012Fh;
        MARSHAL_S_FIRST  = 00040120h;
        MARSHAL_S_LAST   = 0004012Fh;
        DATA_E_FIRST     = 80040130h;
        DATA_E_LAST      = 8004013Fh;
        DATA_S_FIRST     = 00040130h;
        DATA_S_LAST      = 0004013Fh;
        VIEW_E_FIRST     = 80040140h;
        VIEW_E_LAST      = 8004014Fh;
        VIEW_S_FIRST     = 00040140h;
        VIEW_S_LAST      = 0004014Fh;

(*
** MessageId: VIEW_E_DRAW
**
** MessageText:
**
**  Error drawing view
*)
        VIEW_E_DRAW                      = 80040140h;

        REGDB_E_FIRST     = 80040150h;
        REGDB_E_LAST      = 8004015Fh;
        REGDB_S_FIRST     = 00040150h;
        REGDB_S_LAST      = 0004015Fh;
(*
** MessageId: REGDB_E_READREGDB
**
** MessageText:
**
**  Could not read key from registry
*)
        REGDB_E_READREGDB                = 80040150h;

(*
** MessageId: REGDB_E_WRITEREGDB
**
** MessageText:
**
**  Could not write key to registry
*)
        REGDB_E_WRITEREGDB               = 80040151h;

(*
** MessageId: REGDB_E_KEYMISSING
**
** MessageText:
**
**  Could not find the key in the registry
*)
        REGDB_E_KEYMISSING               = 80040152h;

(*
** MessageId: REGDB_E_INVALIDVALUE
**
** MessageText:
**
**  Invalid value for registry
*)
        REGDB_E_INVALIDVALUE             = 80040153h;

(*
** MessageId: REGDB_E_CLASSNOTREG
**
** MessageText:
**
**  Class not registered
*)
        REGDB_E_CLASSNOTREG              = 80040154h;

(*
** MessageId: REGDB_E_IIDNOTREG
**
** MessageText:
**
**  Interface not registered
*)
        REGDB_E_IIDNOTREG                = 80040155h;

        CACHE_E_FIRST     = 80040170h;
        CACHE_E_LAST      = 8004017Fh;
        CACHE_S_FIRST     = 00040170h;
        CACHE_S_LAST      = 0004017Fh;
(*
** MessageId: CACHE_E_NOCACHE_UPDATED
**
** MessageText:
**
**  Cache not updated
*)
        CACHE_E_NOCACHE_UPDATED          = 80040170h;

        OLEOBJ_E_FIRST     = 80040180h;
        OLEOBJ_E_LAST      = 8004018Fh;
        OLEOBJ_S_FIRST     = 00040180h;
        OLEOBJ_S_LAST      = 0004018Fh;
(*
** MessageId: OLEOBJ_E_NOVERBS
**
** MessageText:
**
**  No verbs for OLE object
*)
        OLEOBJ_E_NOVERBS                 = 80040180h;

(*
** MessageId: OLEOBJ_E_INVALIDVERB
**
** MessageText:
**
**  Invalid verb for OLE object
*)
        OLEOBJ_E_INVALIDVERB             = 80040181h;

        CLIENTSITE_E_FIRST     = 80040190h;
        CLIENTSITE_E_LAST      = 8004019Fh;
        CLIENTSITE_S_FIRST     = 00040190h;
        CLIENTSITE_S_LAST      = 0004019Fh;
(*
** MessageId: INPLACE_E_NOTUNDOABLE
**
** MessageText:
**
**  Undo is not available
*)
        INPLACE_E_NOTUNDOABLE            = 800401A0h;

(*
** MessageId: INPLACE_E_NOTOOLSPACE
**
** MessageText:
**
**  Space for tools is not available
*)
        INPLACE_E_NOTOOLSPACE            = 800401A1h;

        INPLACE_E_FIRST     = 800401A0h;
        INPLACE_E_LAST      = 800401AFh;
        INPLACE_S_FIRST     = 000401A0h;
        INPLACE_S_LAST      = 000401AFh;
        ENUM_E_FIRST        = 800401B0h;
        ENUM_E_LAST         = 800401BFh;
        ENUM_S_FIRST        = 000401B0h;
        ENUM_S_LAST         = 000401BFh;
        CONVERT10_E_FIRST        = 800401C0h;
        CONVERT10_E_LAST         = 800401CFh;
        CONVERT10_S_FIRST        = 000401C0h;
        CONVERT10_S_LAST         = 000401CFh;
(*
** MessageId: CONVERT10_E_OLESTREAM_GET
**
** MessageText:
**
**  OLESTREAM Get method failed
*)
        CONVERT10_E_OLESTREAM_GET        = 800401C0h;

(*
** MessageId: CONVERT10_E_OLESTREAM_PUT
**
** MessageText:
**
**  OLESTREAM Put method failed
*)
        CONVERT10_E_OLESTREAM_PUT        = 800401C1h;

(*
** MessageId: CONVERT10_E_OLESTREAM_FMT
**
** MessageText:
**
**  Contents of the OLESTREAM not in correct format
*)
        CONVERT10_E_OLESTREAM_FMT        = 800401C2h;

(*
** MessageId: CONVERT10_E_OLESTREAM_BITMAP_TO_DIB
**
** MessageText:
**
**  There was an error in a Windows GDI call while converting the bitmap to a DIB
*)
        CONVERT10_E_OLESTREAM_BITMAP_TO_DIB = 800401C3h;

(*
** MessageId: CONVERT10_E_STG_FMT
**
** MessageText:
**
**  Contents of the IStorage not in correct format
*)
        CONVERT10_E_STG_FMT              = 800401C4h;

(*
** MessageId: CONVERT10_E_STG_NO_STD_STREAM
**
** MessageText:
**
**  Contents of IStorage is missing one of the standard streams
*)
        CONVERT10_E_STG_NO_STD_STREAM    = 800401C5h;

(*
** MessageId: CONVERT10_E_STG_DIB_TO_BITMAP
**
** MessageText:
**
**  There was an error in a Windows GDI call while converting the DIB to a bitmap.
**
*)
        CONVERT10_E_STG_DIB_TO_BITMAP    = 800401C6h;

        CLIPBRD_E_FIRST        = 800401D0h;
        CLIPBRD_E_LAST         = 800401DFh;
        CLIPBRD_S_FIRST        = 000401D0h;
        CLIPBRD_S_LAST         = 000401DFh;
(*
** MessageId: CLIPBRD_E_CANT_OPEN
**
** MessageText:
**
**  OpenClipboard Failed
*)
        CLIPBRD_E_CANT_OPEN              = 800401D0h;

(*
** MessageId: CLIPBRD_E_CANT_EMPTY
**
** MessageText:
**
**  EmptyClipboard Failed
*)
        CLIPBRD_E_CANT_EMPTY             = 800401D1h;

(*
** MessageId: CLIPBRD_E_CANT_SET
**
** MessageText:
**
**  SetClipboard Failed
*)
        CLIPBRD_E_CANT_SET               = 800401D2h;

(*
** MessageId: CLIPBRD_E_BAD_DATA
**
** MessageText:
**
**  Data on clipboard is invalid
*)
        CLIPBRD_E_BAD_DATA               = 800401D3h;

(*
** MessageId: CLIPBRD_E_CANT_CLOSE
**
** MessageText:
**
**  CloseClipboard Failed
*)
        CLIPBRD_E_CANT_CLOSE             = 800401D4h;

        MK_E_FIRST        = 800401E0h;
        MK_E_LAST         = 800401EFh;
        MK_S_FIRST        = 000401E0h;
        MK_S_LAST         = 000401EFh;
(*
** MessageId: MK_E_CONNECTMANUALLY
**
** MessageText:
**
**  Moniker needs to be connected manually
*)
        MK_E_CONNECTMANUALLY             = 800401E0h;

(*
** MessageId: MK_E_EXCEEDEDDEADLINE
**
** MessageText:
**
**  Operation exceeded deadline
*)
        MK_E_EXCEEDEDDEADLINE            = 800401E1h;

(*
** MessageId: MK_E_NEEDGENERIC
**
** MessageText:
**
**  Moniker needs to be generic
*)
        MK_E_NEEDGENERIC                 = 800401E2h;

(*
** MessageId: MK_E_UNAVAILABLE
**
** MessageText:
**
**  Operation unavailable
*)
        MK_E_UNAVAILABLE                 = 800401E3h;

(*
** MessageId: MK_E_SYNTAX
**
** MessageText:
**
**  Invalid syntax
*)
        MK_E_SYNTAX                      = 800401E4h;

(*
** MessageId: MK_E_NOOBJECT
**
** MessageText:
**
**  No object for moniker
*)
        MK_E_NOOBJECT                    = 800401E5h;

(*
** MessageId: MK_E_INVALIDEXTENSION
**
** MessageText:
**
**  Bad extension for file
*)
        MK_E_INVALIDEXTENSION            = 800401E6h;

(*
** MessageId: MK_E_INTERMEDIATEINTERFACENOTSUPPORTED
**
** MessageText:
**
**  Intermediate operation failed
*)
        MK_E_INTERMEDIATEINTERFACENOTSUPPORTED = 800401E7h;

(*
** MessageId: MK_E_NOTBINDABLE
**
** MessageText:
**
**  Moniker is not bindable
*)
        MK_E_NOTBINDABLE                 = 800401E8h;

(*
** MessageId: MK_E_NOTBOUND
**
** MessageText:
**
**  Moniker is not bound
*)
        MK_E_NOTBOUND                    = 800401E9h;

(*
** MessageId: MK_E_CANTOPENFILE
**
** MessageText:
**
**  Moniker cannot open file
*)
        MK_E_CANTOPENFILE                = 800401EAh;

(*
** MessageId: MK_E_MUSTBOTHERUSER
**
** MessageText:
**
**  User input required for operation to succeed
*)
        MK_E_MUSTBOTHERUSER              = 800401EBh;

(*
** MessageId: MK_E_NOINVERSE
**
** MessageText:
**
**  Moniker class has no inverse
*)
        MK_E_NOINVERSE                   = 800401ECh;

(*
** MessageId: MK_E_NOSTORAGE
**
** MessageText:
**
**  Moniker does not refer to storage
*)
        MK_E_NOSTORAGE                   = 800401EDh;

(*
** MessageId: MK_E_NOPREFIX
**
** MessageText:
**
**  No common prefix
*)
        MK_E_NOPREFIX                    = 800401EEh;

(*
** MessageId: MK_E_ENUMERATION_FAILED
**
** MessageText:
**
**  Moniker could not be enumerated
*)
        MK_E_ENUMERATION_FAILED          = 800401EFh;

        CO_E_FIRST        = 800401F0h;
        CO_E_LAST         = 800401FFh;
        CO_S_FIRST        = 000401F0h;
        CO_S_LAST         = 000401FFh;

(*
** MessageId: CO_E_NOTINITIALIZED
**
** MessageText:
**
**  CoInitialize has not been called.
*)
        CO_E_NOTINITIALIZED              = 800401F0h;

(*
** MessageId: CO_E_ALREADYINITIALIZED
**
** MessageText:
**
**  CoInitialize has already been called.
*)
        CO_E_ALREADYINITIALIZED          = 800401F1h;

(*
** MessageId: CO_E_CANTDETERMINECLASS
**
** MessageText:
**
**  Class of object cannot be determined
*)
        CO_E_CANTDETERMINECLASS          = 800401F2h;

(*
** MessageId: CO_E_CLASSSTRING
**
** MessageText:
**
**  Invalid class string
*)
        CO_E_CLASSSTRING                 = 800401F3h;

(*
** MessageId: CO_E_IIDSTRING
**
** MessageText:
**
**  Invalid interface string
*)
        CO_E_IIDSTRING                   = 800401F4h;

(*
** MessageId: CO_E_APPNOTFOUND
**
** MessageText:
**
**  Application not found
*)
        CO_E_APPNOTFOUND                 = 800401F5h;

(*
** MessageId: CO_E_APPSINGLEUSE
**
** MessageText:
**
**  Application cannot be run more than once
*)
        CO_E_APPSINGLEUSE                = 800401F6h;

(*
** MessageId: CO_E_ERRORINAPP
**
** MessageText:
**
**  Some error in application program
*)
        CO_E_ERRORINAPP                  = 800401F7h;

(*
** MessageId: CO_E_DLLNOTFOUND
**
** MessageText:
**
**  DLL for class not found
*)
        CO_E_DLLNOTFOUND                 = 800401F8h;

(*
** MessageId: CO_E_ERRORINDLL
**
** MessageText:
**
**  Error in the DLL
*)
        CO_E_ERRORINDLL                  = 800401F9h;

(*
** MessageId: CO_E_WRONGOSFORAPP
**
** MessageText:
**
**  Wrong OS or OS version for application
*)
        CO_E_WRONGOSFORAPP               = 800401FAh;

(*
** MessageId: CO_E_OBJNOTREG
**
** MessageText:
**
**  Object is not registered
*)
        CO_E_OBJNOTREG                   = 800401FBh;

(*
** MessageId: CO_E_OBJISREG
**
** MessageText:
**
**  Object is already registered
*)
        CO_E_OBJISREG                    = 800401FCh;

(*
** MessageId: CO_E_OBJNOTCONNECTED
**
** MessageText:
**
**  Object is not connected to server
*)
        CO_E_OBJNOTCONNECTED             = 800401FDh;

(*
** MessageId: CO_E_APPDIDNTREG
**
** MessageText:
**
**  Application was launched but it didn't register a class factory
*)
        CO_E_APPDIDNTREG                 = 800401FEh;

(*
** MessageId: CO_E_RELEASED
**
** MessageText:
**
**  Object has been released
*)
        CO_E_RELEASED                    = 800401FFh;

(*
** Old OLE Success Codes
**
**
** MessageId: OLE_S_USEREG
**
** MessageText:
**
**  Use the registry database to provide the requested information
*)
        OLE_S_USEREG                     = 00040000h;

(*
** MessageId: OLE_S_STATIC
**
** MessageText:
**
**  Success, but static
*)
        OLE_S_STATIC                     = 00040001h;

(*
** MessageId: OLE_S_MAC_CLIPFORMAT
**
** MessageText:
**
**  Macintosh clipboard format
*)
        OLE_S_MAC_CLIPFORMAT             = 00040002h;

(*
** MessageId: DRAGDROP_S_DROP
**
** MessageText:
**
**  Successful drop took place
*)
        DRAGDROP_S_DROP                  = 00040100h;

(*
** MessageId: DRAGDROP_S_CANCEL
**
** MessageText:
**
**  Drag-drop operation canceled
*)
        DRAGDROP_S_CANCEL                = 00040101h;

(*
** MessageId: DRAGDROP_S_USEDEFAULTCURSORS
**
** MessageText:
**
**  Use the default cursor
*)
        DRAGDROP_S_USEDEFAULTCURSORS     = 00040102h;

(*
** MessageId: DATA_S_SAMEFORMATETC
**
** MessageText:
**
**  Data has same FORMATETC
*)
        DATA_S_SAMEFORMATETC             = 00040130h;

(*
** MessageId: VIEW_S_ALREADY_FROZEN
**
** MessageText:
**
**  View is already frozen
*)
        VIEW_S_ALREADY_FROZEN            = 00040140h;

(*
** MessageId: CACHE_S_FORMATETC_NOTSUPPORTED
**
** MessageText:
**
**  FORMATETC not supported
*)
        CACHE_S_FORMATETC_NOTSUPPORTED   = 00040170h;

(*
** MessageId: CACHE_S_SAMECACHE
**
** MessageText:
**
**  Same cache
*)
        CACHE_S_SAMECACHE                = 00040171h;

(*
** MessageId: CACHE_S_SOMECACHES_NOTUPDATED
**
** MessageText:
**
**  Some cache(s) not updated
*)
        CACHE_S_SOMECACHES_NOTUPDATED    = 00040172h;

(*
** MessageId: OLEOBJ_S_INVALIDVERB
**
** MessageText:
**
**  Invalid verb for OLE object
*)
        OLEOBJ_S_INVALIDVERB             = 00040180h;

(*
** MessageId: OLEOBJ_S_CANNOT_DOVERB_NOW
**
** MessageText:
**
**  Verb number is valid but verb cannot be done now
*)
        OLEOBJ_S_CANNOT_DOVERB_NOW       = 00040181h;

(*
** MessageId: OLEOBJ_S_INVALIDHWND
**
** MessageText:
**
**  Invalid window handle passed
*)
        OLEOBJ_S_INVALIDHWND             = 00040182h;

(*
** MessageId: INPLACE_S_TRUNCATED
**
** MessageText:
**
**  Message is too long; some of it had to be truncated before displaying
*)
        INPLACE_S_TRUNCATED              = 000401A0h;

(*
** MessageId: CONVERT10_S_NO_PRESENTATION
**
** MessageText:
**
**  Unable to convert OLESTREAM to IStorage
*)
        CONVERT10_S_NO_PRESENTATION      = 000401C0h;

(*
** MessageId: MK_S_REDUCED_TO_SELF
**
** MessageText:
**
**  Moniker reduced to itself
*)
        MK_S_REDUCED_TO_SELF             = 000401E2h;

(*
** MessageId: MK_S_ME
**
** MessageText:
**
**  Common prefix is this moniker
*)
        MK_S_ME                          = 000401E4h;

(*
** MessageId: MK_S_HIM
**
** MessageText:
**
**  Common prefix is input moniker
*)
        MK_S_HIM                         = 000401E5h;

(*
** MessageId: MK_S_US
**
** MessageText:
**
**  Common prefix is both monikers
*)
        MK_S_US                          = 000401E6h;

(*
** MessageId: MK_S_MONIKERALREADYREGISTERED
**
** MessageText:
**
**  Moniker is already registered in running object table
*)
        MK_S_MONIKERALREADYREGISTERED    = 000401E7h;

(* ******************
** FACILITY_WINDOWS
** ******************
**
** Codes 0x0-0x01ff are reserved for the OLE group of
** interfaces.
**
**
** MessageId: CO_E_CLASS_CREATE_FAILED
**
** MessageText:
**
**  Attempt to create a class object failed
*)
        CO_E_CLASS_CREATE_FAILED         = 80080001h;

(*
** MessageId: CO_E_SCM_ERROR
**
** MessageText:
**
**  OLE service could not bind object
*)
        CO_E_SCM_ERROR                   = 80080002h;

(*
** MessageId: CO_E_SCM_RPC_FAILURE
**
** MessageText:
**
**  RPC communication failed with OLE service
*)
        CO_E_SCM_RPC_FAILURE             = 80080003h;

(*
** MessageId: CO_E_BAD_PATH
**
** MessageText:
**
**  Bad path to object
*)
        CO_E_BAD_PATH                    = 80080004h;

(*
** MessageId: CO_E_SERVER_EXEC_FAILURE
**
** MessageText:
**
**  Server execution failed
*)
        CO_E_SERVER_EXEC_FAILURE         = 80080005h;

(*
** MessageId: CO_E_OBJSRV_RPC_FAILURE
**
** MessageText:
**
**  OLE service could not communicate with the object server
*)
        CO_E_OBJSRV_RPC_FAILURE          = 80080006h;

(*
** MessageId: MK_E_NO_NORMALIZED
**
** MessageText:
**
**  Moniker path could not be normalized
*)
        MK_E_NO_NORMALIZED               = 80080007h;

(*
** MessageId: CO_E_SERVER_STOPPING
**
** MessageText:
**
**  Object server is stopping when OLE service contacts it
*)
        CO_E_SERVER_STOPPING             = 80080008h;

(*
** MessageId: MEM_E_INVALID_ROOT
**
** MessageText:
**
**  An invalid root block pointer was specified
*)
        MEM_E_INVALID_ROOT               = 80080009h;

(*
** MessageId: MEM_E_INVALID_LINK
**
** MessageText:
**
**  An allocation chain contained an invalid link pointer
*)
        MEM_E_INVALID_LINK               = 80080010h;

(*
** MessageId: MEM_E_INVALID_SIZE
**
** MessageText:
**
**  The requested allocation size was too large
*)
        MEM_E_INVALID_SIZE               = 80080011h;

(* ******************
** FACILITY_DISPATCH
** ******************
**
** MessageId: DISP_E_UNKNOWNINTERFACE
**
** MessageText:
**
**  Unknown interface.
*)
        DISP_E_UNKNOWNINTERFACE          = 80020001h;

(*
** MessageId: DISP_E_MEMBERNOTFOUND
**
** MessageText:
**
**  Member not found.
*)
        DISP_E_MEMBERNOTFOUND            = 80020003h;

(*
** MessageId: DISP_E_PARAMNOTFOUND
**
** MessageText:
**
**  Parameter not found.
*)
        DISP_E_PARAMNOTFOUND             = 80020004h;

(*
** MessageId: DISP_E_TYPEMISMATCH
**
** MessageText:
**
**  Type mismatch.
*)
        DISP_E_TYPEMISMATCH              = 80020005h;

(*
** MessageId: DISP_E_UNKNOWNNAME
**
** MessageText:
**
**  Unknown name.
*)
        DISP_E_UNKNOWNNAME               = 80020006h;

(*
** MessageId: DISP_E_NONAMEDARGS
**
** MessageText:
**
**  No named arguments.
*)
        DISP_E_NONAMEDARGS               = 80020007h;

(*
** MessageId: DISP_E_BADVARTYPE
**
** MessageText:
**
**  Bad variable type.
*)
        DISP_E_BADVARTYPE                = 80020008h;

(*
** MessageId: DISP_E_EXCEPTION
**
** MessageText:
**
**  Exception occurred.
*)
        DISP_E_EXCEPTION                 = 80020009h;

(*
** MessageId: DISP_E_OVERFLOW
**
** MessageText:
**
**  Out of present range.
*)
        DISP_E_OVERFLOW                  = 8002000Ah;

(*
** MessageId: DISP_E_BADINDEX
**
** MessageText:
**
**  Invalid index.
*)
        DISP_E_BADINDEX                  = 8002000Bh;

(*
** MessageId: DISP_E_UNKNOWNLCID
**
** MessageText:
**
**  Unknown language.
*)
        DISP_E_UNKNOWNLCID               = 8002000Ch;

(*
** MessageId: DISP_E_ARRAYISLOCKED
**
** MessageText:
**
**  Memory is locked.
*)
        DISP_E_ARRAYISLOCKED             = 8002000Dh;

(*
** MessageId: DISP_E_BADPARAMCOUNT
**
** MessageText:
**
**  Invalid number of parameters.
*)
        DISP_E_BADPARAMCOUNT             = 8002000Eh;

(*
** MessageId: DISP_E_PARAMNOTOPTIONAL
**
** MessageText:
**
**  Parameter not optional.
*)
        DISP_E_PARAMNOTOPTIONAL          = 8002000Fh;

(*
** MessageId: DISP_E_BADCALLEE
**
** MessageText:
**
**  Invalid callee.
*)
        DISP_E_BADCALLEE                 = 80020010h;

(*
** MessageId: DISP_E_NOTACOLLECTION
**
** MessageText:
**
**  Does not support a collection.
*)
        DISP_E_NOTACOLLECTION            = 80020011h;

(*
** MessageId: TYPE_E_BUFFERTOOSMALL
**
** MessageText:
**
**  Buffer too small.
*)
        TYPE_E_BUFFERTOOSMALL            = 80028016h;

(*
** MessageId: TYPE_E_INVDATAREAD
**
** MessageText:
**
**  Old format or invalid type library.
*)
        TYPE_E_INVDATAREAD               = 80028018h;

(*
** MessageId: TYPE_E_UNSUPFORMAT
**
** MessageText:
**
**  Old format or invalid type library.
*)
        TYPE_E_UNSUPFORMAT               = 80028019h;

(*
** MessageId: TYPE_E_REGISTRYACCESS
**
** MessageText:
**
**  Error accessing the OLE registry.
*)
        TYPE_E_REGISTRYACCESS            = 8002801Ch;

(*
** MessageId: TYPE_E_LIBNOTREGISTERED
**
** MessageText:
**
**  Library not registered.
*)
        TYPE_E_LIBNOTREGISTERED          = 8002801Dh;

(*
** MessageId: TYPE_E_UNDEFINEDTYPE
**
** MessageText:
**
**  Bound to unknown type.
*)
        TYPE_E_UNDEFINEDTYPE             = 80028027h;

(*
** MessageId: TYPE_E_QUALIFIEDNAMEDISALLOWED
**
** MessageText:
**
**  Qualified name disallowed.
*)
        TYPE_E_QUALIFIEDNAMEDISALLOWED   = 80028028h;

(*
** MessageId: TYPE_E_INVALIDSTATE
**
** MessageText:
**
**  Invalid forward reference, or reference to uncompiled type.
*)
        TYPE_E_INVALIDSTATE              = 80028029h;

(*
** MessageId: TYPE_E_WRONGTYPEKIND
**
** MessageText:
**
**  Type mismatch.
*)
        TYPE_E_WRONGTYPEKIND             = 8002802Ah;

(*
** MessageId: TYPE_E_ELEMENTNOTFOUND
**
** MessageText:
**
**  Element not found.
*)
        TYPE_E_ELEMENTNOTFOUND           = 8002802Bh;

(*
** MessageId: TYPE_E_AMBIGUOUSNAME
**
** MessageText:
**
**  Ambiguous name.
*)
        TYPE_E_AMBIGUOUSNAME             = 8002802Ch;

(*
** MessageId: TYPE_E_NAMECONFLICT
**
** MessageText:
**
**  Name already exists in the library.
*)
        TYPE_E_NAMECONFLICT              = 8002802Dh;

(*
** MessageId: TYPE_E_UNKNOWNLCID
**
** MessageText:
**
**  Unknown LCID.
*)
        TYPE_E_UNKNOWNLCID               = 8002802Eh;

(*
** MessageId: TYPE_E_DLLFUNCTIONNOTFOUND
**
** MessageText:
**
**  Function not defined in specified DLL.
*)
        TYPE_E_DLLFUNCTIONNOTFOUND       = 8002802Fh;

(*
** MessageId: TYPE_E_BADMODULEKIND
**
** MessageText:
**
**  Wrong module kind for the operation.
*)
        TYPE_E_BADMODULEKIND             = 800288BDh;

(*
** MessageId: TYPE_E_SIZETOOBIG
**
** MessageText:
**
**  Size may not exceed 64K.
*)
        TYPE_E_SIZETOOBIG                = 800288C5h;

(*
** MessageId: TYPE_E_DUPLICATEID
**
** MessageText:
**
**  Duplicate ID in inheritance hierarchy.
*)
        TYPE_E_DUPLICATEID               = 800288C6h;

(*
** MessageId: TYPE_E_INVALIDID
**
** MessageText:
**
**  Incorrect inheritance depth in standard OLE hmember.
*)
        TYPE_E_INVALIDID                 = 800288CFh;

(*
** MessageId: TYPE_E_TYPEMISMATCH
**
** MessageText:
**
**  Type mismatch.
*)
        TYPE_E_TYPEMISMATCH              = 80028CA0h;

(*
** MessageId: TYPE_E_OUTOFBOUNDS
**
** MessageText:
**
**  Invalid number of arguments.
*)
        TYPE_E_OUTOFBOUNDS               = 80028CA1h;

(*
** MessageId: TYPE_E_IOERROR
**
** MessageText:
**
**  I/O Error.
*)
        TYPE_E_IOERROR                   = 80028CA2h;

(*
** MessageId: TYPE_E_CANTCREATETMPFILE
**
** MessageText:
**
**  Error creating unique tmp file.
*)
        TYPE_E_CANTCREATETMPFILE         = 80028CA3h;

(*
** MessageId: TYPE_E_CANTLOADLIBRARY
**
** MessageText:
**
**  Error loading type library/DLL.
*)
        TYPE_E_CANTLOADLIBRARY           = 80029C4Ah;

(*
** MessageId: TYPE_E_INCONSISTENTPROPFUNCS
**
** MessageText:
**
**  Inconsistent property functions.
*)
        TYPE_E_INCONSISTENTPROPFUNCS     = 80029C83h;

(*
** MessageId: TYPE_E_CIRCULARTYPE
**
** MessageText:
**
**  Circular dependency between types/modules.
*)
        TYPE_E_CIRCULARTYPE              = 80029C84h;

(* ******************
** FACILITY_STORAGE
** ******************
**
** MessageId: STG_E_INVALIDFUNCTION
**
** MessageText:
**
**  Unable to perform requested operation.
*)
        STG_E_INVALIDFUNCTION            = 80030001h;

(*
** MessageId: STG_E_FILENOTFOUND
**
** MessageText:
**
**  %1 could not be found.
*)
        STG_E_FILENOTFOUND               = 80030002h;

(*
** MessageId: STG_E_PATHNOTFOUND
**
** MessageText:
**
**  The path %1 could not be found.
*)
        STG_E_PATHNOTFOUND               = 80030003h;

(*
** MessageId: STG_E_TOOMANYOPENFILES
**
** MessageText:
**
**  There are insufficient resources to open another file.
*)
        STG_E_TOOMANYOPENFILES           = 80030004h;

(*
** MessageId: STG_E_ACCESSDENIED
**
** MessageText:
**
**  Access Denied.
*)
        STG_E_ACCESSDENIED               = 80030005h;

(*
** MessageId: STG_E_INVALIDHANDLE
**
** MessageText:
**
**  Attempted an operation on an invalid object.
*)
        STG_E_INVALIDHANDLE              = 80030006h;

(*
** MessageId: STG_E_INSUFFICIENTMEMORY
**
** MessageText:
**
**  There is insufficient memory available to complete operation.
*)
        STG_E_INSUFFICIENTMEMORY         = 80030008h;

(*
** MessageId: STG_E_INVALIDPOINTER
**
** MessageText:
**
**  Invalid pointer error.
*)
        STG_E_INVALIDPOINTER             = 80030009h;

(*
** MessageId: STG_E_NOMOREFILES
**
** MessageText:
**
**  There are no more entries to return.
*)
        STG_E_NOMOREFILES                = 80030012h;

(*
** MessageId: STG_E_DISKISWRITEPROTECTED
**
** MessageText:
**
**  Disk is write-protected.
*)
        STG_E_DISKISWRITEPROTECTED       = 80030013h;

(*
** MessageId: STG_E_SEEKERROR
**
** MessageText:
**
**  An error occurred during a seek operation.
*)
        STG_E_SEEKERROR                  = 80030019h;

(*
** MessageId: STG_E_WRITEFAULT
**
** MessageText:
**
**  A disk error occurred during a write operation.
*)
        STG_E_WRITEFAULT                 = 8003001Dh;

(*
** MessageId: STG_E_READFAULT
**
** MessageText:
**
**  A disk error occurred during a read operation.
*)
        STG_E_READFAULT                  = 8003001Eh;

(*
** MessageId: STG_E_SHAREVIOLATION
**
** MessageText:
**
**  A share violation has occurred.
*)
        STG_E_SHAREVIOLATION             = 80030020h;

(*
** MessageId: STG_E_LOCKVIOLATION
**
** MessageText:
**
**  A lock violation has occurred.
*)
        STG_E_LOCKVIOLATION              = 80030021h;

(*
** MessageId: STG_E_FILEALREADYEXISTS
**
** MessageText:
**
**  %1 already exists.
*)
        STG_E_FILEALREADYEXISTS          = 80030050h;

(*
** MessageId: STG_E_INVALIDPARAMETER
**
** MessageText:
**
**  Invalid parameter error.
*)
        STG_E_INVALIDPARAMETER           = 80030057h;

(*
** MessageId: STG_E_MEDIUMFULL
**
** MessageText:
**
**  There is insufficient disk space to complete operation.
*)
        STG_E_MEDIUMFULL                 = 80030070h;

(*
** MessageId: STG_E_ABNORMALAPIEXIT
**
** MessageText:
**
**  An API call exited abnormally.
*)
        STG_E_ABNORMALAPIEXIT            = 800300FAh;

(*
** MessageId: STG_E_INVALIDHEADER
**
** MessageText:
**
**  The file %1 is not a valid compound file.
*)
        STG_E_INVALIDHEADER              = 800300FBh;

(*
** MessageId: STG_E_INVALIDNAME
**
** MessageText:
**
**  The name %1 is not valid.
*)
        STG_E_INVALIDNAME                = 800300FCh;

(*
** MessageId: STG_E_UNKNOWN
**
** MessageText:
**
**  An unexpected error occurred.
*)
        STG_E_UNKNOWN                    = 800300FDh;

(*
** MessageId: STG_E_UNIMPLEMENTEDFUNCTION
**
** MessageText:
**
**  That function is not implemented.
*)
        STG_E_UNIMPLEMENTEDFUNCTION      = 800300FEh;

(*
** MessageId: STG_E_INVALIDFLAG
**
** MessageText:
**
**  Invalid flag error.
*)
        STG_E_INVALIDFLAG                = 800300FFh;

(*
** MessageId: STG_E_INUSE
**
** MessageText:
**
**  Attempted to use an object that is busy.
*)
        STG_E_INUSE                      = 80030100h;

(*
** MessageId: STG_E_NOTCURRENT
**
** MessageText:
**
**  The storage has been changed since the last commit.
*)
        STG_E_NOTCURRENT                 = 80030101h;

(*
** MessageId: STG_E_REVERTED
**
** MessageText:
**
**  Attempted to use an object that has ceased to exist.
*)
        STG_E_REVERTED                   = 80030102h;

(*
** MessageId: STG_E_CANTSAVE
**
** MessageText:
**
**  Can't save.
*)
        STG_E_CANTSAVE                   = 80030103h;

(*
** MessageId: STG_E_OLDFORMAT
**
** MessageText:
**
**  The compound file %1 was produced with an incompatible version of storage.
*)
        STG_E_OLDFORMAT                  = 80030104h;

(*
** MessageId: STG_E_OLDDLL
**
** MessageText:
**
**  The compound file %1 was produced with a newer version of storage.
*)
        STG_E_OLDDLL                     = 80030105h;

(*
** MessageId: STG_E_SHAREREQUIRED
**
** MessageText:
**
**  Share.exe or equivalent is required for operation.
*)
        STG_E_SHAREREQUIRED              = 80030106h;

(*
** MessageId: STG_E_NOTFILEBASEDSTORAGE
**
** MessageText:
**
**  Illegal operation called on non-file based storage.
*)
        STG_E_NOTFILEBASEDSTORAGE        = 80030107h;

(*
** MessageId: STG_E_EXTANTMARSHALLINGS
**
** MessageText:
**
**  Illegal operation called on object with extant marshallings.
*)
        STG_E_EXTANTMARSHALLINGS         = 80030108h;

(*
** MessageId: STG_S_CONVERTED
**
** MessageText:
**
**  The underlying file was converted to compound file format.
*)
        STG_S_CONVERTED                  = 00030200h;

(* ******************
** FACILITY_RPC
** ******************
**
** Codes 0x0-0x11 are propogated from 16 bit OLE.
**
**
** MessageId: RPC_E_CALL_REJECTED
**
** MessageText:
**
**  Call was rejected by callee.
*)
        RPC_E_CALL_REJECTED              = 80010001h;

(*
** MessageId: RPC_E_CALL_CANCELED
**
** MessageText:
**
**  Call was canceled by the message filter.
*)
        RPC_E_CALL_CANCELED              = 80010002h;

(*
** MessageId: RPC_E_CANTPOST_INSENDCALL
**
** MessageText:
**
**  The caller is dispatching an intertask SendMessage call and
**  cannot call out via PostMessage.
*)
        RPC_E_CANTPOST_INSENDCALL        = 80010003h;

(*
** MessageId: RPC_E_CANTCALLOUT_INASYNCCALL
**
** MessageText:
**
**  The caller is dispatching an asynchronous call and cannot
**  make an outgoing call on behalf of this call.
*)
        RPC_E_CANTCALLOUT_INASYNCCALL    = 80010004h;

(*
** MessageId: RPC_E_CANTCALLOUT_INEXTERNALCALL
**
** MessageText:
**
**  It is illegal to call out while inside message filter.
*)
        RPC_E_CANTCALLOUT_INEXTERNALCALL = 80010005h;

(*
** MessageId: RPC_E_CONNECTION_TERMINATED
**
** MessageText:
**
**  The connection terminated or is in a bogus state
**  and cannot be used any more. Other connections
**  are still valid.
*)
        RPC_E_CONNECTION_TERMINATED      = 80010006h;

(*
** MessageId: RPC_E_SERVER_DIED
**
** MessageText:
**
**  The callee (server [not server application]) is not available
**  and disappeared; all connections are invalid.  The call may
**  have executed.
*)
        RPC_E_SERVER_DIED                = 80010007h;

(*
** MessageId: RPC_E_CLIENT_DIED
**
** MessageText:
**
**  The caller (client) disappeared while the callee (server) was
**  processing a call.
*)
        RPC_E_CLIENT_DIED                = 80010008h;

(*
** MessageId: RPC_E_INVALID_DATAPACKET
**
** MessageText:
**
**  The data packet with the marshalled parameter data is incorrect.
*)
        RPC_E_INVALID_DATAPACKET         = 80010009h;

(*
** MessageId: RPC_E_CANTTRANSMIT_CALL
**
** MessageText:
**
**  The call was not transmitted properly; the message queue
**  was full and was not emptied after yielding.
*)
        RPC_E_CANTTRANSMIT_CALL          = 8001000Ah;

(*
** MessageId: RPC_E_CLIENT_CANTMARSHAL_DATA
**
** MessageText:
**
**  The client (caller) cannot marshall the parameter data - low memory, etc.
*)
        RPC_E_CLIENT_CANTMARSHAL_DATA    = 8001000Bh;

(*
** MessageId: RPC_E_CLIENT_CANTUNMARSHAL_DATA
**
** MessageText:
**
**  The client (caller) cannot unmarshall the return data - low memory, etc.
*)
        RPC_E_CLIENT_CANTUNMARSHAL_DATA  = 8001000Ch;

(*
** MessageId: RPC_E_SERVER_CANTMARSHAL_DATA
**
** MessageText:
**
**  The server (callee) cannot marshall the return data - low memory, etc.
*)
        RPC_E_SERVER_CANTMARSHAL_DATA    = 8001000Dh;

(*
** MessageId: RPC_E_SERVER_CANTUNMARSHAL_DATA
**
** MessageText:
**
**  The server (callee) cannot unmarshall the parameter data - low memory, etc.
*)
        RPC_E_SERVER_CANTUNMARSHAL_DATA  = 8001000Eh;

(*
** MessageId: RPC_E_INVALID_DATA
**
** MessageText:
**
**  Received data is invalid; could be server or client data.
*)
        RPC_E_INVALID_DATA               = 8001000Fh;

(*
** MessageId: RPC_E_INVALID_PARAMETER
**
** MessageText:
**
**  A particular parameter is invalid and cannot be (un)marshalled.
*)
        RPC_E_INVALID_PARAMETER          = 80010010h;

(*
** MessageId: RPC_E_CANTCALLOUT_AGAIN
**
** MessageText:
**
**  There is no second outgoing call on same channel in DDE conversation.
*)
        RPC_E_CANTCALLOUT_AGAIN          = 80010011h;

(*
** MessageId: RPC_E_SERVER_DIED_DNE
**
** MessageText:
**
**  The callee (server [not server application]) is not available
**  and disappeared; all connections are invalid.  The call did not execute.
*)
        RPC_E_SERVER_DIED_DNE            = 80010012h;

(*
** MessageId: RPC_E_SYS_CALL_FAILED
**
** MessageText:
**
**  System call failed.
*)
        RPC_E_SYS_CALL_FAILED            = 80010100h;

(*
** MessageId: RPC_E_OUT_OF_RESOURCES
**
** MessageText:
**
**  Could not allocate some required resource (memory, events, ...)
*)
        RPC_E_OUT_OF_RESOURCES           = 80010101h;

(*
** MessageId: RPC_E_ATTEMPTED_MULTITHREAD
**
** MessageText:
**
**  Attempted to make calls on more than one thread in single threaded mode.
*)
        RPC_E_ATTEMPTED_MULTITHREAD      = 80010102h;

(*
** MessageId: RPC_E_NOT_REGISTERED
**
** MessageText:
**
**  The requested interface is not registered on the server object.
*)
        RPC_E_NOT_REGISTERED             = 80010103h;

(*
** MessageId: RPC_E_FAULT
**
** MessageText:
**
**  RPC could not call the server or could not return the results of calling the server.
*)
        RPC_E_FAULT                      = 80010104h;

(*
** MessageId: RPC_E_SERVERFAULT
**
** MessageText:
**
**  The server threw an exception.
*)
        RPC_E_SERVERFAULT                = 80010105h;

(*
** MessageId: RPC_E_CHANGED_MODE
**
** MessageText:
**
**  Cannot change thread mode after it is set.
*)
        RPC_E_CHANGED_MODE               = 80010106h;

(*
** MessageId: RPC_E_INVALIDMETHOD
**
** MessageText:
**
**  The method called does not exist on the server.
*)
        RPC_E_INVALIDMETHOD              = 80010107h;

(*
** MessageId: RPC_E_DISCONNECTED
**
** MessageText:
**
**  The object invoked has disconnected from its clients.
*)
        RPC_E_DISCONNECTED               = 80010108h;

(*
** MessageId: RPC_E_RETRY
**
** MessageText:
**
**  The object invoked chose not to process the call now.  Try again later.
*)
        RPC_E_RETRY                      = 80010109h;

(*
** MessageId: RPC_E_SERVERCALL_RETRYLATER
**
** MessageText:
**
**  The message filter indicated that the application is busy.
*)
        RPC_E_SERVERCALL_RETRYLATER      = 8001010Ah;

(*
** MessageId: RPC_E_SERVERCALL_REJECTED
**
** MessageText:
**
**  The message filter rejected the call.
*)
        RPC_E_SERVERCALL_REJECTED        = 8001010Bh;

(*
** MessageId: RPC_E_INVALID_CALLDATA
**
** MessageText:
**
**  A call control interfaces was called with invalid data.
*)
        RPC_E_INVALID_CALLDATA           = 8001010Ch;

(*
** MessageId: RPC_E_CANTCALLOUT_ININPUTSYNCCALL
**
** MessageText:
**
**  An outgoing call cannot be made since the application is dispatching an input-synchronous call.
*)
        RPC_E_CANTCALLOUT_ININPUTSYNCCALL = 8001010Dh;

(*
** MessageId: RPC_E_WRONG_THREAD
**
** MessageText:
**
**  The application called an interface that was marshalled for a different thread.
*)
        RPC_E_WRONG_THREAD               = 8001010Eh;

(*
** MessageId: RPC_E_THREAD_NOT_INIT
**
** MessageText:
**
**  CoInitialize has not been called on the current thread.
*)
        RPC_E_THREAD_NOT_INIT            = 8001010Fh;

(*
** MessageId: RPC_E_UNEXPECTED
**
** MessageText:
**
**  An internal error occurred.
*)
        RPC_E_UNEXPECTED                 = 8001FFFFh;



(**************************************************************************
*                                                                         *
* WinGDI -- GDI procedure declarations and constant definitions           *
*                                                                         *
**************************************************************************)



<* IF NOT DEFINED (NORASTEROPS) THEN *>

(* Binary raster ops *)

TYPE ROP2 = (R2_ERROR,
             R2_BLACK,        (*  1 - 0    *)
             R2_NOTMERGEPEN,  (*  2 - DPon *)
             R2_MASKNOTPEN,   (*  3 - DPna *)
             R2_NOTCOPYPEN,   (*  4 - PN   *)
             R2_MASKPENNOT,   (*  5 - PDna *)
             R2_NOT,          (*  6 - Dn   *)
             R2_XORPEN,       (*  7 - DPx  *)
             R2_NOTMASKPEN,   (*  8 - DPan *)
             R2_MASKPEN,      (*  9 - DPa  *)
             R2_NOTXORPEN,    (* 10 - DPxn *)
             R2_NOP,          (* 11 - D    *)
             R2_MERGENOTPEN,  (* 12 - DPno *)
             R2_COPYPEN,      (* 13 - P    *)
             R2_MERGEPENNOT,  (* 14 - PDno *)
             R2_MERGEPEN,     (* 15 - DPo  *)
             R2_WHITE);       (* 16 - 1    *)

CONST R2_LAST = R2_WHITE;

(* Ternary raster operations *)

TYPE ROP = DWORD;

CONST SRCCOPY      = ROP (00CC0020h); (* dest = source                   *)
      SRCPAINT     = ROP (00EE0086h); (* dest = source OR dest           *)
      SRCAND       = ROP (008800C6h); (* dest = source AND dest          *)
      SRCINVERT    = ROP (00660046h); (* dest = source XOR dest          *)
      SRCERASE     = ROP (00440328h); (* dest = source AND (NOT dest )   *)
      NOTSRCCOPY   = ROP (00330008h); (* dest = (NOT source)             *)
      NOTSRCERASE  = ROP (001100A6h); (* dest = (NOT src) AND (NOT dest) *)
      MERGECOPY    = ROP (00C000CAh); (* dest = (source AND pattern)     *)
      MERGEPAINT   = ROP (00BB0226h); (* dest = (NOT source) OR dest     *)
      PATCOPY      = ROP (00F00021h); (* dest = pattern                  *)
      PATPAINT     = ROP (00FB0A09h); (* dest = DPSnoo                   *)
      PATINVERT    = ROP (005A0049h); (* dest = pattern XOR dest         *)
      DSTINVERT    = ROP (00550009h); (* dest = (NOT dest)               *)
      BLACKNESS    = ROP (00000042h); (* dest = BLACK                    *)
      WHITENESS    = ROP (00FF0062h); (* dest = WHITE                    *)

(* Quaternary raster codes *)
TYPE ROP4 = DWORD;

PROCEDURE MAKEROP4 (fore, back : ROP) : ROP4; (* in RTL; was macro *)

<* END *> (* NOT DEFINED (NORASTEROPS) *)

CONST GDI_ERROR = 0FFFFFFFFh;
      HGDI_ERROR = SYSTEM.CAST (HANDLE, VAL (ULONG, 0FFFFFFFFh));

(* Region Flags *)

TYPE RGN_CODE = (RGN_ERROR, NULLREGION, SIMPLEREGION, COMPLEXREGION);

(* CombineRgn() Styles *)
TYPE RGN_COMBINE_ENUM = (RGN_COMBINE_0,
                         RGN_AND,        (* 1 *)
                         RGN_OR,         (* 2 *)
                         RGN_XOR,        (* 3 *)
                         RGN_DIFF,       (* 4 *)
                         RGN_COPY);      (* 5 *)

CONST RGN_MIN = RGN_AND;
      RGN_MAX = RGN_COPY;

(* StretchBlt () Modes *)
TYPE STRETCH_ENUM = (STRETCH_0,
                     BLACKONWHITE,   (* 1 *)
                     WHITEONBLACK,   (* 2 *)
                     COLORONCOLOR,   (* 3 *)
                     HALFTONE);      (* 4 *)

CONST MAXSTRETCHBLTMODE   = HALFTONE;
      STRETCH_ANDSCANS    = BLACKONWHITE;
      STRETCH_ORSCANS     = WHITEONBLACK;
      STRETCH_DELETESCANS = COLORONCOLOR;
      STRETCH_HALFTONE    = HALFTONE;

(* PolyFill(), CreatePolygonRgn() Modes *)

TYPE POLYFILL_ENUM = (POLYFILL_0, ALTERNATE, WINDING);
CONST POLYFILL_LAST = WINDING;

(* Text Alignment Options *)

TYPE TA_ENUM = (TA__0, TA__1, TA__2, TA__3,
                TA__4, TA__5, TA__6, TA__7,
                TA__8);
     TA_SET = SET OF TA_ENUM;

CONST TA_NOUPDATECP = TA_SET {};              (*   0 *)
      TA_UPDATECP   = TA_SET {TA__0};         (*   1 *)

      TA_LEFT       = TA_SET {};              (*   0 *)
      TA_RIGHT      = TA_SET {TA__1};         (*   2 *)
      TA_CENTER     = TA_SET {TA__2, TA__1};  (*   6 *)

      TA_TOP        = TA_SET {};              (*   0 *)
      TA_BOTTOM     = TA_SET {TA__3};         (*   8 *)
      TA_BASELINE   = TA_SET {TA__4, TA__3};  (*  24 *)

      TA_RTLREADING = TA_SET {TA__8};         (* 256 *)
      TA_MASK       = TA_BASELINE + TA_CENTER + TA_UPDATECP + TA_RTLREADING;

CONST VTA_BASELINE = TA_BASELINE;
      VTA_LEFT     = TA_BOTTOM;
      VTA_RIGHT    = TA_TOP;
      VTA_CENTER   = TA_CENTER;
      VTA_BOTTOM   = TA_RIGHT;
      VTA_TOP      = TA_LEFT;

TYPE ETO_ENUM = (ETO__0,
                 ETO__OPAQUE,      (* 1 *)
                 ETO__CLIPPED,     (* 2 *)
                 ETO__3,
                 ETO__GLYPH_INDEX, (* 4 *)
                 ETO__5, ETO__6,
                 ETO__RTLREADING,  (* 7 *)
                 ETO__8,  ETO__9,
                 ETO__10, ETO__11,
                 ETO__IGNORELANGUAGE);
     ETO_SET = SET OF ETO_ENUM;

CONST ETO_OPAQUE         = ETO_SET {ETO__OPAQUE};      (* 0x0002 *)
      ETO_CLIPPED        = ETO_SET {ETO__CLIPPED};     (* 0x0004 *)
      ETO_GLYPH_INDEX    = ETO_SET {ETO__GLYPH_INDEX}; (* 0x0010 *)
      ETO_RTLREADING     = ETO_SET {ETO__RTLREADING};  (* 0x0080 *)
      ETO_IGNORELANGUAGE = ETO_SET {ETO__IGNORELANGUAGE}; (* 0x1000 *)

CONST ASPECT_FILTERING = 1;

(* Bounds Accumulation APIs *)

TYPE DCB_ENUM = (DCB__RESET,       (* 0 *)
                 DCB__ACCUMULATE,  (* 1 *)
                 DCB__ENABLE,      (* 2 *)
                 DCB__DISABLE);    (* 3 *)

     DCB__SET = SET OF DCB_ENUM;

CONST DCB__DIRTY = DCB__ACCUMULATE;

      DCB_RESET       = DCB__SET {DCB__RESET};        (* 0x0001 *)
      DCB_ACCUMULATE  = DCB__SET {DCB__ACCUMULATE};   (* 0x0002 *)
      DCB_DIRTY       = DCB__SET {DCB__DIRTY};        (* 0x0002 *)
      DCB_ENABLE      = DCB__SET {DCB__ENABLE};       (* 0x0004 *)
      DCB_DISABLE     = DCB__SET {DCB__DISABLE};      (* 0x0008 *)
      DCB_SET         = DCB_RESET + DCB_ACCUMULATE;

<* IF NOT DEFINED (NOMETAFILE) THEN *>

(* Metafile Functions *)

CONST META_SETBKCOLOR           =  0201h;
      META_SETBKMODE            =  0102h;
      META_SETMAPMODE           =  0103h;
      META_SETROP2              =  0104h;
      META_SETRELABS            =  0105h;
      META_SETPOLYFILLMODE      =  0106h;
      META_SETSTRETCHBLTMODE    =  0107h;
      META_SETTEXTCHAREXTRA     =  0108h;
      META_SETTEXTCOLOR         =  0209h;
      META_SETTEXTJUSTIFICATION =  020Ah;
      META_SETWINDOWORG         =  020Bh;
      META_SETWINDOWEXT         =  020Ch;
      META_SETVIEWPORTORG       =  020Dh;
      META_SETVIEWPORTEXT       =  020Eh;
      META_OFFSETWINDOWORG      =  020Fh;
      META_SCALEWINDOWEXT       =  0410h;
      META_OFFSETVIEWPORTORG    =  0211h;
      META_SCALEVIEWPORTEXT     =  0412h;
      META_LINETO               =  0213h;
      META_MOVETO               =  0214h;
      META_EXCLUDECLIPRECT      =  0415h;
      META_INTERSECTCLIPRECT    =  0416h;
      META_ARC                  =  0817h;
      META_ELLIPSE              =  0418h;
      META_FLOODFILL            =  0419h;
      META_PIE                  =  081Ah;
      META_RECTANGLE            =  041Bh;
      META_ROUNDRECT            =  061Ch;
      META_PATBLT               =  061Dh;
      META_SAVEDC               =  001Eh;
      META_SETPIXEL             =  041Fh;
      META_OFFSETCLIPRGN        =  0220h;
      META_TEXTOUT              =  0521h;
      META_BITBLT               =  0922h;
      META_STRETCHBLT           =  0B23h;
      META_POLYGON              =  0324h;
      META_POLYLINE             =  0325h;
      META_ESCAPE               =  0626h;
      META_RESTOREDC            =  0127h;
      META_FILLREGION           =  0228h;
      META_FRAMEREGION          =  0429h;
      META_INVERTREGION         =  012Ah;
      META_PAINTREGION          =  012Bh;
      META_SELECTCLIPREGION     =  012Ch;
      META_SELECTOBJECT         =  012Dh;
      META_SETTEXTALIGN         =  012Eh;
      META_CHORD                =  0830h;
      META_SETMAPPERFLAGS       =  0231h;
      META_EXTTEXTOUT           =  0a32h;
      META_SETDIBTODEV          =  0d33h;
      META_SELECTPALETTE        =  0234h;
      META_REALIZEPALETTE       =  0035h;
      META_ANIMATEPALETTE       =  0436h;
      META_SETPALENTRIES        =  0037h;
      META_POLYPOLYGON          =  0538h;
      META_RESIZEPALETTE        =  0139h;
      META_DIBBITBLT            =  0940h;
      META_DIBSTRETCHBLT        =  0b41h;
      META_DIBCREATEPATTERNBRUSH=  0142h;
      META_STRETCHDIB           =  0f43h;
      META_EXTFLOODFILL         =  0548h;
      META_DELETEOBJECT         =  01f0h;
      META_CREATEPALETTE        =  00f7h;
      META_CREATEPATTERNBRUSH   =  01F9h;
      META_CREATEPENINDIRECT    =  02FAh;
      META_CREATEFONTINDIRECT   =  02FBh;
      META_CREATEBRUSHINDIRECT  =  02FCh;
      META_CREATEREGION         =  06FFh;

<* END *> (* NOT DEFINED (NOMETAFILE) *)

(* GDI Escapes *)

CONST NEWFRAME                   = 1;
      ABORTDOC                   = 2;
      NEXTBAND                   = 3;
      SETCOLORTABLE              = 4;
      GETCOLORTABLE              = 5;
      FLUSHOUTPUT                = 6;
      DRAFTMODE                  = 7;
      QUERYESCSUPPORT            = 8;
      SETABORTPROC               = 9;
      STARTDOC                   = 10;
      ENDDOC                     = 11;
      GETPHYSPAGESIZE            = 12;
      GETPRINTINGOFFSET          = 13;
      GETSCALINGFACTOR           = 14;
      MFCOMMENT                  = 15;
      GETPENWIDTH                = 16;
      SETCOPYCOUNT               = 17;
      SELECTPAPERSOURCE          = 18;
      DEVICEDATA                 = 19;
      PASSTHROUGH                = 19;
      GETTECHNOLGY               = 20;
      GETTECHNOLOGY              = 20;
      SETLINECAP                 = 21;
      SETLINEJOIN                = 22;
      SETMITERLIMIT              = 23;
      BANDINFO                   = 24;
      DRAWPATTERNRECT            = 25;
      GETVECTORPENSIZE           = 26;
      GETVECTORBRUSHSIZE         = 27;
      ENABLEDUPLEX               = 28;
      GETSETPAPERBINS            = 29;
      GETSETPRINTORIENT          = 30;
      ENUMPAPERBINS              = 31;
      SETDIBSCALING              = 32;
      EPSPRINTING                = 33;
      ENUMPAPERMETRICS           = 34;
      GETSETPAPERMETRICS         = 35;
      POSTSCRIPT_DATA            = 37;
      POSTSCRIPT_IGNORE          = 38;
      MOUSETRAILS                = 39;
      GETDEVICEUNITS             = 42;

      GETEXTENDEDTEXTMETRICS     = 256;
      GETEXTENTTABLE             = 257;
      GETPAIRKERNTABLE           = 258;
      GETTRACKKERNTABLE          = 259;
      EXTTEXTOUT                 = 512;
      GETFACENAME                = 513;
      DOWNLOADFACE               = 514;
      ENABLERELATIVEWIDTHS       = 768;
      ENABLEPAIRKERNING          = 769;
      SETKERNTRACK               = 770;
      SETALLJUSTVALUES           = 771;
      SETCHARSET                 = 772;

      STRETCHBLT                 = 2048;
      GETSETSCREENPARAMS         = 3072;
      QUERYDIBSUPPORT            = 3073;
      BEGIN_PATH                 = 4096;
      CLIP_TO_PATH               = 4097;
      END_PATH                   = 4098;
      EXT_DEVICE_CAPS            = 4099;
      RESTORE_CTM                = 4100;
      SAVE_CTM                   = 4101;
      SET_ARC_DIRECTION          = 4102;
      SET_BACKGROUND_COLOR       = 4103;
      SET_POLY_MODE              = 4104;
      SET_SCREEN_ANGLE           = 4105;
      SET_SPREAD                 = 4106;
      TRANSFORM_CTM              = 4107;
      SET_CLIP_BOX               = 4108;
      SET_BOUNDS                 = 4109;
      SET_MIRROR_MODE            = 4110;
      OPENCHANNEL                = 4110;
      DOWNLOADHEADER             = 4111;
      CLOSECHANNEL               = 4112;
      POSTSCRIPT_PASSTHROUGH     = 4115;
      ENCAPSULATED_POSTSCRIPT    = 4116;

(* Flag returned from QUERYDIBSUPPORT *)

TYPE QDI_ENUM = (QDI__SETDIBITS,   (* 0 *)
                 QDI__GETDIBITS,   (* 1 *)
                 QDI__DIBTOSCREEN, (* 2 *)
                 QDI__STRETCHDIB); (* 3 *)
     QDI_SET = SET OF QDI_ENUM;

CONST QDI_SETDIBITS   = QDI_SET {QDI__SETDIBITS};   (* 1 *)
      QDI_GETDIBITS   = QDI_SET {QDI__GETDIBITS};   (* 2 *)
      QDI_DIBTOSCREEN = QDI_SET {QDI__DIBTOSCREEN}; (* 4 *)
      QDI_STRETCHDIB  = QDI_SET {QDI__STRETCHDIB};  (* 8 *)

(* Spooler Error Codes *)

CONST SP_NOTREPORTED  = 4000h;
      SP_ERROR        = -1;
      SP_APPABORT     = -2;
      SP_USERABORT    = -3;
      SP_OUTOFDISK    = -4;
      SP_OUTOFMEMORY  = -5;

CONST PR_JOBSTATUS = 0;

(* Object Definitions for EnumObjects() *)

TYPE OBJ_ENUM = (OBJ_ERROR,        (*  0 *)
                 OBJ_PEN,          (*  1 *)
                 OBJ_BRUSH,        (*  2 *)
                 OBJ_DC,           (*  3 *)
                 OBJ_METADC,       (*  4 *)
                 OBJ_PAL,          (*  5 *)
                 OBJ_FONT,         (*  6 *)
                 OBJ_BITMAP,       (*  7 *)
                 OBJ_REGION,       (*  8 *)
                 OBJ_METAFILE,     (*  9 *)
                 OBJ_MEMDC,        (* 10 *)
                 OBJ_EXTPEN,       (* 11 *)
                 OBJ_ENHMETADC,    (* 12 *)
                 OBJ_ENHMETAFILE); (* 13 *)

(* xform stuff *)

TYPE MWT_ENUM = (MWT_0,
                 MWT_IDENTITY,       (* 1 *)
                 MWT_LEFTMULTIPLY,   (* 2 *)
                 MWT_RIGHTMULTIPLY); (* 3 *)

CONST  MWT_MIN = MWT_IDENTITY;
       MWT_MAX = MWT_RIGHTMULTIPLY;

TYPE XFORM = RECORD
                 eM11 : FLOAT;
                 eM12 : FLOAT;
                 eM21 : FLOAT;
                 eM22 : FLOAT;
                 eDx  : FLOAT;
                 eDy  : FLOAT;
             END;
     PXFORM = POINTER TO XFORM;

(* Bitmap Header Definition *)

TYPE BITMAP = RECORD
                     bmType       : LONG;  (* must be 0 *)
                     bmWidth      : LONG;
                     bmHeight     : LONG;
                     bmWidthBytes : LONG;
                     bmPlanes     : WORD;
                     bmBitsPixel  : WORD;
                     bmBits       : PBYTE;
              END;
     PBITMAP = POINTER TO BITMAP;

<* PUSH *> <* ALIGNMENT = "1" *>

TYPE RGBTRIPLE = RECORD
                        rgbtBlue  : BYTE;
                        rgbtGreen : BYTE;
                        rgbtRed   : BYTE;
                 END;

<* POP *>

TYPE RGBQUAD = RECORD
                      rgbBlue     : BYTE;
                      rgbGreen    : BYTE;
                      rgbRed      : BYTE;
                      rgbReserved : BYTE;
               END;
    PRGBQUAD = POINTER TO RGBQUAD;

(* Image Color Matching color definitions *)

TYPE LCSCSTYPE = (LCS_CALIBRATED_RGB, (* 0x00000000L *)
                  LCS_DEVICE_RGB,     (* 0x00000001L *)
                  LCS_DEVICE_CMYK);   (* 0x00000002L *)

TYPE LCS_ENUM = (LCS__GM_BUSINESS,     (* 0 *)
                 LCS__GM_GRAPHICS,     (* 1 *)
                 LCS__GM_IMAGES);      (* 2 *)

TYPE LCSGAMUTMATCH = SET OF LCS_ENUM;

CONST LCS_GM_BUSINESS = LCSGAMUTMATCH {LCS__GM_BUSINESS}; (* 0x00000001L *)
      LCS_GM_GRAPHICS = LCSGAMUTMATCH {LCS__GM_GRAPHICS}; (* 0x00000002L *)
      LCS_GM_IMAGES   = LCSGAMUTMATCH {LCS__GM_IMAGES};   (* 0x00000004L *)

(* ICM Defines for results from CheckColorInGamut() *)

TYPE GAMUT_RESULT = BYTE;

CONST CM_OUT_OF_GAMUT = GAMUT_RESULT (255);
      CM_IN_GAMUT     = GAMUT_RESULT (0);

(* Macros to retrieve CMYK values from a COLORREF *)

PROCEDURE GetCValue (cmyk : COLORREF) : BYTE;
PROCEDURE GetMValue (cmyk : COLORREF) : BYTE;
PROCEDURE GetYValue (cmyk : COLORREF) : BYTE;
PROCEDURE GetKValue (cmyk : COLORREF) : BYTE;
PROCEDURE CMYK (c,m,y,k : BYTE) : COLORREF;

TYPE  FXPT16DOT16 = LONG;
     PFXPT16DOT16 = POINTER TO FXPT16DOT16;

      FXPT2DOT30  = LONG;
     PFXPT2DOT30  = POINTER TO FXPT2DOT30;

(* ICM Color Definitions
   The following two structures are used for defining RGB's in terms of
   CIEXYZ. The values are fixed point 16.16.
*)

TYPE CIEXYZ = RECORD
                     ciexyzX : FXPT2DOT30;
                     ciexyzY : FXPT2DOT30;
                     ciexyzZ : FXPT2DOT30;
              END;
    PCIEXYZ = POINTER TO CIEXYZ;

TYPE CIEXYZTRIPLE = RECORD
                           cciexyzRed  : CIEXYZ;
                           ciexyzGreen : CIEXYZ;
                           ciexyzBlue  : CIEXYZ;
                    END;
    PCIEXYZTRIPLE = POINTER TO CIEXYZTRIPLE;

(* The next structures the logical color space. Unlike pens and brushes,
   but like palettes, there is only one way to create a LogColorSpace.
   A pointer to it must be passed, its elements can't be pushed as
   arguments.
*)

TYPE LOGCOLORSPACEA = RECORD
                             lcsSignature  : DWORD;
                             lcsVersion    : DWORD;
                             lcsSize       : DWORD;
                             lcsCSType     : LCSCSTYPE;
                             lcsIntent     : LCSGAMUTMATCH;
                             lcsEndpoints  : CIEXYZTRIPLE;
                             lcsGammaRed   : DWORD;
                             lcsGammaGreen : DWORD;
                             lcsGammaBlue  : DWORD;
                             lcsFilename   : ARRAY [0..MAX_PATH-1] OF CHAR;
                      END;
    PLOGCOLORSPACEA = POINTER TO LOGCOLORSPACEA;

     LOGCOLORSPACEW = RECORD
                             lcsSignature  : DWORD;
                             lcsVersion    : DWORD;
                             lcsSize       : DWORD;
                             lcsCSType     : LCSCSTYPE;
                             lcsIntent     : LCSGAMUTMATCH;
                             lcsEndpoints  : CIEXYZTRIPLE;
                             lcsGammaRed   : DWORD;
                             lcsGammaGreen : DWORD;
                             lcsGammaBlue  : DWORD;
                             lcsFilename   : ARRAY [0..MAX_PATH-1] OF WCHAR;
                      END;
    PLOGCOLORSPACEW = POINTER TO LOGCOLORSPACEW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE LOGCOLORSPACE = LOGCOLORSPACEW;
           PLOGCOLORSPACE = PLOGCOLORSPACEW;
<* ELSE *>
      TYPE LOGCOLORSPACE = LOGCOLORSPACEA;
           PLOGCOLORSPACE = PLOGCOLORSPACEA;
<* END *>

(* structures for defining DIBs *)

TYPE BITMAPCOREHEADER = RECORD
                               bcSize     : DWORD; (* used to get to color table *)
                               bcWidth    : WORD;
                               bcHeight   : WORD;
                               bcPlanes   : WORD;
                               bcBitCount : WORD;
                        END;

(* constants for the biCompression field *)

TYPE BI_ENUM = (BI_RGB,         (* 0L *)
                BI_RLE8,        (* 1L *)
                BI_RLE4,        (* 2L *)
                BI_BITFIELDS);  (* 3L *)

TYPE BITMAPINFOHEADER = RECORD
                               biSize          : DWORD;
                               biWidth         : LONG;
                               biHeight        : LONG;
                               biPlanes        : WORD;
                               biBitCount      : WORD;
                               biCompression   : BI_ENUM;
                               biSizeImage     : DWORD;
                               biXPelsPerMeter : LONG;
                               biYPelsPerMeter : LONG;
                               biClrUsed       : DWORD;
                               biClrImportant  : DWORD;
                        END;
     PBITMAPINFOHEADER = POINTER TO BITMAPINFOHEADER;

TYPE BITMAPV4HEADER = RECORD
                              bV4Size          : DWORD;
                              bV4Width         : LONG;
                              bV4Height        : LONG;
                              bV4Planes        : WORD;
                              bV4BitCount      : WORD;
                              bV4V4Compression : DWORD;
                              bV4SizeImage     : DWORD;
                              bV4XPelsPerMeter : LONG;
                              bV4YPelsPerMeter : LONG;
                              bV4ClrUsed       : DWORD;
                              bV4ClrImportant  : DWORD;
                              bV4RedMask       : DWORD;
                              bV4GreenMask     : DWORD;
                              bV4BlueMask      : DWORD;
                              bV4AlphaMask     : DWORD;
                              bV4CSType        : DWORD;
                              bV4Endpoints     : CIEXYZTRIPLE;
                              bV4GammaRed      : DWORD;
                              bV4GammaGreen    : DWORD;
                              bV4GammaBlue     : DWORD;
                      END;

TYPE BITMAPINFO = RECORD
                         bmpHeader : BITMAPINFOHEADER;
                         bmiColors : ARRAY [0..0] OF RGBQUAD;
                  END;
     PBITMAPINFO = POINTER TO BITMAPINFO;

TYPE BITMAPINFOPARAM = BITMAPINFOHEADER; (* All functions that had BITMAPINFO
                                            params in wingdi.h now have
                                            BITMAPINFOPARAM parameter in
                                            WInGDI.def.
                                            The header field of a structure is
                                            to be passed
                                         *)
     PBITMAPINFOPARAM = POINTER TO BITMAPINFOPARAM;

TYPE BITMAPCOREINFO = RECORD
                             bmciHeader : BITMAPCOREHEADER;
                             bmciColors : ARRAY [0..0] OF RGBTRIPLE;
                      END;

<* PUSH *> <* ALIGNMENT = "2" *>

TYPE BITMAPFILEHEADER = RECORD
                               bfType      : WORD;
                               bfSize      : DWORD;
                               bfReserved1 : WORD;
                               bfReserved2 : WORD;
                               bfOffBits   : DWORD;
                        END;

<* POP *>

PROCEDURE MAKEPOINTS (l : DWORD) : POINTS;

<* IF NOT DEFINED (NOFONTSIG) THEN *>

TYPE FONTSIGNATURE = RECORD
                            fsUsb : ARRAY [0..3] OF DWORD;
                            fsCsb : ARRAY [0..1] OF DWORD;
                     END;
    PFONTSIGNATURE = POINTER TO FONTSIGNATURE;

TYPE CHARSETINFO = RECORD
                          ciCharset : UINT;
                          ciACP     : UINT;
                          fs        : FONTSIGNATURE;
                   END;
    PCHARSETINFO = POINTER TO CHARSETINFO;

TYPE LOCALESIGNATURE = RECORD
                              lsUsb          : ARRAY [0..3] OF DWORD;
                              lsCsbDefault   : ARRAY [0..1] OF DWORD;
                              lsCsbSupported : ARRAY [0..1] OF DWORD;
                       END;

(* Constants for TranslateCharsetInfo *)

TYPE TCI_ENUM = (TCI_0,
                 TCI_SRCCHARSET,   (* 1 *)
                 TCI_SRCCODEPAGE,  (* 2 *)
                 TCI_SRCFONTSIG);  (* 3 *)

<* END *> (* NOT DEFINED (NOFONTSIG) *)

<* IF NOT DEFINED (NOMETAFILE) THEN *>

(* Clipboard Metafile Picture Structure *)

TYPE HANDLETABLE = RECORD
                          objectHandle : ARRAY [0..0] OF HGDIOBJ;
                   END;
    PHANDLETABLE = POINTER TO HANDLETABLE;

TYPE METARECORD = RECORD
                         rdSize     : DWORD;
                         rdFunction : WORD;
                         rdParm     : ARRAY [0..0] OF WORD;
                  END;
    PMETARECORD = POINTER TO METARECORD;

TYPE METAFILEPICT = RECORD
                           mm   : LONG;  (* actually, MM_ENUM *)
                           xExt : LONG;
                           yExt : LONG;
                           hMF  : HMETAFILE;
                    END;
    PMETAFILEPICT = POINTER TO METAFILEPICT;

<* PUSH *> <* ALIGNMENT = "2" *>

TYPE METAHEADER = RECORD
                          mtType         : WORD;
                          mtHeaderSize   : WORD;
                          mtVersion      : WORD;
                          mtSize         : DWORD;
                          mtNoObjects    : WORD;
                          mtMaxRecord    : DWORD;
                          mtNoParameters : WORD;
                  END;
    PMETAHEADER = POINTER TO METAHEADER;   (* UNALIGNED in wingdi.h *)

<* POP *>

(* Enhanced Metafile structures *)

TYPE ENHMETARECORD = RECORD
                            iType : DWORD;                (* Record type EMR_XXX  *)
                            nSize : DWORD;                (* Record size in bytes *)
                            dParm : ARRAY [0..0] OF DWORD; (* Parameters           *)
                     END;
    PENHMETARECORD  = POINTER TO ENHMETARECORD;

TYPE ENHMETAHEADER = RECORD
      iType          : DWORD;   (* Record type EMR_HEADER *)
      nSize          : DWORD;   (* Record size in bytes.  This may be greater *)
                                (* than the sizeof(ENHMETAHEADER). *)
      rclBounds      : RECTL;   (* Inclusive-inclusive bounds in device units *)
      rclFrame       : RECTL;   (* Inclusive-inclusive Picture Frame of metafile in .01 mm units *)
      dSignature     : DWORD;   (* Signature.  Must be ENHMETA_SIGNATURE. *)
      nVersion       : DWORD;   (* Version number *)
      nBytes         : DWORD;   (* Size of the metafile in bytes *)
      nRecords       : DWORD;   (* Number of records in the metafile *)
      nHandles       : WORD;    (* Number of handles in the handle table *)
                                (* Handle index zero is reserved. *)
      sReserved      : WORD;    (* Reserved.  Must be zero. *)
      nDescription   : DWORD;   (* Number of chars in the unicode description string *)
                                (* This is 0 if there is no description string *)
      offDescription : DWORD;   (* Offset to the metafile description record. *)
                                (* This is 0 if there is no description string *)
      nPalEntries    : DWORD;   (* Number of entries in the metafile palette. *)
      szlDevice      : SIZEL;   (* Size of the reference device in pels *)
      szlMillimeters : SIZEL;   (* Size of the reference device in millimeters *)
      cbPixelFormat  : DWORD;   (* Size of PIXELFORMATDESCRIPTOR information *)
                                (* This is 0 if no pixel format is set *)
      offPixelFormat : DWORD;   (* Offset to PIXELFORMATDESCRIPTOR *)
                                (* This is 0 if no pixel format is set *)
      bOpenGL        : DWORD;   (* TRUE if OpenGL commands are present in *)
                                (* the metafile, otherwise FALSE *)

     END;
  PENHMETAHEADER = POINTER TO ENHMETAHEADER;

<* END *> (* NOT DEFINED (NOMETAFILE) *)

(* Values of type PITCH_AND_FAMILY_SET are used in TEXTMETRIC and LOGFONT structures;
   the value is 1 byte long; lower four bits contain pitch information (in different
   formats in mentioned two structures); higher four bits contain font family information
*)

TYPE PITCH_AND_FAMILY_ENUM = (PF__0, PF__1, PF__2, PF__3, PF__4, PF__5, PF__6, PF__7);

<* PUSH *> <* SETSIZE = "1" *>

TYPE PITCH_AND_FAMILY_SET = SET OF PITCH_AND_FAMILY_ENUM;

<* POP *>

TYPE CHARSET_TYPE = BYTE;

<* IF NOT DEFINED (NOTEXTMETRIC) THEN *>

(* tmPitchAndFamily flags *)

CONST TMPF__FIXED_PITCH = PF__0;
      TMPF__VECTOR      = PF__1;
      TMPF__DEVICE      = PF__3;
      TMPF__TRUETYPE    = PF__2;

      TMPF_FIXED_PITCH = PITCH_AND_FAMILY_SET {TMPF__FIXED_PITCH};  (* 1 *)
      TMPF_VECTOR      = PITCH_AND_FAMILY_SET {TMPF__VECTOR};       (* 2 *)
      TMPF_DEVICE      = PITCH_AND_FAMILY_SET {TMPF__DEVICE};       (* 8 *)
      TMPF_TRUETYPE    = PITCH_AND_FAMILY_SET {TMPF__TRUETYPE};     (* 4 *)

(*
** BCHAR definition for APPs
*)

<* IF DEFINED (UNICODE) THEN *>
      TYPE BCHAR = WCHAR;
<* ELSE *>
      TYPE BCHAR = BYTE;
<* END *>

TYPE TEXTMETRICA = RECORD
                          tmHeight           : LONG;
                          tmAscent           : LONG;
                          tmDescent          : LONG;
                          tmInternalLeading  : LONG;
                          tmExternalLeading  : LONG;
                          tmAveCharWidth     : LONG;
                          tmMaxCharWidth     : LONG;
                          tmWeight           : LONG;
                          tmOverhang         : LONG;
                          tmDigitizedAspectX : LONG;
                          tmDigitizedAspectY : LONG;
                          tmFirstChar        : BYTE;
                          tmLastChar         : BYTE;
                          tmDefaultChar      : BYTE;
                          tmBreakChar        : BYTE;
                          tmItalic           : BOOL8;
                          tmUnderlined       : BOOL8;
                          tmStruckOut        : BOOL8;
                          tmPitchAndFamily   : PITCH_AND_FAMILY_SET;
                          tmCharSet          : CHARSET_TYPE;
                   END;
    PTEXTMETRICA = POINTER TO TEXTMETRICA;

TYPE TEXTMETRICW = RECORD
                          tmHeight           : LONG;
                          tmAscent           : LONG;
                          tmDescent          : LONG;
                          tmInternalLeading  : LONG;
                          tmExternalLeading  : LONG;
                          tmAveCharWidth     : LONG;
                          tmMaxCharWidth     : LONG;
                          tmWeight           : LONG;
                          tmOverhang         : LONG;
                          tmDigitizedAspectX : LONG;
                          tmDigitizedAspectY : LONG;
                          tmFirstChar        : WCHAR;
                          tmLastChar         : WCHAR;
                          tmDefaultChar      : WCHAR;
                          tmBreakChar        : WCHAR;
                          tmItalic           : BOOL8;
                          tmUnderlined       : BOOL8;
                          tmStruckOut        : BOOL8;
                          tmPitchAndFamily   : PITCH_AND_FAMILY_SET;
                          tmCharSet          : CHARSET_TYPE;
                     END;
   PTEXTMETRICW = POINTER TO TEXTMETRICW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE TEXTMETRIC  = TEXTMETRICW;
           PTEXTMETRIC = PTEXTMETRICW;
<* ELSE *>
      TYPE TEXTMETRIC  = TEXTMETRICA;
           PTEXTMETRIC = PTEXTMETRICA;
<* END *>

(* ntmFlags field flags *)

TYPE NTM_ENUM = (NTM__ITALIC,     (* 0 *)
                 NTM__UNDERSCORE, (* 1 *)
                 NTM__NEGATIVE,   (* 2 *)
                 NTM__OUTLINE,    (* 3 *)
                 NTM__STRIKEOUT,  (* 4 *)
                 NTM__BOLD,       (* 5 *)
                 NTM__REGULAR);   (* 6 *)
     NTM_SET = SET OF NTM_ENUM;

CONST NTM_ITALIC     = NTM_SET {NTM__ITALIC};     (* 0x01 *)
      NTM_UNDERSCORE = NTM_SET {NTM__UNDERSCORE}; (* 0x02 *)
      NTM_NEGATIVE   = NTM_SET {NTM__NEGATIVE};   (* 0x04 *)
      NTM_OUTLINE    = NTM_SET {NTM__OUTLINE};    (* 0x08 *)
      NTM_STRIKEOUT  = NTM_SET {NTM__STRIKEOUT};  (* 0x10 *)
      NTM_BOLD       = NTM_SET {NTM__BOLD};       (* 0x20 *)
      NTM_REGULAR    = NTM_SET {NTM__REGULAR};    (* 0x40 *)

<* PUSH *> <* ALIGNMENT = "4" *>

TYPE NEWTEXTMETRICA = RECORD
                             tmHeight           : LONG;
                             tmAscent           : LONG;
                             tmDescent          : LONG;
                             tmInternalLeading  : LONG;
                             tmExternalLeading  : LONG;
                             tmAveCharWidth     : LONG;
                             tmMaxCharWidth     : LONG;
                             tmWeight           : LONG;
                             tmOverhang         : LONG;
                             tmDigitizedAspectX : LONG;
                             tmDigitizedAspectY : LONG;
                             tmFirstChar        : BYTE;
                             tmLastChar         : BYTE;
                             tmDefaultChar      : BYTE;
                             tmBreakChar        : BYTE;
                             tmItalic           : BOOL8;
                             tmUnderlined       : BOOL8;
                             tmStruckOut        : BOOL8;
                             tmPitchAndFamily   : PITCH_AND_FAMILY_SET;
                             tmCharSet          : BYTE;
                             ntmFlags           : NTM_SET;
                             ntmSizeEM          : UINT;
                             ntmCellHeight      : UINT;
                             ntmAvgWidth        : UINT;
                      END;
     PNEWTEXTMETRICA = POINTER TO NEWTEXTMETRICA;

TYPE NEWTEXTMETRICW = RECORD
                             tmHeight           : LONG;
                             tmAscent           : LONG;
                             tmDescent          : LONG;
                             tmInternalLeading  : LONG;
                             tmExternalLeading  : LONG;
                             tmAveCharWidth     : LONG;
                             tmMaxCharWidth     : LONG;
                             tmWeight           : LONG;
                             tmOverhang         : LONG;
                             tmDigitizedAspectX : LONG;
                             tmDigitizedAspectY : LONG;
                             tmFirstChar        : WCHAR;
                             tmLastChar         : WCHAR;
                             tmDefaultChar      : WCHAR;
                             tmBreakChar        : WCHAR;
                             tmItalic           : BOOL8;
                             tmUnderlined       : BOOL8;
                             tmStruckOut        : BOOL8;
                             tmPitchAndFamily   : PITCH_AND_FAMILY_SET;
                             tmCharSet          : BYTE;
                             ntmFlags           : NTM_SET;
                             ntmSizeEM          : UINT;
                             ntmCellHeight      : UINT;
                             ntmAvgWidth        : UINT;
                      END;
     PNEWTEXTMETRICW = POINTER TO NEWTEXTMETRICW;

<* POP *>

<* IF DEFINED (UNICODE) THEN *>
      TYPE NEWTEXTMETRIC = NEWTEXTMETRICW;
           PNEWTEXTMETRIC = PNEWTEXTMETRICW;
<* ELSE *>
      TYPE NEWTEXTMETRIC = NEWTEXTMETRICA;
           PNEWTEXTMETRIC = PNEWTEXTMETRICA;
<* END *>

TYPE NEWTEXTMETRICEXA = RECORD
                               ntmTm      : NEWTEXTMETRICA;
                               ntmFontSig : FONTSIGNATURE;
                        END;
     NEWTEXTMETRICEXW = RECORD
                               ntmTm      : NEWTEXTMETRICW;
                               ntmFontSig : FONTSIGNATURE;
                        END;

TYPE PNEWTEXTMETRICEXA = POINTER TO NEWTEXTMETRICEXA;
     PNEWTEXTMETRICEXW = POINTER TO NEWTEXTMETRICEXW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE NEWTEXTMETRICEX = NEWTEXTMETRICEXW;
           PNEWTEXTMETRICEX = PNEWTEXTMETRICEXW;
<* ELSE *>
      TYPE NEWTEXTMETRICEX = NEWTEXTMETRICEXA;
           PNEWTEXTMETRICEX = PNEWTEXTMETRICEXA;
<* END *>

<* END *> (* NOT DEFINED (NOTEXTMETRIC) *)

(* GDI Logical Objects: *)

(* Pel Array *)

TYPE PELARRAY = RECORD
                       paXCount : LONG;
                       paYCount : LONG;
                       paXExt   : LONG;
                       paYExt   : LONG;
                       paRGBs   : BYTE;
                END;

    PPELARRAY = POINTER TO PELARRAY;

(* Brush Styles *)

TYPE BS_ENUM = (BS_SOLID,          (* 0 *)
                BS_NULL,           (* 1 *)
                BS_HATCHED,        (* 2 *)
                BS_PATTERN,        (* 3 *)
                BS_INDEXED,        (* 4 *)
                BS_DIBPATTERN,     (* 5 *)
                BS_DIBPATTERNPT,   (* 6 *)
                BS_PATTERN8X8,     (* 7 *)
                BS_DIBPATTERN8X8,  (* 8 *)
                BS_MONOPATTERN);   (* 0 *)

CONST BS_HOLLOW = BS_NULL;

(* hatch styles *)

TYPE HS_ENUM = (HS_HORIZONTAL,      (*  0 *)      (* ----- *)
                HS_VERTICAL,        (*  1 *)      (* ||||| *)
                HS_FDIAGONAL,       (*  2 *)      (* \\\\\ *)
                HS_BDIAGONAL,       (*  3 *)      (* ///// *)
                HS_CROSS,           (*  4 *)      (* +++++ *)
                HS_DIAGCROSS,       (*  5 *)      (* xxxxx *)
(* only above values are allowed as lpHatch of LOGBRUSH and elpHatch of LOGPEN *)
                HS_FDIAGONAL1,      (*  6 *)
                HS_BDIAGONAL1,      (*  7 *)
                HS_SOLID,           (*  8 *)
                HS_DENSE1,          (*  9 *)
                HS_DENSE2,          (* 10 *)
                HS_DENSE3,          (* 11 *)
                HS_DENSE4,          (* 12 *)
                HS_DENSE5,          (* 13 *)
                HS_DENSE6,          (* 14 *)
                HS_DENSE7,          (* 15 *)
                HS_DENSE8,          (* 16 *)
                HS_NOSHADE,         (* 17 *)
                HS_HALFTONE,        (* 18 *)
                HS_SOLIDCLR,        (* 19 *)
                HS_DITHEREDCLR,     (* 20 *)
                HS_SOLIDTEXTCLR,    (* 21 *)
                HS_DITHEREDTEXTCLR, (* 22 *)
                HS_SOLIDBKCLR,      (* 23 *)
                HS_DITHEREDBKCLR,   (* 24 *)
                HS_API_MAX);        (* 25 *)

(* Logical Brush (or Pattern) *)

TYPE LOGBRUSH = RECORD
                       lbStyle : BS_ENUM;
                       lbColor : COLORREF;
                       lbHatch : LONG;
                END;
     PLOGBRUSH  = POINTER TO LOGBRUSH;
     PATTERN    = LOGBRUSH;
     PPATTERN   = POINTER TO PATTERN;

(* lpHatch is polymorphic; it can get:
   - HBITMAP (handle of loaded bitmap;  lbStyle = BS_PATTERN)
   - HGLOBAL (handle of DIB memory;     lbStyle = BS_DIBPATTERN)
   - PBYTE   (pointer to packed DIB;    lbStyle = BS_DIBPATTERNPT)
   - HS_ENUM (orientation of hatch;     lbStyle = BS_HATCHED)
   (it is ignored otherwise)
*)

(* Pen Styles *)

TYPE PS_ENUM = (PS__0,PS__1,PS__2,PS__3,PS__4,PS__5,PS__6,PS__7,
                PS__8,PS__9,PS__10,PS__11,PS__12,PS__13,PS__14,
                PS__15,PS__16,PS__17,PS__18,PS__19);
     PS_SET = SET OF PS_ENUM;

CONST PS_SOLID        = SYSTEM.CAST (PS_SET, VAL (UINT, 0));
      PS_DASH         = SYSTEM.CAST (PS_SET, VAL (UINT, 1)); (* ------- *)
      PS_DOT          = SYSTEM.CAST (PS_SET, VAL (UINT, 2)); (* ....... *)
      PS_DASHDOT      = SYSTEM.CAST (PS_SET, VAL (UINT, 3)); (* _._._._ *)
      PS_DASHDOTDOT   = SYSTEM.CAST (PS_SET, VAL (UINT, 4)); (* _.._.._ *)
      PS_NULL         = SYSTEM.CAST (PS_SET, VAL (UINT, 5));
      PS_INSIDEFRAME  = SYSTEM.CAST (PS_SET, VAL (UINT, 6));
      PS_USERSTYLE    = SYSTEM.CAST (PS_SET, VAL (UINT, 7));
      PS_ALTERNATE    = SYSTEM.CAST (PS_SET, VAL (UINT, 8));

      PS_STYLE_MASK   = PS_SET {PS__0..PS__3};  (* 0x0000000F *)

(* Extended pen styles *)

CONST PS_ENDCAP_ROUND  = PS_SET {};                (* 0x00000000 *)
      PS_ENDCAP_SQUARE = PS_SET {PS__8};           (* 0x00000100 *)
      PS_ENDCAP_FLAT   = PS_SET {PS__9};           (* 0x00000200 *)
      PS_ENDCAP_MASK   = PS_SET {PS__8..PS__11};   (* 0x00000F00 *)

CONST PS_JOIN_ROUND    = PS_SET {};                (* 0x00000000 *)
      PS_JOIN_BEVEL    = PS_SET {PS__12};          (* 0x00001000 *)
      PS_JOIN_MITER    = PS_SET {PS__13};          (* 0x00002000 *)
      PS_JOIN_MASK     = PS_SET {PS__12..PS__15};  (* 0x0000F000 *)

CONST PS_COSMETIC      = PS_SET {};                (* 0x00000000 *)
      PS_GEOMETRIC     = PS_SET {PS__16};          (* 0x00010000 *)
      PS_TYPE_MASK     = PS_SET {PS__16..PS__19};  (* 0x000F0000 *)

TYPE LOGPEN = RECORD
                     lopnStyle : PS_SET;
                     lopnWidth : POINT;
                     lopnColor : COLORREF
              END;
     PLOGPEN = POINTER TO LOGPEN;

TYPE EXTLOGPEN = RECORD
                        elpPenStyle   : PS_SET;
                        elpWidth      : DWORD;
                        elpBrushStyle : BS_ENUM;
                        elpColor      : COLORREF;
                        elpHatch      : LONG;
                        elpNumEntries : DWORD;
                        elpStyleEntry : ARRAY [0..0] OF DWORD;
                 END;

(* elpHatch is polymorphic; it can get:
   - HBITMAP (handle of loaded bitmap;  elpBrushStyle = BS_PATTERN)
   - HGLOBAL (handle of DIB memory;     elpBrushStyle = BS_DIBPATTERN)
   - PBYTE   (pointer to packed DIB;    elpBrushStyle = BS_DIBPATTERNPT)
   - HS_ENUM (orientation of hatch;     wlpBrushStyle = BS_HATCHED)
   (it is ignored otherwise)
*)

(* palette entry flags *)

TYPE PC_ENUM = (PC__RESERVED,    (* 0 - palette index used for animation *)
                PC__EXPLICIT,    (* 1 - palette index is explicit to device *)
                PC__NOCOLLAPSE); (* 2 - do not match color to system palette *)

<* PUSH *> <* SETSIZE = "1" *>

TYPE PC_SET = SET OF PC_ENUM;

<* POP *>

CONST PC_RESERVED   = PC_SET {PC__RESERVED};   (* 1 *)
      PC_EXPLICIT   = PC_SET {PC__EXPLICIT};   (* 2 *)
      PC_NOCOLLAPSE = PC_SET {PC__NOCOLLAPSE}; (* 4 *)

(* Logical Palette *)

TYPE PALETTEENTRY = RECORD
                           peRed   : BYTE;
                           peGreen : BYTE;
                           peBlue  : BYTE;
                           peFlags : PC_SET;
                    END;
     PPALETTEENTRY = POINTER TO PALETTEENTRY;

TYPE LOGPALETTE = RECORD
                         palVersion    : WORD;
                         palNumEntries : WORD;
                         palPalEntry   : ARRAY [0..0] OF PALETTEENTRY;
                  END;
     PLOGPALETTE = POINTER TO LOGPALETTE;

(* Logical Font *)

CONST LF_FACESIZE     = 32;
      LF_FULLFACESIZE = 64;

CONST DEFAULT_PITCH  = PITCH_AND_FAMILY_SET {PF__0}; (* 1 *)
      FIXED_PITCH    = PITCH_AND_FAMILY_SET {PF__1}; (* 2 *)
      VARIABLE_PITCH = PITCH_AND_FAMILY_SET {PF__2}; (* 4 *)
      MONO_FONT      = PITCH_AND_FAMILY_SET {PF__3}; (* 8 *)

      FF_DONTCARE    = SYSTEM.CAST (PITCH_AND_FAMILY_SET, 0);    (* Don't care or don't know.             *)
      FF_ROMAN       = SYSTEM.CAST (PITCH_AND_FAMILY_SET, 010h); (* Variable stroke width, serifed.       *)
                                                                 (* Times Roman, Century Schoolbook, etc. *)
      FF_SWISS       = SYSTEM.CAST (PITCH_AND_FAMILY_SET, 020h); (* Variable stroke width, sans-serifed.  *)
                                                                 (* Helvetica, Swiss, etc.                *)
      FF_MODERN      = SYSTEM.CAST (PITCH_AND_FAMILY_SET, 030h); (* Constant stroke width, serifed or sans-serifed. *)
                                                                 (* Pica, Elite, Courier, etc. *)
      FF_SCRIPT      = SYSTEM.CAST (PITCH_AND_FAMILY_SET, 040h); (* Cursive, etc.              *)
      FF_DECORATIVE  = SYSTEM.CAST (PITCH_AND_FAMILY_SET, 050h); (* Old English, etc.          *)

(* masks to retrieve pitch or family bits from PITCH_AND_FAMILY_SET *)

CONST PITCH_MASK  = PITCH_AND_FAMILY_SET {PF__0..PF__3};
      FAMILY_MASK = PITCH_AND_FAMILY_SET {PF__4..PF__7};

(* Font Weights *)

TYPE FW_TYPE = LONG;

CONST FW_DONTCARE    = 0;
      FW_THIN        = 100;
      FW_EXTRALIGHT  = 200;
      FW_LIGHT       = 300;
      FW_NORMAL      = 400;
      FW_MEDIUM      = 500;
      FW_SEMIBOLD    = 600;
      FW_BOLD        = 700;
      FW_EXTRABOLD   = 800;
      FW_HEAVY       = 900;

      FW_ULTRALIGHT  = FW_EXTRALIGHT;
      FW_REGULAR     = FW_NORMAL;
      FW_DEMIBOLD    = FW_SEMIBOLD;
      FW_ULTRABOLD   = FW_EXTRABOLD;
      FW_BLACK       = FW_HEAVY;

(* Character set specification *)

CONST ANSI_CHARSET        = VAL (CHARSET_TYPE, 0);
      DEFAULT_CHARSET     = VAL (CHARSET_TYPE, 1);
      SYMBOL_CHARSET      = VAL (CHARSET_TYPE, 2);
      SHIFTJIS_CHARSET    = VAL (CHARSET_TYPE, 128);
      HANGEUL_CHARSET     = VAL (CHARSET_TYPE, 129);
      GB2312_CHARSET      = VAL (CHARSET_TYPE, 134);
      CHINESEBIG5_CHARSET = VAL (CHARSET_TYPE, 136);
      OEM_CHARSET         = VAL (CHARSET_TYPE, 255);

      JOHAB_CHARSET       = VAL (CHARSET_TYPE, 130);
      HEBREW_CHARSET      = VAL (CHARSET_TYPE, 177);
      ARABIC_CHARSET      = VAL (CHARSET_TYPE, 178);
      GREEK_CHARSET       = VAL (CHARSET_TYPE, 161);
      TURKISH_CHARSET     = VAL (CHARSET_TYPE, 162);
      VIETNAMESE_CHARSET  = VAL (CHARSET_TYPE, 163);
      THAI_CHARSET        = VAL (CHARSET_TYPE, 222);
      EASTEUROPE_CHARSET  = VAL (CHARSET_TYPE, 238);
      RUSSIAN_CHARSET     = VAL (CHARSET_TYPE, 204);

      MAC_CHARSET         = VAL (CHARSET_TYPE, 77);
      BALTIC_CHARSET      = VAL (CHARSET_TYPE, 186);

(* Output precision specification *)

<* PUSH *> <* ENUMSIZE = "1" *>

TYPE OUT_PRECIS_ENUM = (OUT_DEFAULT_PRECIS,         (* 0 *)
                        OUT_STRING_PRECIS,          (* 1 *)
                        OUT_CHARACTER_PRECIS,       (* 2 *)
                        OUT_STROKE_PRECIS,          (* 3 *)
                        OUT_TT_PRECIS,              (* 4 *)
                        OUT_DEVICE_PRECIS,          (* 5 *)
                        OUT_RASTER_PRECIS,          (* 6 *)
                        OUT_TT_ONLY_PRECIS,         (* 7 *)
                        OUT_OUTLINE_PRECIS,         (* 8 *)
                        OUT_SCREEN_OUTLINE_PRECIS); (* 9 *)

<* POP *>

(* Clip precision specidication *)

TYPE CLIP_PRECIS_ENUM = (CLIP__0, CLIP__1, CLIP__2, CLIP__3,
                         CLIP__4, CLIP__5, CLIP__6, CLIP__7);

<* PUSH *> <* SETSIZE = "1" *>

TYPE CLIP_PRECIS_SET = SET OF CLIP_PRECIS_ENUM;

 <* POP *>

CONST CLIP_DEFAULT_PRECIS   = SYSTEM.CAST (CLIP_PRECIS_SET, 0);
      CLIP_CHARACTER_PRECIS = SYSTEM.CAST (CLIP_PRECIS_SET, 1);
      CLIP_STROKE_PRECIS    = SYSTEM.CAST (CLIP_PRECIS_SET, 2);

      CLIP_MASK             = CLIP_PRECIS_SET {CLIP__0..CLIP__3};

      CLIP__LH_ANGLES       = CLIP__4;
      CLIP__TT_ALWAYS       = CLIP__5;
      CLIP__EMBEDDED        = CLIP__7;

      CLIP_LH_ANGLES        = CLIP_PRECIS_SET {CLIP__LH_ANGLES}; (* 10h *)
      CLIP_TT_ALWAYS        = CLIP_PRECIS_SET {CLIP__TT_ALWAYS}; (* 20h *)
      CLIP_EMBEDDED         = CLIP_PRECIS_SET {CLIP__EMBEDDED};  (* 80h *)

(* Output quality specification *)

<* PUSH *> <* ENUMSIZE = "1" *>

TYPE QUALITY_ENUM = (DEFAULT_QUALITY,        (* 0 *)
                     DRAFT_QUALITY,          (* 1 *)
                     PROOF_QUALITY,          (* 2 *)
                     NONANTIALIASED_QUALITY, (* 3 *)
                     ANTIALIASED_QUALITY);   (* 4 *)

<* POP *>

TYPE LOGFONTA = RECORD
                       lfHeight          : LONG;
                       lfWidth           : LONG;
                       lfEscapement      : LONG;
                       lfOrientation     : LONG;
                       lfWeight          : FW_TYPE;
                       lfItalic          : BOOL8;
                       lfUnderline       : BOOL8;
                       lfStrikeOut       : BOOL8;
                       lfCharSet         : CHARSET_TYPE;
                       lfOutPrecision    : OUT_PRECIS_ENUM;
                       lfClipPrecision   : CLIP_PRECIS_SET;
                       lfQuality         : QUALITY_ENUM;
                       lfPitchAndFamily  : PITCH_AND_FAMILY_SET;
                       lfFaceName        : ARRAY [0..LF_FACESIZE-1] OF CHAR;
                END;
     PLOGFONTA = POINTER TO LOGFONTA;

     LOGFONTW = RECORD
                       lfHeight          : LONG;
                       lfWidth           : LONG;
                       lfEscapement      : LONG;
                       lfOrientation     : LONG;
                       lfWeight          : FW_TYPE;
                       lfItalic          : BOOL8;
                       lfUnderline       : BOOL8;
                       lfStrikeOut       : BOOL8;
                       lfCharSet         : CHARSET_TYPE;
                       lfOutputPrecision : OUT_PRECIS_ENUM;
                       lfClipPrecision   : CLIP_PRECIS_SET;
                       lfQuality         : QUALITY_ENUM;
                       lfPitchAndFamily  : PITCH_AND_FAMILY_SET;
                       lfFaceName        : ARRAY [0..LF_FACESIZE-1] OF WCHAR;
                END;
     PLOGFONTW = POINTER TO LOGFONTW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE LOGFONT  = LOGFONTW;
          PLOGFONT = PLOGFONTW;
<* ELSE *>
      TYPE LOGFONT  = LOGFONTA;
          PLOGFONT = PLOGFONTA;
<* END *>

(* Structure passed to FONTFAMENUMPROC *)

TYPE ENUMLOGFONTA = RECORD
                           elfLogFont  : LOGFONTA;
                           elfFullName : ARRAY [0..LF_FULLFACESIZE-1] OF CHAR;
                           elfStyle    : ARRAY [0..LF_FACESIZE-1]     OF CHAR;
                    END;
     PENUMLOGFONTA = POINTER TO ENUMLOGFONTA;

     ENUMLOGFONTW = RECORD
                           elfLogFont  : LOGFONTW;
                           elfFullName : ARRAY [0..LF_FULLFACESIZE-1] OF WCHAR;
                           elfStyle    : ARRAY [0..LF_FACESIZE-1]     OF WCHAR;
                    END;
    PENUMLOGFONTW = POINTER TO ENUMLOGFONTW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  ENUMLOGFONT = ENUMLOGFONTW;
           PENUMLOGFONT = PENUMLOGFONTW;
<* ELSE *>
      TYPE  ENUMLOGFONT = ENUMLOGFONTA;
           PENUMLOGFONT = PENUMLOGFONTA;
<* END *>

TYPE ENUMLOGFONTEXA = RECORD
                         elfLogFont  : LOGFONTA;
                         elfFullName : ARRAY [0..LF_FULLFACESIZE-1] OF BYTE;
                         elfStyle    : ARRAY [0..LF_FACESIZE-1]     OF BYTE;
                         elfScript   : ARRAY [0..LF_FACESIZE-1]     OF BYTE;
                      END;
    PENUMLOGFONTEXA = POINTER TO ENUMLOGFONTEXA;

TYPE ENUMLOGFONTEXW = RECORD
                         elfLogFont  : LOGFONTW;
                         elfFullName : ARRAY [0..LF_FULLFACESIZE-1] OF WCHAR;
                         elfStyle    : ARRAY [0..LF_FACESIZE-1]     OF WCHAR;
                         elfScript   : ARRAY [0..LF_FACESIZE-1]     OF WCHAR;
                      END;
    PENUMLOGFONTEXW = POINTER TO ENUMLOGFONTEXW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE ENUMLOGFONTEX = ENUMLOGFONTEXW;
           PENUMLOGFONTEX = PENUMLOGFONTEXW;
<* ELSE *>
      TYPE ENUMLOGFONTEX = ENUMLOGFONTEXA;
           PENUMLOGFONTEX = PENUMLOGFONTEXA;
<* END *>

TYPE FS_ENUM = (FS__LATIN1,      (* 0 *)
                FS__LATIN2,      (* 1 *)
                FS__CYRILLIC,    (* 2 *)
                FS__GREEK,       (* 3 *)
                FS__TURKISH,     (* 4 *)
                FS__HEBREW,      (* 5 *)
                FS__ARABIC,      (* 6 *)
                FS__BALTIC,      (* 7 *)
                FS__VIETNAMESE,  (* 8 *)
                FS__9,
                FS__10, FS__11,
                FS__12, FS__13,
                FS__14, FS__15,
                FS__THAI,        (* 16 *)
                FS__JISJAPAN,    (* 17 *)
                FS__CHINESESIMP, (* 18 *)
                FS__WANSUNG,     (* 19 *)
                FS__CHINESETRAD, (* 20 *)
                FS__JOHAB,       (* 21 *)
                FS__22, FS__23,
                FS__24, FS__25,
                FS__26, FS__27,
                FS__28, FS__29,
                FS__30,
                FS__SYMBOL);     (* 31 *)
      FS_SET = SET OF FS_ENUM;

CONST FS_LATIN1      = FS_SET {FS__LATIN1};      (* 0x00000001L *)
      FS_LATIN2      = FS_SET {FS__LATIN2};      (* 0x00000002L *)
      FS_CYRILLIC    = FS_SET {FS__CYRILLIC};    (* 0x00000004L *)
      FS_GREEK       = FS_SET {FS__GREEK};       (* 0x00000008L *)
      FS_TURKISH     = FS_SET {FS__TURKISH};     (* 0x00000010L *)
      FS_HEBREW      = FS_SET {FS__HEBREW};      (* 0x00000020L *)
      FS_ARABIC      = FS_SET {FS__ARABIC};      (* 0x00000040L *)
      FS_BALTIC      = FS_SET {FS__BALTIC};      (* 0x00000080L *)
      FS_VIETNAMESE  = FS_SET {FS__VIETNAMESE};  (* 0x00000100L *)
      FS_THAI        = FS_SET {FS__THAI};        (* 0x00010000L *)
      FS_JISJAPAN    = FS_SET {FS__JISJAPAN};    (* 0x00020000L *)
      FS_CHINESESIMP = FS_SET {FS__CHINESESIMP}; (* 0x00040000L *)
      FS_WANSUNG     = FS_SET {FS__WANSUNG};     (* 0x00080000L *)
      FS_CHINESETRAD = FS_SET {FS__CHINESETRAD}; (* 0x00100000L *)
      FS_JOHAB       = FS_SET {FS__JOHAB};       (* 0x00200000L *)
      FS_SYMBOL      = FS_SET {FS__SYMBOL};      (* 0x80000000L *)

(* indices in PANOSE structure *)

TYPE PANOSE_INDEX_ENUM = (PAN_FAMILYTYPE_INDEX,      (* 0 *)
                          PAN_SERIFSTYLE_INDEX,      (* 1 *)
                          PAN_WEIGHT_INDEX,          (* 2 *)
                          PAN_PROPORTION_INDEX,      (* 3 *)
                          PAN_CONTRAST_INDEX,        (* 4 *)
                          PAN_STROKEVARIATION_INDEX, (* 5 *)
                          PAN_ARMSTYLE_INDEX,        (* 6 *)
                          PAN_LETTERFORM_INDEX,      (* 7 *)
                          PAN_MIDLINE_INDEX,         (* 8 *)
                          PAN_XHEIGHT_INDEX);        (* 9 *)

CONST PANOSE_COUNT = 10; (* total number of fields *)

TYPE PAN_TYPE = BYTE;

TYPE PANOSE = RECORD
                     bFamilyType      : PAN_TYPE;
                     bSerifStyle      : PAN_TYPE;
                     bWeight          : PAN_TYPE;
                     bProportion      : PAN_TYPE;
                     bContrast        : PAN_TYPE;
                     bStrokeVariation : PAN_TYPE;
                     bArmStyle        : PAN_TYPE;
                     bLetterform      : PAN_TYPE;
                     bMidline         : PAN_TYPE;
                     bXHeight         : PAN_TYPE;
              END;

CONST

(* General constants *)

PAN_ANY                         = PAN_TYPE ( 0);         (* Any               *)
PAN_NO_FIT                      = PAN_TYPE ( 1);         (* No Fit            *)
PAN_CULTURE_LATIN               = PAN_TYPE ( 0);

(* bFamilyType values *)

PAN_FAMILY_TEXT_DISPLAY         = PAN_TYPE ( 2); (* Text and Display         *)
PAN_FAMILY_SCRIPT               = PAN_TYPE ( 3); (* Script                   *)
PAN_FAMILY_DECORATIVE           = PAN_TYPE ( 4); (* Decorative               *)
PAN_FAMILY_PICTORIAL            = PAN_TYPE ( 5); (* Pictorial                *)

(* bSerifStyle values *)

PAN_SERIF_COVE                  = PAN_TYPE ( 2); (* Cove                     *)
PAN_SERIF_OBTUSE_COVE           = PAN_TYPE ( 3); (* Obtuse Cove              *)
PAN_SERIF_SQUARE_COVE           = PAN_TYPE ( 4); (* Square Cove              *)
PAN_SERIF_OBTUSE_SQUARE_COVE    = PAN_TYPE ( 5); (* Obtuse Square Cove       *)
PAN_SERIF_SQUARE                = PAN_TYPE ( 6); (* Square                   *)
PAN_SERIF_THIN                  = PAN_TYPE ( 7); (* Thin                     *)
PAN_SERIF_BONE                  = PAN_TYPE ( 8); (* Bone                     *)
PAN_SERIF_EXAGGERATED           = PAN_TYPE ( 9); (* Exaggerated              *)
PAN_SERIF_TRIANGLE              = PAN_TYPE (10); (* Triangle                 *)
PAN_SERIF_NORMAL_SANS           = PAN_TYPE (11); (* Normal Sans              *)
PAN_SERIF_OBTUSE_SANS           = PAN_TYPE (12); (* Obtuse Sans              *)
PAN_SERIF_PERP_SANS             = PAN_TYPE (13); (* Prep Sans                *)
PAN_SERIF_FLARED                = PAN_TYPE (14); (* Flared                   *)
PAN_SERIF_ROUNDED               = PAN_TYPE (15); (* Rounded                  *)

(* bWeight values *)

PAN_WEIGHT_VERY_LIGHT           = PAN_TYPE ( 2); (* Very Light               *)
PAN_WEIGHT_LIGHT                = PAN_TYPE ( 3); (* Light                    *)
PAN_WEIGHT_THIN                 = PAN_TYPE ( 4); (* Thin                     *)
PAN_WEIGHT_BOOK                 = PAN_TYPE ( 5); (* Book                     *)
PAN_WEIGHT_MEDIUM               = PAN_TYPE ( 6); (* Medium                   *)
PAN_WEIGHT_DEMI                 = PAN_TYPE ( 7); (* Demi                     *)
PAN_WEIGHT_BOLD                 = PAN_TYPE ( 8); (* Bold                     *)
PAN_WEIGHT_HEAVY                = PAN_TYPE ( 9); (* Heavy                    *)
PAN_WEIGHT_BLACK                = PAN_TYPE (10); (* Black                    *)
PAN_WEIGHT_NORD                 = PAN_TYPE (11); (* Nord                     *)

(* bProportion values *)

PAN_PROP_OLD_STYLE              = PAN_TYPE ( 2); (* Old Style                *)
PAN_PROP_MODERN                 = PAN_TYPE ( 3); (* Modern                   *)
PAN_PROP_EVEN_WIDTH             = PAN_TYPE ( 4); (* Even Width               *)
PAN_PROP_EXPANDED               = PAN_TYPE ( 5); (* Expanded                 *)
PAN_PROP_CONDENSED              = PAN_TYPE ( 6); (* Condensed                *)
PAN_PROP_VERY_EXPANDED          = PAN_TYPE ( 7); (* Very Expanded            *)
PAN_PROP_VERY_CONDENSED         = PAN_TYPE ( 8); (* Very Condensed           *)
PAN_PROP_MONOSPACED             = PAN_TYPE ( 9); (* Monospaced               *)

(* bContrast values *)

PAN_CONTRAST_NONE               = PAN_TYPE ( 2); (* None                     *)
PAN_CONTRAST_VERY_LOW           = PAN_TYPE ( 3); (* Very Low                 *)
PAN_CONTRAST_LOW                = PAN_TYPE ( 4); (* Low                      *)
PAN_CONTRAST_MEDIUM_LOW         = PAN_TYPE ( 5); (* Medium Low               *)
PAN_CONTRAST_MEDIUM             = PAN_TYPE ( 6); (* Medium                   *)
PAN_CONTRAST_MEDIUM_HIGH        = PAN_TYPE ( 7); (* Mediim High              *)
PAN_CONTRAST_HIGH               = PAN_TYPE ( 8); (* High                     *)
PAN_CONTRAST_VERY_HIGH          = PAN_TYPE ( 9); (* Very High                *)

(* bStrokeVariation values *)

PAN_STROKE_GRADUAL_DIAG         = PAN_TYPE ( 2); (* Gradual/Diagonal         *)
PAN_STROKE_GRADUAL_TRAN         = PAN_TYPE ( 3); (* Gradual/Transitional     *)
PAN_STROKE_GRADUAL_VERT         = PAN_TYPE ( 4); (* Gradual/Vertical         *)
PAN_STROKE_GRADUAL_HORZ         = PAN_TYPE ( 5); (* Gradual/Horizontal       *)
PAN_STROKE_RAPID_VERT           = PAN_TYPE ( 6); (* Rapid/Vertical           *)
PAN_STROKE_RAPID_HORZ           = PAN_TYPE ( 7); (* Rapid/Horizontal         *)
PAN_STROKE_INSTANT_VERT         = PAN_TYPE ( 8); (* Instant/Vertical         *)

(* bArmStyle values *)

PAN_STRAIGHT_ARMS_HORZ          = PAN_TYPE ( 2); (* Straight Arms/Horizontal    *)
PAN_STRAIGHT_ARMS_WEDGE         = PAN_TYPE ( 3); (* Straight Arms/Wedge         *)
PAN_STRAIGHT_ARMS_VERT          = PAN_TYPE ( 4); (* Straight Arms/Vertical      *)
PAN_STRAIGHT_ARMS_SINGLE_SERIF  = PAN_TYPE ( 5); (* Straight Arms/Single-Serif  *)
PAN_STRAIGHT_ARMS_DOUBLE_SERIF  = PAN_TYPE ( 6); (* Straight Arms/Double-Serif  *)
PAN_BENT_ARMS_HORZ              = PAN_TYPE ( 7); (* Non-Straight Arms/Horizontal*)
PAN_BENT_ARMS_WEDGE             = PAN_TYPE ( 8); (* Non-Straight Arms/Wedge     *)
PAN_BENT_ARMS_VERT              = PAN_TYPE ( 9); (* Non-Straight Arms/Vertical  *)
PAN_BENT_ARMS_SINGLE_SERIF      = PAN_TYPE (10); (* Non-Straight Arms/Single-Serif*)
PAN_BENT_ARMS_DOUBLE_SERIF      = PAN_TYPE (11); (* Non-Straight Arms/Double-Serif*)

(* bLetterform values *)

PAN_LETT_NORMAL_CONTACT         = PAN_TYPE ( 2); (* Normal/Contact           *)
PAN_LETT_NORMAL_WEIGHTED        = PAN_TYPE ( 3); (* Normal/Weighted          *)
PAN_LETT_NORMAL_BOXED           = PAN_TYPE ( 4); (* Normal/Boxed             *)
PAN_LETT_NORMAL_FLATTENED       = PAN_TYPE ( 5); (* Normal/Flattened         *)
PAN_LETT_NORMAL_ROUNDED         = PAN_TYPE ( 6); (* Normal/Rounded           *)
PAN_LETT_NORMAL_OFF_CENTER      = PAN_TYPE ( 7); (* Normal/Off Center        *)
PAN_LETT_NORMAL_SQUARE          = PAN_TYPE ( 8); (* Normal/Square            *)
PAN_LETT_OBLIQUE_CONTACT        = PAN_TYPE ( 9); (* Oblique/Contact          *)
PAN_LETT_OBLIQUE_WEIGHTED       = PAN_TYPE (10); (* Oblique/Weighted         *)
PAN_LETT_OBLIQUE_BOXED          = PAN_TYPE (11); (* Oblique/Boxed            *)
PAN_LETT_OBLIQUE_FLATTENED      = PAN_TYPE (12); (* Oblique/Flattened        *)
PAN_LETT_OBLIQUE_ROUNDED        = PAN_TYPE (13); (* Oblique/Rounded          *)
PAN_LETT_OBLIQUE_OFF_CENTER     = PAN_TYPE (14); (* Oblique/Off Center       *)
PAN_LETT_OBLIQUE_SQUARE         = PAN_TYPE (15); (* Oblique/Square           *)

(* bMidline values *)

PAN_MIDLINE_STANDARD_TRIMMED    = PAN_TYPE ( 2); (* Standard/Trimmed         *)
PAN_MIDLINE_STANDARD_POINTED    = PAN_TYPE ( 3); (* Standard/Pointed         *)
PAN_MIDLINE_STANDARD_SERIFED    = PAN_TYPE ( 4); (* Standard/Serifed         *)
PAN_MIDLINE_HIGH_TRIMMED        = PAN_TYPE ( 5); (* High/Trimmed             *)
PAN_MIDLINE_HIGH_POINTED        = PAN_TYPE ( 6); (* High/Pointed             *)
PAN_MIDLINE_HIGH_SERIFED        = PAN_TYPE ( 7); (* High/Serifed             *)
PAN_MIDLINE_CONSTANT_TRIMMED    = PAN_TYPE ( 8); (* Constant/Trimmed         *)
PAN_MIDLINE_CONSTANT_POINTED    = PAN_TYPE ( 9); (* Constant/Pointed         *)
PAN_MIDLINE_CONSTANT_SERIFED    = PAN_TYPE (10); (* Constant/Serifed         *)
PAN_MIDLINE_LOW_TRIMMED         = PAN_TYPE (11); (* Low/Trimmed              *)
PAN_MIDLINE_LOW_POINTED         = PAN_TYPE (12); (* Low/Pointed              *)
PAN_MIDLINE_LOW_SERIFED         = PAN_TYPE (13); (* Low/Serifed              *)

(* bXHeight values *)

PAN_XHEIGHT_CONSTANT_SMALL      = PAN_TYPE ( 2); (* Constant/Small           *)
PAN_XHEIGHT_CONSTANT_STD        = PAN_TYPE ( 3); (* Constant/Standard        *)
PAN_XHEIGHT_CONSTANT_LARGE      = PAN_TYPE ( 4); (* Constant/Large           *)
PAN_XHEIGHT_DUCKING_SMALL       = PAN_TYPE ( 5); (* Ducking/Small            *)
PAN_XHEIGHT_DUCKING_STD         = PAN_TYPE ( 6); (* Ducking/Standard         *)
PAN_XHEIGHT_DUCKING_LARGE       = PAN_TYPE ( 7); (* Ducking/Large            *)

(* The extended logical font       *)
(* An extension of the ENUMLOGFONT *)

CONST ELF_VENDOR_SIZE   = 4;
      ELF_VERSION       = 0;
      ELF_CULTURE_LATIN = 0;

TYPE EXTLOGFONTA = RECORD
                           elfLogFont   : LOGFONTA;
                           elfFullName  : ARRAY [0..LF_FULLFACESIZE-1] OF CHAR;
                           elfStyle     : ARRAY [0..LF_FACESIZE-1]     OF CHAR;
                           elfVersion   : DWORD;     (* 0 for the first release of NT *)
                           elfStyleSize : DWORD;
                           elfMatch     : DWORD;
                           elfReserved  : DWORD;
                           elfVendorId  : ARRAY [0..ELF_VENDOR_SIZE-1] OF BYTE;
                           elfCulture   : DWORD;     (* 0 for Latin  *)
                           elfPanose    : PANOSE;
                   END;
     PEXTLOGFONTA = POINTER TO EXTLOGFONTA;

     EXTLOGFONTW = RECORD
                           elfLogFont   : LOGFONTW;
                           elfFullName  : ARRAY [0..LF_FULLFACESIZE-1] OF WCHAR;
                           elfStyle     : ARRAY [0..LF_FACESIZE-1]     OF WCHAR;
                           elfVersion   : DWORD;     (* 0 for the first release of NT *)
                           elfStyleSize : DWORD;
                           elfMatch     : DWORD;
                           elfReserved  : DWORD;
                           elfVendorId  : ARRAY [0..ELF_VENDOR_SIZE-1] OF BYTE;
                           elfCulture   : DWORD;     (* 0 for Latin  *)
                           elfPanose    : PANOSE;
                   END;
     PEXTLOGFONTW = POINTER TO EXTLOGFONTW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE EXTLOGFONT  = EXTLOGFONTW;
           PEXTLOGFONT = POINTER TO EXTLOGFONTW;
<* ELSE *>
      TYPE EXTLOGFONT  = EXTLOGFONTA;
           PEXTLOGFONT = POINTER TO EXTLOGFONTA;
<* END *>

(* EnumFonts Masks *)

TYPE ENUMFONT_ENUM = (RASTER__FONTTYPE,      (*  0 *)
                      DEVICE__FONTTYPE,      (*  1 *)
                      TRUETYPE__FONTTYPE,    (*  2 *)
                      FT__3, FT__4, FT__5,
                      FT__6, FT__7,
                      BOLD__FONTTYPE,        (*  8 *)
                      ITALIC__FONTTYPE,      (*  9 *)
                      REGULAR__FONTTYPE,     (* 10 *)
                      FT__11, FT__12,
                      SCREEN__FONTTYPE,      (* 13 *)
                      PRINTER__FONTTYPE,     (* 14 *)
                      SIMULATED__FONTTYPE);  (* 15 *)

     ENUMFONT_SET = SET OF ENUMFONT_ENUM;

CONST RASTER_FONTTYPE    = ENUMFONT_SET {RASTER__FONTTYPE};    (* 0x0001 *)
      DEVICE_FONTTYPE    = ENUMFONT_SET {DEVICE__FONTTYPE};    (* 0x0002 *)
      TRUETYPE_FONTTYPE  = ENUMFONT_SET {TRUETYPE__FONTTYPE};  (* 0x0004 *)

(* Theese following only apply to Choose Font dialog box *)

CONST BOLD_FONTTYPE      = ENUMFONT_SET {BOLD__FONTTYPE};      (* 0x0100 *)
      ITALIC_FONTTYPE    = ENUMFONT_SET {ITALIC__FONTTYPE};    (* 0x0200 *)
      REGULAR_FONTTYPE   = ENUMFONT_SET {REGULAR__FONTTYPE};   (* 0x0400 *)
      SCREEN_FONTTYPE    = ENUMFONT_SET {SCREEN__FONTTYPE};    (* 0x2000 *)
      PRINTER_FONTTYPE   = ENUMFONT_SET {PRINTER__FONTTYPE};   (* 0x4000 *)
      SIMULATED_FONTTYPE = ENUMFONT_SET {SIMULATED__FONTTYPE}; (* 0x8000 *)

(* following six procedures are in run-time code *)

PROCEDURE RGB          (r,g,b : BYTE) : COLORREF;
PROCEDURE PALETTERGB   (r,g,b : BYTE) : COLORREF;
PROCEDURE PALETTEINDEX (i : BYTE)     : COLORREF;

PROCEDURE GetRValue (rgb : COLORREF) : BYTE;
PROCEDURE GetGValue (rgb : COLORREF) : BYTE;
PROCEDURE GetBValue (rgb : COLORREF) : BYTE;

(* Background Modes *)

TYPE BKMODE_ENUM = (BKMODE_ERROR,
                    TRANSPARENT,     (* 1 *)
                    OPAQUE);         (* 2 *)
CONST BKMODE_LAST = OPAQUE;

(* Graphics Modes *)

TYPE GM_ENUM = (GM_ERROR,
                GM_COMPATIBLE, (* 1 *)
                GM_ADVANCED);  (* 2 *)
CONST GM_LAST = GM_ADVANCED;

(* PolyDraw and GetPath point types *)

TYPE PT_ENUM = (PT__CLOSEFIGURE,
                PT_1, PT__2, PT__3);

<* PUSH *> <* SETSIZE = "1" *>

TYPE PT_SET = SET OF PT_ENUM;

<* POP *>

CONST PT_CLOSEFIGURE = PT_SET {PT__CLOSEFIGURE}; (* 1 *)
      PT_LINETO      = SYSTEM.CAST (PT_SET, 2);
      PT_BEZIERTO    = SYSTEM.CAST (PT_SET, 4);
      PT_MOVETO      = SYSTEM.CAST (PT_SET, 6);

(* Mapping Modes *)
TYPE MM_ENUM = (MM_ERROR,       (* 0 *)
                MM_TEXT,        (* 1 *)
                MM_LOMETRIC,    (* 2 *)
                MM_HIMETRIC,    (* 3 *)
                MM_LOENGLISH,   (* 4 *)
                MM_HIENGLISH,   (* 5 *)
                MM_TWIPS,       (* 6 *)
                MM_ISOTROPIC,   (* 7 *)
                MM_ANISOTROPIC);(* 8 *)

(* Min and Max Mapping Mode values *)
          CONST MM_MIN            = MM_TEXT;
                MM_MAX            = MM_ANISOTROPIC;
                MM_MAX_FIXEDSCALE = MM_TWIPS;


(* Coordinate Modes *)

TYPE COORDMODE_ENUM = (COORDMODE_ERROR,
                       ABSOLUTE,         (* 1 *)
                       RELATIVE);        (* 2 *)

(* Stock Logical Objects *)

TYPE STOCK_ENUM = (WHITE_BRUSH,         (* 0 *)
                   LTGRAY_BRUSH,        (* 1 *)
                   GRAY_BRUSH,          (* 2 *)
                   DKGRAY_BRUSH,        (* 3 *)
                   BLACK_BRUSH,         (* 4 *)
                   NULL_BRUSH,          (* 5 *)
                   WHITE_PEN,           (* 6 *)
                   BLACK_PEN,           (* 7 *)
                   NULL_PEN,            (* 8 *)
                   STOCK_9,
                   OEM_FIXED_FONT,      (* 10 *)
                   ANSI_FIXED_FONT,     (* 11 *)
                   ANSI_VAR_FONT,       (* 12 *)
                   SYSTEM_FONT,         (* 13 *)
                   DEVICE_DEFAULT_FONT, (* 14 *)
                   DEFAULT_PALETTE,     (* 15 *)
                   SYSTEM_FIXED_FONT,   (* 16 *)
                   DEFAULT_GUI_FONT);   (* 17 *)

CONST STOCK_LAST    = DEFAULT_GUI_FONT;
      HOLLOW_BRUSH  = NULL_BRUSH;

CONST CLR_INVALID = 0FFFFFFFFh;

TYPE AD_ENUM = (AD_ERROR,            (* 0 *)
                AD_COUNTERCLOCKWISE, (* 1 *)
                AD_CLOCKWISE);       (* 2 *)

(* Device Parameters for GetDeviceCaps() (to be casted to different types) *)

CONST DRIVERVERSION =  0;    (* Device driver version                    *)

CONST TECHNOLOGY    =  2;    (* Device classification *)
      HORZSIZE      =  4;    (* Horizontal size in millimeters           *)
      VERTSIZE      =  6;    (* Vertical size in millimeters             *)
      HORZRES       =  8;    (* Horizontal width in pixels               *)
      VERTRES       = 10;    (* Vertical width in pixels                 *)
      BITSPIXEL     = 12;    (* Number of bits per pixel                 *)
      PLANES        = 14;    (* Number of planes                         *)
      NUMBRUSHES    = 16;    (* Number of brushes the device has         *)
      NUMPENS       = 18;    (* Number of pens the device has            *)
      NUMMARKERS    = 20;    (* Number of markers the device has         *)
      NUMFONTS      = 22;    (* Number of fonts the device has           *)
      NUMCOLORS     = 24;    (* Number of colors the device supports     *)
      PDEVICESIZE   = 26;    (* Size required for device descriptor      *)
      CURVECAPS     = 28;    (* Curve capabilities *)
      LINECAPS      = 30;    (* Line capabilities *)
      POLYGONALCAPS = 32;    (* Polygonal capabilities *)
      TEXTCAPS      = 34;    (* Text capabilities *)
      CLIPCAPS      = 36;    (* Clipping capabilities *)
      RASTERCAPS    = 38;    (* Bitblt capabilities *)
      ASPECTX       = 40;    (* Length of the X leg                      *)
      ASPECTY       = 42;    (* Length of the Y leg                      *)
      ASPECTXY      = 44;    (* Length of the hypotenuse                 *)

      LOGPIXELSX    = 88;    (* Logical pixels/inch in X                 *)
      LOGPIXELSY    = 90;    (* Logical pixels/inch in Y                 *)

      SIZEPALETTE   = 104;   (* Number of entries in physical palette    *)
      NUMRESERVED   = 106;   (* Number of reserved entries in palette    *)
      COLORRES      = 108;   (* Actual color resolution                  *)

(* Printing related DeviceCaps. These replace the appropriate Escapes *)

      PHYSICALWIDTH   = 110; (* Physical Width in device units   *)
      PHYSICALHEIGHT  = 111; (* Physical Height in device units  *)
      PHYSICALOFFSETX = 112; (* Physical Printable Area x margin *)
      PHYSICALOFFSETY = 113; (* Physical Printable Area y margin *)
      SCALINGFACTORX  = 114; (* Scaling factor x                 *)
      SCALINGFACTORY  = 115; (* Scaling factor y                 *)

(* Display driver specific *)

CONST VREFRESH        = 116;  (* Current vertical refresh rate of the     *)
                              (* display device (for displays only) in Hz *)
      DESKTOPVERTRES  = 117;  (* Horizontal width of entire desktop in    *)
                              (* pixels                                   *)
      DESKTOPHORZRES  = 118;  (* Vertical height of entire desktop in     *)
                              (* pixels                                   *)
      BLTALIGNMENT    = 119;  (* Preferred blt alignment                  *)

<* IF NOT DEFINED (NOGDICAPMASKS) THEN *>

(* Device Technologies *)

TYPE DT_ENUM = (DT_PLOTTER,    (* 0 - Vector plotter                   *)
                DT_RASDISPLAY, (* 1 - Raster display                   *)
                DT_RASPRINTER, (* 2 - Raster printer                   *)
                DT_RASCAMERA,  (* 3 - Raster camera                    *)
                DT_CHARSTREAM, (* 4 - Character-stream, PLP            *)
                DT_METAFILE,   (* 5 - Metafile, VDM                    *)
                DT_DISPFILE);  (* 6 - Display-file                     *)

(* Curve Capabilities *)

TYPE CC_ENUM = (CC__CIRCLES,       (* 0; Can do circles           *)
                CC__PIE,           (* 1; Can do pie wedges        *)
                CC__CHORD,         (* 2; Can do chord arcs        *)
                CC__ELLIPSES,      (* 3; Can do ellipses          *)
                CC__WIDE,          (* 4; Can do wide lines        *)
                CC__STYLED,        (* 5; Can do styled lines      *)
                CC__WIDESTYLED,    (* 6; Can do wide styled lines *)
                CC__INTERIORS,     (* 7; Can do interiors         *)
                CC__ROUNDRECT);    (* 8; Can do round rectangles  *)

     CC_SET = SET OF CC_ENUM;

CONST CC_NONE       = CC_SET {};               (*   0; Curves not supported *)
      CC_CIRCLES    = CC_SET {CC__CIRCLES};    (*   1 *)
      CC_PIE        = CC_SET {CC__PIE};        (*   2 *)
      CC_CHORD      = CC_SET {CC__CHORD};      (*   4 *)
      CC_ELLIPSES   = CC_SET {CC__ELLIPSES};   (*   8 *)
      CC_WIDE       = CC_SET {CC__WIDE};       (*  16 *)
      CC_STYLED     = CC_SET {CC__STYLED};     (*  32 *)
      CC_WIDESTYLED = CC_SET {CC__WIDESTYLED}; (*  64 *)
      CC_INTERIORS  = CC_SET {CC__INTERIORS};  (* 128 *)
      CC_ROUNDRECT  = CC_SET {CC__ROUNDRECT};  (* 256 *)

(* Line Capabilities *)

TYPE LC_ENUM = (LC__0,
                LC__POLYLINE,      (* 1 - Can do polylines         *)
                LC__MARKER,        (* 2 - Can do markers           *)
                LC__POLYMARKER,    (* 3 - Can do polymarkers       *)
                LC__WIDE,          (* 4 - Can do wide lines        *)
                LC__STYLED,        (* 5 - Can do styled lines      *)
                LC__WIDESTYLED,    (* 6 - Can do wide styled lines *)
                LC__INTERIORS);    (* 7 - Can do interiors         *)

     LC_SET = SET OF LC_ENUM;

CONST LC_NONE       = LC_SET {};                (* 0 - Lines not supported *)
      LC_POLYLINE   = LC_SET {LC__POLYLINE   }; (* 2   *)
      LC_MARKER     = LC_SET {LC__MARKER     }; (* 4   *)
      LC_POLYMARKER = LC_SET {LC__POLYMARKER }; (* 8   *)
      LC_WIDE       = LC_SET {LC__WIDE       }; (* 16  *)
      LC_STYLED     = LC_SET {LC__STYLED     }; (* 32  *)
      LC_WIDESTYLED = LC_SET {LC__WIDESTYLED }; (* 64  *)
      LC_INTERIORS  = LC_SET {LC__INTERIORS  }; (* 128 *)

(* Polygonal Capabilities *)

TYPE PC__ENUM = (PC__POLYGON,        (* 0 - Can do polygons            *)
                 PC__RECTANGLE,      (* 1 - Can do rectangles          *)
                 PC__WINDPOLYGON,    (* 2 - Can do winding polygons    *)
                 PC__SCANLINE,       (* 3 - Can do scanlines           *)
                 PC__WIDE,           (* 4 - Can do wide borders        *)
                 PC__STYLED,         (* 5 - Can do styled borders      *)
                 PC__WIDESTYLED,     (* 6 - Can do wide styled borders *)
                 PC__INTERIORS,      (* 7 - Can do interiors           *)
                 PC__POLYPOLYGON,    (* 8 - Can do polypolygons        *)
                 PC__PATHS);         (* 9 - Can do paths               *)

     PC__SET = SET OF PC__ENUM;

CONST PC__TRAPEZOID = PC__WINDPOLYGON; (* Can do trapezoids  *)

      PC_NONE         = PC__SET {};                (*   0 *)
      PC_POLYGON      = PC__SET {PC__POLYGON    }; (*   1 *)
      PC_RECTANGLE    = PC__SET {PC__RECTANGLE  }; (*   2 *)
      PC_WINDPOLYGON  = PC__SET {PC__WINDPOLYGON}; (*   4 *)
      PC_TRAPEZOID    = PC__SET {PC__TRAPEZOID  }; (*   4 *)
      PC_SCANLINE     = PC__SET {PC__SCANLINE   }; (*   8 *)
      PC_WIDE         = PC__SET {PC__WIDE       }; (*  16 *)
      PC_STYLED       = PC__SET {PC__STYLED     }; (*  32 *)
      PC_WIDESTYLED   = PC__SET {PC__WIDESTYLED }; (*  64 *)
      PC_INTERIORS    = PC__SET {PC__INTERIORS  }; (* 128 *)

(* Clipping Capabilities *)

TYPE CP_ENUM = (CP_NONE,      (* 0  - No clipping of output               *)
                CP_RECTANGLE, (* 1  - Output clipped to rects             *)
                CP_REGION);   (* 2  - Output clipped to region (obsolete) *)

(* Text Capabilities *)

TYPE TC_ENUM = (TC__OP_CHARACTER, (*  0 Can do OutputPrecision   CHARACTER      *)
                TC__OP_STROKE,    (*  1 Can do OutputPrecision   STROKE         *)
                TC__CP_STROKE,    (*  2 Can do ClipPrecision     STROKE         *)
                TC__CR_90,        (*  3 Can do CharRotAbility    90             *)
                TC__CR_ANY,       (*  4 Can do CharRotAbility    ANY            *)
                TC__SF_X_YINDEP,  (*  5 Can do ScaleFreedom      X_YINDEPENDENT *)
                TC__SA_DOUBLE,    (*  6 Can do ScaleAbility      DOUBLE         *)
                TC__SA_INTEGER,   (*  7 Can do ScaleAbility      INTEGER        *)
                TC__SA_CONTIN,    (*  8 Can do ScaleAbility      CONTINUOUS     *)
                TC__EA_DOUBLE,    (*  9 Can do EmboldenAbility   DOUBLE         *)
                TC__IA_ABLE,      (* 10 Can do ItalisizeAbility  ABLE           *)
                TC__UA_ABLE,      (* 11 Can do UnderlineAbility  ABLE           *)
                TC__SO_ABLE,      (* 12 Can do StrikeOutAbility  ABLE           *)
                TC__RA_ABLE,      (* 13 Can do RasterFontAble    ABLE           *)
                TC__VA_ABLE,      (* 14 Can do VectorFontAble    ABLE           *)
                TC__RESERVED,     (* 15 *)
                TC__SCROLLBLT);   (* 16 do text scroll with blt                 *)

           TC_SET = SET OF TC_ENUM;

CONST TC_OP_CHARACTER  = TC_SET {TC__OP_CHARACTER}; (* 0x00000001 *)
      TC_OP_STROKE     = TC_SET {TC__OP_STROKE   }; (* 0x00000002 *)
      TC_CP_STROKE     = TC_SET {TC__CP_STROKE   }; (* 0x00000004 *)
      TC_CR_90         = TC_SET {TC__CR_90       }; (* 0x00000008 *)
      TC_CR_ANY        = TC_SET {TC__CR_ANY      }; (* 0x00000010 *)
      TC_SF_X_YINDEP   = TC_SET {TC__SF_X_YINDEP }; (* 0x00000020 *)
      TC_SA_DOUBLE     = TC_SET {TC__SA_DOUBLE   }; (* 0x00000040 *)
      TC_SA_INTEGER    = TC_SET {TC__SA_INTEGER  }; (* 0x00000080 *)
      TC_SA_CONTIN     = TC_SET {TC__SA_CONTIN   }; (* 0x00000100 *)
      TC_EA_DOUBLE     = TC_SET {TC__EA_DOUBLE   }; (* 0x00000200 *)
      TC_IA_ABLE       = TC_SET {TC__IA_ABLE     }; (* 0x00000400 *)
      TC_UA_ABLE       = TC_SET {TC__UA_ABLE     }; (* 0x00000800 *)
      TC_SO_ABLE       = TC_SET {TC__SO_ABLE     }; (* 0x00001000 *)
      TC_RA_ABLE       = TC_SET {TC__RA_ABLE     }; (* 0x00002000 *)
      TC_VA_ABLE       = TC_SET {TC__VA_ABLE     }; (* 0x00004000 *)
      TC_RESERVED      = TC_SET {TC__RESERVED    }; (* 0x00008000 *)
      TC_SCROLLBLT     = TC_SET {TC__SCROLLBLT   }; (* 0x00010000 *)

<* END *> (* NOT DEFINED (NOGDICAPMASKS) *)

(* Raster Capabilities *)

TYPE RC_ENUM = (RC__BITBLT,         (*  0 - Can do standard BLT.             *)
                RC__BANDING,        (*  1 - Device requires banding support  *)
                RC__SCALING,        (*  2 - Device requires scaling support  *)
                RC__BITMAP64,       (*  3 - Device can support >64K bitmap   *)
                RC__GDI20_OUTPUT,   (*  4 - has 2.0 output calls             *)
                RC__GDI20_STATE,    (*  5 *)
                RC__SAVEBITMAP,     (*  6 *)
                RC__DI_BITMAP,      (*  7 - supports DIB to memory           *)
                RC__PALETTE,        (*  8 - supports a palette               *)
                RC__DIBTODEV,       (*  9 - supports DIBitsToDevice          *)
                RC__BIGFONT,        (* 10 - supports >64K fonts              *)
                RC__STRETCHBLT,     (* 11 - supports StretchBlt              *)
                RC__FLOODFILL,      (* 12 - supports FloodFill               *)
                RC__STRETCHDIB,     (* 13 - supports StretchDIBits           *)
                RC__OP_DX_OUTPUT,   (* 14 *)
                RC__DEVBITS);       (* 15 *)

           RC_SET = SET OF RC_ENUM;

      CONST RC_NONE         = RC_SET {};
            RC_BITBLT       = RC_SET {RC__BITBLT       }; (*      1 *)
            RC_BANDING      = RC_SET {RC__BANDING      }; (*      2 *)
            RC_SCALING      = RC_SET {RC__SCALING      }; (*      4 *)
            RC_BITMAP64     = RC_SET {RC__BITMAP64     }; (*      8 *)
            RC_GDI20_OUTPUT = RC_SET {RC__GDI20_OUTPUT }; (* 0x0010 *)
            RC_GDI20_STATE  = RC_SET {RC__GDI20_STATE  }; (* 0x0020 *)
            RC_SAVEBITMAP   = RC_SET {RC__SAVEBITMAP   }; (* 0x0040 *)
            RC_DI_BITMAP    = RC_SET {RC__DI_BITMAP    }; (* 0x0080 *)
            RC_PALETTE      = RC_SET {RC__PALETTE      }; (* 0x0100 *)
            RC_DIBTODEV     = RC_SET {RC__DIBTODEV     }; (* 0x0200 *)
            RC_BIGFONT      = RC_SET {RC__BIGFONT      }; (* 0x0400 *)
            RC_STRETCHBLT   = RC_SET {RC__STRETCHBLT   }; (* 0x0800 *)
            RC_FLOODFILL    = RC_SET {RC__FLOODFILL    }; (* 0x1000 *)
            RC_STRETCHDIB   = RC_SET {RC__STRETCHDIB   }; (* 0x2000 *)
            RC_OP_DX_OUTPUT = RC_SET {RC__OP_DX_OUTPUT }; (* 0x4000 *)
            RC_DEVBITS      = RC_SET {RC__DEVBITS      }; (* 0x8000 *)

(* DIB color table identifiers *)

TYPE DIB_COLOR_ENUM = (
         DIB_RGB_COLORS,       (* 0 - color table in RGBs                      *)
         DIB_PAL_COLORS,       (* 1 - color table in palette indices           *)
         DIB_PAL_PHYSINDICES,  (* 2 - No color table indices into surf palette *)
         DIB_PAL_LOGINDICES);  (* 3 - No color table indices into DC palette   *)

CONST    DIB_PAL_INDICES = DIB_PAL_PHYSINDICES;

(* constants for Get/SetSystemPaletteUse() *)

TYPE SYSPAL_ENUM = (SYSPAL_ERROR,     (* 0 *)
                    SYSPAL_STATIC,    (* 1 *)
                    SYSPAL_NOSTATIC); (* 2 *)

(* constants for CreateDIBitmap *)
TYPE CBM_ENUM = (CBM_0, CBM_1,
                CBM_CREATEDIB,  (* 0x02L  - create DIB bitmap *)
                CBM_3,
                CBM_INIT);      (* 0x04L  - initialize bitmap *)

(* ExtFloodFill style flags *)
TYPE FLOODFILL_ENUM = (FLOODFILLBORDER,   (* 0 *)
                       FLOODFILLSURFACE); (* 1 *)

(* DEVMODE structure stuff *)

(* current version of specification *)
CONST DM_SPECVERSION = 0401h;

(* field selection set (dmFields field) *)

TYPE DM_ENUM = (DM__ORIENTATION,      (* 0 *)
                DM__PAPERSIZE,        (* 1 *)
                DM__PAPERLENGTH,      (* 2 *)
                DM__PAPERWIDTH,       (* 3 *)
                DM__SCALE,            (* 4 *)
                DM__5, DM__6, DM__7,
                DM__COPIES,           (* 8 *)
                DM__DEFAULTSOURCE,    (* 9 *)
                DM__PRINTQUALITY,     (* 10 *)
                DM__COLOR,            (* 11 *)
                DM__DUPLEX,           (* 12 *)
                DM__YRESOLUTION,      (* 13 *)
                DM__TTOPTION,         (* 14 *)
                DM__COLLATE,          (* 15 *)
                DM__FORMNAME,         (* 16 *)
                DM__LOGPIXELS,        (* 17 *)
                DM__BITSPERPEL,       (* 18 *)
                DM__PELSWIDTH,        (* 19 *)
                DM__PELSHEIGHT,       (* 20 *)
                DM__DISPLAYFLAGS,     (* 21 *)
                DM__DISPLAYFREQUENCY, (* 22 *)
                DM__PANNINGWIDTH,     (* 23 *)
                DM__PANNINGHEIGHT,    (* 24 *)
                DM__ICMMETHOD,        (* 25 *)
                DM__ICMINTENT,        (* 26 *)
                DM__MEDIATYPE,        (* 27 *)
                DM__DITHERTYPE,       (* 28 *)
                DM__ICCMANUFACTURER,  (* 29 *)
                DM__ICCMODEL);        (* 30 *)

     DM_SET = SET OF DM_ENUM;

CONST DM_ORIENTATION      = DM_SET {DM__ORIENTATION     };  (* 0x00000001 *)
      DM_PAPERSIZE        = DM_SET {DM__PAPERSIZE       };  (* 0x00000002 *)
      DM_PAPERLENGTH      = DM_SET {DM__PAPERLENGTH     };  (* 0x00000004 *)
      DM_PAPERWIDTH       = DM_SET {DM__PAPERWIDTH      };  (* 0x00000008 *)
      DM_SCALE            = DM_SET {DM__SCALE           };  (* 0x00000010 *)
      DM_COPIES           = DM_SET {DM__COPIES          };  (* 0x00000100 *)
      DM_DEFAULTSOURCE    = DM_SET {DM__DEFAULTSOURCE   };  (* 0x00000200 *)
      DM_PRINTQUALITY     = DM_SET {DM__PRINTQUALITY    };  (* 0x00000400 *)
      DM_COLOR            = DM_SET {DM__COLOR           };  (* 0x00000800 *)
      DM_DUPLEX           = DM_SET {DM__DUPLEX          };  (* 0x00001000 *)
      DM_YRESOLUTION      = DM_SET {DM__YRESOLUTION     };  (* 0x00002000 *)
      DM_TTOPTION         = DM_SET {DM__TTOPTION        };  (* 0x00004000 *)
      DM_COLLATE          = DM_SET {DM__COLLATE         };  (* 0x00008000 *)
      DM_FORMNAME         = DM_SET {DM__FORMNAME        };  (* 0x00010000 *)
      DM_LOGPIXELS        = DM_SET {DM__LOGPIXELS       };  (* 0x00020000 *)
      DM_BITSPERPEL       = DM_SET {DM__BITSPERPEL      };  (* 0x00040000 *)
      DM_PELSWIDTH        = DM_SET {DM__PELSWIDTH       };  (* 0x00080000 *)
      DM_PELSHEIGHT       = DM_SET {DM__PELSHEIGHT      };  (* 0x00100000 *)
      DM_DISPLAYFLAGS     = DM_SET {DM__DISPLAYFLAGS    };  (* 0x00200000 *)
      DM_DISPLAYFREQUENCY = DM_SET {DM__DISPLAYFREQUENCY}; (* 0x00400000 *)
      DM_PANNINGWIDTH     = DM_SET {DM__PANNINGWIDTH    };  (* 0x00800000 *)
      DM_PANNINGHEIGHT    = DM_SET {DM__PANNINGHEIGHT   };  (* 0x01000000 *)
      DM_ICMMETHOD        = DM_SET {DM__ICMMETHOD       };  (* 0x02000000 *)
      DM_ICMINTENT        = DM_SET {DM__ICMINTENT       };  (* 0x04000000 *)
      DM_MEDIATYPE        = DM_SET {DM__MEDIATYPE       };  (* 0x08000000 *)
      DM_DITHERTYPE       = DM_SET {DM__DITHERTYPE      };  (* 0x10000000 *)
      DM_ICCMANUFACTURER  = DM_SET {DM__ICCMANUFACTURER };  (* 0x20000000 *)
      DM_ICCMODEL         = DM_SET {DM__ICCMODEL        };  (* 0x40000000 *)

(* orientation selections - values of dmOrientation *)

<* PUSH *> <* ENUMSIZE = "2" *>
TYPE DMORIENT_ENUM = (DMORIENT_0,
                      DMORIENT_PORTRAIT,   (* 1 *)
                      DMORIENT_LANDSCAPE); (* 2 *)
<* POP *>

(* paper selections - values for dmPaperSize *)

<* PUSH *> <* ENUMSIZE = "2" *>

TYPE DMPAPER_ENUM = (
      DMPAPER_0,
      DMPAPER_LETTER,              (* 1  - Letter 8 1/2 x 11 in               *)
      DMPAPER_LETTERSMALL,         (* 2  - Letter Small 8 1/2 x 11 in         *)
      DMPAPER_TABLOID,             (* 3  - Tabloid 11 x 17 in                 *)
      DMPAPER_LEDGER,              (* 4  - Ledger 17 x 11 in                  *)
      DMPAPER_LEGAL,               (* 5  - Legal 8 1/2 x 14 in                *)
      DMPAPER_STATEMENT,           (* 6  - Statement 5 1/2 x 8 1/2 in         *)
      DMPAPER_EXECUTIVE,           (* 7  - Executive 7 1/4 x 10 1/2 in        *)
      DMPAPER_A3,                  (* 8  - A3 297 x 420 mm                    *)
      DMPAPER_A4,                  (* 9  - A4 210 x 297 mm                    *)
      DMPAPER_A4SMALL,             (* 10 - A4 Small 210 x 297 mm              *)
      DMPAPER_A5,                  (* 11 - A5 148 x 210 mm                    *)
      DMPAPER_B4,                  (* 12 - B4 250 x 354                       *)
      DMPAPER_B5,                  (* 13 - B5 182 x 257 mm                    *)
      DMPAPER_FOLIO,               (* 14 - Folio 8 1/2 x 13 in                *)
      DMPAPER_QUARTO,              (* 15 - Quarto 215 x 275 mm                *)
      DMPAPER_10X14,               (* 16 - 10x14 in                           *)
      DMPAPER_11X17,               (* 17 - 11x17 in                           *)
      DMPAPER_NOTE,                (* 18 - Note 8 1/2 x 11 in                 *)
      DMPAPER_ENV_9,               (* 19 - Envelope #9 3 7/8 x 8 7/8          *)
      DMPAPER_ENV_10,              (* 20 - Envelope #10 4 1/8 x 9 1/2         *)
      DMPAPER_ENV_11,              (* 21 - Envelope #11 4 1/2 x 10 3/8        *)
      DMPAPER_ENV_12,              (* 22 - Envelope #12 4 \276 x 11           *)
      DMPAPER_ENV_14,              (* 23 - Envelope #14 5 x 11 1/2            *)
      DMPAPER_CSHEET,              (* 24 - C size sheet                       *)
      DMPAPER_DSHEET,              (* 25 - D size sheet                       *)
      DMPAPER_ESHEET,              (* 26 - E size sheet                       *)
      DMPAPER_ENV_DL,              (* 27 - Envelope DL 110 x 220mm            *)
      DMPAPER_ENV_C5,              (* 28 - Envelope C5 162 x 229 mm           *)
      DMPAPER_ENV_C3,              (* 29 - Envelope C3  324 x 458 mm          *)
      DMPAPER_ENV_C4,              (* 30 - Envelope C4  229 x 324 mm          *)
      DMPAPER_ENV_C6,              (* 31 - Envelope C6  114 x 162 mm          *)
      DMPAPER_ENV_C65,             (* 32 - Envelope C65 114 x 229 mm          *)
      DMPAPER_ENV_B4,              (* 33 - Envelope B4  250 x 353 mm          *)
      DMPAPER_ENV_B5,              (* 34 - Envelope B5  176 x 250 mm          *)
      DMPAPER_ENV_B6,              (* 35 - Envelope B6  176 x 125 mm          *)
      DMPAPER_ENV_ITALY,           (* 36 - Envelope 110 x 230 mm              *)
      DMPAPER_ENV_MONARCH,         (* 37 - Envelope Monarch 3.875 x 7.5 in    *)
      DMPAPER_ENV_PERSONAL,        (* 38 - 6 3/4 Envelope 3 5/8 x 6 1/2 in    *)
      DMPAPER_FANFOLD_US,          (* 39 - US Std Fanfold 14 7/8 x 11 in      *)
      DMPAPER_FANFOLD_STD_GERMAN,  (* 40 - German Std Fanfold 8 1/2 x 12 in   *)
      DMPAPER_FANFOLD_LGL_GERMAN,  (* 41 - German Legal Fanfold 8 1/2 x 13 in *)

      DMPAPER_ISO_B4,              (* 42 - B4 (ISO) 250 x 353 mm              *)
      DMPAPER_JAPANESE_POSTCARD,   (* 43 - Japanese Postcard 100 x 148 mm     *)
      DMPAPER_9X11,                (* 44 - 9 x 11 in                          *)
      DMPAPER_10X11,               (* 45 - 10 x 11 in                         *)
      DMPAPER_15X11,               (* 46 - 15 x 11 in                         *)
      DMPAPER_ENV_INVITE,          (* 47 - Envelope Invite 220 x 220 mm       *)
      DMPAPER_RESERVED_48,         (* 48 - RESERVED--DO NOT USE               *)
      DMPAPER_RESERVED_49,         (* 49 - RESERVED--DO NOT USE               *)
      DMPAPER_LETTER_EXTRA,        (* 50 - Letter Extra 9 \275 x 12 in        *)
      DMPAPER_LEGAL_EXTRA,         (* 51 - Legal Extra 9 \275 x 15 in         *)
      DMPAPER_TABLOID_EXTRA,       (* 52 - Tabloid Extra 11.69 x 18 in        *)
      DMPAPER_A4_EXTRA,            (* 53 - A4 Extra 9.27 x 12.69 in           *)
      DMPAPER_LETTER_TRANSVERSE,   (* 54 - Letter Transverse 8 \275 x 11 in   *)
      DMPAPER_A4_TRANSVERSE,       (* 55 - A4 Transverse 210 x 297 mm         *)
      DMPAPER_LETTER_EXTRA_TRANSVERSE, (* 56 - Letter Extra Transverse 9\275 x 12 in *)
      DMPAPER_A_PLUS,              (* 57 - SuperA/SuperA/A4 227 x 356 mm      *)
      DMPAPER_B_PLUS,              (* 58 - SuperB/SuperB/A3 305 x 487 mm      *)
      DMPAPER_LETTER_PLUS,         (* 59 - Letter Plus 8.5 x 12.69 in         *)
      DMPAPER_A4_PLUS,             (* 60 - A4 Plus 210 x 330 mm               *)
      DMPAPER_A5_TRANSVERSE,       (* 61 - A5 Transverse 148 x 210 mm         *)
      DMPAPER_B5_TRANSVERSE,       (* 62 - B5 (JIS) Transverse 182 x 257 mm   *)
      DMPAPER_A3_EXTRA,            (* 63 - A3 Extra 322 x 445 mm              *)
      DMPAPER_A5_EXTRA,            (* 64 - A5 Extra 174 x 235 mm              *)
      DMPAPER_B5_EXTRA,            (* 65 - B5 (ISO) Extra 201 x 276 mm        *)
      DMPAPER_A2,                  (* 66 - A2 420 x 594 mm                    *)
      DMPAPER_A3_TRANSVERSE,       (* 67 - A3 Transverse 297 x 420 mm         *)
      DMPAPER_A3_EXTRA_TRANSVERSE, (* 68 - A3 Extra Transverse 322 x 445 mm   *)

      DMPAPER_DBL_JAPANESE_POSTCARD,(* 69 - Japanese Double Postcard 200 x 148 mm *)
      DMPAPER_A6,                  (* 70 - A6 105 x 148 mm                 *)
      DMPAPER_JENV_KAKU2,          (* 71 - Japanese Envelope Kaku #2       *)
      DMPAPER_JENV_KAKU3,          (* 72 - Japanese Envelope Kaku #3       *)
      DMPAPER_JENV_CHOU3,          (* 73 - Japanese Envelope Chou #3       *)
      DMPAPER_JENV_CHOU4,          (* 74 - Japanese Envelope Chou #4       *)
      DMPAPER_LETTER_ROTATED,      (* 75 - Letter Rotated 11 x 8 1/2 11 in *)
      DMPAPER_A3_ROTATED,          (* 76 - A3 Rotated 420 x 297 mm         *)
      DMPAPER_A4_ROTATED,          (* 77 - A4 Rotated 297 x 210 mm         *)
      DMPAPER_A5_ROTATED,          (* 78 - A5 Rotated 210 x 148 mm         *)
      DMPAPER_B4_JIS_ROTATED,      (* 79 - B4 (JIS) Rotated 364 x 257 mm   *)
      DMPAPER_B5_JIS_ROTATED,      (* 80 - B5 (JIS) Rotated 257 x 182 mm   *)
      DMPAPER_JAPANESE_POSTCARD_ROTATED,(* 81 - Japanese Postcard Rotated 148 x 100 mm *)
      DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED,(* 82 - Double Japanese Postcard Rotated 148 x 200 mm *)
      DMPAPER_A6_ROTATED,          (* 83 - A6 Rotated 148 x 105 mm         *)
      DMPAPER_JENV_KAKU2_ROTATED,  (* 84 - Japanese Envelope Kaku #2 Rotated *)
      DMPAPER_JENV_KAKU3_ROTATED,  (* 85 - Japanese Envelope Kaku #3 Rotated *)
      DMPAPER_JENV_CHOU3_ROTATED,  (* 86 - Japanese Envelope Chou #3 Rotated *)
      DMPAPER_JENV_CHOU4_ROTATED,  (* 87 - Japanese Envelope Chou #4 Rotated *)
      DMPAPER_B6_JIS,              (* 88 - B6 (JIS) 128 x 182 mm           *)
      DMPAPER_B6_JIS_ROTATED,      (* 89 - B6 (JIS) Rotated 182 x 128 mm   *)
      DMPAPER_12X11,               (* 90 - 12 x 11 in                      *)
      DMPAPER_JENV_YOU4,           (* 91 - Japanese Envelope You #4        *)
      DMPAPER_JENV_YOU4_ROTATED,   (* 92 - Japanese Envelope You #4 Rotated*)
      DMPAPER_P16K,                (* 93 - PRC 16K 146 x 215 mm            *)
      DMPAPER_P32K,                (* 94 - PRC 32K 97 x 151 mm             *)
      DMPAPER_P32KBIG,             (* 95 - PRC 32K(Big) 97 x 151 mm        *)
      DMPAPER_PENV_1,              (* 96 - PRC Envelope #1 102 x 165 mm    *)
      DMPAPER_PENV_2,              (* 97 - PRC Envelope #2 102 x 176 mm    *)
      DMPAPER_PENV_3,              (* 98 - PRC Envelope #3 125 x 176 mm    *)
      DMPAPER_PENV_4,              (* 99 - PRC Envelope #4 110 x 208 mm    *)
      DMPAPER_PENV_5,              (*100 - PRC Envelope #5 110 x 220 mm    *)
      DMPAPER_PENV_6,              (*101 - PRC Envelope #6 120 x 230 mm    *)
      DMPAPER_PENV_7,              (*102 - PRC Envelope #7 160 x 230 mm    *)
      DMPAPER_PENV_8,              (*103 - PRC Envelope #8 120 x 309 mm    *)
      DMPAPER_PENV_9,              (*104 - PRC Envelope #9 229 x 324 mm    *)
      DMPAPER_PENV_10,             (*105 - PRC Envelope #10 324 x 458 mm   *)
      DMPAPER_P16K_ROTATED,        (*106 - PRC 16K Rotated                 *)
      DMPAPER_P32K_ROTATED,        (*107 - PRC 32K Rotated                 *)
      DMPAPER_P32KBIG_ROTATED,     (*108 - PRC 32K(Big) Rotated            *)
      DMPAPER_PENV_1_ROTATED,      (*109 - PRC Envelope #1 Rotated 165 x 102 mm *)
      DMPAPER_PENV_2_ROTATED,      (*110 - PRC Envelope #2 Rotated 176 x 102 mm *)
      DMPAPER_PENV_3_ROTATED,      (*111 - PRC Envelope #3 Rotated 176 x 125 mm *)
      DMPAPER_PENV_4_ROTATED,      (*112 - PRC Envelope #4 Rotated 208 x 110 mm *)
      DMPAPER_PENV_5_ROTATED,      (*113 - PRC Envelope #5 Rotated 220 x 110 mm *)
      DMPAPER_PENV_6_ROTATED,      (*114 - PRC Envelope #6 Rotated 230 x 120 mm *)
      DMPAPER_PENV_7_ROTATED,      (*115 - PRC Envelope #7 Rotated 230 x 160 mm *)
      DMPAPER_PENV_8_ROTATED,      (*116 - PRC Envelope #8 Rotated 309 x 120 mm *)
      DMPAPER_PENV_9_ROTATED,      (*117 - PRC Envelope #9 Rotated 324 x 229 mm *)
      DMPAPER_PENV_10_ROTATED);    (*118 - PRC Envelope #10 Rotated 458 x 324 mm *)

CONST DMPAPER_FIRST = DMPAPER_LETTER;
      DMPAPER_LAST  = DMPAPER_PENV_10_ROTATED;

      DMPAPER_USER  = DM_ENUM (256);

<* POP *>

(* bin selections - dmDefaultSource values *)

<* PUSH *> <* ENUMSIZE = "2" *>

TYPE DMBIN_ENUM = (DMBIN_0,
                   DMBIN_UPPER,         (*  1 *)
                   DMBIN_LOWER,         (*  2 *)
                   DMBIN_MIDDLE,        (*  3 *)
                   DMBIN_MANUAL,        (*  4 *)
                   DMBIN_ENVELOPE,      (*  5 *)
                   DMBIN_ENVMANUA,      (*  6 *)
                   DMBIN_AUTO,          (*  7 *)
                   DMBIN_TRACTOR,       (*  8 *)
                   DMBIN_SMALLFMT,      (*  9 *)
                   DMBIN_LARGEFMT,      (* 10 *)
                   DMBIN_LARGECAPACITY, (* 11 *)
                   DMBIN_CASSETTE,      (* 14 *)
                   DMBIN_FORMSOURCE);   (* 15 *)

<* POP *>

CONST DMBIN_ONLYONE       = DMBIN_UPPER; (* 1 *)
      DMBIN_FIRST = DMBIN_UPPER;
      DMBIN_LAST  = DMBIN_FORMSOURCE;
      DMBIN_USER  = DMBIN_ENUM (256);    (* device specific bins start here *)

(* print qualities - values of dmPrintQuality field *)
TYPE DMRES_ENUM = SHORT;

CONST DMRES_DRAFT   = DMRES_ENUM (-1);
      DMRES_LOW     = DMRES_ENUM (-2);
      DMRES_MEDIUM  = DMRES_ENUM (-3);
      DMRES_HIGH    = DMRES_ENUM (-4);

(* color enable/disable for color printers - dmColor values *)

<* PUSH *> <* ENUMSIZE = "2" *>

TYPE DMCOLOR_ENUM = (DMCOLOR_0,
                     DMCOLOR_MONOCHROME, (* 1 *)
                     DMCOLOR_COLOR);     (* 2 *)

<* POP *>

(* duplex enable - dmDuplex values *)

<* PUSH *> <* ENUMSIZE = "2" *>

TYPE DMDUP_ENUM = (DMDUPLEX_0,
                   DMDUP_SIMPLEX,     (* 1 *)
                   DMDUP_VERTICAL,    (* 2 *)
                   DMDUP_HORIZONTAL); (* 3 *)

<* POP *>

(* TrueType options - dmTTOption values *)

<* PUSH *> <* ENUMSIZE = "2" *>

TYPE DMTT_ENUM = (DMTT_0,
                  DMTT_BITMAP,            (* 1 - print TT fonts as graphics *)
                  DMTT_DOWNLOAD,          (* 2 - download TT fonts as soft fonts *)
                  DMTT_SUBDEV,            (* 3 - substitute device fonts for TT fonts *)
                  DMTT_DOWNLOAD_OUTLINE); (* 4 - download TT fonts as outline soft fonts *)

<* POP *>

(* Collation selections *)

<* PUSH *> <* ENUMSIZE = "2" *>

TYPE DMCOLLATE_ENUM = (DMCOLLATE_FALSE, (* 0 *)
                       DMCOLLATE_TRUE); (* 1 *)

<* POP *>

(* DEVMODE dmDisplayFlags flags *)

TYPE DMDISP_ENUM = (DM__GRAYSCALE,              (* 0 *)
                    DM__INTERLACED,             (* 1 *)
                    DMDISPLAYFLAGS__TEXTMODE);  (* 2 *)

     DMDISP_SET = SET OF DMDISP_ENUM;

CONST DM_GRAYSCALE  = DMDISP_SET {DM__GRAYSCALE};   (* 0x00000001 *)
      DM_INTERLACED = DMDISP_SET {DM__INTERLACED};  (* 0x00000002 *)
      DMDISPLAYFLAGS_TEXTMODE = DMDISP_SET {DMDISPLAYFLAGS__TEXTMODE}; (* 0x00000002 *)

(* ICM methods *)

TYPE  DMICMMETHOD_ENUM = (DMICMMETHOD_0,
                          DMICMMETHOD_NONE,    (* 1 - ICM disabled *)
                          DMICMMETHOD_SYSTEM,  (* 2 - ICM handled by system *)
                          DMICMMETHOD_DRIVER,  (* 3 - ICM handled by driver *)
                          DMICMMETHOD_DEVICE); (* 4 - ICM handled by device *)

CONST DMICMMETHOD_USER = DMICMMETHOD_ENUM (256);

(* ICM Intents *)

TYPE DMICM_ENUM = (DMICM_0,
                   DMICM_SATURATE,     (* 1 - Maximize color saturation *)
                   DMICM_CONTRAST,     (* 2 - Maximize color contrast   *)
                   DMICM_COLORMETRIC); (* 3 - Use specific color metric *)

CONST DMICM_USER = DMICM_ENUM (256);   (* Device-specific intents start here *)

(* Media types *)

TYPE  DMMEDIA_ENUM = (DMMEDIA_0,
                      DMMEDIA_STANDARD,     (* 1 - Standard paper *)
                      DMMEDIA_TRANSPARENCY, (* 2 - Transparency *)
                      DMMEDIA_GLOSSY);      (* 3 - Glossy paper *)

CONST DMMEDIA_USER = DMMEDIA_ENUM (256);   (* Device-specific media start here *)

(* Dither types *)

TYPE DMDITHER_ENUM = (DMDITHER_0,
                      DMDITHER_NONE,        (* 1 - No dithering *)
                      DMDITHER_COARSE,      (* 2 - Dither with a coarse brush *)
                      DMDITHER_FINE,        (* 3 - Dither with a fine brush *)
                      DMDITHER_LINEART,     (* 4 - LineArt dithering *)
                      DMDITHER_GRAYSCALE);  (* 5 - Device does grayscaling *)

CONST DMDITHER_USER = DMDITHER_ENUM (256);  (* Device-specific dithers start here *)

(* size of a device name string (dmDeviceName field) *)
CONST CCHDEVICENAME = 32;

(* size of a form name string (dmFormName field) *)
CONST CCHFORMNAME = 32;

TYPE DEVMODEA = RECORD
                    dmDeviceName     : ARRAY [0..CCHDEVICENAME-1] OF CHAR;
                    dmSpecVersion    : WORD;
                    dmDriverVersion  : WORD;
                    dmSize           : WORD;
                    dmDriverExtra    : WORD;
                    dmFields         : DM_SET;
                    dmOrientation    : DMORIENT_ENUM;
                    dmPaperSize      : DMPAPER_ENUM;
                    dmPaperLength    : SHORT;
                    dmPaperWidth     : SHORT;
                    dmScale          : SHORT;
                    dmCopies         : SHORT;
                    dmDefaultSource  : DMBIN_ENUM;
                    dmPrintQuality   : DMRES_ENUM;
                    dmColor          : DMCOLOR_ENUM;
                    dmDuplex         : DMDUP_ENUM;
                    dmYResolution    : SHORT;
                    dmTTOption       : DMTT_ENUM;
                    dmCollate        : DMCOLLATE_ENUM;
                    dmFormName       : ARRAY [0..CCHFORMNAME-1] OF CHAR;
                    dmLogPixels      : WORD;
                    dmBitsPerPel     : DWORD;
                    dmPelsWidth      : DWORD;
                    dmPelsHeight     : DWORD;
                    dmDisplayFlags   : DMDISP_SET;
                    dmDisplayFrequency : DWORD;
                    dmICMMethod        : DMICMMETHOD_ENUM;
                    dmICMIntent        : DMICM_ENUM;
                    dmMediaType        : DMMEDIA_ENUM;
                    dmDitherType       : DMDITHER_ENUM;
                    dmICCManufacturer  : DWORD;
                    dmICCModel         : DWORD;
                    dmPanningWidth     : DWORD;
                    dmPanningHeight    : DWORD;
                END;
     PDEVMODEA  = POINTER TO DEVMODEA;

TYPE DEVMODEW = RECORD
                    dmDeviceName     : ARRAY [0..CCHDEVICENAME-1] OF WCHAR;
                    dmSpecVersion    : WORD;
                    dmDriverVersion  : WORD;
                    dmSize           : WORD;
                    dmDriverExtra    : WORD;
                    dmFields         : DM_SET;
                    dmOrientation    : DMORIENT_ENUM;
                    dmPaperSize      : DMPAPER_ENUM;
                    dmPaperLength    : SHORT;
                    dmPaperWidth     : SHORT;
                    dmScale          : SHORT;
                    dmCopies         : SHORT;
                    dmDefaultSource  : DMBIN_ENUM;
                    dmPrintQuality   : DMRES_ENUM;
                    dmColor          : DMCOLOR_ENUM;
                    dmDuplex         : DMDUP_ENUM;
                    dmYResolution    : SHORT;
                    dmTTOption       : DMTT_ENUM;
                    dmCollate        : DMCOLLATE_ENUM;
                    dmFormName       : ARRAY [0..CCHFORMNAME-1] OF WCHAR;
                    dmLogPixels      : WORD;
                    dmBitsPerPel     : DWORD;
                    dmPelsWidth      : DWORD;
                    dmPelsHeight     : DWORD;
                    dmDisplayFlags   : DMDISP_SET;
                    dmDisplayFrequency : DWORD;
                    dmICMMethod        : DMICMMETHOD_ENUM;
                    dmICMIntent        : DMICM_ENUM;
                    dmMediaType        : DMMEDIA_ENUM;
                    dmDitherType       : DMDITHER_ENUM;
                    dmICCManufacturer  : DWORD;
                    dmICCModel         : DWORD;
                    dmPanningWidth     : DWORD;
                    dmPanningHeight    : DWORD;
                END;
     PDEVMODEW  = POINTER TO DEVMODEW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE DEVMODE   = DEVMODEW;
           PDEVMODE  = PDEVMODEW;
<* ELSE *>
      TYPE DEVMODE   = DEVMODEA;
           PDEVMODE  = PDEVMODEA;
<* END *>

(* GetRegionData/ExtCreateRegion *)

CONST RDH_RECTANGLES = 1; (* the only value for iType *)

TYPE RGNDATAHEADER = RECORD
                            dwSize   : DWORD;
                            iType    : DWORD;
                            nCount   : DWORD;
                            nRgnSize : DWORD;
                            rcBound  : RECT;
                     END;
     PRGNDATAHEADER = POINTER TO RGNDATAHEADER;

     RGNDATA = RECORD
                      rdh : RGNDATAHEADER;
                      Buffer : ARRAY [0..0] OF CHAR;
               END;
    PRGNDATA  = POINTER TO RGNDATA;

TYPE ABC = RECORD
                  abcA : INTEGER;
                  abcB : UINT;
                  abcC : INTEGER;
           END;
     PABC = POINTER TO ABC;

TYPE ABCFLOAT = RECORD
                       abcA : FLOAT;
                       abcB : FLOAT;
                       abcC : FLOAT;
                END;
     PABCFLOAT = POINTER TO ABCFLOAT;

<* IF NOT DEFINED (NOTEXTMETRIC) THEN *>

TYPE OUTLINETEXTMETRICA = RECORD
                                otmSize                : UINT;
                                otmTextMetrics         : TEXTMETRICA;
                                otmFiller              : BYTE;
                                otmPanoseNumber        : PANOSE;
                                otmfsSelection         : NTM_SET;
                                otmfsType              : UINT;
                                otmsCharSlopeRise      : INTEGER;
                                otmsCharSlopeRun       : INTEGER;
                                otmItalicAngle         : INTEGER;
                                otmEMSquare            : UINT;
                                otmAscent              : INTEGER;
                                otmDescent             : INTEGER;
                                otmLineGap             : UINT;
                                otmsCapEmHeight        : UINT;
                                otmsXHeight            : UINT;
                                otmrcFontBox           : RECT;
                                otmMacAscent           : INTEGER;
                                otmMacDescent          : INTEGER;
                                otmMacLineGap          : UINT;
                                otmusMinimumPPEM       : UINT;
                                otmptSubscriptSize     : POINT;
                                otmptSubscriptOffset   : POINT;
                                otmptSuperscriptSize   : POINT;
                                otmptSuperscriptOffset : POINT;
                                otmsStrikeoutSize      : UINT;
                                otmsStrikeoutPosition  : INTEGER;
                                otmsUnderscoreSize     : INTEGER;
                                otmsUnderscorePosition : INTEGER;
                                otmpFamilyName         : PSTR;
                                otmpFaceName           : PSTR;
                                otmpStyleName          : PSTR;
                                otmpFullName           : PSTR
                          END;

TYPE OUTLINETEXTMETRICW = RECORD
                                otmSize                : UINT;
                                otmTextMetrics         : TEXTMETRICW;
                                otmFiller              : BYTE;
                                otmPanoseNumber        : PANOSE;
                                otmfsSelection         : NTM_SET;
                                otmfsType              : UINT;
                                otmsCharSlopeRise      : INTEGER;
                                otmsCharSlopeRun       : INTEGER;
                                otmItalicAngle         : INTEGER;
                                otmEMSquare            : UINT;
                                otmAscent              : INTEGER;
                                otmDescent             : INTEGER;
                                otmLineGap             : UINT;
                                otmsCapEmHeight        : UINT;
                                otmsXHeight            : UINT;
                                otmrcFontBox           : RECT;
                                otmMacAscent           : INTEGER;
                                otmMacDescent          : INTEGER;
                                otmMacLineGap          : UINT;
                                otmusMinimumPPEM       : UINT;
                                otmptSubscriptSize     : POINT;
                                otmptSubscriptOffset   : POINT;
                                otmptSuperscriptSize   : POINT;
                                otmptSuperscriptOffset : POINT;
                                otmsStrikeoutSize      : UINT;
                                otmsStrikeoutPosition  : INTEGER;
                                otmsUnderscoreSize     : INTEGER;
                                otmsUnderscorePosition : INTEGER;
                                otmpFamilyName         : PWSTR;
                                otmpFaceName           : PWSTR;
                                otmpStyleName          : PWSTR;
                                otmpFullName           : PWSTR
                          END;
TYPE POUTLINETEXTMETRICA = POINTER TO OUTLINETEXTMETRICA;
     POUTLINETEXTMETRICW = POINTER TO OUTLINETEXTMETRICW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE OUTLINETEXTMETRIC = OUTLINETEXTMETRICW;
           POUTLINETEXTMETRIC = POUTLINETEXTMETRICW;
<* ELSE *>
      TYPE OUTLINETEXTMETRIC = OUTLINETEXTMETRICA;
           POUTLINETEXTMETRIC = POUTLINETEXTMETRICA;
<* END *>

<* END *> (* NOT DEFINED (NOTEXTMETRIC) *)

TYPE POLYTEXTA = RECORD
                        x       : INTEGER;
                        y       : INTEGER;
                        n       : UINT;
                        lpstr   : PSTR;
                        uiFlags : ETO_SET;
                        rcl     : RECT;
                        pdx     : INTARRAY;
                 END;
     PPOLYTEXTA = POINTER TO POLYTEXTA;

     POLYTEXTW = RECORD
                        x       : INTEGER;
                        y       : INTEGER;
                        n       : UINT;
                        lpstr   : PWSTR;
                        uiFlags : ETO_SET;
                        rcl     : RECT;
                        pdx     : INTARRAY;
                 END;
     PPOLYTEXTW = POINTER TO POLYTEXTW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  POLYTEXT = POLYTEXTW;
            PPOLYTEXT = PPOLYTEXTW;
<* ELSE *>
      TYPE  POLYTEXT = POLYTEXTA;
            PPOLYTEXT = PPOLYTEXTA;
<* END *>

TYPE FIXED = RECORD
                    fract : WORD;
                    value : SHORT;
             END;

TYPE MAT2 = RECORD
                   eM11 : FIXED;
                   eM12 : FIXED;
                   eM21 : FIXED;
                   eM22 : FIXED;
            END;
     PMAT2 = POINTER TO MAT2;


TYPE GLYPHMETRICS = RECORD
                           gmBlackBoxX     : UINT;
                           gmBlackBoxY     : UINT;
                           gmptGlyphOrigin : POINT;
                           gmCellIncX      : SHORT;
                           gmCellIncY      : SHORT;
                    END;
    PGLYPHMETRICS = POINTER TO GLYPHMETRICS;

(* GetGlyphOutline constants *)

TYPE GGO_ENUM = (GGO_METRICS,       (* 0 *)
                 GGO_BITMAP,        (* 1 *)
                 GGO_NATIVE,        (* 2 *)
                 GGO_3,
                 GGO_GRAY2_BITMAP,  (* 4 *)
                 GGO_GRAY4_BITMAP,  (* 5 *)
                 GGO_GRAY8_BITMAP); (* 6 *)

CONST GGO_GLYPH_INDEX = 080H;

CONST TT_POLYGON_TYPE = 24;

<* PUSH *> <* ENUMSIZE = "2" *>

TYPE TT_PRIM_ENUM = (TT_PRIM_0,
                     TT_PRIM_LINE,     (* 1 *)
                     TT_PRIM_QSPLINE); (* 2 *)

<* POP *>

TYPE POINTFX = RECORD
                      x : FIXED;
                      y : FIXED;
               END;
     PPOINTFX = POINTER  TO POINTFX;

TYPE TTPOLYCURVE = RECORD
                          wType : TT_PRIM_ENUM;
                          cpfx : WORD;
                          apfx : ARRAY [0..0] OF POINTFX;
                   END;

TYPE TTPOLYGONHEADER = RECORD
                              cb : DWORD;
                              dwType : DWORD;      (* must be TT_POLYGON_TYPE *)
                              pfxStart : POINTFX;
                       END;

TYPE GCP_ENUM = (GCP__DBCS,            (* 0 *)
                 GCP__REORDER,         (* 1 *)
                 GCO__2,
                 GCP__USEKERNING,      (* 3 *)
                 GCP__GLYPHSHAPE,      (* 4 *)
                 GCP__LIGATE,          (* 5 *)
                 GCP__6,
                 GCP__GLYPHINDEXING,   (* 7 *)
                 GCP__DIACRITIC,       (* 8 *)
                 GCP__9,
                 GCP__KASHIDA,         (* 10 *)
                 GCP__11, GCP__12,
                 GCP__13, GCP__14,
                 GCP__ERROR,           (* 15 *)

                 GCP__JUSTIFY,         (* 16 *)
                 GCP__NODIACRITICS,    (* 17 *)
                 FLI__GLYPHS,          (* 18 *)
                 GCP__CLASSIN,         (* 19 *)
                 GCP__MAXEXTENT,       (* 20 *)
                 GCP__JUSTIFYIN,       (* 21 *)
                 GCP__DISPLAYZWG,      (* 22 *)
                 GCP__SYMSWAPOFF,      (* 23 *)
                 GCP__NUMERICOVERRIDE, (* 24 *)
                 GCP__NEUTRALOVERRIDE, (* 25 *)
                 GCP__NUMERICSLATIN,   (* 26 *)
                 GCP__NUMERICSLOCAL);  (* 27 *)

     GCP_SET = SET OF GCP_ENUM;

CONST GCP_DBCS            = GCP_SET {GCP__DBCS};            (* 0x0001 *)
      GCP_REORDER         = GCP_SET {GCP__REORDER};         (* 0x0002 *)
      GCP_USEKERNING      = GCP_SET {GCP__USEKERNING};      (* 0x0008 *)
      GCP_GLYPHSHAPE      = GCP_SET {GCP__GLYPHSHAPE};      (* 0x0010 *)
      GCP_LIGATE          = GCP_SET {GCP__LIGATE};          (* 0x0020 *)
      GCP_GLYPHINDEXING   = GCP_SET {GCP__GLYPHINDEXING};   (* 0x0080 *)
      GCP_DIACRITIC       = GCP_SET {GCP__DIACRITIC};       (* 0x0100 *)
      GCP_KASHIDA         = GCP_SET {GCP__KASHIDA};         (* 0x0400 *)
      GCP_ERROR           = GCP_SET {GCP__ERROR};           (* 0x8000 *)

      FLI_MASK            = GCP_SET {GCP__12,
                                     GCP__LIGATE,
                                     GCP__GLYPHSHAPE,
                                     GCP__USEKERNING,
                                     GCP__REORDER,
                                     GCP__DBCS};            (* 0x103B *)

      GCP_JUSTIFY         = GCP_SET {GCP__JUSTIFY};         (* 0x00010000L *)
      GCP_NODIACRITICS    = GCP_SET {GCP__NODIACRITICS};    (* 0x00020000L *)
      FLI_GLYPHS          = GCP_SET {FLI__GLYPHS};          (* 0x00040000L *)
      GCP_CLASSIN         = GCP_SET {GCP__CLASSIN};         (* 0x00080000L *)
      GCP_MAXEXTENT       = GCP_SET {GCP__MAXEXTENT};       (* 0x00100000L *)
      GCP_JUSTIFYIN       = GCP_SET {GCP__JUSTIFYIN};       (* 0x00200000L *)
      GCP_DISPLAYZWG      = GCP_SET {GCP__DISPLAYZWG};      (* 0x00400000L *)
      GCP_SYMSWAPOFF      = GCP_SET {GCP__SYMSWAPOFF};      (* 0x00800000L *)
      GCP_NUMERICOVERRIDE = GCP_SET {GCP__NUMERICOVERRIDE}; (* 0x01000000L *)
      GCP_NEUTRALOVERRIDE = GCP_SET {GCP__NEUTRALOVERRIDE}; (* 0x02000000L *)
      GCP_NUMERICSLATIN   = GCP_SET {GCP__NUMERICSLATIN};   (* 0x04000000L *)
      GCP_NUMERICSLOCAL   = GCP_SET {GCP__NUMERICSLOCAL};   (* 0x08000000L *)


CONST GCPCLASS_LATIN                  =  1;
      GCPCLASS_HEBREW                 =  2;
      GCPCLASS_ARABIC                 =  2;
      GCPCLASS_NEUTRAL                =  3;
      GCPCLASS_LOCALNUMBER            =  4;
      GCPCLASS_LATINNUMBER            =  5;
      GCPCLASS_LATINNUMERICTERMINATOR =  6;
      GCPCLASS_LATINNUMERICSEPARATOR  =  7;
      GCPCLASS_NUMERICSEPARATOR       =  8;
      GCPCLASS_PREBOUNDLTR            = 80h;
      GCPCLASS_PREBOUNDRTL            = 40h;
      GCPCLASS_POSTBOUNDLTR           = 20h;
      GCPCLASS_POSTBOUNDRTL           = 10h;

CONST GCPGLYPH_LINKBEFORE = 8000h;
      GCPGLYPH_LINKAFTER  = 4000h;

TYPE GCP_RESULTSA = RECORD
                           lStructSize      : DWORD;
                           lpOutString      : PSTR;
                           lpOrder          : UINT;
                           lpDx             : INTARRAY;
                           lpCaretPos       : INTARRAY;
                           lpClass          : PSTR;
                           lpGlyphs         : PWSTR;
                           nGlyphs          : UINT;
                           nMaxFit          : INTEGER;
                    END;
    PGCP_RESULTSA = POINTER TO GCP_RESULTSA;

     GCP_RESULTSW = RECORD
                           lStructSize      : DWORD;
                           lpOutString      : PWSTR;
                           lpOrder          : UINT;
                           lpDx             : INTARRAY;
                           lpCaretPos       : INTARRAY;
                           lpClass          : PSTR;
                           lpGlyphs         : PWSTR;
                           nGlyphs          : UINT;
                           nMaxFit          : INTEGER;
                    END;
    PGCP_RESULTSW = POINTER TO GCP_RESULTSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE GCP_RESULTS = GCP_RESULTSW;
           PGCP_RESULTS = PGCP_RESULTSW;
<* ELSE *>
      TYPE GCP_RESULTS  = GCP_RESULTSA;
           PGCP_RESULTS = PGCP_RESULTSA;
<* END *>

(* bits defined in wFlags of RASTERIZER_STATUS *)

<* PUSH *> <* SETSIZE = "2" *>

TYPE TT_RASTERIZER_ENUM = (TT__AVAILABLE, (* 0 *)
                           TT__ENABLED);  (* 1 *)

     TT_RASTERIZER_SET = SET OF TT_RASTERIZER_ENUM;

<* POP *>

CONST TT_AVAILABLE = TT_RASTERIZER_SET {TT__AVAILABLE};  (* 0x0001 *)
      TT_ENABLED   = TT_RASTERIZER_SET {TT__ENABLED};    (* 0x0002 *)

TYPE RASTERIZER_STATUS = RECORD
                                nSize       : SHORT;
                                wFlags      : TT_RASTERIZER_SET;
                                nLanguageID : SHORT;
                         END;

(* Pixel format descriptor *)

(* PIXELFORMATDESCRIPTOR flags *)

TYPE PFD_ENUM = (PFD__DOUBLEBUFFER,          (*  0 *)
                 PFD__STEREO,                (*  1 *)
                 PFD__DRAW_TO_WINDOW,        (*  2 *)
                 PFD__DRAW_TO_BITMAP,        (*  3 *)
                 PFD__SUPPORT_GDI,           (*  4 *)
                 PFD__SUPPORT_OPENGL,        (*  5 *)
                 PFD__GENERIC_FORMAT,        (*  6 *)
                 PFD__NEED_PALETTE,          (*  7 *)
                 PFD__NEED_SYSTEM_PALETTE,   (*  8 *)
                 PFD__SWAP_EXCHANGE,         (*  9 *)
                 PFD__SWAP_COPY,             (* 10 *)
                 PFD__SWAP_LAYER_BUFFERS,    (* 11 *)
                 PFD__GENERIC_ACCELERATED,   (* 12 *)
                 PFD__13,PFD__14,PFD__15,
                 PFD__16,PFD__17,PFD__18,
                 PFD__19,PFD__20,PFD__21,
                 PFD__22,PFD__23,PFD__24,
                 PFD__25,PFD__26,PFD__27,
                 PFD__28,
                 PFD__DEPTH_DONTCARE,        (* 29 *)
                 PFD__DOUBLEBUFFER_DONTCARE, (* 30 *)
                 PFD__STEREO_DONTCARE);      (* 31 *)
     PFD_SET = SET OF PFD_ENUM;

CONST PFD_DOUBLEBUFFER        = PFD_SET {PFD__DOUBLEBUFFER       }; (* 0x00000001 *)
      PFD_STEREO              = PFD_SET {PFD__STEREO             }; (* 0x00000002 *)
      PFD_DRAW_TO_WINDOW      = PFD_SET {PFD__DRAW_TO_WINDOW     }; (* 0x00000004 *)
      PFD_DRAW_TO_BITMAP      = PFD_SET {PFD__DRAW_TO_BITMAP     }; (* 0x00000008 *)
      PFD_SUPPORT_GDI         = PFD_SET {PFD__SUPPORT_GDI        }; (* 0x00000010 *)
      PFD_SUPPORT_OPENGL      = PFD_SET {PFD__SUPPORT_OPENGL     }; (* 0x00000020 *)
      PFD_GENERIC_FORMAT      = PFD_SET {PFD__GENERIC_FORMAT     }; (* 0x00000040 *)
      PFD_NEED_PALETTE        = PFD_SET {PFD__NEED_PALETTE       }; (* 0x00000080 *)
      PFD_NEED_SYSTEM_PALETTE = PFD_SET {PFD__NEED_SYSTEM_PALETTE}; (* 0x00000100 *)
      PFD_SWAP_EXCHANGE       = PFD_SET {PFD__SWAP_EXCHANGE      }; (* 0x00000200 *)
      PFD_SWAP_COPY           = PFD_SET {PFD__SWAP_COPY          }; (* 0x00000400 *)
      PFD_SWAP_LAYER_BUFFERS  = PFD_SET {PFD__SWAP_LAYER_BUFFERS }; (* 0x00000800 *)
      PFD_GENERIC_ACCELERATED = PFD_SET {PFD__GENERIC_ACCELERATED}; (* 0x00001000 *)

(* PIXELFORMATDESCRIPTOR flags for use in ChoosePixelFormat only *)

      PFD_DEPTH_DONTCARE        = PFD_SET {PFD__DEPTH_DONTCARE       }; (* 0x20000000 *)
      PFD_DOUBLEBUFFER_DONTCARE = PFD_SET {PFD__DOUBLEBUFFER_DONTCARE}; (* 0x40000000 *)
      PFD_STEREO_DONTCARE       = PFD_SET {PFD__STEREO_DONTCARE      }; (* 0x80000000 *)

(* pixel types *)

<* PUSH *> <* ENUMSIZE = "1" *>

TYPE PFD_TYPE_ENUM = (PFD_TYPE_RGBA,        (* 0 *)
                      PFD_TYPE_COLORINDEX); (* 1 *)

<* POP *>

(* layer types *)

TYPE PFD_LAYER_TYPE = INT8;

CONST PFD_MAIN_PLANE       = PFD_LAYER_TYPE ( 0);
      PFD_OVERLAY_PLANE    = PFD_LAYER_TYPE ( 1);
      PFD_UNDERLAY_PLANE   = PFD_LAYER_TYPE (-1);

TYPE PIXELFORMATDESCRIPTOR = RECORD
         nSize           :     WORD;
         nVersion        :     WORD;
         dwFlags         :     PFD_SET;
         iPixelType      :     PFD_TYPE_ENUM;
         cColorBits      :     BYTE;
         cRedBits        :     BYTE;
         cRedShift       :     BYTE;
         cGreenBits      :     BYTE;
         cGreenShift     :     BYTE;
         cBlueBits       :     BYTE;
         cBlueShift      :     BYTE;
         cAlphaBits      :     BYTE;
         cAlphaShift     :     BYTE;
         cAccumBits      :     BYTE;
         cAccumRedBits   :     BYTE;
         cAccumGreenBits :     BYTE;
         cAccumBlueBits  :     BYTE;
         cAccumAlphaBits :     BYTE;
         cDepthBits      :     BYTE;
         cStencilBits    :     BYTE;
         cAuxBuffers     :     BYTE;
         iLayerType      :     PFD_LAYER_TYPE;
         bReserved       :     BYTE;
         dwLayerMask     :     DWORD;
         dwVisibleMask   :     DWORD;
         dwDamageMask    :     DWORD;
     END;

   PPIXELFORMATDESCRIPTOR = POINTER TO PIXELFORMATDESCRIPTOR;

TYPE OLDFONTENUMPROCA = PROCEDURE ((* IN *) PLOGFONTA, (* IN *) PTEXTMETRICA,
                                  ENUMFONT_SET, LPARAM) : INTEGER;

TYPE OLDFONTENUMPROCW = PROCEDURE ((* IN *) PLOGFONTW, (* IN *) PTEXTMETRICW,
                                  ENUMFONT_SET, LPARAM) : INTEGER;

TYPE FONTENUMPROCA = OLDFONTENUMPROCA;
TYPE FONTENUMPROCW = OLDFONTENUMPROCW;

TYPE ENUMFONTFAMEXPROCA = PROCEDURE (PENUMLOGFONTEXA, PNEWTEXTMETRICEXA,
                                     DWORD, LPARAM) : INTEGER;

TYPE ENUMFONTFAMEXPROCW = PROCEDURE (PENUMLOGFONTEXW, PNEWTEXTMETRICEXW,
                                     DWORD, LPARAM) : INTEGER;


<* IF DEFINED (UNICODE) THEN *>
       TYPE OLDFONTENUMPROC = OLDFONTENUMPROCW;
            FONTENUMPROC    = FONTENUMPROCW;
<* ELSE *>
       TYPE OLDFONTENUMPROC = OLDFONTENUMPROCA;
            FONTENUMPROC    = FONTENUMPROCA;
<* END *>

TYPE GOBJENUMPROC = PROCEDURE (PVOID, LPARAM) : INTEGER;

TYPE LINEDDAPROC  = PROCEDURE (INTEGER, INTEGER, LPARAM);

PROCEDURE AddFontResourceA (FileName : ARRAY OF CHAR)  : INTEGER;
PROCEDURE AddFontResourceW (FileName : ARRAY OF WCHAR) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST AddFontResource = AddFontResourceW;
<* ELSE *>
      CONST AddFontResource = AddFontResourceA;
<* END *>

PROCEDURE AnimatePalette (hpal : HPALETTE;
                          StartIndex, Entries : UINT;
                          pc : ARRAY OF PALETTEENTRY) : BOOL;

PROCEDURE Arc (hdc : HDC; left, top, right, bottom : INTEGER;
               XStart, YStart, XEnd, YEnd : INTEGER) : BOOL;

PROCEDURE BitBlt (hdcDest : HDC; XDest, YDest, Width, Height : INTEGER;
                  hdcSrc  : HDC; XSrc, YSrc : INTEGER;
                  operation : ROP) : BOOL;

PROCEDURE CancelDC (hdc : HDC) : BOOL;
PROCEDURE Chord (hdc : HDC; left, top, right, bottom : INTEGER;
                 XRadial1, YRadial1, XRadial2, YRadial2 : INTEGER) : BOOL;

<* IF BACKEND # "C" THEN *>
PROCEDURE ChoosePixelFormat (hdc : HDC; pf : PIXELFORMATDESCRIPTOR) : INTEGER;
<* ELSE *>
PROCEDURE ChoosePixelFormat (hdc : HDC; pf : PPIXELFORMATDESCRIPTOR) : INTEGER;
<* END *> (*!*)
PROCEDURE CloseMetaFile (hdc : HDC) : HMETAFILE;
PROCEDURE CombineRgn (hRgnDest : HRGN; hRgnSrc1 : HRGN;
                      hRgnSrc2 : HRGN; CombineMode : RGN_COMBINE_ENUM) : RGN_CODE;

PROCEDURE CopyMetaFileA (hmf : HMETAFILE; fname : PCSTR) : HMETAFILE;
PROCEDURE CopyMetaFileW (hmf : HMETAFILE; fname : PCWSTR) : HMETAFILE;

<* IF DEFINED (UNICODE) THEN *>
      CONST CopyMetaFile   = CopyMetaFileW;
<* ELSE *>
      CONST CopyMetaFile   = CopyMetaFileA;
<* END *>

PROCEDURE CreateBitmap (Width, Height : INTEGER;
                        Planes, BitsPerPel : UINT;
                        Bits : ARRAY OF SYSTEM.BYTE) : HBITMAP;
<* IF BACKEND # "C" THEN *>
PROCEDURE CreateBitmapIndirect    (Bitmap : BITMAP) : HBITMAP;
<* ELSE *>
PROCEDURE CreateBitmapIndirect    (Bitmap : PBITMAP) : HBITMAP;
<* END *> (*!*)
<* IF BACKEND # "C" THEN *>
PROCEDURE CreateBrushIndirect     (Brush : LOGBRUSH) : HBRUSH;
<* ELSE *>
PROCEDURE CreateBrushIndirect     (Brush : PLOGBRUSH) : HBRUSH;
<* END *> (*!*)
PROCEDURE CreateCompatibleBitmap  (hdc : HDC; Width, Height : INTEGER) : HBITMAP;
PROCEDURE CreateDiscardableBitmap (hdc : HDC; Width, Height : INTEGER) : HBITMAP;
PROCEDURE CreateCompatibleDC      (hdc : HDC) : HDC;

PROCEDURE CreateDCA (Driver : PCSTR;
                     Device : PCSTR;
                     Output : PCSTR;
                     InitData : PDEVMODEA) : HDC;  (* InitData can be NIL *)

PROCEDURE CreateDCW (Driver : PCWSTR;
                     Device : PCWSTR;
                     Output : PCWSTR;
                     InitData : PDEVMODEW) : HDC;  (* InitData can be NIL *)

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateDC = CreateDCW;
<* ELSE *>
      CONST CreateDC = CreateDCA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE CreateDIBitmap (hdc      : HDC;
                          bmih     : BITMAPINFOHEADER;
                          dwInit   : CBM_ENUM;
                          Init     : ARRAY OF SYSTEM.BYTE;
                          bmi      : BITMAPINFOPARAM;
                          ColorUse : DIB_COLOR_ENUM) : HBITMAP;
<* ELSE *>
PROCEDURE CreateDIBitmap (hdc      : HDC;
                          bmih     : PBITMAPINFOHEADER;
                          dwInit   : CBM_ENUM;
                          Init     : ARRAY OF SYSTEM.BYTE;
                          bmi      : PBITMAPINFOPARAM;
                          ColorUse : DIB_COLOR_ENUM) : HBITMAP;
<* END *> (*!*)

PROCEDURE CreateDIBPatternBrush (hglbPackedDIB : HGLOBAL;
                                 ColorSpec : DIB_COLOR_ENUM) : HBRUSH;
PROCEDURE CreateDIBPatternBrushPt (PackedDIB : ARRAY OF SYSTEM.BYTE;
                                   ColorUse : DIB_COLOR_ENUM) : HBRUSH;
PROCEDURE CreateEllipticRgn (LeftRect, TopRect,
                             RightRect, BottomRect : INTEGER) : HRGN;
<* IF BACKEND # "C" THEN *>
PROCEDURE CreateEllipticRgnIndirect (rc : RECT) : HRGN;
<* ELSE *>
PROCEDURE CreateEllipticRgnIndirect (rc : PRECT) : HRGN;
<* END *> (*!*)

<* IF BACKEND # "C" THEN *>
PROCEDURE CreateFontIndirectA (logfont : LOGFONTA) : HFONT;
<* ELSE *>
PROCEDURE CreateFontIndirectA (logfont : PLOGFONTA) : HFONT;
<* END *> (*!*)
<* IF BACKEND # "C" THEN *>
PROCEDURE CreateFontIndirectW (logfont : LOGFONTW) : HFONT;
<* ELSE *>
PROCEDURE CreateFontIndirectW (logfont : PLOGFONTW) : HFONT;
<* END *> (*!*)

PROCEDURE CreateFontA (Height, Width   : INTEGER;
                       Escapement      : INTEGER;
                       Orientation     : INTEGER;
                       Weight          : FW_TYPE;
                       Italic          : BOOL;
                       Underline       : BOOL;
                       StrikeOut       : BOOL;
                       CharSet         : CHARSET_TYPE;
                       OutputPrecision : OUT_PRECIS_ENUM;
                       ClipPrecision   : CLIP_PRECIS_SET;
                       Quality         : QUALITY_ENUM;
                       PitchAndFamily  : PITCH_AND_FAMILY_SET;
                       FaceName        : PCSTR) : HFONT;

PROCEDURE CreateFontW (Height, Width   : INTEGER;
                       Escapement      : INTEGER;
                       Orientation     : INTEGER;
                       Weight          : FW_TYPE;
                       Italic          : BOOL;
                       Underline       : BOOL;
                       StrikeOut       : BOOL;
                       CharSet         : CHARSET_TYPE;
                       OutputPrecision : OUT_PRECIS_ENUM;
                       ClipPrecision   : CLIP_PRECIS_SET;
                       Quality         : QUALITY_ENUM;
                       PitchAndFamily  : PITCH_AND_FAMILY_SET;
                       FaceName        : PCWSTR) : HFONT;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateFontIndirect = CreateFontIndirectW;
            CreateFont = CreateFontW;
<* ELSE *>
      CONST CreateFontIndirect = CreateFontIndirectA;
            CreateFont = CreateFontA;
<* END *>

PROCEDURE CreateHatchBrush   (Style : HS_ENUM; Color : COLORREF) : HBRUSH;

PROCEDURE CreateICA (Driver : PCSTR;
                     Device : ARRAY OF CHAR;
                     Output : PCSTR;
         (* IN NIL*) InitData : PDEVMODEA) : HDC;

PROCEDURE CreateICW (Driver : PCSTR;
                     Device : ARRAY OF WCHAR;
                     Output : PCSTR;
        (* IN NIL *) InitData : PDEVMODEW) : HDC;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateIC = CreateICW;
<* ELSE *>
      CONST CreateIC = CreateICA;
<* END *>

PROCEDURE CreateMetaFileA (fname : PCSTR) : HDC;  (* fname can be NIL *)
PROCEDURE CreateMetaFileW (fname : PCWSTR) : HDC; (* fname can be NIL *)

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateMetaFile = CreateMetaFileW;
<* ELSE *>
      CONST CreateMetaFile = CreateMetaFileA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE CreatePalette (palette : LOGPALETTE) : HPALETTE;
<* ELSE *>
PROCEDURE CreatePalette (palette : PLOGPALETTE) : HPALETTE;
<* END *> (*!*)
PROCEDURE CreatePen (PenStyle : PS_SET;
                     Width : INTEGER;
                     Color : COLORREF) : HPEN;
<* IF BACKEND # "C" THEN *>
PROCEDURE CreatePenIndirect (lgpn : LOGPEN) : HPEN;
<* ELSE *>
PROCEDURE CreatePenIndirect (lgpn : PLOGPEN) : HPEN;
<* END *> (*!*)
PROCEDURE CreatePolyPolygonRgn (pt : ARRAY OF POINT;
                                PolyCounts : ARRAY OF INTEGER;
                                nCount : INTEGER;
                                PolyFillMode : POLYFILL_ENUM) : HRGN;

PROCEDURE CreatePatternBrush (bitmap : HBITMAP) : HBRUSH;
PROCEDURE CreateRectRgn (LeftRect, TopRect,
                         RightRect, BottomRect : INTEGER) : HRGN;
<* IF BACKEND # "C" THEN *>
PROCEDURE CreateRectRgnIndirect (rc : RECT) : HRGN;
<* ELSE *>
PROCEDURE CreateRectRgnIndirect (rc : PRECT) : HRGN;
<* END *> (*!*)
PROCEDURE CreateRoundRectRgn (LeftRect, TopRect,
                              RightRect, BottomRect,
                              WidthEllipse, HeightEllipse : INTEGER) : HRGN;

PROCEDURE CreateScalableFontResourceA (Hidden      : BOOL;
                                       FontRes     : ARRAY OF CHAR;
                                       FontFile    : ARRAY OF CHAR;
                             (* NIL *) CurrentPath : PSTR) : BOOL;
PROCEDURE CreateScalableFontResourceW (Hidden      : BOOL;
                                       FontRes     : ARRAY OF CHAR;
                                       FontFile    : ARRAY OF WCHAR;
                             (* NIL *) CurrentPath : PCWSTR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateScalableFontResource = CreateScalableFontResourceW;
<* ELSE *>
      CONST CreateScalableFontResource = CreateScalableFontResourceA;
<* END *>

PROCEDURE CreateSolidBrush   (Color : COLORREF) : HBRUSH;

PROCEDURE DeleteDC (hdc : HDC) : BOOL;
PROCEDURE DeleteMetaFile (mf : HMETAFILE) : BOOL;
PROCEDURE DeleteObject (hGdiObj : HGDIOBJ) : BOOL;
PROCEDURE DescribePixelFormat (hdc : HDC;
                               pixelformat : INTEGER;
                               size : UINT;
                               VAR [NIL] buffer : PIXELFORMATDESCRIPTOR) : INTEGER;

(* define types of pointers to ExtDeviceMode() and DeviceCapabilities()
 * functions for Win 3.1 compatibility
 *)

TYPE PFNDEVMODE = PROCEDURE (HWND, HMODULE, PDEVMODE, PSTR, PSTR, PDEVMODE, PSTR, UINT) : UINT;

TYPE PFNDEVCAPS = PROCEDURE (PSTR, PSTR, UINT, PSTR, PDEVMODE) : DWORD;

(* mode selections for the device mode function *)

TYPE _DM_ENUM = (DM__UPDATE,   (* 1 *)
                 DM__COPY,     (* 2 *)
                 DM__PROMPT,   (* 4 *)
                 DM__MODIFY);  (* 8 *)
     _DM_SET = SET OF _DM_ENUM;

CONST DM_UPDATE = _DM_SET {DM__UPDATE}; (* 1 *)
      DM_COPY   = _DM_SET {DM__COPY};   (* 2 *)
      DM_PROMPT = _DM_SET {DM__PROMPT}; (* 4 *)
      DM_MODIFY = _DM_SET {DM__MODIFY}; (* 8 *)

      DM_IN_BUFFER   = DM_MODIFY;
      DM_IN_PROMPT   = DM_PROMPT;
      DM_OUT_BUFFER  = DM_COPY;
      DM_OUT_DEFAULT = DM_UPDATE;

(* device capabilities indices *)

TYPE DC_TYPE = (DC_0,
                DC_FIELDS,            (*  1 *)
                DC_PAPERS,            (*  2 *)
                DC_PAPERSIZE,         (*  3 *)
                DC_MINEXTENT,         (*  4 *)
                DC_MAXEXTENT,         (*  5 *)
                DC_BINS,              (*  6 *)
                DC_DUPLEX,            (*  7 *)
                DC_SIZE,              (*  8 *)
                DC_EXTRA,             (*  9 *)
                DC_VERSION,           (* 10 *)
                DC_DRIVER,            (* 11 *)
                DC_BINNAMES,          (* 12 *)
                DC_ENUMRESOLUTIONS,   (* 13 *)
                DC_FILEDEPENDENCIES,  (* 14 *)
                DC_TRUETYPE,          (* 15 *)
                DC_PAPERNAMES,        (* 16 *)
                DC_ORIENTATION,       (* 17 *)
                DC_COPIES,            (* 18 *)
                DC_BINADJUST,         (* 19 *)
                DC_EMF_COMPLIANT,     (* 20 *)
                DC_DATATYPE_PRODUCED, (* 21 *)
                DC_COLLATE,           (* 22 *)
                DC_MANUFACTURER,      (* 23 *)
                DC_MODEL);            (* 24 *)

(* bit fields of the return value (DWORD) for DC_TRUETYPE *)

TYPE DCTT_ENUM = (DCTT__BITMAP,             (* 0 *)
                  DCTT__DOWNLOAD,           (* 1 *)
                  DCTT__SUBDEV,             (* 2 *)
                  DCTT__DOWNLOAD_OUTLINE);  (* 3 *)
     DCTT_SET  = SET OF DCTT_ENUM;

CONST DCTT_BITMAP           = DCTT_SET {DCTT__BITMAP};           (* 0x0000001L *)
      DCTT_DOWNLOAD         = DCTT_SET {DCTT__DOWNLOAD};         (* 0x0000002L *)
      DCTT_SUBDEV           = DCTT_SET {DCTT__SUBDEV};           (* 0x0000004L *)
      DCTT_DOWNLOAD_OUTLINE = DCTT_SET {DCTT__DOWNLOAD_OUTLINE}; (* 0x0000008L *)


(* return values for DC_BINADJUST *)

CONST DCBA_FACEUPNONE       = 0000h;
      DCBA_FACEUPCENTER     = 0001h;
      DCBA_FACEUPLEFT       = 0002h;
      DCBA_FACEUPRIGHT      = 0003h;
      DCBA_FACEDOWNNONE     = 0100h;
      DCBA_FACEDOWNCENTER   = 0101h;
      DCBA_FACEDOWNLEFT     = 0102h;
      DCBA_FACEDOWNRIGHT    = 0103h;

PROCEDURE DeviceCapabilitiesA (DriverName : ARRAY OF CHAR;
                               PortDeviceName : ARRAY OF CHAR;
                               Capability : DC_TYPE;
                               Output : PSTR;
                  (* IN NIL *) dev : PDEVMODEA) : INTEGER;
PROCEDURE DeviceCapabilitiesW (DriverName : ARRAY OF WCHAR;
                               PortDeviceName : ARRAY OF WCHAR;
                               Capability : DC_TYPE;
                               Output : PWSTR;
                  (* IN NIL *) dev : PDEVMODEW) : INTEGER;

<* IF DEFINED (UNICODE) THEN*>
   CONST DeviceCapabilities = DeviceCapabilitiesW;
<* ELSE *>
   CONST DeviceCapabilities = DeviceCapabilitiesA;
<* END *>

PROCEDURE DrawEscape (hdc : HDC; Escape : INTEGER;
                      InputSize : INTEGER;
                      input : PCBYTE) : INTEGER;

PROCEDURE Ellipse (hdc : HDC; left, top, right, bottom : INTEGER) : BOOL;

<* IF BACKEND # "C" THEN *>
PROCEDURE EnumFontFamiliesExA (hdc    : HDC;
                               lf     : LOGFONTA;
                               proc   : ENUMFONTFAMEXPROCA;
                               lparam : LPARAM;
                               flags  : DWORD) : INTEGER;
<* ELSE *>
PROCEDURE EnumFontFamiliesExA (hdc    : HDC;
                               lf     : PLOGFONTA;
                               proc   : ENUMFONTFAMEXPROCA;
                               lparam : LPARAM;
                               flags  : DWORD) : INTEGER;
<* END *> (*!*)
<* IF BACKEND # "C" THEN *>
PROCEDURE EnumFontFamiliesExW (hdc    : HDC;
                               lf     : LOGFONTW;
                               proc   : ENUMFONTFAMEXPROCW;
                               lparam : LPARAM;
                               flags  : DWORD) : INTEGER;
<* ELSE *>
PROCEDURE EnumFontFamiliesExW (hdc    : HDC;
                               lf     : PLOGFONTW;
                               proc   : ENUMFONTFAMEXPROCW;
                               lparam : LPARAM;
                               flags  : DWORD) : INTEGER;
<* END *> (*!*)

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumFontFamiliesEx = EnumFontFamiliesExW;
<* ELSE *>
      CONST EnumFontFamiliesEx = EnumFontFamiliesExA;
<* END *>

PROCEDURE EnumFontFamiliesA (hdc : HDC;
                             Family : PCSTR;
                             EnumFontFamProc : FONTENUMPROCA;
                             lParam : LPARAM) : INTEGER;

PROCEDURE EnumFontFamiliesW (hdc : HDC;
                             Family : PCWSTR;
                             EnumFontFamProc : FONTENUMPROCW;
                             lParam : LPARAM) : INTEGER;

PROCEDURE EnumFontsA (hdc : HDC;
                      FaceName : PCSTR;
                      EnumFontProc : FONTENUMPROCA;
                      lParam : LPARAM) : INTEGER;

PROCEDURE EnumFontsW (hdc : HDC;
                      FaceName : PCWSTR;
                      EnumFontProc : FONTENUMPROCW;
                      lParam : LPARAM) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumFontFamilies = EnumFontFamiliesW;
            EnumFonts        = EnumFontsW;
<* ELSE *>
      CONST EnumFontFamilies = EnumFontFamiliesA;
            EnumFonts        = EnumFontsA;
<* END *>

PROCEDURE EnumObjects (hdc : HDC;
                       ObjectType : OBJ_ENUM;
                       ObjectFunc : GOBJENUMPROC;
                       lParam : LPARAM) : INTEGER;

PROCEDURE EqualRgn (hRgn1 : HRGN; hRgn2 : HRGN) : BOOL;
PROCEDURE Escape (hdc : HDC; Escape : INTEGER; InputSize : INTEGER;
                  input : PCBYTE; output : PBYTE) : INTEGER;
PROCEDURE ExtEscape (hdc : HDC; Escape : INTEGER;
                     InputSize : INTEGER; input : PCBYTE;
                     OutputSize : INTEGER; output : PBYTE) : INTEGER;
PROCEDURE ExcludeClipRect (hdc : HDC; left, top, right, bottom : INTEGER) : RGN_CODE;
<* IF BACKEND # "C" THEN *>
PROCEDURE ExtCreateRegion ((* IN NIL *) Xform : PXFORM;
                           nCount : DWORD;
                           RgnData : RGNDATA) : HRGN;
<* ELSE *>
PROCEDURE ExtCreateRegion ((* IN NIL *) Xform : PXFORM;
                           nCount : DWORD;
                           RgnData : PRGNDATA) : HRGN;
<* END *> (*!*)
PROCEDURE ExtFloodFill (hdc : HDC; x, y : INTEGER; color : COLORREF;
                        mode : FLOODFILL_ENUM) : BOOL;
PROCEDURE FillRgn (hdc : HDC; hrgn : HRGN; hbrush : HBRUSH) : BOOL;
PROCEDURE FloodFill (hdc : HDC; x, y : INTEGER; color : COLORREF) : BOOL;
PROCEDURE FrameRgn  (hdc : HDC; hrgn : HRGN; hbrush : HBRUSH;
                     width, height : INTEGER) : BOOL;
PROCEDURE GetROP2 (hdc : HDC) : ROP2;
PROCEDURE GetAspectRatioFilterEx (hdc : HDC; VAR AspectRatio : SIZEL) : BOOL;
PROCEDURE GetBkColor (hdc : HDC) : COLORREF;
PROCEDURE GetBkMode (hdc : HDC) : BKMODE_ENUM;
PROCEDURE GetBitmapBits (hbmp : HBITMAP;
                         BufSize : LONG;
                         VAR Bits : ARRAY OF SYSTEM.BYTE) : LONG;
PROCEDURE GetBitmapDimensionEx (hbmp : HBITMAP; VAR Dimension : SIZEL) : BOOL;
PROCEDURE GetBoundsRect (hdc : HDC; VAR rect : RECT; flags : DCB__SET) : DCB__SET;
PROCEDURE GetBrushOrgEx (dc : HDC; VAR p : POINT) : BOOL;

PROCEDURE GetCharWidthA (hdc : HDC; FirstChar, LastChar : UINT;
                         VAR Buffer : ARRAY OF INTEGER) : BOOL;
PROCEDURE GetCharWidthW (hdc : HDC; FirstChar, LastChar : UINT;
                         VAR Buffer : ARRAY OF INTEGER) : BOOL;

PROCEDURE GetCharWidth32A (hdc : HDC; FirstChar, LastChar : UINT;
                           VAR Buffer : ARRAY OF INTEGER) : BOOL;
PROCEDURE GetCharWidth32W (hdc : HDC; FirstChar, LastChar : UINT;
                           VAR Buffer : ARRAY OF INTEGER) : BOOL;

PROCEDURE GetCharWidthFloatA (hdc : HDC; FirstChar, LastChar : UINT;
                              VAR Buffer : ARRAY OF FLOAT) : BOOL;
PROCEDURE GetCharWidthFloatW (hdc : HDC; FirstChar, LastChar : UINT;
                              VAR Buffer : ARRAY OF FLOAT) : BOOL;

PROCEDURE GetCharABCWidthsA (hdc : HDC; FirstChar, LastChar : UINT;
                             VAR abc : ARRAY OF ABC) : BOOL;
PROCEDURE GetCharABCWidthsW (hdc : HDC; FirstChar, LastChar : UINT;
                             VAR abc : ARRAY OF ABC) : BOOL;

PROCEDURE GetCharABCWidthsFloatA (hdc : HDC; FirstChar, LastChar : UINT;
                                  VAR abcflt : ARRAY OF ABCFLOAT) : BOOL;
PROCEDURE GetCharABCWidthsFloatW (hdc : HDC; FirstChar, LastChar : UINT;
                                  VAR abcflt : ARRAY OF ABCFLOAT) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetCharWidth          = GetCharWidthW;
            GetCharWidth32        = GetCharWidth32W;
            GetCharWidthFloat     = GetCharWidthFloatW;
            GetCharABCWidths      = GetCharABCWidthsW;
            GetCharABCWidthsFloat = GetCharABCWidthsFloatW;
<* ELSE *>
      CONST GetCharWidth          = GetCharWidthA;
            GetCharWidth32        = GetCharWidth32A;
            GetCharWidthFloat     = GetCharWidthFloatA;
            GetCharABCWidths      = GetCharABCWidthsA;
            GetCharABCWidthsFloat = GetCharABCWidthsFloatA;
<* END *>

PROCEDURE GetClipBox (hdc : HDC; VAR rc : RECT) : RGN_CODE;
PROCEDURE GetClipRgn (hdc : HDC; hrgn : HRGN) : INTEGER;
PROCEDURE GetMetaRgn (hdc : HDC; hrgn : HRGN) : RGN_CODE;
PROCEDURE GetCurrentObject (hdc : HDC; ObjectType : OBJ_ENUM) : HGDIOBJ;
PROCEDURE GetCurrentPositionEx (hdc : HDC; VAR position : POINT) : BOOL;
PROCEDURE GetDeviceCaps (hdc : HDC; index : INTEGER) : INTEGER;
PROCEDURE GetDIBits (hdc : HDC; hbmp : HBITMAP;
                     StartScan, ScanLines : UINT;
                     Bits : PBYTE;
                     VAR bmi : BITMAPINFOPARAM;
                     ColorUse : DIB_COLOR_ENUM) : INTEGER;
PROCEDURE GetFontData (hdc : HDC;
                       Table : DWORD;
                       Offset : DWORD;
                       Buffer : PBYTE;
                       Length : DWORD) : DWORD;

PROCEDURE GetGlyphOutlineA (hdc : HDC; Char : UINT;
                            Format : GGO_ENUM;
                            VAR pgm : GLYPHMETRICS;
                            BufSize : DWORD;
                            Buffr : PBYTE;
              (* IN, NIL *) mat2 : PMAT2) : DWORD;

PROCEDURE GetGlyphOutlineW (hdc : HDC; Char : UINT;
                            Format : GGO_ENUM;
                            VAR pgm : GLYPHMETRICS;
                            BufSize : DWORD;
                            Buffr : PBYTE;
              (* IN, NIL *) mat2 : PMAT2) : DWORD;
<* IF DEFINED (UNICODE) THEN *>
      CONST GetGlyphOutline = GetGlyphOutlineW;
<* ELSE *>
      CONST GetGlyphOutline = GetGlyphOutlineA;
<* END *>

PROCEDURE GetGraphicsMode (hdc : HDC) : GM_ENUM;
PROCEDURE GetMapMode (hdc : HDC) : MM_ENUM;

PROCEDURE GetMetaFileBitsEx (mf : HMETAFILE; sz : UINT;
                             Buffer : PBYTE) : UINT;

PROCEDURE GetMetaFileA (fname : ARRAY OF CHAR)  : HMETAFILE;
PROCEDURE GetMetaFileW (fname : ARRAY OF WCHAR) : HMETAFILE;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetMetaFile = GetMetaFileW;
<* ELSE *>
      CONST GetMetaFile = GetMetaFileA;
<* END *>

PROCEDURE GetNearestColor (hdc : HDC; color : COLORREF) : COLORREF;
PROCEDURE GetNearestPaletteIndex (hpal : HPALETTE; color : COLORREF) : UINT;
PROCEDURE GetObjectType (h : HGDIOBJ) : OBJ_ENUM;

<* IF NOT DEFINED (NOTEXTMETRIC) THEN *>

PROCEDURE GetOutlineTextMetricsA (hdc : HDC; BufLen : UINT;
                                  VAR Buf : ARRAY OF OUTLINETEXTMETRICA) : UINT;
PROCEDURE GetOutlineTextMetricsW (hdc : HDC; BufLen : UINT;
                                  VAR Buf : ARRAY OF OUTLINETEXTMETRICW) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetOutlineTextMetrics = GetOutlineTextMetricsW;
<* ELSE *>
      CONST GetOutlineTextMetrics = GetOutlineTextMetricsA;
<* END *>

<* END *> (* NOT DEFINED (NOTEXTMETRIC) *)

PROCEDURE GetPaletteEntries (hpal : HPALETTE;
                             StartIndex, Entries : UINT;
                             VAR [NIL] pc : PALETTEENTRY) : UINT;

PROCEDURE GetPixel (hdc : HDC; x, y : INTEGER) : COLORREF;
PROCEDURE GetPixelFormat (hdc : HDC) : INTEGER;
PROCEDURE GetPolyFillMode (hdc : HDC) : POLYFILL_ENUM;
PROCEDURE GetRasterizerCaps (VAR rs : RASTERIZER_STATUS; len : UINT) : BOOL;
PROCEDURE GetRegionData (hRgn : HRGN; BufSize : DWORD;
                         VAR [NIL] RgnData : RGNDATA) : DWORD;
PROCEDURE GetRgnBox (hRgn : HRGN; VAR rect : RECT) : RGN_CODE;
PROCEDURE GetStockObject (Object : STOCK_ENUM) : HGDIOBJ;
PROCEDURE GetStretchBltMode (hdc : HDC) : STRETCH_ENUM;
PROCEDURE GetSystemPaletteEntries (hdc : HDC;
                                   StartIndex, Entries : UINT;
                                   VAR [NIL] pc : PALETTEENTRY) : UINT;

PROCEDURE GetSystemPaletteUse (hdc : HDC) : SYSPAL_ENUM;
PROCEDURE GetTextCharacterExtra (hdc : HDC) : INTEGER;
PROCEDURE GetTextAlign (hdc : HDC) : TA_SET;
PROCEDURE GetTextColor (hdc : HDC) : COLORREF;

PROCEDURE GetTextExtentPointA (hdc : HDC; text : ARRAY OF CHAR;
                               len : INTEGER; VAR size : SIZEL) : BOOL;
PROCEDURE GetTextExtentPointW (hdc : HDC; text : ARRAY OF WCHAR;
                               len : INTEGER; VAR size : SIZEL) : BOOL;

PROCEDURE GetTextExtentPoint32A (hdc : HDC; text : ARRAY OF CHAR;
                                 len : INTEGER; VAR size : SIZEL) : BOOL;
PROCEDURE GetTextExtentPoint32W (hdc : HDC; text : ARRAY OF WCHAR;
                                 len : INTEGER; VAR size : SIZEL) : BOOL;

PROCEDURE GetTextExtentExPointA (hdc : HDC; text : ARRAY OF CHAR;
                                 len : INTEGER; MaxExtent : INTEGER;
                                 VAR fit : INTEGER;
                                 VAR [NIL] dx : ARRAY OF INTEGER;
                                 VAR size : SIZEL) : BOOL;

PROCEDURE GetTextExtentExPointW (hdc : HDC; text : ARRAY OF WCHAR;
                                 len : INTEGER; MaxExtent : INTEGER;
                                 VAR fit : INTEGER;
                                 VAR [NIL] dx : ARRAY OF INTEGER;
                                 VAR size : SIZEL) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetTextExtentPoint = GetTextExtentPointW;
            GetTextExtentPoint32 = GetTextExtentPoint32W;
            GetTextExtentExPoint = GetTextExtentExPointW;
<* ELSE *>
      CONST GetTextExtentPoint = GetTextExtentPointA;
            GetTextExtentPoint32 = GetTextExtentPoint32A;
            GetTextExtentExPoint = GetTextExtentExPointA;
<* END *>

PROCEDURE GetTextCharset (hdc : HDC) : CHARSET_TYPE;
PROCEDURE GetTextCharsetInfo (hdc : HDC;
                              VAR[NIL] Sig : FONTSIGNATURE;
                              dwFlags : DWORD) : CHARSET_TYPE;
PROCEDURE TranslateCharsetInfo (lpSrc : PDWORD;
                                VAR Cs : CHARSETINFO;
                                dwFlags : TCI_ENUM) : BOOL;
PROCEDURE GetFontLanguageInfo  (hdc : HDC) : DWORD;

PROCEDURE GetCharacterPlacementA (hdc : HDC; string : ARRAY OF CHAR;
                                  count : INTEGER; MaxExtent : INTEGER;
                                  VAR results : GCP_RESULTSA;
                                  flags : GCP_SET) : DWORD;
PROCEDURE GetCharacterPlacementW (hdc : HDC; string : ARRAY OF WCHAR;
                                  count : INTEGER; MaxExtent : INTEGER;
                                  VAR results : GCP_RESULTSW;
                                  flags : GCP_SET) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetCharacterPlacement = GetCharacterPlacementW;
<* ELSE *>
      CONST GetCharacterPlacement = GetCharacterPlacementA;
<* END *>

PROCEDURE GetViewportExtEx (hdc : HDC; VAR ext : SIZEL) : BOOL;
PROCEDURE GetViewportOrgEx    (hdc : HDC; VAR org : POINT) : BOOL;
PROCEDURE GetWindowExtEx (hdc : HDC; VAR ext : SIZEL) : BOOL;
PROCEDURE GetWindowOrgEx (hdc : HDC; VAR org : POINT) : BOOL;
PROCEDURE IntersectClipRect (hdc : HDC; left, top, right, bottom : INTEGER) : RGN_CODE;
PROCEDURE InvertRgn (hdc : HDC; hrgn : HRGN) : BOOL;

PROCEDURE LineDDA (xStart, YStart, XEnd, YEnd : INTEGER;
                   linefunc : LINEDDAPROC; lparam : LPARAM) : BOOL;

PROCEDURE LineTo (hdc : HDC; x, y : INTEGER) : BOOL;
PROCEDURE MaskBlt (hdcDest : HDC; XDest, YDest, Width, Height : INTEGER;
                   hdcSrc  : HDC; XSrc, YSrc : INTEGER;
                   Mask : HBITMAP; xMask, yMask : INTEGER;
                   rop : ROP4) : BOOL;

(* This structure was not present in wingdi.h; POINT * was used instead *)

TYPE PARALLELOGRAM = RECORD
                            UpperLeft  : POINT;
                            UpperRight : POINT;
                            LowerLeft  : POINT;
                     END;
     PPARALLELOGRAM = POINTER TO PARALLELOGRAM;

<* IF BACKEND # "C" THEN *>
PROCEDURE PlgBlt (hdcDest : HDC; plg : PARALLELOGRAM;
                  hdcSrc : HDC; XSrc, YSrc, Width, Height : INTEGER;
                  Mask : HBITMAP; xMask, yMask : INTEGER) : BOOL;
<* ELSE *>
PROCEDURE PlgBlt (hdcDest : HDC; plg : PPARALLELOGRAM;
                  hdcSrc : HDC; XSrc, YSrc, Width, Height : INTEGER;
                  Mask : HBITMAP; xMask, yMask : INTEGER) : BOOL;
<* END *>

PROCEDURE OffsetClipRgn (hdc : HDC; dx, dy : INTEGER) : RGN_CODE;
PROCEDURE OffsetRgn (hRgn : HRGN; x, y : INTEGER) : RGN_CODE;
PROCEDURE PatBlt (hdc : HDC; Left, Top, Width, Height : INTEGER;
                  operation : ROP) : BOOL;
PROCEDURE Pie (hdc : HDC; left, top, right, bottom : INTEGER;
               XRadial1, YRadial1, XRadial2, YRadial2 : INTEGER) : BOOL;
PROCEDURE PlayMetaFile (hdc : HDC; hmf : HMETAFILE) : BOOL;
PROCEDURE PaintRgn  (hdc : HDC; hrgn : HRGN) : BOOL;
PROCEDURE PolyPolygon (hdc : HDC; points : ARRAY OF POINT;
                       polypoints : ARRAY OF INTEGER; n : INTEGER) : BOOL;

PROCEDURE PtInRegion   (hRgn : HRGN; x, y : INTEGER) : BOOL;
PROCEDURE PtVisible (hdc : HDC; x, y : INTEGER) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE RectInRegion (hRgn : HRGN; rect : RECT) : BOOL;
<* ELSE *>
PROCEDURE RectInRegion (hRgn : HRGN; rect : PRECT) : BOOL;
<* END *> (*!*)
<* IF BACKEND # "C" THEN *>
PROCEDURE RectVisible (hdc : HDC; rect : RECT) : BOOL;
<* ELSE *>
PROCEDURE RectVisible (hdc : HDC; rect : PRECT) : BOOL;
<* END *> (*!*)
PROCEDURE Rectangle (hdc : HDC; left, top, right, bottom : INTEGER) : BOOL;
PROCEDURE RestoreDC (hdc : HDC; s : INTEGER) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE ResetDCA (hdc : HDC; InitData : DEVMODEA) : HDC;
<* ELSE *>
PROCEDURE ResetDCA (hdc : HDC; InitData : PDEVMODEA) : HDC;
<* END *> (*!*)
<* IF BACKEND # "C" THEN *>
PROCEDURE ResetDCW (hdc : HDC; InitData : DEVMODEW) : HDC;
<* ELSE *>
PROCEDURE ResetDCW (hdc : HDC; InitData : PDEVMODEW) : HDC;
<* END *> (*!*)

<* IF DEFINED (UNICODE) THEN *>
      CONST ResetDC = ResetDCW;
<* ELSE *>
      CONST ResetDC = ResetDCA;
<* END *>

PROCEDURE RealizePalette (hdc : HDC) : UINT;

PROCEDURE RemoveFontResourceA (FileName : ARRAY OF CHAR) : BOOL;
PROCEDURE RemoveFontResourceW (FileName : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST RemoveFontResource = RemoveFontResourceW;
<* ELSE *>
      CONST RemoveFontResource = RemoveFontResourceA;
<* END *>

PROCEDURE RoundRect (hdc : HDC; left, top, right, bottom,
                                width, height : INTEGER) : BOOL;

PROCEDURE ResizePalette (hpal : HPALETTE; nEntries : UINT) : BOOL;
PROCEDURE SaveDC    (hdc : HDC) : INTEGER;
PROCEDURE SelectClipRgn     (hdc : HDC; hrgn : HRGN) : RGN_CODE;
PROCEDURE ExtSelectClipRgn  (hdc : HDC; hrgn : HRGN; mode : RGN_COMBINE_ENUM) : RGN_CODE;
PROCEDURE SetMetaRgn (hdc : HDC) : RGN_CODE;
PROCEDURE SelectObject (hdc : HDC; hObject : HGDIOBJ) : HGDIOBJ;
PROCEDURE SelectPalette (hdc : HDC; hpl : HPALETTE;
                         ForceBackGround : BOOL) : HPALETTE;

PROCEDURE SetBkColor (hdc : HDC; color : COLORREF) : COLORREF;
PROCEDURE SetBkMode (hdc : HDC; mode : BKMODE_ENUM) : BKMODE_ENUM;
PROCEDURE SetBitmapBits (hbmp : HBITMAP; NBits : DWORD;
                         Bits : ARRAY OF SYSTEM.BYTE) : LONG;
PROCEDURE SetBoundsRect (hdc : HDC; (* IN NIL *) rect : PRECT; flags : DCB__SET) : DCB__SET;
<* IF BACKEND # "C" THEN *>
PROCEDURE SetDIBits (hdc : HDC; hbmp : HBITMAP;
                     StartScan, ScanLines : UINT;
                     Bits : ARRAY OF SYSTEM.BYTE;
                     bmi : BITMAPINFOPARAM; (*!*)
                     ColorUse : DIB_COLOR_ENUM) : INTEGER;
<* ELSE *>
PROCEDURE SetDIBits (hdc : HDC; hbmp : HBITMAP;
                     StartScan, ScanLines : UINT;
                     Bits : ARRAY OF SYSTEM.BYTE;
                     bmi : PBITMAPINFOPARAM; (*!*)
                     ColorUse : DIB_COLOR_ENUM) : INTEGER;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE SetDIBitsToDevice (hdcDest : HDC; XDest, YDest, Width, Height : INTEGER;
                             XSrc, YSrc : INTEGER;
                             StartScan, ScanLines : UINT;
                             Bits : ARRAY OF BYTE;
                             BitsInfo : BITMAPINFOPARAM;
                             ColorUse : DIB_COLOR_ENUM) : INTEGER;
<* ELSE *>
PROCEDURE SetDIBitsToDevice (hdcDest : HDC; XDest, YDest, Width, Height : INTEGER;
                             XSrc, YSrc : INTEGER;
                             StartScan, ScanLines : UINT;
                             Bits : ARRAY OF BYTE;
                             BitsInfo : PBITMAPINFOPARAM;
                             ColorUse : DIB_COLOR_ENUM) : INTEGER;
<* END *>
PROCEDURE SetMapperFlags (hdc : HDC; flag : DWORD) : DWORD;
PROCEDURE SetGraphicsMode (hdc : HDC; Mode : GM_ENUM) : GM_ENUM;
PROCEDURE SetMapMode (hdc : HDC; map : MM_ENUM) : MM_ENUM;
PROCEDURE SetMetaFileBitsEx (sz : UINT; Buffer : ARRAY OF SYSTEM.BYTE) : HMETAFILE;
PROCEDURE SetPaletteEntries (hpal : HPALETTE;
                             StartIndex, Entries : UINT;
                             pc : ARRAY OF PALETTEENTRY) : UINT;
PROCEDURE SetPixel (hdc : HDC; x, y : INTEGER; color : COLORREF) : COLORREF;
PROCEDURE SetPixelV (hdc : HDC; x, y : INTEGER; color : COLORREF) : BOOL;

<* IF BACKEND # "C" THEN *>
PROCEDURE SetPixelFormat (hdc : HDC; format : INTEGER;
                          pfd : PIXELFORMATDESCRIPTOR) : BOOL;
<* ELSE *>
PROCEDURE SetPixelFormat (hdc : HDC; format : INTEGER;
                          pfd : PPIXELFORMATDESCRIPTOR) : BOOL;
<* END *> (*!*)

PROCEDURE SetPolyFillMode (hdc : HDC; mode : POLYFILL_ENUM) : POLYFILL_ENUM;
PROCEDURE StretchBlt (hdcDest : HDC; XDest, YDest, WDest, HDest : INTEGER;
                      hdcSrc  : HDC; XSrc, YSrc, WSrc, HSrc : INTEGER;
                      operation : ROP) : BOOL;
PROCEDURE SetRectRgn (hRgn : HRGN;
                      LeftRect, TopRect, RightRect, BottomRect : INTEGER) : BOOL;

<* IF BACKEND # "C" THEN *>
PROCEDURE StretchDIBits (hdcDest : HDC; XDest, YDest, WDest, HDest : INTEGER;
                         XSrc, YSrc, WSrc, HSrc : INTEGER;
                         Bits : ARRAY OF BYTE;
                         BitsInfo : BITMAPINFOPARAM; (*!*)
                         ColorUse : DIB_COLOR_ENUM; operation : ROP) : INTEGER;
<* ELSE *>
PROCEDURE StretchDIBits (hdcDest : HDC; XDest, YDest, WDest, HDest : INTEGER;
                         XSrc, YSrc, WSrc, HSrc : INTEGER;
                         Bits : ARRAY OF BYTE;
                         BitsInfo : PBITMAPINFOPARAM; (*!*)
                         ColorUse : DIB_COLOR_ENUM; operation : ROP) : INTEGER;
<* END *>
PROCEDURE SetROP2 (hdc : HDC; rop : ROP2) : ROP2;
PROCEDURE SetStretchBltMode (hdc : HDC; mode : STRETCH_ENUM) : STRETCH_ENUM;
PROCEDURE SetSystemPaletteUse (hdc : HDC; new : SYSPAL_ENUM) : SYSPAL_ENUM;
PROCEDURE SetTextCharacterExtra (hdc : HDC; extra : INTEGER) : INTEGER;
PROCEDURE SetTextColor (hdc : HDC; color : COLORREF) : COLORREF;
PROCEDURE SetTextAlign (hdc : HDC; align : TA_SET) : TA_SET;
PROCEDURE SetTextJustification (hdc : HDC; BreakExtra : INTEGER;
                                BreakOut : INTEGER) : BOOL;

PROCEDURE UpdateColors (hdc : HDC) : BOOL;

<* IF NOT DEFINED (NOMETAFILE) THEN *>

<* IF BACKEND # "C" THEN *>
PROCEDURE PlayMetaFileRecord (hdc : HDC;
                              VAR HandleTable : HANDLETABLE;
                              MetaRecord  : METARECORD;  (*!*)
                              nHandles    : UINT) : BOOL;
TYPE MFENUMPROC = PROCEDURE (HDC, VAR HANDLETABLE, VAR METARECORD, INTEGER, LPARAM) : INTEGER; (*!*)
<* ELSE *>
PROCEDURE PlayMetaFileRecord (hdc : HDC;
                              VAR HandleTable : HANDLETABLE;
                              MetaRecord  : PMETARECORD;  (*!*)
                              nHandles    : UINT) : BOOL;
TYPE MFENUMPROC = PROCEDURE (HDC, PHANDLETABLE, PMETARECORD, INTEGER, LPARAM) : INTEGER; (*!*)
<* END *>

PROCEDURE EnumMetaFile (hdc : HDC;
                        hMetaFile : HMETAFILE;
                        MetaFunc : MFENUMPROC;
                        lParam : LPARAM) : BOOL;

<* IF BACKEND # "C" THEN *>
TYPE ENHMFENUMPROC = PROCEDURE (HDC, VAR HANDLETABLE, VAR ENHMETARECORD, INTEGER, LPARAM) : INTEGER; (*!*)
<* ELSE *>
TYPE ENHMFENUMPROC = PROCEDURE (HDC, PHANDLETABLE, PENHMETARECORD, INTEGER, LPARAM) : INTEGER; (*!*)
<* END *>

(* Enhanced Metafile Function Declarations *)


PROCEDURE CloseEnhMetaFile (hdc : HDC) : HENHMETAFILE;
PROCEDURE CopyEnhMetaFileA (emf : HENHMETAFILE; filename : PCSTR)  : HENHMETAFILE;
PROCEDURE CopyEnhMetaFileW (emf : HENHMETAFILE; filename : PCWSTR) : HENHMETAFILE;

<* IF DEFINED (UNICODE) THEN *>
      CONST CopyEnhMetaFile = CopyEnhMetaFileW;
<* ELSE *>
      CONST CopyEnhMetaFile = CopyEnhMetaFileA;
<* END *>

PROCEDURE CreateEnhMetaFileA (hdc : HDC; (* IN NIL *) filename : PCSTR;  (* IN NIL *) rect : PRECT; (* IN NIL *) descr : PCSTR) : HDC;
PROCEDURE CreateEnhMetaFileW (hdc : HDC; (* IN NIL *) filename : PCWSTR; (* IN NIL *) rect : PRECT; (* IN NIL *) descr : PCWSTR) : HDC;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateEnhMetaFile = CreateEnhMetaFileW;
<* ELSE *>
      CONST CreateEnhMetaFile = CreateEnhMetaFileA;
<* END *>

PROCEDURE DeleteEnhMetaFile (emf : HENHMETAFILE) : BOOL;
PROCEDURE EnumEnhMetaFile (hdc : HDC; emf : HENHMETAFILE; enumproc : ENHMFENUMPROC;
                           data : PVOID; (* IN NIL *) rect : PRECT) : BOOL;
PROCEDURE GetEnhMetaFileA (filename : PCSTR) : HENHMETAFILE;
PROCEDURE GetEnhMetaFileW (filename : PCWSTR): HENHMETAFILE;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetEnhMetaFile = GetEnhMetaFileW;
<* ELSE *>
      CONST GetEnhMetaFile = GetEnhMetaFileA;
<* END *>

PROCEDURE GetEnhMetaFileBits (emf : HENHMETAFILE; len : UINT; VAR [NIL] buf : ARRAY OF SYSTEM.BYTE) : UINT;
PROCEDURE GetEnhMetaFileDescriptionA (emf : HENHMETAFILE; bsize : UINT; VAR [NIL] buffer : ARRAY OF CHAR) : UINT;
PROCEDURE GetEnhMetaFileDescriptionW (emf : HENHMETAFILE; bsize : UINT; VAR [NIL] buffer : ARRAY OF WCHAR) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetEnhMetaFileDescription = GetEnhMetaFileDescriptionW;
<* ELSE *>
      CONST GetEnhMetaFileDescription = GetEnhMetaFileDescriptionA;
<* END *>

PROCEDURE GetEnhMetaFileHeader (emf : HENHMETAFILE;
                                bsize : UINT; VAR [NIL] buffer : ENHMETAHEADER) : UINT;
PROCEDURE GetEnhMetaFilePaletteEntries (emf : HENHMETAFILE;
                                        cEntries : UINT;
                                        VAR [NIL] entries : ARRAY OF PALETTEENTRY) : UINT;
PROCEDURE GetEnhMetaFilePixelFormat (emf : HENHMETAFILE; bufsize : UINT;
                                     VAR [NIL] format : PIXELFORMATDESCRIPTOR) : UINT;

PROCEDURE GetWinMetaFileBits (emf : HENHMETAFILE; bsize : UINT;
                              VAR [NIL] buffer : ARRAY OF SYSTEM.BYTE;
                              MapMode : MM_ENUM;
                              hdc : HDC) : UINT;
<* IF BACKEND # "C" THEN *>
PROCEDURE PlayEnhMetaFile (hdc : HDC; emf : HENHMETAFILE; rect : RECT) : BOOL;
<* ELSE *>
PROCEDURE PlayEnhMetaFile (hdc : HDC; emf : HENHMETAFILE; rect : PRECT) : BOOL;
<* END *> (*!*)
<* IF BACKEND # "C" THEN *>
PROCEDURE PlayEnhMetaFileRecord (hdc : HDC;
                                 VAR handles : HANDLETABLE;
                                 records : ENHMETARECORD; (*!*)
                                 nHandles : UINT) : BOOL;
<* ELSE *>
PROCEDURE PlayEnhMetaFileRecord (hdc : HDC;
                                 VAR handles : HANDLETABLE;
                                 records : PENHMETARECORD; (*!*)
                                 nHandles : UINT) : BOOL;
<* END *>
PROCEDURE SetEnhMetaFileBits (bsize : UINT;
                              buf : ARRAY OF SYSTEM.BYTE) : HENHMETAFILE;

<* IF BACKEND # "C" THEN *>
PROCEDURE SetWinMetaFileBits (bsize : UINT;
                              buf : ARRAY OF SYSTEM.BYTE;
                              hdc : HDC;
                              metapict : METAFILEPICT) : HENHMETAFILE;
<* ELSE *>
PROCEDURE SetWinMetaFileBits (bsize : UINT;
                              buf : ARRAY OF SYSTEM.BYTE;
                              hdc : HDC;
                              metapict : PMETAFILEPICT) : HENHMETAFILE;
<* END *>   (*!*)
PROCEDURE GdiComment (hdc : HDC; bsize : UINT; buf : ARRAY OF SYSTEM.BYTE) : BOOL;

<* END *> (* NOT DEFINED (NOMETAFILE) *)

<* IF NOT DEFINED (NOTEXTMETRIC) THEN *>

PROCEDURE GetTextMetricsA(hdc : HDC; VAR metrics : TEXTMETRICA) : BOOL;
PROCEDURE GetTextMetricsW(hdc : HDC; VAR metrics : TEXTMETRICW) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetTextMetrics = GetTextMetricsW;
<* ELSE *>
      CONST GetTextMetrics = GetTextMetricsA;
<* END *>

<* END *> (* NOT DEFINED (NOTEXTMETRICS) *)

(* new GDI *)

TYPE DIBSECTION = RECORD
                         dsBm        : BITMAP;
                         dsBmih      : BITMAPINFOHEADER;
                         dsBitfields : ARRAY [0..2] OF DWORD;
                         dshSection  : HANDLE;
                         dsOffset    : DWORD;
                  END;
    PDIBSECTION = POINTER TO DIBSECTION;

PROCEDURE AngleArc (hdc : HDC; x, y : INTEGER; Radius : DWORD;
                    StartAngle, SweepAngle : FLOAT) : BOOL;
PROCEDURE PolyPolyline (hdc : HDC; points : ARRAY OF POINT;
                        polypoints : ARRAY OF DWORD; n : DWORD) : BOOL;

PROCEDURE GetWorldTransform (hdc : HDC; VAR xform : XFORM) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE SetWorldTransform (hdc : HDC; xform : XFORM) : BOOL;
<* ELSE *>
PROCEDURE SetWorldTransform (hdc : HDC; xform : PXFORM) : BOOL;
<* END *> (*!*)
PROCEDURE ModifyWorldTransform (hdc : HDC; xform : PXFORM; mode : MWT_ENUM) : BOOL; (*!*)
<* IF BACKEND # "C" THEN *>
PROCEDURE CombineTransform (VAR Result : XFORM;
                            Xform1, Xform2 : XFORM) : BOOL;
<* ELSE *>
PROCEDURE CombineTransform (VAR Result : XFORM;
                            Xform1, Xform2 : PXFORM) : BOOL;
<* END *> (*!*)

<* IF BACKEND # "C" THEN *>
PROCEDURE CreateDIBSection (hdc : HDC;
                            bmi : BITMAPINFOPARAM;
                            usage : DIB_COLOR_ENUM;
                            VAR bits : PBYTE;
                            hSection : HANDLE;
                            offset : DWORD) : HBITMAP;
<* ELSE *>
PROCEDURE CreateDIBSection (hdc : HDC;
                            bmi : PBITMAPINFOPARAM;
                            usage : DIB_COLOR_ENUM;
                            VAR bits : PBYTE;
                            hSection : HANDLE;
                            offset : DWORD) : HBITMAP;
<* END *>

PROCEDURE GetDIBColorTable (hdc : HDC; StartIndex : UINT; nEntries : UINT; VAR buffer : ARRAY OF RGBQUAD) : UINT;
PROCEDURE SetDIBColorTable (hdc : HDC; StartIndex : UINT; nEntries : UINT;     buffer : ARRAY OF RGBQUAD) : UINT;

(* COLORADJUSTMENT structure and values for its fields *)

   (* Flags value for COLORADJUSTMENT *)

TYPE CA_ENUM = (CA__NEGATIVE,    (* 0 *)
                CA__LOG_FILTER); (* 1 *)

<* PUSH *> <* SETSIZE = "2" *>

TYPE CA_SET = SET OF CA_ENUM;

CONST CA_NEGATIVE   = CA_SET {CA__NEGATIVE}; (* 0x0001 *)
      CA_LOG_FILTER = CA_SET {CA__LOG_FILTER}; (* 0x0002 *)

<* POP *>

(* IlluminantIndex values *)

<* PUSH *> <* ENUMSIZE = "2" *>

TYPE ILLUMINANT_ENUM = (ILLUMINANT_DEVICE_DEFAULT, (* 0 *)
                        ILLUMINANT_A,              (* 1 *)
                        ILLUMINANT_B,              (* 2 *)
                        ILLUMINANT_C,              (* 3 *)
                        ILLUMINANT_D50,            (* 4 *)
                        ILLUMINANT_D55,            (* 5 *)
                        ILLUMINANT_D65,            (* 6 *)
                        ILLUMINANT_D75,            (* 7 *)
                        ILLUMINANT_F2);            (* 8 *)

CONST    ILLUMINANT_MAX_INDEX      = ILLUMINANT_F2;

         ILLUMINANT_TUNGSTEN       = ILLUMINANT_A;
         ILLUMINANT_DAYLIGHT       = ILLUMINANT_C;
         ILLUMINANT_FLUORESCENT    = ILLUMINANT_F2;
         ILLUMINANT_NTSC           = ILLUMINANT_C;

<* POP *>

(* Min and max for RedGamma, GreenGamma, BlueGamma *)
         RGB_GAMMA_MIN             = VAL (WORD, 2500);
         RGB_GAMMA_MAX             = VAL (WORD, 65000);

(* Min and max for ReferenceBlack and ReferenceWhite *)
         REFERENCE_WHITE_MIN       = VAL (WORD, 6000);
         REFERENCE_WHITE_MAX       = VAL (WORD, 10000);
         REFERENCE_BLACK_MIN       = VAL (WORD, 0);
         REFERENCE_BLACK_MAX       = VAL (WORD, 4000);

(* Min and max for Contrast, Brightness, Colorfulness, RedGreenTint *)
         COLOR_ADJ_MIN             = VAL (SHORT, -100);
         COLOR_ADJ_MAX             = VAL (SHORT, -100);

TYPE COLORADJUSTMENT = RECORD
                              caSize            : WORD;
                              caFlags           : CA_SET;
                              caIlluminantIndex : ILLUMINANT_ENUM;
                              caRedGamma        : WORD;
                              caGreenGamma      : WORD;
                              caBlueGamma       : WORD;
                              caReferenceBlack  : WORD;
                              caReferenceWhite  : WORD;
                              caContrast        : SHORT;
                              caBrightness      : SHORT;
                              caColorfulness    : SHORT;
                              caRedGreenTint    : SHORT;
                       END;
     PCOLORADJUSTMENT = POINTER TO COLORADJUSTMENT;

<* IF BACKEND # "C" THEN *>
PROCEDURE SetColorAdjustment (hdc : HDC; adj : COLORADJUSTMENT) : BOOL;
<* ELSE *>
PROCEDURE SetColorAdjustment (hdc : HDC; adj : PCOLORADJUSTMENT) : BOOL;
<* END *> (*!*)
PROCEDURE GetColorAdjustment (hdc : HDC; VAR adj : COLORADJUSTMENT) : BOOL;

PROCEDURE CreateHalftonePalette (hdc : HDC) : HPALETTE;

TYPE ABORTPROC = PROCEDURE (HDC, INTEGER) : BOOL;

CONST DI_APPBANDING = 1;

TYPE DOCINFOA = RECORD
                       cbSize : INTEGER;
                       lpszDocName  : PCSTR;
                       lpszOutput   : PCSTR;
                       lpszDatatype : PCSTR;
                       fwType       : DWORD;
                END;
     PDOCINFOA = POINTER TO DOCINFOA;

     DOCINFOW = RECORD
                       cbSize       : INTEGER;
                       lpszDocName  : PCWSTR;
                       lpszOutput   : PCWSTR;
                       lpszDatatype : PCWSTR;
                       fwType       : DWORD;
                END;
     PDOCINFOW = POINTER TO DOCINFOW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE DOCINFO = DOCINFOW;
           PDOCINFO = PDOCINFOW;
<* ELSE *>
      TYPE DOCINFO = DOCINFOA;
           PDOCINFO = PDOCINFOA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE  StartDocA    (hdc : HDC; dinfo : DOCINFOA) : INTEGER;
<* ELSE *>
PROCEDURE  StartDocA    (hdc : HDC; dinfo : PDOCINFOA) : INTEGER;
<* END *> (*!*)
<* IF BACKEND # "C" THEN *>
PROCEDURE  StartDocW    (hdc : HDC; dinfo : DOCINFOW) : INTEGER;
<* ELSE *>
PROCEDURE  StartDocW    (hdc : HDC; dinfo : PDOCINFOW) : INTEGER;
<* END *> (*!*)
PROCEDURE  EndDoc       (hdc : HDC) : INTEGER;
PROCEDURE  StartPage    (hdc : HDC) : INTEGER;
PROCEDURE  EndPage      (hdc : HDC) : INTEGER;
PROCEDURE  AbortDoc     (hdc : HDC) : INTEGER;
PROCEDURE  SetAbortProc (hdc : HDC; aproc : ABORTPROC) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST StartDoc = StartDocW;
<* ELSE *>
      CONST StartDoc = StartDocA;
<* END *>

PROCEDURE AbortPath (hdc : HDC) : BOOL;
PROCEDURE ArcTo (hdc : HDC; left, top, right, bottom : INTEGER;
                 XRadial1, YRadial1, XRadial2, YRadial2 : INTEGER) : BOOL;
PROCEDURE BeginPath (hdc : HDC) : BOOL;
PROCEDURE CloseFigure       (hdc : HDC) : BOOL;
PROCEDURE EndPath           (hdc : HDC) : BOOL;
PROCEDURE FillPath          (hdc : HDC) : BOOL;
PROCEDURE FlattenPath       (hdc : HDC) : BOOL;
PROCEDURE GetPath (hdc : HDC;
                   VAR [NIL] Points : POINT;
                   VAR [NIL] types  : PT_SET;
                   n : INTEGER) : INTEGER;
PROCEDURE PathToRegion (hdc : HDC) : HRGN;
PROCEDURE PolyDraw (hdc : HDC;
                    points : ARRAY OF POINT;
                    types : ARRAY OF PT_SET;
                    n : INTEGER) : BOOL;

PROCEDURE SelectClipPath  (hdc : HDC; mode : RGN_COMBINE_ENUM) : BOOL;
PROCEDURE SetArcDirection (hdc : HDC; ArcDirection : AD_ENUM) : AD_ENUM;
PROCEDURE SetMiterLimit (hdc : HDC; limit : FLOAT; VAR oldlimit : FLOAT) : BOOL;
PROCEDURE StrokeAndFillPath (hdc : HDC) : BOOL;
PROCEDURE StrokePath        (hdc : HDC) : BOOL;
PROCEDURE WidenPath         (hdc : HDC) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE ExtCreatePen (PenStyle : PS_SET; Width : DWORD;
                        lb : LOGBRUSH; StyleCount : DWORD; (*!*)
                        (* IN NIL *) Style : PDWORD) : HPEN;
<* ELSE *>
PROCEDURE ExtCreatePen (PenStyle : PS_SET; Width : DWORD;
                        lb : PLOGBRUSH; StyleCount : DWORD; (*!*)
                        (* IN NIL *) Style : PDWORD) : HPEN;
<* END *>
PROCEDURE GetMiterLimit (hdc : HDC; VAR limit : FLOAT) : BOOL;
PROCEDURE GetArcDirection (hdc : HDC) : AD_ENUM;


PROCEDURE GetObjectA (hObject : HGDIOBJ; BuffSize : INTEGER;
                      VAR [NIL] Buffer : ARRAY OF SYSTEM.BYTE) : INTEGER;
PROCEDURE GetObjectW (hObject : HGDIOBJ; BuffSize : INTEGER;
                      VAR [NIL] Buffer : ARRAY OF SYSTEM.BYTE) : INTEGER;
<*IF DEFINED (UNICODE) THEN *>
     CONST GetObject = GetObjectW;
<* ELSE *>
     CONST GetObject = GetObjectA;
<* END *>

PROCEDURE MoveToEx (hdc : HDC; x, y : INTEGER; VAR [NIL] old : POINT) : BOOL;
PROCEDURE TextOutA (hdc : HDC; XStart, YStart : INTEGER;
                    Str : ARRAY OF CHAR; len : INTEGER) : BOOL;
PROCEDURE TextOutW (hdc : HDC; XStart, YStart : INTEGER;
                    Str : ARRAY OF WCHAR; len : INTEGER) : BOOL;

PROCEDURE ExtTextOutA (hdc : HDC; XStart, YStart : INTEGER;
                       Options : ETO_SET; clipping : PRECT; (*!*)
                       Str : ARRAY OF CHAR; len : UINT;
                       (* IN NIL *) Dx : INTARRAY) : BOOL;
PROCEDURE ExtTextOutW (hdc : HDC; XStart, YStart : INTEGER;
                       Options : ETO_SET; clipping : PRECT; (*!*)
                       Str : ARRAY OF WCHAR; len : UINT;
                       (* IN NIL *) Dx : INTARRAY) : BOOL;

PROCEDURE PolyTextOutA (hdc : HDC; txts : ARRAY OF POLYTEXTA;
                        ntxts : INTEGER) : BOOL;
PROCEDURE PolyTextOutW (hdc : HDC; txts : ARRAY OF POLYTEXTW;
                        ntxts : INTEGER) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST TextOut = TextOutW;
            ExtTextOut = ExtTextOutW;
            PolyTextOut = PolyTextOutW;
<* ELSE *>
      CONST TextOut = TextOutA;
            ExtTextOut = ExtTextOutA;
            PolyTextOut = PolyTextOutA;
<* END *>


PROCEDURE CreatePolygonRgn (pt : ARRAY OF POINT;
                            cPoints : INTEGER;
                            PolyFillMode : POLYFILL_ENUM) : HRGN;


PROCEDURE DPtoLP (hdc : HDC; VAR points : ARRAY OF POINT; npoints : INTEGER) : BOOL;
PROCEDURE LPtoDP (hdc : HDC; VAR points : ARRAY OF POINT; npoints : INTEGER) : BOOL;

PROCEDURE Polygon (hdc : HDC; points : ARRAY OF POINT; n : INTEGER) : BOOL;
PROCEDURE Polyline   (hdc : HDC; points : ARRAY OF POINT; n : INTEGER) : BOOL;

PROCEDURE PolyBezier   (hdc : HDC; points : ARRAY OF POINT; n : DWORD) : BOOL;
PROCEDURE PolyBezierTo (hdc : HDC; points : ARRAY OF POINT; n : DWORD) : BOOL;
PROCEDURE PolylineTo (hdc : HDC; points : ARRAY OF POINT; n : DWORD) : BOOL;

PROCEDURE SetViewportExtEx (hdc : HDC; x, y : INTEGER; VAR [NIL] oldext : SIZEL) : BOOL;
PROCEDURE SetViewportOrgEx (hdc : HDC; x, y : INTEGER; VAR [NIL] oldorg : POINT) : BOOL;
PROCEDURE SetWindowOrgEx   (hdc : HDC; x, y : INTEGER; VAR [NIL] oldorg : POINT) : BOOL;
PROCEDURE SetWindowExtEx   (hdc : HDC; x, y : INTEGER; VAR [NIL] oldext : SIZEL) : BOOL;

PROCEDURE OffsetViewportOrgEx (hdc : HDC; dx, dy : INTEGER; VAR oldorg : POINT) : BOOL;
PROCEDURE OffsetWindowOrgEx   (hdc : HDC; dx, dy : INTEGER; VAR oldorg : POINT) : BOOL;
PROCEDURE ScaleViewportExtEx (hdc : HDC; Xnum, Xdenom, Ynum, Ydenom : INTEGER;
                              VAR [NIL] oldext : SIZEL) : BOOL;
PROCEDURE ScaleWindowExtEx   (hdc : HDC; Xnum, Xdenom, Ynum, Ydenom : INTEGER;
                              VAR [NIL] oldext : SIZEL) : BOOL;

PROCEDURE SetBitmapDimensionEx (hbmp : HBITMAP; Width, Height : INTEGER;
                                VAR [NIL] OldSize : SIZEL) : BOOL;

PROCEDURE SetBrushOrgEx (dc : HDC; x, y : INTEGER; VAR [NIL] old : POINT) : BOOL;

PROCEDURE GetTextFaceA (hdc : HDC; len : INTEGER;
                        VAR [NIL] Buffer : ARRAY OF CHAR) : INTEGER;
PROCEDURE GetTextFaceW (hdc : HDC; len : INTEGER;
                        VAR [NIL] Buffer : ARRAY OF WCHAR) : INTEGER;
<* IF DEFINED (UNICODE) THEN *>
      CONST GetTextFace = GetTextFaceW;
<* ELSE *>
      CONST GetTextFace = GetTextFaceA;
<* END *>

CONST FONTMAPPER_MAX = 10;

TYPE KERNINGPAIR = RECORD
                          wFirst  : WORD;
                          wSecond : WORD;
                          iKernAmount : INTEGER;
                   END;
    PKERNINGPAIR = POINTER TO KERNINGPAIR;


PROCEDURE GetKerningPairsA (hdc : HDC;
                            NumPairs : DWORD;
                            VAR [NIL] krnpair : ARRAY OF KERNINGPAIR) : DWORD;

PROCEDURE GetKerningPairsW (hdc : HDC;
                            NumPairs : DWORD;
                            VAR [NIL] krnpair : ARRAY OF KERNINGPAIR) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetKerningPairs = GetKerningPairsW;
<* ELSE *>
      CONST GetKerningPairs = GetKerningPairsA;
<* END *>

PROCEDURE GetDCOrgEx (hdc : HDC; VAR point : POINT) : BOOL;
PROCEDURE FixBrushOrgEx (hdc : HDC; x, y : INTEGER; VAR [NIL] prev : POINT) : BOOL;
PROCEDURE UnrealizeObject (object : HGDIOBJ) : BOOL;

PROCEDURE GdiFlush() : BOOL;
PROCEDURE GdiSetBatchLimit (limit : DWORD) : DWORD;
PROCEDURE GdiGetBatchLimit () : DWORD;



TYPE ICM_ENUM = (ICM_0,
                 ICM_OFF,    (* 1 *)
                 ICM_ON,     (* 2 *)
                 ICM_QUERY); (* 3 *)

PROCEDURE SetICMMode (hdc : HDC; icm : ICM_ENUM) : ICM_ENUM;

PROCEDURE CheckColorsInGamut (hdc : HDC; rgn : ARRAY OF RGBQUAD;
                              VAR result : ARRAY OF GAMUT_RESULT;
                              count : DWORD) : BOOL;
PROCEDURE GetColorSpace (hdc : HDC) : HANDLE;
PROCEDURE GetLogColorSpaceA (hcolorspace : HCOLORSPACE; VAR cs : LOGCOLORSPACEA; size : DWORD) : BOOL;
PROCEDURE GetLogColorSpaceW (hcolorspace : HCOLORSPACE; VAR cs : LOGCOLORSPACEW; size : DWORD) : BOOL;
<* IF DEFINED (UNICODE) THEN *>
      CONST GetLogColorSpace = GetLogColorSpaceW;
<* ELSE *>
      CONST GetLogColorSpace = GetLogColorSpaceA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE CreateColorSpaceA (cs : LOGCOLORSPACEA) : HCOLORSPACE;
<* ELSE *>
PROCEDURE CreateColorSpaceA (cs : PLOGCOLORSPACEA) : HCOLORSPACE;
<* END *> (*!*)
<* IF BACKEND # "C" THEN *>
PROCEDURE CreateColorSpaceW (cs : LOGCOLORSPACEW) : HCOLORSPACE;
<* ELSE *>
PROCEDURE CreateColorSpaceW (cs : PLOGCOLORSPACEW) : HCOLORSPACE;
<* END *> (*!*)

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateColorSpace = CreateColorSpaceW;
<* ELSE *>
      CONST CreateColorSpace = CreateColorSpaceA;
<* END *>

PROCEDURE SetColorSpace (hdc : HDC; hcs : HCOLORSPACE) : BOOL;
PROCEDURE DeleteColorSpace (hcs : HCOLORSPACE) : BOOL;
PROCEDURE GetICMProfileA (hdc : HDC; VAR size : DWORD; filename : PSTR)  : BOOL;
PROCEDURE GetICMProfileW (hdc : HDC; VAR size : DWORD; filename : PWSTR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetICMProfile = GetICMProfileW;
<* ELSE *>
      CONST GetICMProfile = GetICMProfileA;
<* END *>

PROCEDURE SetICMProfileA (hdc : HDC; VAR filename : ARRAY OF CHAR)  : BOOL;
PROCEDURE SetICMProfileW (hdc : HDC; VAR filename : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetICMProfile = SetICMProfileW;
<* ELSE *>
      CONST SetICMProfile = SetICMProfileA;
<* END *>

TYPE RAMP_INDEX = (RAMP_INDEX_RED, RAMP_INDEX_GREEN, RAMP_INDEX_BLUE);
     RAMP_ARRAY = ARRAY RAMP_INDEX, [0..255] OF BYTE;

PROCEDURE GetDeviceGammaRamp (hdc : HDC; VAR ramp : RAMP_ARRAY) : BOOL;
PROCEDURE SetDeviceGammaRamp (hdc : HDC;     ramp : RAMP_ARRAY) : BOOL; (*!*)
PROCEDURE ColorMatchToTarget (hdc : HDC; hdctarget : HDC; action : DWORD) : BOOL;
PROCEDURE UpdateICMRegKeyA (reserved : DWORD; CMID : DWORD; filename : PSTR;  command : UINT) : BOOL;
PROCEDURE UpdateICMRegKeyW (reserved : DWORD; CMID : DWORD; filename : PWSTR; command : UINT) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST UpdateICMRegKey = UpdateICMRegKeyW;
<* ELSE *>
      CONST UpdateICMRegKey = UpdateICMRegKeyA;
<* END *>

TYPE ICMENUMPROCA = PROCEDURE (ARRAY OF CHAR,  LPARAM) : INTEGER;
TYPE ICMENUMPROCW = PROCEDURE (ARRAY OF WCHAR, LPARAM) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      TYPE ICMENUMPROC = ICMENUMPROCW;
<* ELSE *>
      TYPE ICMENUMPROC = ICMENUMPROCA;
<* END *>

PROCEDURE EnumICMProfilesA (hdc : HDC; enumfunc : ICMENUMPROCA; lparam : LPARAM) : INTEGER;
PROCEDURE EnumICMProfilesW (hdc : HDC; enumfunc : ICMENUMPROCW; lparam : LPARAM) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumICMProfiles = EnumICMProfilesW;
<* ELSE *>
      CONST EnumICMProfiles = EnumICMProfilesA;
<* END *>

<* IF NOT DEFINED (NOMETAFILE) THEN *>

(* Enhanced metafile constants. *)

CONST ENHMETA_SIGNATURE = 464D4520h;

(* Stock object flag used in the object handle index in the enhanced
 * metafile records.
 * E.g. The object handle index (META_STOCK_OBJECT + BLACK_BRUSH)
 * represents the stock object BLACK_BRUSH.
 *)
      ENHMETA_STOCK_OBJECT =  80000000h;

(* Enhanced metafile record types. *)

      EMR_HEADER                     = 1;
      EMR_POLYBEZIER                 = 2;
      EMR_POLYGON                    = 3;
      EMR_POLYLINE                   = 4;
      EMR_POLYBEZIERTO               = 5;
      EMR_POLYLINETO                 = 6;
      EMR_POLYPOLYLINE               = 7;
      EMR_POLYPOLYGON                = 8;
      EMR_SETWINDOWEXTEX             = 9;
      EMR_SETWINDOWORGEX             = 10;
      EMR_SETVIEWPORTEXTEX           = 11;
      EMR_SETVIEWPORTORGEX           = 12;
      EMR_SETBRUSHORGEX              = 13;
      EMR_EOF                        = 14;
      EMR_SETPIXELV                  = 15;
      EMR_SETMAPPERFLAGS             = 16;
      EMR_SETMAPMODE                 = 17;
      EMR_SETBKMODE                  = 18;
      EMR_SETPOLYFILLMODE            = 19;
      EMR_SETROP2                    = 20;
      EMR_SETSTRETCHBLTMODE          = 21;
      EMR_SETTEXTALIGN               = 22;
      EMR_SETCOLORADJUSTMENT         = 23;
      EMR_SETTEXTCOLOR               = 24;
      EMR_SETBKCOLOR                 = 25;
      EMR_OFFSETCLIPRGN              = 26;
      EMR_MOVETOEX                   = 27;
      EMR_SETMETARGN                 = 28;
      EMR_EXCLUDECLIPRECT            = 29;
      EMR_INTERSECTCLIPRECT          = 30;
      EMR_SCALEVIEWPORTEXTEX         = 31;
      EMR_SCALEWINDOWEXTEX           = 32;
      EMR_SAVEDC                     = 33;
      EMR_RESTOREDC                  = 34;
      EMR_SETWORLDTRANSFORM          = 35;
      EMR_MODIFYWORLDTRANSFORM       = 36;
      EMR_SELECTOBJECT               = 37;
      EMR_CREATEPEN                  = 38;
      EMR_CREATEBRUSHINDIRECT        = 39;
      EMR_DELETEOBJECT               = 40;
      EMR_ANGLEARC                   = 41;
      EMR_ELLIPSE                    = 42;
      EMR_RECTANGLE                  = 43;
      EMR_ROUNDRECT                  = 44;
      EMR_ARC                        = 45;
      EMR_CHORD                      = 46;
      EMR_PIE                        = 47;
      EMR_SELECTPALETTE              = 48;
      EMR_CREATEPALETTE              = 49;
      EMR_SETPALETTEENTRIES          = 50;
      EMR_RESIZEPALETTE              = 51;
      EMR_REALIZEPALETTE             = 52;
      EMR_EXTFLOODFILL               = 53;
      EMR_LINETO                     = 54;
      EMR_ARCTO                      = 55;
      EMR_POLYDRAW                   = 56;
      EMR_SETARCDIRECTION            = 57;
      EMR_SETMITERLIMIT              = 58;
      EMR_BEGINPATH                  = 59;
      EMR_ENDPATH                    = 60;
      EMR_CLOSEFIGURE                = 61;
      EMR_FILLPATH                   = 62;
      EMR_STROKEANDFILLPATH          = 63;
      EMR_STROKEPATH                 = 64;
      EMR_FLATTENPATH                = 65;
      EMR_WIDENPATH                  = 66;
      EMR_SELECTCLIPPATH             = 67;
      EMR_ABORTPATH                  = 68;

      EMR_GDICOMMENT                 = 70;
      EMR_FILLRGN                    = 71;
      EMR_FRAMERGN                   = 72;
      EMR_INVERTRGN                  = 73;
      EMR_PAINTRGN                   = 74;
      EMR_EXTSELECTCLIPRGN           = 75;
      EMR_BITBLT                     = 76;
      EMR_STRETCHBLT                 = 77;
      EMR_MASKBLT                    = 78;
      EMR_PLGBLT                     = 79;
      EMR_SETDIBITSTODEVICE          = 80;
      EMR_STRETCHDIBITS              = 81;
      EMR_EXTCREATEFONTINDIRECTW     = 82;
      EMR_EXTTEXTOUTA                = 83;
      EMR_EXTTEXTOUTW                = 84;
      EMR_POLYBEZIER16               = 85;
      EMR_POLYGON16                  = 86;
      EMR_POLYLINE16                 = 87;
      EMR_POLYBEZIERTO16             = 88;
      EMR_POLYLINETO16               = 89;
      EMR_POLYPOLYLINE16             = 90;
      EMR_POLYPOLYGON16              = 91;
      EMR_POLYDRAW16                 = 92;
      EMR_CREATEMONOBRUSH            = 93;
      EMR_CREATEDIBPATTERNBRUSHPT    = 94;
      EMR_EXTCREATEPEN               = 95;
      EMR_POLYTEXTOUTA               = 96;
      EMR_POLYTEXTOUTW               = 97;
      EMR_SETICMMODE                 = 98;
      EMR_CREATECOLORSPACE           = 99;
      EMR_SETCOLORSPACE              =100;
      EMR_DELETECOLORSPACE           =101;
      EMR_GLSRECORD                  =102;
      EMR_GLSBOUNDEDRECORD           =103;
      EMR_PIXELFORMAT                =104;

      EMR_MIN                        =  1;
      EMR_MAX                        =104;

(* Base record type for the enhanced metafile. *)

TYPE EMR = RECORD
                  iType : DWORD; (* Enhanced metafile record type  *)
                  nSize : DWORD; (* Length of the record in bytes. *)
           END;                  (* This must be a multiple of 4.  *)
     PEMR = POINTER TO EMR;

(* Base text record type for the enhanced metafile. *)

TYPE EMRTEXT = RECORD
                      ptlReference : POINTL;
                      nChars       : DWORD;
                      offString    : DWORD; (* Offset to the string *)
                      fOptions     : ETO_SET;
                      rcl          : RECTL;
                      offDx        : DWORD; (* Offset to the inter-character spacing array. *)
               END;                         (* This is always given. *)
    PEMRTEXT = POINTER TO EMRTEXT;

(* Record structures for the enhanced metafile. *)

TYPE EMRABORTPATH = RECORD
                         emr : EMR;
                    END;
                                       PEMRABORTPATH      = POINTER TO EMRABORTPATH;
     EMRBEGINPATH      = EMRABORTPATH; PPEMRBEGINPATH     = POINTER TO EMRBEGINPATH;
     EMRENDPATH        = EMRABORTPATH; PEMRENDPATH        = POINTER TO EMRENDPATH;
     EMRCLOSEFIGURE    = EMRABORTPATH; PEMRCLOSEFIGURE    = POINTER TO EMRCLOSEFIGURE;
     EMRFLATTENPATH    = EMRABORTPATH; PEMRFLATTENPATH    = POINTER TO EMRFLATTENPATH;
     EMRWIDENPATH      = EMRABORTPATH; PEMRWIDENPATH      = POINTER TO EMRWIDENPATH;
     EMRSETMETARGN     = EMRABORTPATH; PEMRSETMETARGN     = POINTER TO EMRSETMETARGN;
     EMRSAVEDC         = EMRABORTPATH; PEMRSAVEDC         = POINTER TO EMRSAVEDC;
     EMRREALIZEPALETTE = EMRABORTPATH; PEMRREALIZEPALETTE = POINTER TO EMRREALIZEPALETTE;

TYPE EMRSELECTCLIPPATH = RECORD
                                emr   : EMR;
                                iMode : DWORD;
                         END;
                                              PEMRSELECTCLIPPATH    = POINTER TO EMRSELECTCLIPPATH;
    EMRSETBKMODE         = EMRSELECTCLIPPATH; PEMRSETBKMODE         = POINTER TO EMRSETBKMODE;
    EMRSETMAPMODE        = EMRSELECTCLIPPATH; PEMRSETMAPMODE        = POINTER TO EMRSETMAPMODE;
    EMRSETPOLYFILLMODE   = EMRSELECTCLIPPATH; PEMRSETPOLYFILLMODE   = POINTER TO EMRSETPOLYFILLMODE;
    EMRSETROP2           = EMRSELECTCLIPPATH; PEMRSETROP2           = POINTER TO EMRSETROP2;
    EMRSETSTRETCHBLTMODE = EMRSELECTCLIPPATH; PEMRSETSTRETCHBLTMODE = POINTER TO EMRSETSTRETCHBLTMODE;
    EMRSETICMMODE        = EMRSELECTCLIPPATH; PEMRSETICMMODE        = POINTER TO EMRSETICMMODE;
    EMRSETTEXTALIGN      = EMRSELECTCLIPPATH; PEMRSETTEXTALIGN      = POINTER TO EMRSETTEXTALIGN;

TYPE EMRSETMITERLIMIT = RECORD
                               emr : EMR;
                               eMiterLimit : FLOAT;
                        END;
    PEMRSETMITERLIMIT = POINTER TO EMRSETMITERLIMIT;

TYPE EMRRESTOREDC = RECORD
                           emr : EMR;
                           iRelative : LONG; (* Specifies a relative instance *)
                    END;
    PEMRRESTOREDC = POINTER TO EMRRESTOREDC;

TYPE EMRSETARCDIRECTION = RECORD
                                 emr : EMR;
                                 iArcDirection : DWORD;
                                     (* Specifies the arc direction in the
                                        advanced graphics mode. *)
                          END;
    PEMRSETARCDIRECTION = POINTER TO EMRSETARCDIRECTION;

TYPE EMRSETMAPPERFLAGS = RECORD
                                emr : EMR;
                                dwFlags : DWORD;
                         END;
    PEMRSETMAPPERFLAGS = POINTER TO EMRSETMAPPERFLAGS;


TYPE EMRSETTEXTCOLOR = RECORD
                              emr : EMR;
                              crColor : COLORREF;
                       END;
      EMRSETBKCOLOR = EMRSETTEXTCOLOR;

      PEMRSETBKCOLOR   = POINTER TO EMRSETBKCOLOR;
      PEMRSETTEXTCOLOR = POINTER TO EMRSETTEXTCOLOR;

TYPE EMRSELECTOBJECT = RECORD
                              emr : EMR;
                              ihObject : DWORD ; (* Object handle index *)
                       END;
     PEMRSELECTOBJECT = POINTER TO EMRSELECTOBJECT;
      EMRDELETEOBJECT = EMRSELECTOBJECT;
     PEMRDELETEOBJECT = POINTER TO EMRDELETEOBJECT;

TYPE EMRSELECTCOLORSPACE = RECORD
                                  emr : EMR;
                                  ihCS : DWORD; (* ColorSpace handle index *)
                           END;
    PEMRSELECTCOLORSPACE = POINTER TO EMRSELECTCOLORSPACE;
     EMRDELETECOLORSPACE = EMRSELECTCOLORSPACE;
    PEMRDELETECOLORSPACE = POINTER TO EMRDELETECOLORSPACE;

TYPE EMRSELECTPALETTE = RECORD
                               emr : EMR;
                               ihPal : DWORD; (* Palette handle index, background mode only *)
                        END;
    PEMRSELECTPALETTE = POINTER TO EMRSELECTPALETTE;

TYPE EMRRESIZEPALETTE = RECORD
                               emr : EMR;
                               ihPal : DWORD;       (* Palette handle index *)
                               cEntries : DWORD;
                        END;
    PEMRRESIZEPALETTE = POINTER TO EMRRESIZEPALETTE;

TYPE EMRSETPALETTEENTRIES =
           RECORD
                  emr         : EMR;
                  ihPal       : DWORD;   (* Palette handle index *)
                  iStart      : DWORD;
                  cEntries    : DWORD;
                  aPalEntries : ARRAY[0..0] OF PALETTEENTRY;
           END;   (* The peFlags fields do not contain any flags *)

    PEMRSETPALETTEENTRIES = POINTER TO EMRSETPALETTEENTRIES;

TYPE EMRSETCOLORADJUSTMENT = RECORD
                                    emr : EMR;
                                    ColorAdjustment : COLORADJUSTMENT;
                             END;
    PEMRSETCOLORADJUSTMENT = POINTER TO EMRSETCOLORADJUSTMENT;

TYPE EMRGDICOMMENT = RECORD
                            emr    : EMR;
                            cbData : DWORD; (* Size of data in bytes *)
                            Data   : ARRAY [0..0] OF BYTE;
                     END;
    PEMRGDICOMMENT = POINTER TO EMRGDICOMMENT;

TYPE EMREOF = RECORD
                     emr           : EMR;
                     nPalEntries   : DWORD; (* Number of palette entries *)
                     offPalEntries : DWORD; (* Offset to the palette entries *)
                     nSizeLast     : DWORD; (* Same as nSize and must be the last DWORD *)
                                            (* of the record.  The palette entries, *)
              END;                          (* if exist, precede this field. *)
    PEMREOF = POINTER TO EMREOF;

TYPE EMRLINETO = RECORD
                        emr : EMR;
                        ptl : POINTL;
                 END;
    PEMRLINETO = POINTER TO EMRLINETO;
   EMRMOVETOEX = EMRLINETO;
  PEMRMOVETOEX = POINTER TO EMRMOVETOEX;

TYPE EMROFFSETCLIPRGN = RECORD
                               emr : EMR;
                               ptlOffset : POINTL;
                        END;
    PEMROFFSETCLIPRGN = POINTER TO EMROFFSETCLIPRGN;

TYPE EMRFILLPATH = RECORD
                          emr : EMR;
                          rclBounds : RECTL; (* Inclusive-inclusive bounds in device units *)
                   END;
    PEMRFILLPATH = POINTER TO EMRFILLPATH;
    EMRSTROKEANDFILLPATH = EMRFILLPATH;
    EMRSTROKEPATH = EMRFILLPATH;
   PEMRSTROKEANDFILLPATH = POINTER TO EMRSTROKEANDFILLPATH;
   PEMRSTROKEPATH        = POINTER TO EMRSTROKEPATH;

TYPE EMREXCLUDECLIPRECT = RECORD
                                 emr : EMR;
                                 rclClip : RECTL;
                          END;
    PEMREXCLUDECLIPRECT   = POINTER TO EMREXCLUDECLIPRECT;
     EMRINTERSECTCLIPRECT = EMREXCLUDECLIPRECT;
   PEMRINTERSECTCLIPRECT  = POINTER TO EMRINTERSECTCLIPRECT;

TYPE EMRSETVIEWPORTORGEX = RECORD
                                 emr : EMR;
                                 ptlOrigin : POINTL;
                           END;

   EMRSETWINDOWORGEX =  EMRSETVIEWPORTORGEX;
   EMRSETBRUSHORGEX  =  EMRSETVIEWPORTORGEX;
  PEMRSETVIEWPORTORGEX = POINTER TO EMRSETVIEWPORTORGEX;
  PEMRSETWINDOWORGEX   = POINTER TO EMRSETWINDOWORGEX;
  PEMRSETBRUSHORGEX    = POINTER TO EMRSETBRUSHORGEX;


TYPE EMRSETVIEWPORTEXTEX = RECORD
                                  emr : EMR;
                                  szlExtent : SIZEL;
                           END;
   PEMRSETVIEWPORTEXTEX = POINTER TO EMRSETVIEWPORTEXTEX;
    EMRSETWINDOWEXTEX   = EMRSETVIEWPORTEXTEX;
   PEMRSETWINDOWEXTEX   = POINTER TO EMRSETWINDOWEXTEX;

TYPE EMRSCALEVIEWPORTEXTEX = RECORD
                                    emr    : EMR;
                                    xNum   : LONG;
                                    xDenom : LONG;
                                    yNum   : LONG;
                                    yDenom : LONG;
                             END;
    PEMRSCALEVIEWPORTEXTEX = POINTER TO EMRSCALEVIEWPORTEXTEX;
   EMRSCALEWINDOWEXTEX     = EMRSCALEVIEWPORTEXTEX;
  PEMRSCALEWINDOWEXTEX     = POINTER TO EMRSCALEWINDOWEXTEX;

TYPE EMRSETWORLDTRANSFORM = RECORD
                                   emr : EMR;
                                   xform : XFORM;
                            END;
    PEMRSETWORLDTRANSFORM = POINTER TO EMRSETWORLDTRANSFORM;

TYPE EMRMODIFYWORLDTRANSFORM = RECORD
                                      emr   : EMR;
                                      xform : XFORM;
                                      iMode : MWT_ENUM;
                               END;
    PEMRMODIFYWORLDTRANSFORM = POINTER TO EMRMODIFYWORLDTRANSFORM;

TYPE EMRSETPIXELV = RECORD
                           emr      : EMR;
                           ptlPixel : POINTL;
                           crColor  : COLORREF;
                    END;
    PEMRSETPIXELV = POINTER TO EMRSETPIXELV;

TYPE EMREXTFLOODFILL = RECORD
                              emr      : EMR;
                              ptlStart : POINTL;
                              crColor  : COLORREF;
                              iMode    : FLOODFILL_ENUM;
                       END;
    PEMREXTFLOODFILL = POINTER TO EMREXTFLOODFILL;

TYPE EMRELLIPSE = RECORD
                         emr : EMR;
                         rclBox : RECTL; (* Inclusive-inclusive bounding rectangle *)
                  END;
  PEMRELLIPSE   = POINTER TO EMRELLIPSE;
   EMRRECTANGLE = EMRELLIPSE;
  PEMRRECTANGLE = POINTER TO EMRRECTANGLE;

TYPE EMRROUNDRECT = RECORD
                           emr : EMR;
                           rclBox : RECTL;    (* Inclusive-inclusive bounding rectangle *)
                           szlCorner : SIZEL;
                    END;
    PEMRROUNDRECT = POINTER TO EMRROUNDRECT;

TYPE EMRARC = RECORD
                     emr      : EMR;
                     rclBox   : RECTL;  (* Inclusive-inclusive bounding rectangle *)
                     ptlStart : POINTL;
                     ptlEnd   : POINTL;
              END;

  EMRARCTO  = EMRARC;
  EMRCHORD  = EMRARC;
  EMRPIE    = EMRARC;
  PEMRARC   = POINTER TO EMRARC;
  PEMRARCTO = POINTER TO EMRARCTO;
  PEMRCHORD = POINTER TO EMRCHORD;
  PEMRPIE   = POINTER TO EMRPIE;

TYPE EMRANGLEARC = RECORD
                          emr : EMR;
                          ptlCenter : POINTL;
                          nRadius : DWORD;
                          eStartAngle : FLOAT;
                          eSweepAngle : FLOAT;
                   END;
    PEMRANGLEARC = POINTER TO EMRANGLEARC;

TYPE EMRPOLYLINE = RECORD
                          emr : EMR;
                          rclBounds : RECTL; (* Inclusive-inclusive bounds in device units *)
                          cptl : DWORD;
                          aptl : ARRAY [0..0] OF POINTL;
                   END;

     EMRPOLYBEZIER   = EMRPOLYLINE;
     EMRPOLYGON      = EMRPOLYLINE;
     EMRPOLYBEZIERTO = EMRPOLYLINE;
     EMRPOLYLINETO   = EMRPOLYLINE;

    PEMRPOLYLINE     = POINTER TO EMRPOLYLINE;
    PEMRPOLYBEZIER   = POINTER TO EMRPOLYBEZIER;
    PEMRPOLYGON      = POINTER TO EMRPOLYGON;
    PEMRPOLYBEZIERTO = POINTER TO EMRPOLYBEZIERTO;
    PEMRPOLYLINETO   = POINTER TO EMRPOLYLINETO;

TYPE EMRPOLYLINE16 = RECORD
                            emr : EMR;
                            rclBounds : RECTL; (* Inclusive-inclusive bounds in device units *)
                            cpts : DWORD;
                            apts : ARRAY [0..0] OF POINTS;
                     END;
     EMRPOLYBEZIER16   =  EMRPOLYLINE16;
     EMRPOLYGON16      =  EMRPOLYLINE16;
     EMRPOLYBEZIERTO16 =  EMRPOLYLINE16;
     EMRPOLYLINETO16   =  EMRPOLYLINE16;

    PEMRPOLYLINE16     = POINTER TO EMRPOLYLINE16;
    PEMRPOLYBEZIER16   = POINTER TO EMRPOLYBEZIER16;
    PEMRPOLYGON16      = POINTER TO EMRPOLYGON16;
    PEMRPOLYBEZIERTO16 = POINTER TO EMRPOLYBEZIERTO16;
    PEMRPOLYLINETO16   = POINTER TO EMRPOLYLINETO16;

TYPE EMRPOLYDRAW =
     RECORD
            emr : EMR;
            rclBounds : RECTL;              (* Inclusive-inclusive bounds in device units *)
            cptl : DWORD;                   (* Number of points *)
            aptl : ARRAY [0..0] OF POINTL;  (* Array of points *)
            abTypes : ARRAY [0..0] OF BYTE; (* Array of point types *)
     END;
    PEMRPOLYDRAW = POINTER TO EMRPOLYDRAW;

TYPE EMRPOLYDRAW16 =
     RECORD
            emr       : EMR;
            rclBounds : RECTL;                  (* Inclusive-inclusive bounds in device units *)
            cpts      : DWORD;                  (* Number of points *)
            apts      : ARRAY [0..0] OF POINTS; (* Array of points  *)
            abTypes   : ARRAY [0..0] OF BYTE;   (* Array of point types *)
     END;
    PEMRPOLYDRAW16 = POINTER TO EMRPOLYDRAW16;

TYPE EMRPOLYPOLYLINE =
     RECORD
            emr : EMR;
            rclBounds : RECTL;          (* Inclusive-inclusive bounds in device units *)
            nPolys : DWORD;             (* Number of polys *)
            cptl : DWORD;               (* Total number of points in all polys *)
            aPolyCounts : ARRAY [0..0] OF DWORD; (* Array of point counts for each poly *)
            aptl : ARRAY [0..0] OF POINTL;       (* Array of points *)
     END;
     EMRPOLYPOLYGON  = EMRPOLYPOLYLINE;
    PEMRPOLYPOLYLINE = POINTER TO EMRPOLYPOLYLINE;
    PEMRPOLYPOLYGON  = POINTER TO EMRPOLYPOLYGON;

TYPE EMRPOLYPOLYLINE16 =
     RECORD
            emr         : EMR;
            rclBounds   : RECTL;          (* Inclusive-inclusive bounds in device units *)
            nPolys      : DWORD;          (* Number of polys *)
            cpts        : DWORD;          (* Total number of points in all polys *)
            aPolyCounts : ARRAY [0..0] OF DWORD;     (* Array of point counts for each poly *)
            apts        : ARRAY [0..0] OF POINTS;    (* Array of points *)
     END;
     EMRPOLYPOLYGON16 = EMRPOLYPOLYLINE16;
    PEMRPOLYPOLYLINE16 = POINTER TO EMRPOLYPOLYLINE16;
    PEMRPOLYPOLYGON16  = POINTER TO EMRPOLYPOLYGON16;

TYPE EMRINVERTRGN =
     RECORD
            emr : EMR;
            rclBounds : RECTL;          (* Inclusive-inclusive bounds in device units *)
            cbRgnData : DWORD;          (* Size of region data in bytes *)
            RgnData : ARRAY [0..0] OF BYTE;
     END;
     EMRPAINTRGN = EMRINVERTRGN;
    PEMRINVERTRGN = POINTER TO EMRINVERTRGN;
    PEMRPAINTRGN  = POINTER TO EMRPAINTRGN;

TYPE EMRFILLRGN =
     RECORD
            emr : EMR;
            rclBounds : RECTL;            (* Inclusive-inclusive bounds in device units *)
            cbRgnData : DWORD;            (* Size of region data in bytes *)
            ihBrush   : DWORD;            (* Brush handle index *)
            RgnData   : ARRAY [0..0] OF BYTE;
     END;
     PEMRFILLRGN = POINTER TO EMRFILLRGN;

TYPE EMRFRAMERGN =
     RECORD
            emr       : EMR;
            rclBounds : RECTL;          (* Inclusive-inclusive bounds in device units *)
            cbRgnData : DWORD;          (* Size of region data in bytes *)
            ihBrush   : DWORD;          (* Brush handle index *)
            szlStroke : SIZEL;
            RgnData   : ARRAY [0..0] OF BYTE;
     END;
     PEMRFRAMERGN = POINTER TO EMRFRAMERGN;

TYPE EMREXTSELECTCLIPRGN =
     RECORD
            emr : EMR;
            cbRgnData : DWORD;         (* Size of region data in bytes *)
            iMode     : RGN_COMBINE_ENUM;
            RgnData   : ARRAY [0..0] OF BYTE;
     END;
     PEMREXTSELECTCLIPRGN = POINTER TO EMREXTSELECTCLIPRGN;

TYPE EMREXTTEXTOUTA =
     RECORD
            emr : EMR;
            rclBounds : RECTL;       (* Inclusive-inclusive bounds in device units *)
            iGraphicsMode : GM_ENUM; (* Current graphics mode *)
            exScale : FLOAT;         (* X and Y scales from Page units to .01mm units *)
            eyScale : FLOAT;         (* if graphics mode is GM_COMPATIBLE. *)
            emrtext : EMRTEXT;       (* This is followed by the string and spacing array *)
     END;
     EMREXTTEXTOUTW = EMREXTTEXTOUTA;
    PEMREXTTEXTOUTA = POINTER TO EMREXTTEXTOUTA;
    PEMREXTTEXTOUTW = POINTER TO EMREXTTEXTOUTW;


TYPE EMRPOLYTEXTOUTA =
     RECORD
            emr : EMR;
            rclBounds : RECTL;          (* Inclusive-inclusive bounds in device units *)
            iGraphicsMode : GM_ENUM;    (* Current graphics mode *)
            exScale : FLOAT;            (* X and Y scales from Page units to .01mm units *)
            eyScale : FLOAT;            (*   if graphics mode is GM_COMPATIBLE. *)
            cStrings : LONG;
            aemrtext : ARRAY [0..0] OF EMRTEXT; (* Array of EMRTEXT structures.  This is *)
                                                (* followed by the strings and spacing arrays. *)
     END;
     EMRPOLYTEXTOUTW  = EMRPOLYTEXTOUTA;
     PEMRPOLYTEXTOUTA = POINTER TO EMRPOLYTEXTOUTA;
     PEMRPOLYTEXTOUTW = POINTER TO EMRPOLYTEXTOUTW;

TYPE EMRBITBLT =
     RECORD
            emr          : EMR;
            rclBounds    : RECTL;    (* Inclusive-inclusive bounds in device units *)
            xDest        : LONG;
            yDest        : LONG;
            cxDest       : LONG;
            cyDest       : LONG;
            dwRop        : ROP;
            xSrc         : LONG;
            ySrc         : LONG;
            xformSrc     : XFORM;    (* Source DC transform *)
            crBkColorSrc : COLORREF; (* Source DC BkColor in RGB *)
            iUsageSrc    : DIB_COLOR_ENUM; (* Source bitmap info color table usage *)
                                     (* (DIB_RGB_COLORS) *)
            offBmiSrc    : DWORD;    (* Offset to the source BITMAPINFO structure *)
            cbBmiSrc     : DWORD;    (* Size of the source BITMAPINFO structure *)
            offBitsSrc   : DWORD;    (* Offset to the source bitmap bits *)
            cbBitsSrc    : DWORD;    (* Size of the source bitmap bits *)
END;
PEMRBITBLT = POINTER TO EMRBITBLT;

TYPE EMRSTRETCHBLT =
     RECORD
            emr          : EMR;
            rclBounds    : RECTL;          (* Inclusive-inclusive bounds in device units *)
            xDest        : LONG;
            yDest        : LONG;
            cxDest       : LONG;
            cyDest       : LONG;
            dwRop        : ROP;
            xSrc         : LONG;
            ySrc         : LONG;
            xformSrc     : XFORM;          (* Source DC transform *)
            crBkColorSrc : COLORREF;       (* Source DC BkColor in RGB *)
            iUsageSrc    : DIB_COLOR_ENUM; (* Source bitmap info color table usage *)
                                           (* (DIB_RGB_COLORS) *)
            offBmiSrc    : DWORD;          (* Offset to the source BITMAPINFO structure *)
            cbBmiSrc     : DWORD;          (* Size of the source BITMAPINFO structure *)
            offBitsSrc   : DWORD;          (* Offset to the source bitmap bits *)
            cbBitsSrc    : DWORD;          (* Size of the source bitmap bits *)
            cxSrc        : LONG;
            cySrc        : LONG;
     END;
     PEMRSTRETCHBLT = POINTER TO EMRSTRETCHBLT;

TYPE EMRMASKBLT =
     RECORD
            emr          : EMR;
            rclBounds    : RECTL;  (* Inclusive-inclusive bounds in device units *)
            xDest        : LONG;
            yDest        : LONG;
            cxDest       : LONG;
            cyDest       : LONG;
            dwRop        : ROP;
            xSrc         : LONG;
            ySrc         : LONG;
            xformSrc     : XFORM;          (* Source DC transform *)
            crBkColorSrc : COLORREF;       (* Source DC BkColor in RGB *)
            iUsageSrc    : DIB_COLOR_ENUM; (* Source bitmap info color table usage *)
            offBmiSrc    : DWORD;          (* Offset to the source BITMAPINFO structure *)
            cbBmiSrc     : DWORD;          (* Size of the source BITMAPINFO structure *)
            offBitsSrc   : DWORD;          (* Offset to the source bitmap bits *)
            cbBitsSrc    : DWORD;          (* Size of the source bitmap bits *)
            xMask        : LONG;
            yMask        : LONG;
            iUsageMask   : DIB_COLOR_ENUM; (* Mask bitmap info color table usage *)
            offBmiMask   : DWORD;          (* Offset to the mask BITMAPINFO structure if any *)
            cbBmiMask    : DWORD;          (* Size of the mask BITMAPINFO structure if any *)
            offBitsMask  : DWORD;          (* Offset to the mask bitmap bits if any *)
            cbBitsMask   : DWORD;          (* Size of the mask bitmap bits if any *)
     END;
     PEMRMASKBLT = POINTER TO EMRMASKBLT;

TYPE EMRPLGBLT =
     RECORD
            emr          : EMR;
            rclBounds    : RECTL;         (* Inclusive-inclusive bounds in device units *)
            aptlDest     : ARRAY [0..2] OF POINTL;
            xSrc         : LONG;
            ySrc         : LONG;
            cxSrc        : LONG;
            cySrc        : LONG;
            xformSrc     : XFORM;         (* Source DC transform *)
            crBkColorSrc : COLORREF;      (* Source DC BkColor in RGB *)
            iUsageSrc    : DIB_COLOR_ENUM;(* Source bitmap info color table usage *)
            offBmiSrc    : DWORD;         (* Offset to the source BITMAPINFO structure *)
            cbBmiSrc     : DWORD;         (* Size of the source BITMAPINFO structure *)
            offBitsSrc   : DWORD;         (* Offset to the source bitmap bits *)
            cbBitsSrc    : DWORD;         (* Size of the source bitmap bits *)
            xMask        : LONG;
            yMask        : LONG;
            iUsageMask   : DIB_COLOR_ENUM; (* Mask bitmap info color table usage *)
            offBmiMask   : DWORD;          (* Offset to the mask BITMAPINFO structure if any *)
            cbBmiMask    : DWORD;          (* Size of the mask BITMAPINFO structure if any *)
            offBitsMask  : DWORD;          (* Offset to the mask bitmap bits if any *)
            cbBitsMask   : DWORD;          (* Size of the mask bitmap bits if any *)
     END;
     PEMRPLGBLT = POINTER TO EMRPLGBLT;

TYPE EMRSETDIBITSTODEVICE =
     RECORD
            emr        : EMR;
            rclBounds  : RECTL;          (* Inclusive-inclusive bounds in device units *)
            xDest      : LONG;
            yDest      : LONG;
            xSrc       : LONG;
            ySrc       : LONG;
            cxSrc      : LONG;
            cySrc      : LONG;
            offBmiSrc  : DWORD;         (* Offset to the source BITMAPINFO structure *)
            cbBmiSrc   : DWORD;         (* Size of the source BITMAPINFO structure *)
            offBitsSrc : DWORD;         (* Offset to the source bitmap bits *)
            cbBitsSrc  : DWORD;         (* Size of the source bitmap bits *)
            iUsageSrc  : DIB_COLOR_ENUM;(* Source bitmap info color table usage *)
            iStartScan : DWORD;
            cScans     : DWORD;
     END;
    PEMRSETDIBITSTODEVICE = POINTER TO EMRSETDIBITSTODEVICE;

TYPE EMRSTRETCHDIBITS =
     RECORD
            emr        : EMR;
            rclBounds  : RECTL;          (* Inclusive-inclusive bounds in device units *)
            xDest      : LONG;
            yDest      : LONG;
            xSrc       : LONG;
            ySrc       : LONG;
            cxSrc      : LONG;
            cySrc      : LONG;
            offBmiSrc  : DWORD;          (* Offset to the source BITMAPINFO structure *)
            cbBmiSrc   : DWORD;          (* Size of the source BITMAPINFO structure *)
            offBitsSrc : DWORD;          (* Offset to the source bitmap bits *)
            cbBitsSrc  : DWORD;          (* Size of the source bitmap bits *)
            iUsageSrc  : DIB_COLOR_ENUM; (* Source bitmap info color table usage *)
            dwRop      : ROP;
            cxDest     : LONG;
            cyDest     : LONG;
     END;
     PEMRSTRETCHDIBITS = POINTER TO EMRSTRETCHDIBITS;

TYPE EMREXTCREATEFONTINDIRECTW = RECORD
                                        emr : EMR;
                                        ihFont : DWORD; (* Font handle index *)
                                        elfw : EXTLOGFONTW;
                                 END;
    PEMREXTCREATEFONTINDIRECTW = POINTER TO EMREXTCREATEFONTINDIRECTW;

TYPE EMRCREATEPALETTE = RECORD
                               emr   : EMR;
                               ihPal : DWORD;      (* Palette handle index *)
                               lgpl  : LOGPALETTE; (* The peFlags fields in the palette entries *)
                        END;                       (* do not contain any flags *)
    PEMRCREATEPALETTE = POINTER TO EMRCREATEPALETTE;

TYPE EMRCREATECOLORSPACE = RECORD
                                  emr  : EMR;
                                  ihCS : DWORD; (* ColorSpace handle index *)
                                  lcs  : LOGCOLORSPACEW;
                           END;
    PEMRCREATECOLORSPACE = POINTER TO EMRCREATECOLORSPACE;

TYPE EMRCREATEPEN = RECORD
                           emr : EMR;
                           ihPen : DWORD; (* Pen handle index *)
                           lopn : LOGPEN;
                    END;
    PEMRCREATEPEN = POINTER TO EMRCREATEPEN;

TYPE EMREXTCREATEPEN =
     RECORD
            emr     : EMR;
            ihPen   : DWORD;     (* Pen handle index *)
            offBmi  : DWORD;     (* Offset to the BITMAPINFO structure if any *)
            cbBmi   : DWORD;     (* Size of the BITMAPINFO structure if any *)
                                 (* The bitmap info is followed by the bitmap *)
                                 (* bits to form a packed DIB. *)
            offBits : DWORD;     (* Offset to the brush bitmap bits if any *)
            cbBits  : DWORD;     (* Size of the brush bitmap bits if any *)
            elp     : EXTLOGPEN; (* The extended pen with the style array. *)
     END;
     PEMREXTCREATEPEN = POINTER TO EMREXTCREATEPEN;

TYPE EMRCREATEBRUSHINDIRECT =
     RECORD
            emr     : EMR;
            ihBrush : DWORD;    (* Brush handle index *)
            lb      : LOGBRUSH; (* The style must be BS_SOLID, BS_HOLLOW, *)
                                (* BS_NULL or BS_HATCHED. *)
     END;
     PEMRCREATEBRUSHINDIRECT = POINTER TO EMRCREATEBRUSHINDIRECT;

TYPE EMRCREATEMONOBRUSH =
     RECORD
            emr     : EMR;
            ihBrush : DWORD;            (* Brush handle index *)
            iUsage  : DIB_COLOR_ENUM;   (* Bitmap info color table usage *)
            offBmi  : DWORD;            (* Offset to the BITMAPINFO structure *)
            cbBmi   : DWORD;            (* Size of the BITMAPINFO structure *)
            offBits : DWORD;            (* Offset to the bitmap bits *)
            cbBits  : DWORD;            (* Size of the bitmap bits *)
     END;
     PEMRCREATEMONOBRUSH = POINTER TO EMRCREATEMONOBRUSH;

TYPE EMRCREATEDIBPATTERNBRUSHPT =
     RECORD
            emr     : EMR;
            ihBrush : DWORD;    (* Brush handle index *)
            iUsage  : DWORD;    (* Bitmap info color table usage *)
            offBmi  : DWORD;    (* Offset to the BITMAPINFO structure *)
            cbBmi   : DWORD;    (* Size of the BITMAPINFO structure *)
                                (* The bitmap info is followed by the bitmap *)
                                (* bits to form a packed DIB. *)
            offBits : DWORD;    (* Offset to the bitmap bits *)
            cbBits  : DWORD;    (* Size of the bitmap bits *)
     END;
     PEMRCREATEDIBPATTERNBRUSHPT = POINTER TO EMRCREATEDIBPATTERNBRUSHPT;


TYPE EMRFORMAT =
     RECORD
            dSignature : DWORD;  (* Format signature, e.g. ENHMETA_SIGNATURE. *)
            nVersion : DWORD;    (* Format version number. *)
            cbData : DWORD;      (* Size of data in bytes. *)
            offData : DWORD;     (* Offset to data from GDICOMMENT_IDENTIFIER. *)
                                 (* It must begin at a DWORD offset. *)
     END;
     PEMRFORMAT = POINTER TO EMRFORMAT;

TYPE EMRGLSRECORD =
     RECORD
            emr : EMR;
            cbData : DWORD;             (* Size of data in bytes *)
            Data : ARRAY [0..0] OF BYTE;
     END;
     PEMRGLSRECORD = POINTER TO EMRGLSRECORD;

TYPE EMRGLSBOUNDEDRECORD =
     RECORD
            emr : EMR;
            rclBounds : RECTL;          (* Bounds in recording coordinates *)
            cbData : DWORD;             (* Size of data in bytes *)
            Data : ARRAY [0..0] OF BYTE;
     END;
     PEMRGLSBOUNDEDRECORD = POINTER TO EMRGLSBOUNDEDRECORD;

TYPE EMRPIXELFORMAT =
     RECORD
            emr : EMR;
            pfd : PIXELFORMATDESCRIPTOR;
     END;
     PEMRPIXELFORMAT = POINTER  TO EMRPIXELFORMAT;


CONST GDICOMMENT_IDENTIFIER        = 43494447h;
      GDICOMMENT_WINDOWS_METAFILE  = 80000001h;
      GDICOMMENT_BEGINGROUP        = 00000002h;
      GDICOMMENT_ENDGROUP          = 00000003h;
      GDICOMMENT_MULTIFORMATS      = 40000004h;
      EPS_SIGNATURE                = 46535045h;

<* END *>  (* NOT DEFINED (NOMETAFILE) *)


(* OpenGL wgl prototypes *)

PROCEDURE wglCopyContext (src : HGLRC; dst : HGLRC; mask : UINT) : BOOL;
PROCEDURE wglCreateContext (hdc : HDC) : HGLRC;
PROCEDURE wglCreateLayerContext (hdc : HDC; LayerPlane : INTEGER) : HGLRC;
PROCEDURE wglDeleteContext (hglrc : HGLRC) : BOOL;
PROCEDURE wglGetCurrentContext (): HGLRC;
PROCEDURE wglGetCurrentDC (): HDC;
PROCEDURE wglGetProcAddress (proc : ARRAY OF CHAR) : PROC;
PROCEDURE wglMakeCurrent (hdc : HDC; hrlrc : HGLRC) : BOOL;
PROCEDURE wglShareLists (hglrc1, hglrc2 : HGLRC) : BOOL;
PROCEDURE wglUseFontBitmapsA (hdc : HDC; first : DWORD; count : DWORD; listbase : DWORD) : BOOL;
PROCEDURE wglUseFontBitmapsW (hdc : HDC; first : DWORD; count : DWORD; listbase : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST wglUseFontBitmaps = wglUseFontBitmapsW;
<* ELSE *>
      CONST wglUseFontBitmaps = wglUseFontBitmapsA;
<* END *>

PROCEDURE SwapBuffers (hdc : HDC) : BOOL;

TYPE POINTFLOAT = RECORD
                         x : FLOAT;
                         y : FLOAT;
                  END;
    PPOINTFLOAT = POINTER TO POINTFLOAT;

TYPE GLYPHMETRICSFLOAT = RECORD
                                gmfBlackBoxX : FLOAT;
                                gmfBlackBoxY : FLOAT;
                                gmfptGlyphOrigin : POINTFLOAT;
                                gmfCellIncX : FLOAT;
                                gmfCellIncY : FLOAT;
                         END;
    PGLYPHMETRICSFLOAT = POINTER TO GLYPHMETRICSFLOAT;

TYPE WGI_FONT_ENUM = (WGL_FONT_LINES,     (* 0 *)
                      WGL_FONT_POLYGONS); (* 1 *)

PROCEDURE wglUseFontOutlinesA (hdc       : HDC;
                               first     : DWORD;
                               count     : DWORD;
                               listbase  : DWORD;
                               deviation : FLOAT;
                               extursion : FLOAT;
                               format    : WGI_FONT_ENUM;
                               VAR [NIL] gmf : ARRAY OF GLYPHMETRICSFLOAT) : BOOL;
PROCEDURE wglUseFontOutlinesW (hdc       : HDC;
                               first     : DWORD;
                               count     : DWORD;
                               listbase  : DWORD;
                               deviation : FLOAT;
                               extursion : FLOAT;
                               format    : WGI_FONT_ENUM;
                               VAR [NIL] gmf : ARRAY OF GLYPHMETRICSFLOAT) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST wglUseFontOutlines = wglUseFontOutlinesW;
<* ELSE *>
      CONST wglUseFontOutlines = wglUseFontOutlinesA;
<* END *>

(* LAYERPLANEDESCRIPTOR flags *)

TYPE LPD_ENUM = (LPD__DOUBLEBUFFER,       (* 0 *)
                 LPD__STEREO,             (* 1 *)
                 LPD__2, LPD__3,
                 LPD__SUPPORT_GDI,        (* 4 *)
                 LPD__SUPPORT_OPENGL,     (* 5*)
                 LPD__SHARE_DEPTH,        (* 6 *)
                 LPD__SHARE_STENCIL,      (* 7 *)
                 LPD__SHARE_ACCUM,        (* 8 *)
                 LPD__SWAP_EXCHANGE,      (* 9 *)
                 LPD__SWAP_COPY,          (* 10 *)
                 LPD__11,
                 LPD__TRANSPARENT);       (* 12 *)

TYPE LPD_SET = SET OF LPD_ENUM;

CONST LPD_DOUBLEBUFFER   = LPD_SET {LPD__DOUBLEBUFFER  }; (* 0x00000001 *)
      LPD_STEREO         = LPD_SET {LPD__STEREO        }; (* 0x00000002 *)
      LPD_SUPPORT_GDI    = LPD_SET {LPD__SUPPORT_GDI   }; (* 0x00000010 *)
      LPD_SUPPORT_OPENGL = LPD_SET {LPD__SUPPORT_OPENGL}; (* 0x00000020 *)
      LPD_SHARE_DEPTH    = LPD_SET {LPD__SHARE_DEPTH   }; (* 0x00000040 *)
      LPD_SHARE_STENCIL  = LPD_SET {LPD__SHARE_STENCIL }; (* 0x00000080 *)
      LPD_SHARE_ACCUM    = LPD_SET {LPD__SHARE_ACCUM   }; (* 0x00000100 *)
      LPD_SWAP_EXCHANGE  = LPD_SET {LPD__SWAP_EXCHANGE }; (* 0x00000200 *)
      LPD_SWAP_COPY      = LPD_SET {LPD__SWAP_COPY     }; (* 0x00000400 *)
      LPD_TRANSPARENT    = LPD_SET {LPD__TRANSPARENT   }; (* 0x00001000 *)

<* PUSH *> <* ENUMSIZE = "1" *>

TYPE LPD_TYPE_ENUM = (LPD_TYPE_RGBA,        (* 0 *)
                      LPD_TYPE_COLORINDEX); (* 1 *)

<* POP *>

TYPE LAYERPLANEDESCRIPTOR = RECORD
                                   nSize           : WORD;
                                   nVersion        : WORD;
                                   dwFlags         : LPD_SET;
                                   iPixelType      : LPD_TYPE_ENUM;
                                   cColorBits      : BYTE;
                                   cRedBits        : BYTE;
                                   cRedShift       : BYTE;
                                   cGreenBits      : BYTE;
                                   cGreenShift     : BYTE;
                                   cBlueBits       : BYTE;
                                   cBlueShift      : BYTE;
                                   cAlphaBits      : BYTE;
                                   cAlphaShift     : BYTE;
                                   cAccumBits      : BYTE;
                                   cAccumRedBits   : BYTE;
                                   cAccumGreenBits : BYTE;
                                   cAccumBlueBits  : BYTE;
                                   cAccumAlphaBits : BYTE;
                                   cDepthBits      : BYTE;
                                   cStencilBits    : BYTE;
                                   cAuxBuffers     : BYTE;
                                   iLayerPlane     : BYTE;
                                   bReserved       : BYTE;
                                   crTransparent   : COLORREF;
                            END;
     PLAYERPLANEDESCRIPTOR = POINTER TO LAYERPLANEDESCRIPTOR;

(* wglSwapLayerBuffers flags *)

TYPE WGL_SWAP_ENUM = (WGL_SWAP__MAIN_PLANE,     (*  0 *)
                      WGL_SWAP__OVERLAY1,       (*  1 *)
                      WGL_SWAP__OVERLAY2,       (*  2 *)
                      WGL_SWAP__OVERLAY3,       (*  3 *)
                      WGL_SWAP__OVERLAY4,       (*  4 *)
                      WGL_SWAP__OVERLAY5,       (*  5 *)
                      WGL_SWAP__OVERLAY6,       (*  6 *)
                      WGL_SWAP__OVERLAY7,       (*  7 *)
                      WGL_SWAP__OVERLAY8,       (*  8 *)
                      WGL_SWAP__OVERLAY9,       (*  9 *)
                      WGL_SWAP__OVERLAY10,      (* 10 *)
                      WGL_SWAP__OVERLAY11,      (* 11 *)
                      WGL_SWAP__OVERLAY12,      (* 12 *)
                      WGL_SWAP__OVERLAY13,      (* 13 *)
                      WGL_SWAP__OVERLAY14,      (* 14 *)
                      WGL_SWAP__OVERLAY15,      (* 15 *)
                      WGL_SWAP__UNDERLAY1,      (* 16 *)
                      WGL_SWAP__UNDERLAY2,      (* 17 *)
                      WGL_SWAP__UNDERLAY3,      (* 18 *)
                      WGL_SWAP__UNDERLAY4,      (* 19 *)
                      WGL_SWAP__UNDERLAY5,      (* 20 *)
                      WGL_SWAP__UNDERLAY6,      (* 21 *)
                      WGL_SWAP__UNDERLAY7,      (* 22 *)
                      WGL_SWAP__UNDERLAY8,      (* 23 *)
                      WGL_SWAP__UNDERLAY9,      (* 24 *)
                      WGL_SWAP__UNDERLAY10,     (* 25 *)
                      WGL_SWAP__UNDERLAY11,     (* 26 *)
                      WGL_SWAP__UNDERLAY12,     (* 27 *)
                      WGL_SWAP__UNDERLAY13,     (* 28 *)
                      WGL_SWAP__UNDERLAY14,     (* 29 *)
                      WGL_SWAP__UNDERLAY15);    (* 30 *)

      WGL_SWAP_SET = SET OF WGL_SWAP_ENUM;

CONST WGL_SWAP_MAIN_PLANE = WGL_SWAP_SET {WGL_SWAP__MAIN_PLANE}; (* 0x00000001 *)
      WGL_SWAP_OVERLAY1   = WGL_SWAP_SET {WGL_SWAP__OVERLAY1  }; (* 0x00000002 *)
      WGL_SWAP_OVERLAY2   = WGL_SWAP_SET {WGL_SWAP__OVERLAY2  }; (* 0x00000004 *)
      WGL_SWAP_OVERLAY3   = WGL_SWAP_SET {WGL_SWAP__OVERLAY3  }; (* 0x00000008 *)
      WGL_SWAP_OVERLAY4   = WGL_SWAP_SET {WGL_SWAP__OVERLAY4  }; (* 0x00000010 *)
      WGL_SWAP_OVERLAY5   = WGL_SWAP_SET {WGL_SWAP__OVERLAY5  }; (* 0x00000020 *)
      WGL_SWAP_OVERLAY6   = WGL_SWAP_SET {WGL_SWAP__OVERLAY6  }; (* 0x00000040 *)
      WGL_SWAP_OVERLAY7   = WGL_SWAP_SET {WGL_SWAP__OVERLAY7  }; (* 0x00000080 *)
      WGL_SWAP_OVERLAY8   = WGL_SWAP_SET {WGL_SWAP__OVERLAY8  }; (* 0x00000100 *)
      WGL_SWAP_OVERLAY9   = WGL_SWAP_SET {WGL_SWAP__OVERLAY9  }; (* 0x00000200 *)
      WGL_SWAP_OVERLAY10  = WGL_SWAP_SET {WGL_SWAP__OVERLAY10 }; (* 0x00000400 *)
      WGL_SWAP_OVERLAY11  = WGL_SWAP_SET {WGL_SWAP__OVERLAY11 }; (* 0x00000800 *)
      WGL_SWAP_OVERLAY12  = WGL_SWAP_SET {WGL_SWAP__OVERLAY12 }; (* 0x00001000 *)
      WGL_SWAP_OVERLAY13  = WGL_SWAP_SET {WGL_SWAP__OVERLAY13 }; (* 0x00002000 *)
      WGL_SWAP_OVERLAY14  = WGL_SWAP_SET {WGL_SWAP__OVERLAY14 }; (* 0x00004000 *)
      WGL_SWAP_OVERLAY15  = WGL_SWAP_SET {WGL_SWAP__OVERLAY15 }; (* 0x00008000 *)
      WGL_SWAP_UNDERLAY1  = WGL_SWAP_SET {WGL_SWAP__UNDERLAY1 }; (* 0x00010000 *)
      WGL_SWAP_UNDERLAY2  = WGL_SWAP_SET {WGL_SWAP__UNDERLAY2 }; (* 0x00020000 *)
      WGL_SWAP_UNDERLAY3  = WGL_SWAP_SET {WGL_SWAP__UNDERLAY3 }; (* 0x00040000 *)
      WGL_SWAP_UNDERLAY4  = WGL_SWAP_SET {WGL_SWAP__UNDERLAY4 }; (* 0x00080000 *)
      WGL_SWAP_UNDERLAY5  = WGL_SWAP_SET {WGL_SWAP__UNDERLAY5 }; (* 0x00100000 *)
      WGL_SWAP_UNDERLAY6  = WGL_SWAP_SET {WGL_SWAP__UNDERLAY6 }; (* 0x00200000 *)
      WGL_SWAP_UNDERLAY7  = WGL_SWAP_SET {WGL_SWAP__UNDERLAY7 }; (* 0x00400000 *)
      WGL_SWAP_UNDERLAY8  = WGL_SWAP_SET {WGL_SWAP__UNDERLAY8 }; (* 0x00800000 *)
      WGL_SWAP_UNDERLAY9  = WGL_SWAP_SET {WGL_SWAP__UNDERLAY9 }; (* 0x01000000 *)
      WGL_SWAP_UNDERLAY10 = WGL_SWAP_SET {WGL_SWAP__UNDERLAY10}; (* 0x02000000 *)
      WGL_SWAP_UNDERLAY11 = WGL_SWAP_SET {WGL_SWAP__UNDERLAY11}; (* 0x04000000 *)
      WGL_SWAP_UNDERLAY12 = WGL_SWAP_SET {WGL_SWAP__UNDERLAY12}; (* 0x08000000 *)
      WGL_SWAP_UNDERLAY13 = WGL_SWAP_SET {WGL_SWAP__UNDERLAY13}; (* 0x10000000 *)
      WGL_SWAP_UNDERLAY14 = WGL_SWAP_SET {WGL_SWAP__UNDERLAY14}; (* 0x20000000 *)
      WGL_SWAP_UNDERLAY15 = WGL_SWAP_SET {WGL_SWAP__UNDERLAY15}; (* 0x40000000 *)

PROCEDURE wglDescribeLayerPlane (hdc : HDC; PixelFormat : INTEGER;
                                 LayerPlane : INTEGER;
                                 nBytes : UINT;
                                 VAR lpd : LAYERPLANEDESCRIPTOR) : BOOL;

PROCEDURE wglSetLayerPaletteEntries (hdc : HDC;
                                     LayerPlane : INTEGER;
                                     Start : INTEGER;
                                     nEntries : INTEGER;
                                     cr : ARRAY OF COLORREF) : INTEGER;

PROCEDURE wglGetLayerPaletteEntries (hdc : HDC;
                                     LayerPlane : INTEGER;
                                     Start : INTEGER;
                                     nEntries : INTEGER;
                                     VAR cr : ARRAY OF COLORREF) : INTEGER;

PROCEDURE wglRealizeLayerPalette (hdc : HDC; LayerPlane : INTEGER; Realize : BOOL) : BOOL;
PROCEDURE wglSwapLayerBuffers (hdc : HDC; Planes : WGL_SWAP_SET) : BOOL;






(* ----------------------------------------------------- *)

TYPE HDWP = HANDLE;
TYPE PMENUTEMPLATEA = PVOID;
     PMENUTEMPLATEW = PVOID;

TYPE WNDPROC = PROCEDURE (HWND, UINT, WPARAM, LPARAM) : LRESULT;
     DLGPROC = PROCEDURE (HWND, UINT, WPARAM, LPARAM) : BOOL;
     TIMERPROC = PROCEDURE (HWND,
                            (* Msg     : *) UINT,
                            (* IdEvent : *) UINT,
                            (* Time    : *) DWORD);
     GRAYSTRINGPROC = PROCEDURE (HDC, LPARAM, INTEGER) : BOOL;
     WNDENUMPROC   = PROCEDURE (HWND, LPARAM) : BOOL;
     HOOKPROC      = PROCEDURE ((* code : *) INTEGER,
                                (* wParam : *) WPARAM,
                                (* lParam : *) LPARAM) : LRESULT;
     SENDASYNCPROC = PROCEDURE (HWND, UINT, DWORD, LRESULT);

TYPE PROPENUMPROCW   = PROCEDURE (HWND, ARRAY OF WCHAR, HANDLE) : BOOL;
     PROPENUMPROCA   = PROCEDURE (HWND, ARRAY OF CHAR,  HANDLE) : BOOL;
     PROPENUMPROCEXW = PROCEDURE (HWND, ARRAY OF WCHAR, HANDLE, DWORD) : BOOL;
     PROPENUMPROCEXA = PROCEDURE (HWND, ARRAY OF CHAR,  HANDLE, DWORD) : BOOL;

TYPE PCREATESTRUCTA = POINTER TO CREATESTRUCTA; (* used before definition in *)
     PCREATESTRUCTW = POINTER TO CREATESTRUCTW; (* CBT_CREATEWNDA *)

(*
 * EDITWORDBREAKPROC code values
 *)

TYPE WB_ENUM = (WB_LEFT, WB_RIGHT, WB_ISDELIMITER);

TYPE EDITWORDBREAKPROCA = PROCEDURE ((* lpch    : *) ARRAY OF CHAR,
                                     (* Current : *) INTEGER,
                                     (* cch     : *) INTEGER,
                                     (* code    : *) WB_ENUM) : INTEGER;

TYPE EDITWORDBREAKPROCW = PROCEDURE ((* lpch    : *) ARRAY OF WCHAR,
                                     (* Current : *) INTEGER,
                                     (* cch     : *) INTEGER,
                                     (* code    : *) WB_ENUM) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      TYPE PROPENUMPROC      = PROPENUMPROCW;
           PROPENUMPROCEX    = PROPENUMPROCEXW;
           EDITWORDBREAKPROC = EDITWORDBREAKPROCW;
<* ELSE *>
      TYPE PROPENUMPROC      = PROPENUMPROCA;
           PROPENUMPROCEX    = PROPENUMPROCEXA;
           EDITWORDBREAKPROC = EDITWORDBREAKPROCA;
<* END *>

TYPE DRAWSTATEPROC = PROCEDURE ((* hdc :   *) HDC,
                                (* lData : *) LPARAM,
                                (* wData : *) WPARAM,
                                (* cx :    *) INTEGER,
                                (* cy :    *) INTEGER) : BOOL;

TYPE  NAMEENUMPROCA = PROCEDURE (PSTR,  LPARAM) : BOOL;
      NAMEENUMPROCW = PROCEDURE (PWSTR, LPARAM) : BOOL;

TYPE   WINSTAENUMPROCA  = NAMEENUMPROCA;
       DESKTOPENUMPROCA = NAMEENUMPROCA;
       WINSTAENUMPROCW  = NAMEENUMPROCW;
       DESKTOPENUMPROCW = NAMEENUMPROCW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE WINSTAENUMPROC  = WINSTAENUMPROCW;
           DESKTOPENUMPROC = DESKTOPENUMPROCW;
<* ELSE *>
      TYPE WINSTAENUMPROC  = WINSTAENUMPROCA;
           DESKTOPENUMPROC = DESKTOPENUMPROCA;
<* END *>

(* MAKEINTRESOURCE is RTL call instead of C macro *)

PROCEDURE MAKEINTRESOURCEA (x : INTEGER) : RESOURCESTRA;
PROCEDURE MAKEINTRESOURCEW (x : INTEGER) : RESOURCESTRW;

<* IF DEFINED (UNICODE) THEN *>
      CONST MAKEINTRESOURCE = MAKEINTRESOURCEW;
<* ELSE *>
      CONST MAKEINTRESOURCE = MAKEINTRESOURCEA;
<* END *>

(* Predefined Resource Types *)

CONST RT_CURSOR       = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 1));
      RT_BITMAP       = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 2));
      RT_ICON         = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 3));
      RT_MENU         = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 4));
      RT_DIALOG       = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 5));
      RT_STRING       = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 6));
      RT_FONTDIR      = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 7));
      RT_FONT         = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 8));
      RT_ACCELERATOR  = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 9));
      RT_RCDATA       = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 10));
      RT_MESSAGETABLE = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 11));

CONST DIFFERENCE = 11;

CONST RT_GROUP_CURSOR = SYSTEM.CAST (RESOURCESTR, SYSTEM.CAST (ULONG, RT_CURSOR) + DIFFERENCE);
      RT_GROUP_ICON   = SYSTEM.CAST (RESOURCESTR, SYSTEM.CAST (ULONG, RT_ICON)   + DIFFERENCE);
      RT_VERSION      = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 16));
      RT_DLGINCLUDE   = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 17));
      RT_PLUGPLAY     = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 19));
      RT_VXD          = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 20));
      RT_ANICURSOR    = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 21));
      RT_ANIICON      = SYSTEM.CAST (RESOURCESTR, VAL (DWORD, 22));

PROCEDURE wvsprintfA (VAR result : ARRAY OF CHAR;
                      format : ARRAY OF CHAR;
                      arglist : SYSTEM.ADDRESS) : INTEGER;
PROCEDURE wvsprintfW (VAR result : ARRAY OF WCHAR;
                      format : ARRAY OF WCHAR;
                      arglist : SYSTEM.ADDRESS) : INTEGER;

PROCEDURE wsprintfA (VAR result : ARRAY OF CHAR;
                     format : ARRAY OF CHAR;
                     SEQ args : SYSTEM.BYTE) : INTEGER;
PROCEDURE wsprintfW (VAR result : ARRAY OF WCHAR;
                     format : ARRAY OF WCHAR;
                     SEQ args : SYSTEM.BYTE) : INTEGER;


<* IF DEFINED (UNICODE) THEN *>
      CONST wsprintf  = wsprintfW;
            wvsprintf = wvsprintfW;
<* ELSE *>
      CONST wsprintf = wsprintfA;
            wvsprintf = wvsprintfA;
<* END *>


(* Scroll Bar Constants *)

TYPE SB_TYPE = (SB_HORZ,      (* 0 *)
                SB_VERT,      (* 1 *)
                SB_CTL,       (* 2 *)
                SB_BOTH);     (* 3 *)

(* Scroll Bar Commands *)

TYPE SB_ENUM = (SB_LINEUP,         (* 0 *)
                SB_LINEDOWN,       (* 1 *)
                SB_PAGEUP,         (* 2 *)
                SB_PAGEDOWN,       (* 3 *)
                SB_THUMBPOSITION,  (* 4 *)
                SB_THUMBTRACK,     (* 5 *)
                SB_TOP,            (* 6 *)
                SB_BOTTOM,         (* 7 *)
                SB_ENDSCROLL);     (* 8 *)


CONST SB_LINELEFT  = SB_LINEUP;
      SB_LINERIGHT = SB_LINEDOWN;
      SB_PAGELEFT  = SB_PAGEUP;
      SB_PAGERIGHT = SB_PAGEDOWN;
      SB_LEFT      = SB_TOP;
      SB_RIGHT     = SB_BOTTOM;

(* ShowWindow commands *)

TYPE SW_ENUM = (SW_HIDE,            (* 0 *)
                SW_SHOWNORMAL,      (* 1 *)
                SW_SHOWMINIMIZED,   (* 2 *)
                SW_SHOWMAXIMIZED,   (* 3 *)
                SW_SHOWNOACTIVATE,  (* 4 *)
                SW_SHOW,            (* 5 *)
                SW_MINIMIZE,        (* 6 *)
                SW_SHOWMINNOACTIVE, (* 7 *)
                SW_SHOWNA,          (* 8 *)
                SW_RESTORE,         (* 9 *)
                SW_SHOWDEFAULT);    (* 10 *)

CONST SW_NORMAL   = SW_SHOWNORMAL;    (* 1 *)
      SW_MAXIMIZE = SW_SHOWMAXIMIZED; (* 3 *)
      SW_MAX      = SW_SHOWDEFAULT;   (* 10 *)

(* Old ShowWindow () Commands *)

CONST  HIDE_WINDOW         = SW_HIDE;             (* 0 *)
       SHOW_OPENWINDOW     = SW_NORMAL;           (* 1 *)
       SHOW_ICONWINDOW     = SW_SHOWMINIMIZED;    (* 2 *)
       SHOW_FULLSCREEN     = SW_SHOWMAXIMIZED;    (* 3 *)
       SHOW_OPENNOACTIVATE = SW_SHOWNOACTIVATE;   (* 4 *)


(* Identifiers for the LPARAM of WM_SHOWWINDOW message: 0 means ShowWindow
   has been called; otherwise, following values: *)

CONST SW_PARENTCLOSING = 1;
      SW_OTHERZOOM     = 2;
      SW_PARENTOPENING = 3;
      SW_OTHERUNZOOM   = 4;

(*
 * WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags - ???
 *)

TYPE KF_ENUM = (KF__0, KF__1,
                KF__2, KF__3,
                KF__4, KF__5,
                KF__6, KF__7,
                KF__EXTENDED,        (* 8 *)
                KF__9, KF__10,
                KF__DLGMODE,          (* 11 *)
                KF__MENUMODE,         (* 12 *)
                KF__ALTDOWN,          (* 13 *)
                KF__REPEAT,           (* 14 *)
                KF__UP);              (* 15 *)
     KF_SET = SET OF KF_ENUM;

CONST KF_EXTENDED = KF_SET {KF__EXTENDED};    (* 0x0100 *)
      KF_DLGMODE  = KF_SET {KF__DLGMODE};     (* 0x0800 *)
      KF_MENUMODE = KF_SET {KF__MENUMODE};    (* 0x1000 *)
      KF_ALTDOWN  = KF_SET {KF__ALTDOWN};     (* 0x2000 *)
      KF_REPEAT   = KF_SET {KF__REPEAT};      (* 0x4000 *)
      KF_UP       = KF_SET {KF__UP};          (* 0x8000 *)

(* Virtual Keys, Standard Set *)

CONST VK_LBUTTON     = 01h;
      VK_RBUTTON     = 02h;
      VK_CANCEL      = 03h;
      VK_MBUTTON     = 04h;    (* NOT contiguous with L & RBUTTON *)

      VK_BACK        = 08h;
      VK_TAB         = 09h;

      VK_CLEAR       = 0Ch;
      VK_RETURN      = 0Dh;

      VK_SHIFT       = 10h;
      VK_CONTROL     = 11h;
      VK_MENU        = 12h;
      VK_PAUSE       = 13h;
      VK_CAPITAL     = 14h;

      VK_ESCAPE      = 1Bh;

      VK_SPACE       = 20h;
      VK_PRIOR       = 21h;
      VK_NEXT        = 22h;
      VK_END         = 23h;
      VK_HOME        = 24h;
      VK_LEFT        = 25h;
      VK_UP          = 26h;
      VK_RIGHT       = 27h;
      VK_DOWN        = 28h;
      VK_SELECT      = 29h;
      VK_PRINT       = 2Ah;
      VK_EXECUTE     = 2Bh;
      VK_SNAPSHOT    = 2Ch;
      VK_INSERT      = 2Dh;
      VK_DELETE      = 2Eh;
      VK_HELP        = 2Fh;

(* VK_0 thru VK_9 are the same as ASCII '0' thru '9' (0x30 - 0x39) *)
(* VK_A thru VK_Z are the same as ASCII 'A' thru 'Z' (0x41 - 0x5A) *)

      VK_LWIN        = 5Bh;
      VK_RWIN        = 5Ch;
      VK_APPS        = 5Dh;

      VK_NUMPAD0     = 60h;
      VK_NUMPAD1     = 61h;
      VK_NUMPAD2     = 62h;
      VK_NUMPAD3     = 63h;
      VK_NUMPAD4     = 64h;
      VK_NUMPAD5     = 65h;
      VK_NUMPAD6     = 66h;
      VK_NUMPAD7     = 67h;
      VK_NUMPAD8     = 68h;
      VK_NUMPAD9     = 69h;
      VK_MULTIPLY    = 6Ah;
      VK_ADD         = 6Bh;
      VK_SEPARATOR   = 6Ch;
      VK_SUBTRACT    = 6Dh;
      VK_DECIMAL     = 6Eh;
      VK_DIVIDE      = 6Fh;
      VK_F1          = 70h;
      VK_F2          = 71h;
      VK_F3          = 72h;
      VK_F4          = 73h;
      VK_F5          = 74h;
      VK_F6          = 75h;
      VK_F7          = 76h;
      VK_F8          = 77h;
      VK_F9          = 78h;
      VK_F10         = 79h;
      VK_F11         = 7Ah;
      VK_F12         = 7Bh;
      VK_F13         = 7Ch;
      VK_F14         = 7Dh;
      VK_F15         = 7Eh;
      VK_F16         = 7Fh;
      VK_F17         = 80h;
      VK_F18         = 81h;
      VK_F19         = 82h;
      VK_F20         = 83h;
      VK_F21         = 84h;
      VK_F22         = 85h;
      VK_F23         = 86h;
      VK_F24         = 87h;

      VK_NUMLOCK     = 90h;
      VK_SCROLL      = 91h;

(*
 * VK_L* & VK_R* - left and right Alt, Ctrl and Shift virtual keys.
 * Used only as parameters to GetAsyncKeyState() and GetKeyState().
 * No other API or message will distinguish left and right keys in this way.
 *)
      VK_LSHIFT      = 0A0h;
      VK_RSHIFT      = 0A1h;
      VK_LCONTROL    = 0A2h;
      VK_RCONTROL    = 0A3h;
      VK_LMENU       = 0A4h;
      VK_RMENU       = 0A5h;

      VK_PROCESSKEY  = 0E5h;

      VK_ATTN        = 0F6h;
      VK_CRSEL       = 0F7h;
      VK_EXSEL       = 0F8h;
      VK_EREOF       = 0F9h;
      VK_PLAY        = 0FAh;
      VK_ZOOM        = 0FBh;
      VK_NONAME      = 0FCh;
      VK_PA1         = 0FDh;
      VK_OEM_CLEAR   = 0FEh;


(* SetWindowsHook() codes *)

CONST WH_MIN              = -1;
      WH_MSGFILTER        = -1;
      WH_JOURNALRECORD    =  0;
      WH_JOURNALPLAYBACK  =  1;
      WH_KEYBOARD         =  2;
      WH_GETMESSAGE       =  3;
      WH_CALLWNDPROC      =  4;
      WH_CBT              =  5;
      WH_SYSMSGFILTER     =  6;
      WH_MOUSE            =  7;
      WH_HARDWARE         =  8;
      WH_DEBUG            =  9;
      WH_SHELL            = 10;
      WH_FOREGROUNDIDLE   = 11;
      WH_CALLWNDPROCRET   = 12;
      WH_MAX              = 12;
      WH_MINHOOK          = WH_MIN;
      WH_MAXHOOK          = WH_MAX;

(* Hook Codes *)

CONST HC_ACTION           = 0;
      HC_GETNEXT          = 1;
      HC_SKIP             = 2;
      HC_NOREMOVE         = 3;
      HC_NOREM            = HC_NOREMOVE;
      HC_SYSMODALON       = 4;
      HC_SYSMODALOFF      = 5;

(* CBT Hook Codes *)

CONST HCBT_MOVESIZE       = 0;
      HCBT_MINMAX         = 1;
      HCBT_QS             = 2;
      HCBT_CREATEWND      = 3;
      HCBT_DESTROYWND     = 4;
      HCBT_ACTIVATE       = 5;
      HCBT_CLICKSKIPPED   = 6;
      HCBT_KEYSKIPPED     = 7;
      HCBT_SYSCOMMAND     = 8;
      HCBT_SETFOCUS       = 9;

(* HCBT_CREATEWND parameters pointed to by lParam *)

TYPE CBT_CREATEWNDA  = RECORD
                              lpcs : PCREATESTRUCTA;
                              hwndInsertAfter : HWND;
                       END;
     PCBT_CREATEWNDA = POINTER TO CBT_CREATEWNDA;
     CBT_CREATEWNDW  = RECORD
                              lpcs : PCREATESTRUCTW;
                              hwndInsertAfter : HWND;
                       END;
     PCBT_CREATEWNDW = POINTER TO CBT_CREATEWNDW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE CBT_CREATEWND  = CBT_CREATEWNDW;
      TYPE PCBT_CREATEWND = PCBT_CREATEWNDW;
<* ELSE *>
      TYPE CBT_CREATEWND  = CBT_CREATEWNDA;
      TYPE PCBT_CREATEWND = PCBT_CREATEWNDA;
<* END *>

(* HCBT_ACTIVATE structure pointed to by lParam *)

TYPE CBTACTIVATESTRUCT = RECORD
                                fMouse : BOOL;
                                hWndActive : HWND;
                         END;
     PCBTACTIVATESTRUCT = POINTER TO CBTACTIVATESTRUCT;

(* WH_MSGFILTER Filter Proc Codes *)

CONST MSGF_DIALOGBOX    = 0;
      MSGF_MESSAGEBOX   = 1;
      MSGF_MENU         = 2;
      MSGF_MOVE         = 3;
      MSGF_SIZE         = 4;
      MSGF_SCROLLBAR    = 5;
      MSGF_NEXTWINDOW   = 6;
      MSGF_MAINLOOP     = 8;
      MSGF_MAX          = 8;
      MSGF_USER         = 4096;

(* Shell support *)

CONST HSHELL_WINDOWCREATED        = 1;
      HSHELL_WINDOWDESTROYED      = 2;
      HSHELL_ACTIVATESHELLWINDOW  = 3;
      HSHELL_WINDOWACTIVATED      = 4;
      HSHELL_GETMINRECT           = 5;
      HSHELL_REDRAW               = 6;
      HSHELL_TASKMAN              = 7;
      HSHELL_LANGUAGE             = 8;

(* Message Structure used in Journaling *)

TYPE EVENTMSG = RECORD
                       message : UINT;
                       paramL  : UINT;
                       paramH  : UINT;
                       time    : DWORD;
                       hwnd    : HWND;
                END;
    PEVENTMSG = POINTER TO EVENTMSG;

(* Message structure used by WH_CALLWNDPROC *)

TYPE CWPSTRUCT = RECORD
                       lParam  : LPARAM;
                       wParam  : WPARAM;
                       message : UINT;
                       hwnd    : HWND;
                 END;
    PCWPSTRUCT = POINTER TO CWPSTRUCT;

(* Message structure used by WH_CALLWNDPROCRET *)

TYPE CWPRETSTRUCT = RECORD
                           lResult : LRESULT;
                           lParam  : LPARAM;
                           wParam  : WPARAM;
                           message : UINT;
                           hwnd    : HWND;
                    END;
    PCWPRETSTRUCT = POINTER TO CWPRETSTRUCT;

(* Structure used by WH_DEBUG *)

TYPE DEBUGHOOKINFO = RECORD
                            idThread          : DWORD;
                            idThreadInstaller : DWORD;
                            lParam            : LPARAM;
                            wParam            : WPARAM;
                            code              : INTEGER;
                     END;
    PDEBUGHOOKINFO = POINTER TO DEBUGHOOKINFO;

(* Structure used by WH_MOUSE *)

TYPE MOUSEHOOKSTRUCT = RECORD
                              pt           : POINT;
                              hwnd         : HWND;
                              wHitTestCode : UINT;
                              dwExtraInfo  : DWORD;
                       END;
    PMOUSEHOOKSTRUCT = POINTER TO MOUSEHOOKSTRUCT;

(* Structure used by WH_HARDWARE *)

TYPE HARDWAREHOOKSTRUCT = RECORD
                                 hwnd    : HWND;
                                 message : UINT;
                                 wParam  : WPARAM;
                                 lParam  : LPARAM;
                          END;
    PHARDWAREHOOKSTRUCT = POINTER TO HARDWAREHOOKSTRUCT;

(* Keyboard Layout API *)

CONST HKL_PREV  = SYSTEM.CAST (HKL, VAL (ULONG, 0));
      HKL_NEXT  = SYSTEM.CAST (HKL, VAL (ULONG, 1));

TYPE KLF_ENUM = (KLF__ACTIVATE,       (* 0 *)
                 KLF__SUBSTITUTE_OK,  (* 1 *)
                 KLF__UNLOADPREVIOUS, (* 2 *)
                 KLF__REORDER,        (* 3 *)
                 KLF__REPLACELANG,    (* 4 *)
                 KLF__5, KLF__6,
                 KLF__NOTELLSHELL);   (* 7 *)

     KLF_SET = SET OF KLF_ENUM;

CONST KLF_ACTIVATE       = KLF_SET {KLF__ACTIVATE};      (* 0x00000001 *)
      KLF_SUBSTITUTE_OK  = KLF_SET {KLF__SUBSTITUTE_OK}; (* 0x00000002 *)
      KLF_UNLOADPREVIOUS = KLF_SET {KLF__UNLOADPREVIOUS};(* 0x00000004 *)
      KLF_REORDER        = KLF_SET {KLF__REORDER};       (* 0x00000008 *)
      KLF_REPLACELANG    = KLF_SET {KLF__REPLACELANG};   (* 0x00000010 *)
      KLF_NOTELLSHELL    = KLF_SET {KLF__NOTELLSHELL};   (* 0x00000080 *)

(*
 * Size of KeyboardLayoutName (number of characters), including nul terminator
 *)
CONST KL_NAMELENGTH = 9;

PROCEDURE LoadKeyboardLayoutA (KLID : ARRAY OF CHAR;  Flags : KLF_SET) : HKL;
PROCEDURE LoadKeyboardLayoutW (KLID : ARRAY OF WCHAR; Flags : KLF_SET) : HKL;

<* IF DEFINED (UNICODE) THEN *>
      CONST LoadKeyboardLayout    = LoadKeyboardLayoutW;
<* ELSE *>
      CONST LoadKeyboardLayout    = LoadKeyboardLayoutA;
<* END *>

PROCEDURE ActivateKeyboardLayout (hkl  : HKL; Flags : KLF_SET) : HKL;
PROCEDURE ToUnicodeEx (wVirtKey   : UINT;
                       wScanCode  : UINT;
                       lpKeyState : PBYTE;
                       VAR Buff   : ARRAY OF CHAR;
                       cchBuff    : INTEGER;
                       wFlags     : UINT;
                       dwhkl      : HKL) : INTEGER;

PROCEDURE UnloadKeyboardLayout   (hkl  : HKL) : BOOL;
PROCEDURE GetKeyboardLayoutNameA (VAR KLID : ARRAY OF CHAR)  : BOOL;
PROCEDURE GetKeyboardLayoutNameW (VAR KLID : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetKeyboardLayoutName = GetKeyboardLayoutNameW;
<* ELSE *>
      CONST GetKeyboardLayoutName = GetKeyboardLayoutNameA;
<* END *>

PROCEDURE GetKeyboardLayoutList (nBuff : INTEGER;
                                 VAR lpList : ARRAY OF HKL) : INTEGER;

PROCEDURE GetKeyboardLayout (dwLayout : DWORD) : HKL;

(*
 * Desktop-specific access flags
 *)

TYPE DESKTOP_ENUM = (DESKTOP__READOBJECTS,     (* 0 *)
                     DESKTOP__CREATEWINDOW,    (* 1 *)
                     DESKTOP__CREATEMENU,      (* 2 *)
                     DESKTOP__HOOKCONTROL,     (* 3 *)
                     DESKTOP__JOURNALRECORD,   (* 4 *)
                     DESKTOP__JOURNALPLAYBACK, (* 5 *)
                     DESKTOP__ENUMERATE,       (* 6 *)
                     DESKTOP__WRITEOBJECTS,    (* 7 *)
                     DESKTOP__SWITCHDESKTOP);  (* 8 *)
     DESKTOP_SET = SET OF DESKTOP_ENUM;

CONST DESKTOP_READOBJECTS     = DESKTOP_SET {DESKTOP__READOBJECTS};     (* 0x0001L *)
      DESKTOP_CREATEWINDOW    = DESKTOP_SET {DESKTOP__CREATEWINDOW};    (* 0x0002L *)
      DESKTOP_CREATEMENU      = DESKTOP_SET {DESKTOP__CREATEMENU};      (* 0x0004L *)
      DESKTOP_HOOKCONTROL     = DESKTOP_SET {DESKTOP__HOOKCONTROL};     (* 0x0008L *)
      DESKTOP_JOURNALRECORD   = DESKTOP_SET {DESKTOP__JOURNALRECORD};   (* 0x0010L *)
      DESKTOP_JOURNALPLAYBACK = DESKTOP_SET {DESKTOP__JOURNALPLAYBACK}; (* 0x0020L *)
      DESKTOP_ENUMERATE       = DESKTOP_SET {DESKTOP__ENUMERATE};       (* 0x0040L *)
      DESKTOP_WRITEOBJECTS    = DESKTOP_SET {DESKTOP__WRITEOBJECTS};    (* 0x0080L *)
      DESKTOP_SWITCHDESKTOP   = DESKTOP_SET {DESKTOP__SWITCHDESKTOP};   (* 0x0100L *)

(*
 * Desktop-specific control flags
 *)

TYPE DF_ENUM = (DF__ALLOWOTHERACCOUNTHOOK); (* 0 *)
TYPE DF_SET = SET OF DF_ENUM;
CONST DF_ALLOWOTHERACCOUNTHOOK = DF_SET {DF__ALLOWOTHERACCOUNTHOOK}; (* 0001h *)

PROCEDURE CreateDesktopA (Desktop           : ARRAY OF CHAR;
                          lpszDevice        : PCSTR; (* NIL *)
                          VAR [NIL] Devmode : DEVMODEA; (* must be NIL *)
                          dwFlags           : DF_SET;
                          dwDesiredAccess   : DESKTOP_SET;
                          lpsa              : PSECURITY_ATTRIBUTES) : HDESK;

PROCEDURE CreateDesktopW (Desktop           : ARRAY OF WCHAR;
                          lpszDevice        : PCWSTR; (* NIL *)
                          VAR [NIL] Devmode : DEVMODEA; (* must be NIL *)
                          dwFlags           : DF_SET;
                          dwDesiredAccess   : DESKTOP_SET;
                          lpsa              : PSECURITY_ATTRIBUTES) : HDESK;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateDesktop = CreateDesktopW;
<* ELSE *>
      CONST CreateDesktop = CreateDesktopA;
<* END *>

PROCEDURE OpenDesktopA (lpszDesktop     : ARRAY OF CHAR;
                        dwFlags         : DF_SET;
                        fInherit        : BOOL;
                        dwDesiredAccess : DESKTOP_SET) : HDESK;

PROCEDURE OpenDesktopW (lpszDesktop     : ARRAY OF WCHAR;
                        dwFlags         : DF_SET;
                        fInherit        : BOOL;
                        dwDesiredAccess : DESKTOP_SET) : HDESK;

<* IF DEFINED (UNICODE) THEN *>
      CONST OpenDesktop = OpenDesktopW;
<* ELSE *>
      CONST OpenDesktop = OpenDesktopA;
<* END *>

PROCEDURE OpenInputDesktop (dwFlags         : DF_SET;
                            fInherit        : BOOL;
                            dwDesiredAccess : DESKTOP_SET) : HDESK;

PROCEDURE EnumDesktopsA (hwinsta    : HWINSTA;
                         lpEnumFunc : DESKTOPENUMPROCA;
                         lParam     : LPARAM)
                                               : BOOL;

PROCEDURE EnumDesktopsW (hwinsta    : HWINSTA;
                         lpEnumFunc : DESKTOPENUMPROCW;
                         lParam     : LPARAM)
                                               : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumDesktops = EnumDesktopsW;
<* ELSE *>
      CONST EnumDesktops = EnumDesktopsA;
<* END *>

PROCEDURE EnumDesktopWindows (hDesktop : HDESK;
                              lpfn : WNDENUMPROC;
                              lParam : LPARAM) : BOOL;

PROCEDURE SwitchDesktop    (hDesktop   : HDESK) : BOOL;
PROCEDURE SetThreadDesktop (hDesktop   : HDESK) : BOOL;
PROCEDURE CloseDesktop     (hDesktop   : HDESK) : BOOL;
PROCEDURE GetThreadDesktop (dwThreadId : DWORD) : HDESK;

(*
 * Windowstation-specific access flags
 *)

TYPE WINSTA_ENUM = (WINSTA__ENUMDESKTOPS,      (* 0 *)
                    WINSTA__READATTRIBUTES,    (* 1 *)
                    WINSTA__ACCESSCLIPBOARD,   (* 2 *)
                    WINSTA__CREATEDESKTOP,     (* 3 *)
                    WINSTA__WRITEATTRIBUTES,   (* 4 *)
                    WINSTA__ACCESSGLOBALATOMS, (* 5 *)
                    WINSTA__EXITWINDOWS,       (* 6 *)
                    WINSTA__7,
                    WINSTA__ENUMERATE,         (* 8 *)
                    WINSTA__READSCREEN);       (* 9 *)
     WINSTA_SET = SET OF WINSTA_ENUM;

CONST WINSTA_ENUMDESKTOPS      = WINSTA_SET {WINSTA__ENUMDESKTOPS};      (* 0x0001L *)
      WINSTA_READATTRIBUTES    = WINSTA_SET {WINSTA__READATTRIBUTES};    (* 0x0002L *)
      WINSTA_ACCESSCLIPBOARD   = WINSTA_SET {WINSTA__ACCESSCLIPBOARD};   (* 0x0004L *)
      WINSTA_CREATEDESKTOP     = WINSTA_SET {WINSTA__CREATEDESKTOP};     (* 0x0008L *)
      WINSTA_WRITEATTRIBUTES   = WINSTA_SET {WINSTA__WRITEATTRIBUTES};   (* 0x0010L *)
      WINSTA_ACCESSGLOBALATOMS = WINSTA_SET {WINSTA__ACCESSGLOBALATOMS}; (* 0x0020L *)
      WINSTA_EXITWINDOWS       = WINSTA_SET {WINSTA__EXITWINDOWS};       (* 0x0040L *)
      WINSTA_ENUMERATE         = WINSTA_SET {WINSTA__ENUMERATE};         (* 0x0100L *)
      WINSTA_READSCREEN        = WINSTA_SET {WINSTA__READSCREEN};        (* 0x0200L *)

(*
 * Windowstation-specific attribute flags
 *)

CONST WSF_VISIBLE = 1;

PROCEDURE CreateWindowStationA (lpwinsta        : PCSTR;  (* NIL *)
                                dwReserved      : DWORD;
                                dwDesiredAccess : WINSTA_SET;
                                lpsa            : PSECURITY_ATTRIBUTES) : HWINSTA;

PROCEDURE CreateWindowStationW (lpwinsta        : PCWSTR; (* NIL *)
                                dwReserved      : DWORD;
                                dwDesiredAccess : WINSTA_SET;
                                lpsa            : PSECURITY_ATTRIBUTES) : HWINSTA;


PROCEDURE OpenWindowStationA (lpszWinSta      : ARRAY OF CHAR;
                              fInherit        : BOOL;
                              dwDesiredAccess : WINSTA_SET) : HWINSTA;

PROCEDURE OpenWindowStationW (lpszWinSta      : ARRAY OF WCHAR;
                              fInherit        : BOOL;
                              dwDesiredAccess : WINSTA_SET) : HWINSTA;

PROCEDURE EnumWindowStationsA (lpEnumFunc : WINSTAENUMPROCA;
                               lParam     : LPARAM) : BOOL;

PROCEDURE EnumWindowStationsW (lpEnumFunc : WINSTAENUMPROCW;
                               lParam     : LPARAM) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateWindowStation = CreateWindowStationW;
            OpenWindowStation   = OpenWindowStationW;
            EnumWindowStations  = EnumWindowStationsW;
<* ELSE *>
      CONST CreateWindowStation = CreateWindowStationA;
            OpenWindowStation   = OpenWindowStationA;
            EnumWindowStations  = EnumWindowStationsA;
<* END *>

PROCEDURE CloseWindowStation      (hWinSta : HWINSTA) : BOOL;
PROCEDURE SetProcessWindowStation (hWinSta : HWINSTA) : BOOL;
PROCEDURE GetProcessWindowStation () : HWINSTA;

PROCEDURE SetUserObjectSecurity (hObj : HANDLE;
                                 VAR SIRequested : SECURITY_INFORMATION;
                                 pSID : PSECURITY_DESCRIPTOR) : BOOL;

PROCEDURE GetUserObjectSecurity (hObj : HANDLE;
                                 VAR SIRequested : SECURITY_INFORMATION;
                                 pSID : PSECURITY_DESCRIPTOR;
                                 nLength : DWORD;
                                 VAR LengthNeeded : DWORD) : BOOL;

TYPE UOI_INDEX = (UOI_0,
                  UOI_FLAGS,     (* 1 *)
                  UOI_NAME,      (* 2 *)
                  UOI_TYPE,      (* 3 *)
                  UOI_USER_SID); (* 4 *)

TYPE USEROBJECTFLAGS = RECORD
                              fInherit  : BOOL;
                              fReserved : BOOL;
                              dwFlags   : DWORD;
                       END;
    PUSEROBJECTFLAGS = POINTER TO USEROBJECTFLAGS;

PROCEDURE GetUserObjectInformationA (hObj    : HANDLE;
                                     nIndex  : UOI_INDEX;
                                     pvInfo  : PVOID;
                                     nLength : DWORD;
                                     VAR LengthNeeded : DWORD) : BOOL;

PROCEDURE GetUserObjectInformationW (hObj    : HANDLE;
                                     nIndex  : UOI_INDEX;
                                     pvInfo  : PVOID;
                                     nLength : DWORD;
                                     VAR LengthNeeded : DWORD) : BOOL;

PROCEDURE SetUserObjectInformationA (hObj    : HANDLE;
                                     nIndex  : UOI_INDEX;
                                     pvInfo  : PVOID;
                                     nLength : DWORD) : BOOL;

PROCEDURE SetUserObjectInformationW (hObj    : HANDLE;
                                     nIndex  : UOI_INDEX;
                                     pvInfo  : PVOID;
                                     nLength : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetUserObjectInformation = GetUserObjectInformationW;
            SetUserObjectInformation = SetUserObjectInformationW;
<* ELSE *>
      CONST GetUserObjectInformation = GetUserObjectInformationA;
            SetUserObjectInformation = SetUserObjectInformationA;
<* END *>

(* Class style constants *)

TYPE CS_ENUM = (CS__VREDRAW,          (* 0 *)
                CS__HREDRAW,          (* 1 *)
                CS__KEYCVTWINDOW,     (* 2 *)
                CS__DBLCLKS,          (* 3 *)
                CS__4,
                CS__OWNDC,            (* 5 *)
                CS__CLASSDC,          (* 6 *)
                CS__PARENTDC,         (* 7 *)
                CS__NOKEYCVT,         (* 8 *)
                CS__NOCLOSE,          (* 9 *)
                CS__10,
                CS__SAVEBITS,         (*11 *)
                CS__BYTEALIGNCLIENT,  (*12 *)
                CS__BYTEALIGNWINDOW,  (*13 *)
                CS__GLOBALCLASS,      (*14 *)
                CS__15,
                CS__IME);             (*16 *)

TYPE CS_SET = SET OF CS_ENUM;

CONST CS_VREDRAW          = CS_SET {CS__VREDRAW};           (* 0x00001 *)
      CS_HREDRAW          = CS_SET {CS__HREDRAW};           (* 0x00002 *)
      CS_KEYCVTWINDOW     = CS_SET {CS__KEYCVTWINDOW};      (* 0x00004 *)
      CS_DBLCLKS          = CS_SET {CS__DBLCLKS};           (* 0x00008 *)
      CS_OWNDC            = CS_SET {CS__OWNDC};             (* 0x00020 *)
      CS_CLASSDC          = CS_SET {CS__CLASSDC};           (* 0x00040 *)
      CS_PARENTDC         = CS_SET {CS__PARENTDC};          (* 0x00080 *)
      CS_NOKEYCVT         = CS_SET {CS__NOKEYCVT};          (* 0x00100 *)
      CS_NOCLOSE          = CS_SET {CS__NOCLOSE};           (* 0x00200 *)
      CS_SAVEBITS         = CS_SET {CS__SAVEBITS};          (* 0x00800 *)
      CS_BYTEALIGNCLIENT  = CS_SET {CS__BYTEALIGNCLIENT};   (* 0x01000 *)
      CS_BYTEALIGNWINDOW  = CS_SET {CS__BYTEALIGNWINDOW};   (* 0x02000 *)
      CS_GLOBALCLASS      = CS_SET {CS__GLOBALCLASS};       (* 0x04000 *)
      CS_IME              = CS_SET {CS__IME};               (* 0x10000 *)

TYPE WNDCLASSEXA = RECORD
                          cbSize        : UINT;
                          style         : CS_SET;
                          lpfnWndProc   : WNDPROC;
                          cbClsExtra    : INTEGER;
                          cbWndExtra    : INTEGER;
                          hInstance     : HINSTANCE;
                          hIcon         : HICON;
                          hCursor       : HCURSOR;
                          hbrBackground : HBRUSH;
                          lpszMenuName  : RESOURCESTRA;
                          lpszClassName : ATOMSTR;
                          hIconSm       : HICON;
                   END;
      PWNDCLASSEXA = POINTER TO WNDCLASSEXA;

TYPE WNDCLASSEXW = RECORD
                          cbSize        : UINT;
                          style         : CS_SET;
                          lpfnWndProc   : WNDPROC;
                          cbClsExtra    : INTEGER;
                          cbWndExtra    : INTEGER;
                          hInstance     : HINSTANCE;
                          hIcon         : HICON;
                          hCursor       : HCURSOR;
                          hbrBackground : HBRUSH;
                          lpszMenuName  : RESOURCESTRW;
                          lpszClassName : ATOMWSTR;
                          hIconSm       : HICON;
                  END;
      PWNDCLASSEXW = POINTER TO WNDCLASSEXW;

TYPE WNDCLASSA = RECORD
                        style         : CS_SET;
                        lpfnWndProc   : WNDPROC;
                        cbClsExtra    : INTEGER;
                        cbWndExtra    : INTEGER;
                        hInstance     : HINSTANCE;
                        hIcon         : HICON;
                        hCursor       : HCURSOR;
                        hbrBackground : HBRUSH;
                        lpszMenuName  : RESOURCESTRA;
                        lpszClassName : ATOMSTR;
                END;
      PWNDCLASSA = POINTER TO WNDCLASSA;

TYPE WNDCLASSW = RECORD
                        style         : CS_SET;
                        lpfnWndProc   : WNDPROC;
                        cbClsExtra    : INTEGER;
                        cbWndExtra    : INTEGER;
                        hInstance     : HINSTANCE;
                        hIcon         : HICON;
                        hCursor       : HCURSOR;
                        hbrBackground : HBRUSH;
                        lpszMenuName  : RESOURCESTRW;
                        lpszClassName : ATOMWSTR;
                 END;
      PWNDCLASSW = POINTER TO WNDCLASSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE
           WNDCLASSEX   = WNDCLASSEXW;
           WNDCLASS     = WNDCLASSW;
           PWNDCLASSEX  = PWNDCLASSEXW;
           PWNDCLASS    = PWNDCLASSW;
<* ELSE *>
      TYPE WNDCLASSEX   = WNDCLASSEXA;
           WNDCLASS     = WNDCLASSA;
           PWNDCLASSEX  = PWNDCLASSEXA;
           PWNDCLASS    = PWNDCLASSA;
<* END *>

TYPE MSG = RECORD
                hwnd    : HWND;
                message : UINT;
                wParam  : WPARAM;
                lParam  : LPARAM;
                time    : DWORD;
                pt      : POINT;
           END;
    PMSG = POINTER TO MSG;

(* Following 2 procedures were macra in windows.h, so they're implemented
   in RTL
*)

PROCEDURE POINTSTOPOINT (VAR pt : POINT; pts : LPARAM);
<* IF BACKEND # "C" THEN *>
PROCEDURE POINTTOPOINTS (pt : POINT) : LPARAM;
<* ELSE *>
PROCEDURE POINTTOPOINTS (pt : PPOINT) : LPARAM;
<* END *>

(*
PROCEDURE MAKEWPARAM  (l, h : WORD) : WPARAM;
PROCEDURE MAKELPARAM  (l, h : WORD) : LPARAM;
PROCEDURE MAKELRESULT (l, h : WORD) : LRESULT;
*)

CONST MAKEWPARAM  = MAKELONG;
      MAKELPARAM  = MAKELONG;
      MAKELRESULT = MAKELONG;

(* Window field offsets for GetWindowLong *)

CONST GWL_WNDPROC     =   -4;
      GWL_HINSTANCE   =   -6;
      GWL_HWNDPARENT  =   -8;
      GWL_STYLE       =   -16;
      GWL_EXSTYLE     =   -20;
      GWL_USERDATA    =   -21;
      GWL_ID          =   -12;

(* Class field offsets for GetClassLong *)
CONST  GCL_MENUNAME        = -8;
       GCL_HBRBACKGROUND   = -10;
       GCL_HCURSOR         = -12;
       GCL_HICON           = -14;
       GCL_HMODULE         = -16;
       GCL_CBWNDEXTRA      = -18;
       GCL_CBCLSEXTRA      = -20;
       GCL_WNDPROC         = -24;
       GCL_STYLE           = -26;
       GCW_ATOM            = -32;
       GCL_HICONSM         = -34;

(* Window Messages                                                      *)

CONST WM_NULL                   =      0000h;
      WM_CREATE                 =      0001h;
      WM_DESTROY                =      0002h;
      WM_MOVE                   =      0003h;
      WM_SIZE                   =      0005h;
      WM_ACTIVATE   =                  0006h;

(* WM_ACTIVATE state values *)
           WA_INACTIVE    =  0;
           WA_ACTIVE      =  1;
           WA_CLICKACTIVE =  2;

       WM_SETFOCUS              =      0007h;
       WM_KILLFOCUS             =      0008h;
       WM_ENABLE                =      000Ah;
       WM_SETREDRAW             =      000Bh;
       WM_SETTEXT               =      000Ch;
       WM_GETTEXT               =      000Dh;
       WM_GETTEXTLENGTH         =      000Eh;
       WM_PAINT                 =      000Fh;
       WM_CLOSE                 =      0010h;
       WM_QUERYENDSESSION       =      0011h;
       WM_QUIT                  =      0012h;
       WM_QUERYOPEN             =      0013h;
       WM_ERASEBKGND            =      0014h;
       WM_SYSCOLORCHANGE        =      0015h;
       WM_ENDSESSION            =      0016h;
       WM_SHOWWINDOW            =      0018h;
       WM_WININICHANGE          =      001Ah;
       WM_SETTINGCHANGE         =      WM_WININICHANGE;
       WM_DEVMODECHANGE         =      001Bh;
       WM_ACTIVATEAPP           =      001Ch;
       WM_FONTCHANGE            =      001Dh;
       WM_TIMECHANGE            =      001Eh;
       WM_CANCELMODE            =      001Fh;
       WM_SETCURSOR             =      0020h;
       WM_MOUSEACTIVATE         =      0021h;
       WM_CHILDACTIVATE         =      0022h;
       WM_QUEUESYNC             =      0023h;

       WM_GETMINMAXINFO         =      0024h;

(* Struct pointed to by WM_GETMINMAXINFO lParam *)

TYPE MINMAXINFO = RECORD
                       ptReserved     : POINT;
                       ptMaxSize      : POINT;
                       ptMaxPosition  : POINT;
                       ptMinTrackSize : POINT;
                       ptMaxTrackSize : POINT;
                  END;
    PMINMAXINFO = POINTER TO MINMAXINFO;

CONST  WM_PAINTICON             =      0026h;
       WM_ICONERASEBKGND        =      0027h;
       WM_NEXTDLGCTL            =      0028h;
       WM_SPOOLERSTATUS         =      002Ah;
       WM_DRAWITEM              =      002Bh;
       WM_MEASUREITEM           =      002Ch;
       WM_DELETEITEM            =      002Dh;
       WM_VKEYTOITEM            =      002Eh;
       WM_CHARTOITEM            =      002Fh;
       WM_SETFONT               =      0030h;
       WM_GETFONT               =      0031h;
       WM_SETHOTKEY             =      0032h;
       WM_GETHOTKEY             =      0033h;
       WM_QUERYDRAGICON         =      0037h;
       WM_COMPAREITEM           =      0039h;
       WM_COMPACTING            =      0041h;
       WM_OTHERWINDOWCREATED    =      0042h;  (* no longer suported *)
       WM_OTHERWINDOWDESTROYED  =      0043h;  (* no longer suported *)
       WM_COMMNOTIFY            =      0044h;  (* no longer suported *)
       WM_WINDOWPOSCHANGING     =      0046h;
       WM_WINDOWPOSCHANGED      =      0047h;

CONST  WM_POWER                 =      0048h;

(* wParam for WM_POWER window message and DRV_POWER driver notification *)
           PWR_OK              =  1;
           PWR_FAIL            = -1;
           PWR_SUSPENDREQUEST  =  1;
           PWR_SUSPENDRESUME   =  2;
           PWR_CRITICALRESUME  =  3;

       WM_COPYDATA              =      004Ah;
       WM_CANCELJOURNAL         =      004Bh;

(* lParam of WM_COPYDATA message points to... *)

TYPE COPYDATASTRUCT = RECORD
                           dwData : DWORD;
                           cbData : DWORD;
                           lpData : PBYTE;
                      END;
    PCOPYDATASTRUCT = POINTER TO COPYDATASTRUCT;

CONST  WM_NOTIFY                =      004Eh;
       WM_INPUTLANGCHANGEREQUEST=      0050h;
       WM_INPUTLANGCHANGE       =      0051h;
       WM_TCARD                 =      0052h;
       WM_HELP                  =      0053h;
       WM_USERCHANGED           =      0054h;
       WM_NOTIFYFORMAT          =      0055h;

(* return codes for WM_NOTIFYFORMAT *)

           NFR_ANSI            = 1;
           NFR_UNICODE         = 2;

(* lParam values for WM_NOTIFYFORMAT *)

           NF_QUERY            = 3;
           NF_REQUERY          = 4;

       WM_CONTEXTMENU           =      007Bh;
       WM_STYLECHANGING         =      007Ch;
       WM_STYLECHANGED          =      007Dh;
       WM_DISPLAYCHANGE         =      007Eh;
       WM_GETICON               =      007Fh;
       WM_SETICON               =      0080h;

       WM_NCCREATE              =      0081h;
       WM_NCDESTROY             =      0082h;
       WM_NCCALCSIZE            =      0083h;
       WM_NCHITTEST             =      0084h;
       WM_NCPAINT               =      0085h;
       WM_NCACTIVATE            =      0086h;
       WM_GETDLGCODE            =      0087h;

       WM_NCMOUSEMOVE           =      00A0h;
       WM_NCLBUTTONDOWN         =      00A1h;
       WM_NCLBUTTONUP           =      00A2h;
       WM_NCLBUTTONDBLCLK       =      00A3h;
       WM_NCRBUTTONDOWN         =      00A4h;
       WM_NCRBUTTONUP           =      00A5h;
       WM_NCRBUTTONDBLCLK       =      00A6h;
       WM_NCMBUTTONDOWN         =      00A7h;
       WM_NCMBUTTONUP           =      00A8h;
       WM_NCMBUTTONDBLCLK       =      00A9h;

       WM_KEYFIRST              =      0100h;
       WM_KEYDOWN               =      0100h;
       WM_KEYUP                 =      0101h;
       WM_CHAR                  =      0102h;
       WM_DEADCHAR              =      0103h;
       WM_SYSKEYDOWN            =      0104h;
       WM_SYSKEYUP              =      0105h;
       WM_SYSCHAR               =      0106h;
       WM_SYSDEADCHAR           =      0107h;
       WM_KEYLAST               =      0108h;

       WM_IME_STARTCOMPOSITION  =      010Dh;
       WM_IME_ENDCOMPOSITION    =      010Eh;
       WM_IME_COMPOSITION       =      010Fh;
       WM_IME_KEYLAST           =      010Fh;

       WM_INITDIALOG            =      0110h;
       WM_COMMAND               =      0111h;
       WM_SYSCOMMAND            =      0112h;
       WM_TIMER                 =      0113h;
       WM_HSCROLL               =      0114h;
       WM_VSCROLL               =      0115h;
       WM_INITMENU              =      0116h;
       WM_INITMENUPOPUP         =      0117h;
       WM_MENUSELECT            =      011Fh;
       WM_MENUCHAR              =      0120h;
       WM_ENTERIDLE             =      0121h;

       WM_CTLCOLORMSGBOX        =      0132h;
       WM_CTLCOLOREDIT          =      0133h;
       WM_CTLCOLORLISTBOX       =      0134h;
       WM_CTLCOLORBTN           =      0135h;
       WM_CTLCOLORDLG           =      0136h;
       WM_CTLCOLORSCROLLBAR     =      0137h;
       WM_CTLCOLORSTATIC        =      0138h;

       WM_MOUSEFIRST            =      0200h;
       WM_MOUSEMOVE             =      0200h;
       WM_LBUTTONDOWN           =      0201h;
       WM_LBUTTONUP             =      0202h;
       WM_LBUTTONDBLCLK         =      0203h;
       WM_RBUTTONDOWN           =      0204h;
       WM_RBUTTONUP             =      0205h;
       WM_RBUTTONDBLCLK         =      0206h;
       WM_MBUTTONDOWN           =      0207h;
       WM_MBUTTONUP             =      0208h;
       WM_MBUTTONDBLCLK         =      0209h;
       WM_MOUSEWHEEL            =      020Ah;
       WM_MOUSELAST             =      020Ah;

CONST WHEEL_DELTA               =      120;            (*  Value for rolling one detent *)
      WHEEL_PAGESCROLL          =      MAX (CARDINAL); (* Scroll one page *)

CONST  WM_PARENTNOTIFY          =      0210h;
           MENULOOP_WINDOW = 0;
           MENULOOP_POPUP  = 1;
       WM_ENTERMENULOOP         =      0211h;
       WM_EXITMENULOOP          =      0212h;

       WM_NEXTMENU              =      0213h;

TYPE MDINEXTMENU = RECORD
                          hmenuIn   : HMENU;
                          hmenuNext : HMENU;
                          hwndNext  : HWND;
                   END;
    PMDINEXTMENU = POINTER TO MDINEXTMENU;

CONST  WM_SIZING                =      0214h;
       WM_CAPTURECHANGED        =      0215h;
       WM_MOVING                =      0216h;
       WM_POWERBROADCAST        =      0218h;

       PBT_APMQUERYSUSPEND       =         0;
       PBT_APMQUERYSTANDBY       =         1;
       PBT_APMQUERYSUSPENDFAILED =         2;
       PBT_APMQUERYSTANDBYFAILED =         3;
       PBT_APMSUSPEND            =         4;
       PBT_APMSTANDBY            =         5;
       PBT_APMRESUMECRITICAL     =         6;
       PBT_APMRESUMESUSPEND      =         7;
       PBT_APMRESUMESTANDBY      =         7;
       PBT_APMRESUMEFROMFAILURE  =         1;
       PBT_APMBATTERYLOW         =         9;
       PBT_APMPOWERSTATUSCHANGE  =        10;
       PBT_APMOEMEVENT           =        11;

       WM_DEVICECHANGE          =      0219h;

       WM_IME_SETCONTEXT        =      0281h;
       WM_IME_NOTIFY            =      0282h;
       WM_IME_CONTROL           =      0283h;
       WM_IME_COMPOSITIONFULL   =      0284h;
       WM_IME_SELECT            =      0285h;
       WM_IME_CHAR              =      0286h;
       WM_IME_KEYDOWN           =      0290h;
       WM_IME_KEYUP             =      0291h;

       WM_MDICREATE             =      0220h;
       WM_MDIDESTROY            =      0221h;
       WM_MDIACTIVATE           =      0222h;
       WM_MDIRESTORE            =      0223h;
       WM_MDINEXT               =      0224h;
       WM_MDIMAXIMIZE           =      0225h;
       WM_MDITILE               =      0226h;
       WM_MDICASCADE            =      0227h;
       WM_MDIICONARRANGE        =      0228h;
       WM_MDIGETACTIVE          =      0229h;

       WM_MDISETMENU            =      0230h;
       WM_ENTERSIZEMOVE         =      0231h;
       WM_EXITSIZEMOVE          =      0232h;
       WM_DROPFILES             =      0233h;
       WM_MDIREFRESHMENU        =      0234h;

       WM_MOUSEHOVER            =      02A1h;
       WM_MOUSELEAVE            =      02A3h;

       WM_CUT                   =      0300h;
       WM_COPY                  =      0301h;
       WM_PASTE                 =      0302h;
       WM_CLEAR                 =      0303h;
       WM_UNDO                  =      0304h;
       WM_RENDERFORMAT          =      0305h;
       WM_RENDERALLFORMATS      =      0306h;
       WM_DESTROYCLIPBOARD      =      0307h;
       WM_DRAWCLIPBOARD         =      0308h;
       WM_PAINTCLIPBOARD        =      0309h;
       WM_VSCROLLCLIPBOARD      =      030Ah;
       WM_SIZECLIPBOARD         =      030Bh;
       WM_ASKCBFORMATNAME       =      030Ch;
       WM_CHANGECBCHAIN         =      030Dh;
       WM_HSCROLLCLIPBOARD      =      030Eh;
       WM_QUERYNEWPALETTE       =      030Fh;
       WM_PALETTEISCHANGING     =      0310h;
       WM_PALETTECHANGED        =      0311h;
       WM_HOTKEY                =      0312h;

       WM_PRINT                 =      0317h;
       WM_PRINTCLIENT           =      0318h;

       WM_HANDHELDFIRST         =      0358h;
       WM_HANDHELDLAST          =      035Fh;

       WM_AFXFIRST              =      0360h;
       WM_AFXLAST               =      037Fh;

       WM_PENWINFIRST           =      0380h;
       WM_PENWINLAST            =      038Fh;

       WM_APP                   =      8000h;

(* NOTE: All Message Numbers below 0x0400 are RESERVED.
 *
 * Private Window Messages Start Here:
 *)
       WM_USER                  =      0400h;

(*  wParam for WM_SIZING message  *)

CONST WMSZ_LEFT        = 1;
      WMSZ_RIGHT       = 2;
      WMSZ_TOP         = 3;
      WMSZ_TOPLEFT     = 4;
      WMSZ_TOPRIGHT    = 5;
      WMSZ_BOTTOM      = 6;
      WMSZ_BOTTOMLEFT  = 7;
      WMSZ_BOTTOMRIGHT = 8;

CONST ST_BEGINSWP = 0;
      ST_ENDSWP   = 1;

(* WM_NCHITTEST and MOUSEHOOKSTRUCT Mouse Position Codes *)

CONST HTERROR       = -2;
      HTTRANSPARENT = -1;
      HTNOWHERE     =  0;
      HTCLIENT      =  1;
      HTCAPTION     =  2;
      HTSYSMENU     =  3;
      HTGROWBOX     =  4;
      HTSIZE        =  HTGROWBOX;
      HTMENU        =  5;
      HTHSCROLL     =  6;
      HTVSCROLL     =  7;
      HTMINBUTTON   =  8;
      HTMAXBUTTON   =  9;
      HTLEFT        = 10;
      HTRIGHT       = 11;
      HTTOP         = 12;
      HTTOPLEFT     = 13;
      HTTOPRIGHT    = 14;
      HTBOTTOM      = 15;
      HTBOTTOMLEFT  = 16;
      HTBOTTOMRIGHT = 17;
      HTBORDER      = 18;
      HTREDUCE      = HTMINBUTTON;
      HTZOOM        = HTMAXBUTTON;
      HTSIZEFIRST   = HTLEFT;
      HTSIZELAST    = HTBOTTOMRIGHT;
      HTOBJECT      = 19;
      HTCLOSE       = 20;
      HTHELP        = 21;

(*
 * SendMessageTimeout values
 *)

TYPE  SMTO_ENUM = (SMTO__BLOCK,        (* 0 *)
                   SMTO__ABORTIFHUNG); (* 1 *)
      SMTO_SET = SET OF SMTO_ENUM;

CONST SMTO_NORMAL      = SMTO_SET {};                   (* 0x0000 *)
      SMTO_BLOCK       = SMTO_SET {SMTO__BLOCK};        (* 0x0001 *)
      SMTO_ABORTIFHUNG = SMTO_SET {SMTO__ABORTIFHUNG};  (* 0x0002 *)

(* WM_MOUSEACTIVATE Return Codes *)

CONST MA_ACTIVATE         = 1;
      MA_ACTIVATEANDEAT   = 2;
      MA_NOACTIVATE       = 3;
      MA_NOACTIVATEANDEAT = 4;

(* WM_SETICON / WM_GETICON Type Codes *)

CONST ICON_SMALL = 0;
      ICON_BIG   = 1;

PROCEDURE RegisterWindowMessageA (String : ARRAY OF CHAR) : UINT;
PROCEDURE RegisterWindowMessageW (String : ARRAY OF WCHAR) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegisterWindowMessage = RegisterWindowMessageW;
<* ELSE *>
      CONST RegisterWindowMessage = RegisterWindowMessageA;
<* END *>

(* WM_SIZE message wParam values *)

CONST SIZE_RESTORED   = 0;
      SIZE_MINIMIZED  = 1;
      SIZE_MAXIMIZED  = 2;
      SIZE_MAXSHOW    = 3;
      SIZE_MAXHIDE    = 4;

(* Obsolete constant names *)

      SIZENORMAL      = SIZE_RESTORED;
      SIZEICONIC      = SIZE_MINIMIZED;
      SIZEFULLSCREEN  = SIZE_MAXIMIZED;
      SIZEZOOMSHOW    = SIZE_MAXSHOW;
      SIZEZOOMHIDE    = SIZE_MAXHIDE;

(* Constants for SetWindowPos and WM_WINDOWPOSCHANGING structure *)

TYPE SWP_ENUM = (SWP__NOSIZE,          (* 0 *)
                 SWP__NOMOVE,          (* 1 *)
                 SWP__NOZORDER,        (* 2 *)
                 SWP__NOREDRAW,        (* 3 *)
                 SWP__NOACTIVATE,      (* 4 *)
                 SWP__FRAMECHANGED,    (* 5 *)
                 SWP__SHOWWINDOW,      (* 6 *)
                 SWP__HIDEWINDOW,      (* 7 *)
                 SWP__NOCOPYBITS,      (* 8 *)
                 SWP__NOOWNERZORDER,   (* 9 *)
                 SWP__NOSENDCHANGING,  (*10 *)
                 SWP__11, SWP__12,
                 SWP__DEFERERASE,      (*13 *)
                 SWP__ASYNCWINDOWPOS); (*14 *)

       SWP_SET = SET OF SWP_ENUM;

CONST  SWP_NOSIZE          = SWP_SET {SWP__NOSIZE};        (* 0x0001 *)
       SWP_NOMOVE          = SWP_SET {SWP__NOMOVE};        (* 0x0002 *)
       SWP_NOZORDER        = SWP_SET {SWP__NOZORDER};      (* 0x0004 *)
       SWP_NOREDRAW        = SWP_SET {SWP__NOREDRAW};      (* 0x0008 *)
       SWP_NOACTIVATE      = SWP_SET {SWP__NOACTIVATE};    (* 0x0010 *)
       SWP_FRAMECHANGED    = SWP_SET {SWP__FRAMECHANGED};  (* 0x0020 *)
                        (* The frame changed: send WM_NCCALCSIZE *)
       SWP_SHOWWINDOW      = SWP_SET {SWP__SHOWWINDOW};    (* 0x0040 *)
       SWP_HIDEWINDOW      = SWP_SET {SWP__HIDEWINDOW};    (* 0x0080 *)
       SWP_NOCOPYBITS      = SWP_SET {SWP__NOCOPYBITS};    (* 0x0100 *)
       SWP_NOOWNERZORDER   = SWP_SET {SWP__NOOWNERZORDER}; (* 0x0200 *)
                        (* Don't do owner Z ordering *)
       SWP_NOSENDCHANGING  = SWP_SET {SWP__NOSENDCHANGING}; (* 0x0400 *)
       SWP_DEFERERASE      = SWP_SET {SWP__DEFERERASE};     (* 0x2000 *)
       SWP_ASYNCWINDOWPOS  = SWP_SET {SWP__ASYNCWINDOWPOS}; (* 0x4000 *)

       SWP_DRAWFRAME       = SWP_FRAMECHANGED;
       SWP_NOREPOSITION    = SWP_NOOWNERZORDER;

(* WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam *)

TYPE WINDOWPOS = RECORD
                        hwnd : HWND;
                        hwndInsertAfter : HWND;
                        x, y, cx, cy : INTEGER;
                        flags : SWP_SET;
                 END;
    PWINDOWPOS = POINTER TO WINDOWPOS;

(* WM_NCCALCSIZE parameter structure *)

TYPE NCCALCSIZE_PARAMS = RECORD
                                rgrc  : ARRAY [0..2] OF RECT;
                                lppos : PWINDOWPOS;
                         END;
    PNCCALCSIZE_PARAMS = POINTER TO NCCALCSIZE_PARAMS;

(* WM_NCCALCSIZE "window valid rect" return values *)

CONST  WVR_ALIGNTOP        = 0010h;
       WVR_ALIGNLEFT       = 0020h;
       WVR_ALIGNBOTTOM     = 0040h;
       WVR_ALIGNRIGHT      = 0080h;
       WVR_HREDRAW         = 0100h;
       WVR_VREDRAW         = 0200h;
       WVR_REDRAW          = (WVR_HREDRAW + WVR_VREDRAW);
       WVR_VALIDRECTS      = 0400h;

(* Key State Masks for Mouse Messages *)

TYPE MK_ENUM = (MK__LBUTTON,  (* 0 *)
                MK__RBUTTON,  (* 1 *)
                MK__SHIFT,    (* 2 *)
                MK__CONTROL,  (* 3 *)
                MK__MBUTTON); (* 4 *)
     MK_SET = SET OF MK_ENUM;

CONST  MK_LBUTTON  = MK_SET {MK__LBUTTON}; (* 0x0001 *)
       MK_RBUTTON  = MK_SET {MK__RBUTTON}; (* 0x0002 *)
       MK_SHIFT    = MK_SET {MK__SHIFT};   (* 0x0004 *)
       MK_CONTROL  = MK_SET {MK__CONTROL}; (* 0x0008 *)
       MK_MBUTTON  = MK_SET {MK__MBUTTON}; (* 0x0010 *)

TYPE TME_ENUM = [0..31];
CONST TME__HOVER  = 0;
      TME__LEAVE  = 1;
      TME__QUERY  = 30;
      TME__CANCEL = 31;

TYPE  TME_SET = SET OF TME_ENUM;

CONST TME_HOVER  = TME_SET {TME__HOVER};  (* 0x00000001 *)
      TME_LEAVE  = TME_SET {TME__LEAVE};  (* 0x00000002 *)
      TME_QUERY  = TME_SET {TME__QUERY};  (* 0x40000000 *)
      TME_CANCEL = TME_SET {TME__CANCEL}; (* 0x80000000 *)

CONST HOVER_DEFAULT = 0FFFFFFFFh;

TYPE TRACKMOUSEEVENT = RECORD
                              cbSize : DWORD;
                              dwFlags : TME_SET;
                              hwndTrack : HWND;
                              dwHoverTime : DWORD;
                       END;
    PTRACKMOUSEEVENT = POINTER TO TRACKMOUSEEVENT;

PROCEDURE TrackMouseEvent (VAR EventTrack : TRACKMOUSEEVENT);

(* Window Styles *)

TYPE WS_ENUM =  (WS__0,  WS__1,  WS__2,  WS__3,  WS__4,  WS__5,  WS__6,  WS__7,
                 WS__8,  WS__9,  WS__10, WS__11, WS__12, WS__13, WS__14, WS__15,
                 WS__16, WS__17, WS__18, WS__19, WS__20, WS__21, WS__22, WS__23,
                 WS__24, WS__25, WS__26, WS__27, WS__28, WS__29, WS__30, WS__31);

     WS_SET = SET OF WS_ENUM; (* 32-bit value with bit 0 LSB *)

(* Basic window Styles *)

CONST WS_OVERLAPPED     = WS_SET {  };                (* 0x00000000L *)
      WS_POPUP          = WS_SET {WS__31};            (* 0x80000000L *)
      WS_CHILD          = WS_SET {WS__30};            (* 0x40000000L *)
      WS_MINIMIZE       = WS_SET {WS__29};            (* 0x20000000L *)
      WS_VISIBLE        = WS_SET {WS__28};            (* 0x10000000L *)
      WS_DISABLED       = WS_SET {WS__27};            (* 0x08000000L *)
      WS_CLIPSIBLINGS   = WS_SET {WS__26};            (* 0x04000000L *)
      WS_CLIPCHILDREN   = WS_SET {WS__25};            (* 0x02000000L *)
      WS_MAXIMIZE       = WS_SET {WS__24};            (* 0x01000000L *)
      WS_BORDER         = WS_SET {WS__23};            (* 0x00800000L *)
      WS_DLGFRAME       = WS_SET {WS__22};            (* 0x00400000L *)
      WS_CAPTION        = WS_BORDER + WS_DLGFRAME;    (* 0x00C00000L *)
      WS_VSCROLL        = WS_SET {WS__21};            (* 0x00200000L *)
      WS_HSCROLL        = WS_SET {WS__20};            (* 0x00100000L *)
      WS_SYSMENU        = WS_SET {WS__19};            (* 0x00080000L *)
      WS_THICKFRAME     = WS_SET {WS__18};            (* 0x00040000L *)
      WS_GROUP          = WS_SET {WS__17};            (* 0x00020000L *)
      WS_TABSTOP        = WS_SET {WS__16};            (* 0x00010000L *)

      WS_MINIMIZEBOX    = WS_SET {WS__17};            (* 0x00020000L *)
      WS_MAXIMIZEBOX    = WS_SET {WS__16};            (* 0x00010000L *)

      WS_TILED          = WS_OVERLAPPED;
      WS_ICONIC         = WS_MINIMIZE;
      WS_SIZEBOX        = WS_THICKFRAME;

(* Common Window Styles *)

CONST WS_OVERLAPPEDWINDOW = WS_OVERLAPPED  +
                            WS_CAPTION     +
                            WS_SYSMENU     +
                            WS_THICKFRAME  +
                            WS_MINIMIZEBOX +
                            WS_MAXIMIZEBOX;

      WS_TILEDWINDOW    = WS_OVERLAPPEDWINDOW;

      WS_POPUPWINDOW      = WS_POPUP   +
                            WS_BORDER  +
                            WS_SYSMENU;

      WS_CHILDWINDOW      = WS_CHILD;

(* Extended window styles *)

TYPE WS_EX_ENUM =  (WS_EX__DLGMODALFRAME,   (* 0 *)
                    WS_EX__1,
                    WS_EX__NOPARENTNOTIFY,  (* 2 *)
                    WS_EX__TOPMOST,         (* 3 *)
                    WS_EX__ACCEPTFILES,     (* 4 *)
                    WS_EX__TRANSPARENT,     (* 5 *)
                    WS_EX__MDICHILD,        (* 6 *)
                    WS_EX__TOOLWINDOW,      (* 7 *)
                    WS_EX__WINDOWEDGE,      (* 8 *)
                    WS_EX__CLIENTEDGE,      (* 9 *)
                    WS_EX__CONTEXTHELP,     (*10 *)
                    WS_EX__11,
                    WS_EX__RIGHT,           (* 12 *)
                    WS_EX__RTLREADING,      (* 13 *)
                    WS_EX__LEFTSCROLLBAR,   (* 14 *)
                    WS_EX__15,
                    WS_EX__CONTROLPARENT,   (* 16 *)
                    WS_EX__STATICEDGE,      (* 17 *)
                    WS_EX__APPWINDOW);      (* 18 *)

     WS_EX_SET = SET OF WS_EX_ENUM; (* assumed 32-bit set *)

CONST WS_EX_DLGMODALFRAME  = WS_EX_SET {WS_EX__DLGMODALFRAME};  (* 0x00000001L *)
      WS_EX_NOPARENTNOTIFY = WS_EX_SET {WS_EX__NOPARENTNOTIFY}; (* 0x00000004L *)
      WS_EX_TOPMOST        = WS_EX_SET {WS_EX__TOPMOST};        (* 0x00000008L *)
      WS_EX_ACCEPTFILES    = WS_EX_SET {WS_EX__ACCEPTFILES};    (* 0x00000010L *)
      WS_EX_TRANSPARENT    = WS_EX_SET {WS_EX__TRANSPARENT};    (* 0x00000020L *)
      WS_EX_MDICHILD       = WS_EX_SET {WS_EX__MDICHILD};       (* 0x00000040L *)
      WS_EX_TOOLWINDOW     = WS_EX_SET {WS_EX__TOOLWINDOW};     (* 0x00000080L *)
      WS_EX_WINDOWEDGE     = WS_EX_SET {WS_EX__WINDOWEDGE};     (* 0x00000100L *)
      WS_EX_CLIENTEDGE     = WS_EX_SET {WS_EX__CLIENTEDGE};     (* 0x00000200L *)
      WS_EX_CONTEXTHELP    = WS_EX_SET {WS_EX__CONTEXTHELP};    (* 0x00000400L *)
      WS_EX_RIGHT          = WS_EX_SET {WS_EX__RIGHT};          (* 0x00001000L *)
      WS_EX_LEFT           = WS_EX_SET {};                      (* 0x00000000L *)
      WS_EX_RTLREADING     = WS_EX_SET {WS_EX__RTLREADING};     (* 0x00002000L *)
      WS_EX_LTRREADING     = WS_EX_SET {};                      (* 0x00000000L *)
      WS_EX_LEFTSCROLLBAR  = WS_EX_SET {WS_EX__LEFTSCROLLBAR};  (* 0x00004000L *)
      WS_EX_RIGHTSCROLLBAR = WS_EX_SET {};                      (* 0x00000000L *)
      WS_EX_CONTROLPARENT  = WS_EX_SET {WS_EX__CONTROLPARENT};  (* 0x00010000L *)
      WS_EX_STATICEDGE     = WS_EX_SET {WS_EX__STATICEDGE};     (* 0x00020000L *)
      WS_EX_APPWINDOW      = WS_EX_SET {WS_EX__APPWINDOW};      (* 0x00040000L *)

      WS_EX_OVERLAPPEDWINDOW = WS_EX_WINDOWEDGE + WS_EX_CLIENTEDGE;
      WS_EX_PALETTEWINDOW    = WS_EX_WINDOWEDGE + WS_EX_TOOLWINDOW + WS_EX_TOPMOST;

(* Class types declared earlier near WNDCLASS structure *)

(* WM_PRINT flags *)

TYPE PRF_ENUM = (PRF__CHECKVISIBLE,  (* 0 *)
                 PRF__NONCLIENT,     (* 1 *)
                 PRF__CLIENT,        (* 2 *)
                 PRF__ERASEBKGND,    (* 3 *)
                 PRF__CHILDREN,      (* 4 *)
                 PRF__OWNED);        (* 5 *)
     PRF_SET = SET OF PRF_ENUM;

CONST PRF_CHECKVISIBLE = PRF_SET {PRF__CHECKVISIBLE}; (* 0x00000001L *)
      PRF_NONCLIENT    = PRF_SET {PRF__NONCLIENT};    (* 0x00000002L *)
      PRF_CLIENT       = PRF_SET {PRF__CLIENT};       (* 0x00000004L *)
      PRF_ERASEBKGND   = PRF_SET {PRF__ERASEBKGND};   (* 0x00000008L *)
      PRF_CHILDREN     = PRF_SET {PRF__CHILDREN};     (* 0x00000010L *)
      PRF_OWNED        = PRF_SET {PRF__OWNED};        (* 0x00000020L *)

(* 3D border styles *)

TYPE BDR_ENUM = (BDR__RAISEDOUTER,  (* 0 *)
                 BDR__SUNKENOUTER,  (* 1 *)
                 BDR__RAISEDINNER,  (* 2 *)
                 BDR__SUNKENINNER); (* 3 *)
      BDR_SET = SET OF BDR_ENUM;

CONST BDR_RAISEDOUTER = BDR_SET {BDR__RAISEDOUTER}; (* 0x0001 *)
      BDR_SUNKENOUTER = BDR_SET {BDR__SUNKENOUTER}; (* 0x0002 *)
      BDR_RAISEDINNER = BDR_SET {BDR__RAISEDINNER}; (* 0x0004 *)
      BDR_SUNKENINNER = BDR_SET {BDR__SUNKENINNER}; (* 0x0008 *)

      BDR_OUTER  =  BDR_SUNKENOUTER + BDR_RAISEDOUTER; (* 0x0003 *)
      BDR_INNER  =  BDR_SUNKENINNER + BDR_RAISEDINNER; (* 0x000c *)
      BDR_RAISED =  BDR_RAISEDINNER + BDR_RAISEDOUTER; (* 0x0005 *)
      BDR_SUNKEN =  BDR_SUNKENINNER + BDR_SUNKENOUTER; (* 0x000a *)

      EDGE_RAISED = BDR_RAISEDOUTER + BDR_RAISEDINNER;
      EDGE_SUNKEN = BDR_SUNKENOUTER + BDR_SUNKENINNER;
      EDGE_ETCHED = BDR_SUNKENOUTER + BDR_RAISEDINNER;
      EDGE_BUMP   = BDR_RAISEDOUTER + BDR_SUNKENINNER;

(* Border flags *)

TYPE BF_ENUM = (BF__LEFT,       (* 0 *)
                BF__TOP,        (* 1 *)
                BF__RIGHT,      (* 2 *)
                BF__BOTTOM,     (* 3 *)
                BF__DIAGONAL,   (* 4 *)
                BF__5, BF__6,
                BF__7, BF__8,
                BF__9, BF__10,
                BF__MIDDLE,     (* 11 *)
                BF__SOFT,       (* 12 *)
                BF__ADJUST,     (* 13 *)
                BF__FLAT,       (* 14 *)
                BF__MONO);      (* 15 *)

     BF_SET = SET OF BF_ENUM;

CONST BF_LEFT   = BF_SET {BF__LEFT};       (* 0x0001 *)
      BF_TOP    = BF_SET {BF__TOP};        (* 0x0002 *)
      BF_RIGHT  = BF_SET {BF__RIGHT};      (* 0x0004 *)
      BF_BOTTOM = BF_SET {BF__BOTTOM};     (* 0x0008 *)

      BF_TOPLEFT     = BF_TOP + BF_LEFT;
      BF_TOPRIGHT    = BF_TOP + BF_RIGHT;
      BF_BOTTOMLEFT  = BF_BOTTOM + BF_LEFT;
      BF_BOTTOMRIGHT = BF_BOTTOM + BF_RIGHT;
      BF_RECT        = BF_LEFT + BF_TOP + BF_RIGHT + BF_BOTTOM;

      BF_DIAGONAL    = BF_SET {BF__DIAGONAL}; (* 0x0010 *)

(* For diagonal lines, the BF_RECT flags specify the end point of the
   vector bounded by the rectangle parameter.
*)

CONST  BF_DIAGONAL_ENDTOPRIGHT    = BF_DIAGONAL + BF_TOP    + BF_RIGHT;
       BF_DIAGONAL_ENDTOPLEFT     = BF_DIAGONAL + BF_TOP    + BF_LEFT;
       BF_DIAGONAL_ENDBOTTOMLEFT  = BF_DIAGONAL + BF_BOTTOM + BF_LEFT;
       BF_DIAGONAL_ENDBOTTOMRIGHT = BF_DIAGONAL + BF_BOTTOM + BF_RIGHT;

CONST BF_MIDDLE = BF_SET {BF__MIDDLE};  (* 0x0800  - Fill in the middle *)
      BF_SOFT   = BF_SET {BF__SOFT};    (* 0x1000  - For softer buttons *)
      BF_ADJUST = BF_SET {BF__ADJUST};  (* 0x2000  - Calculate the space left over *)
      BF_FLAT   = BF_SET {BF__FLAT};    (* 0x4000  - For flat rather than 3D borders *)
      BF_MONO   = BF_SET {BF__MONO};    (* 0x8000  - For monochrome borders *)

<* IF BACKEND # "C" THEN *>
PROCEDURE DrawEdge (hdc : HDC; qrc : RECT; (* NIL *)
                    edge : BDR_SET;
                    grfFlags : BF_SET) : BOOL;
<* ELSE *>
PROCEDURE DrawEdge (hdc : HDC; qrc : PRECT; (* NIL *)
                    edge : BDR_SET;
                    grfFlags : BF_SET) : BOOL;
<* END *>


(* flags for DrawFrameControl *)

TYPE DFC_ENUM = (DFC_0,
                 DFC_CAPTION, (* 1 *)
                 DFC_MENU,    (* 2 *)
                 DFC_SCROLL,  (* 3 *)
                 DFC_BUTTON); (* 4 *)

TYPE DFCS_ENUM = (DFCS__0, DFCS__1,
                  DFCS__2, DFCS__3,
                  DFCS__4, DFCS__5,
                  DFCS__6, DFCS__7,
                  DFCS__INACTIVE,        (*  8 *)
                  DFCS__PUSHED,          (*  9 *)
                  DFCS__CHECKED,         (* 10 *)
                  DFCS__11, DFCS__12,
                  DFCS__ADJUSTRECT,      (* 13 *)
                  DFCS__FLAT,            (* 14 *)
                  DFCS__MONO);           (* 15 *)
     DFCS_SET = SET OF DFCS_ENUM;

CONST DFCS_CAPTIONCLOSE        = DFCS_SET {};                 (* 0x0000 *)
      DFCS_CAPTIONMIN          = DFCS_SET {DFCS__0};          (* 0x0001 *)
      DFCS_CAPTIONMAX          = DFCS_SET {DFCS__1};          (* 0x0002 *)
      DFCS_CAPTIONRESTORE      = DFCS_SET {DFCS__0, DFCS__1}; (* 0x0003 *)
      DFCS_CAPTIONHELP         = DFCS_SET {DFCS__2};          (* 0x0004 *)

      DFCS_MENUARROW           = DFCS_SET {};                 (* 0x0000 *)
      DFCS_MENUCHECK           = DFCS_SET {DFCS__0};          (* 0x0001 *)
      DFCS_MENUBULLET          = DFCS_SET {DFCS__1};          (* 0x0002 *)
      DFCS_MENUARROWRIGHT      = DFCS_SET {DFCS__2};          (* 0x0004 *)

      DFCS_SCROLLUP            = DFCS_SET {};                 (* 0x0000 *)
      DFCS_SCROLLDOWN          = DFCS_SET {DFCS__0};          (* 0x0001 *)
      DFCS_SCROLLLEFT          = DFCS_SET {DFCS__1};          (* 0x0002 *)
      DFCS_SCROLLRIGHT         = DFCS_SET {DFCS__0, DFCS__1}; (* 0x0003 *)
      DFCS_SCROLLCOMBOBOX      = DFCS_SET {DFCS__0, DFCS__2}; (* 0x0005 *)
      DFCS_SCROLLSIZEGRIP      = DFCS_SET {DFCS__3};          (* 0x0008 *)
      DFCS_SCROLLSIZEGRIPRIGHT = DFCS_SET {DFCS__4};          (* 0x0010 *)

      DFCS_BUTTONCHECK         = DFCS_SET {};                 (* 0x0000 *)
      DFCS_BUTTONRADIOIMAGE    = DFCS_SET {DFCS__0};          (* 0x0001 *)
      DFCS_BUTTONRADIOMASK     = DFCS_SET {DFCS__1};          (* 0x0002 *)
      DFCS_BUTTONRADIO         = DFCS_SET {DFCS__2};          (* 0x0004 *)
      DFCS_BUTTON3STATE        = DFCS_SET {DFCS__3};          (* 0x0008 *)
      DFCS_BUTTONPUSH          = DFCS_SET {DFCS__4};          (* 0x0010 *)

      DFCS_INACTIVE            = DFCS_SET {DFCS__INACTIVE};   (* 0x0100 *)
      DFCS_PUSHED              = DFCS_SET {DFCS__PUSHED};     (* 0x0200 *)
      DFCS_CHECKED             = DFCS_SET {DFCS__CHECKED};    (* 0x0400 *)
      DFCS_ADJUSTRECT          = DFCS_SET {DFCS__ADJUSTRECT}; (* 0x2000 *)
      DFCS_FLAT                = DFCS_SET {DFCS__FLAT};       (* 0x4000 *)
      DFCS_MONO                = DFCS_SET {DFCS__MONO};       (* 0x8000 *)

<* IF BACKEND # "C" THEN *>
PROCEDURE DrawFrameControl (hdc : HDC; rect : RECT; (* IN *)
                            uType : DFC_ENUM; uState : DFCS_SET) : BOOL;
<* ELSE *>
PROCEDURE DrawFrameControl (hdc : HDC; rect : PRECT; (* IN *)
                            uType : DFC_ENUM; uState : DFCS_SET) : BOOL;
<* END *>

(* flags for DrawCaption *)

TYPE DC_ENUM = (DC__ACTIVE,    (* 0 *)
                DC__SMALLCAP,  (* 1 *)
                DC__ICON,      (* 2 *)
                DC__TEXT,      (* 3 *)
                DC__INBUTTON); (* 4 *)
     DC_SET = SET OF DC_ENUM;

CONST DC_ACTIVE   = DC_SET {DC__ACTIVE};   (* 0x0001 *)
      DC_SMALLCAP = DC_SET {DC__SMALLCAP}; (* 0x0002 *)
      DC_ICON     = DC_SET {DC__ICON};     (* 0x0004 *)
      DC_TEXT     = DC_SET {DC__TEXT};     (* 0x0008 *)
      DC_INBUTTON = DC_SET {DC__INBUTTON}; (* 0x0010 *)

<* IF BACKEND # "C" THEN *>
PROCEDURE DrawCaption (hwnd : HWND; hdc : HDC;
                       rect : RECT; (* NIL *)
                       wFlags : DC_SET) : BOOL;
<* ELSE *>
PROCEDURE DrawCaption (hwnd : HWND; hdc : HDC;
                       rect : PRECT; (* NIL *)
                       wFlags : DC_SET) : BOOL;
<* END *>


TYPE IDANI_ENUM = (IDANI_0,
                   IDANI_OPEN,     (* 1 *)
                   IDANI_CLOSE,    (* 2 *)
                   IDANI_CAPTION); (* 3 *)

<* IF BACKEND # "C" THEN *>
PROCEDURE DrawAnimatedRects (hwnd : HWND;
                             idAni : IDANI_ENUM;
                             lprcFrom : RECT; (* IN *)
                             lprcTo   : RECT  (* IN *)) : BOOL;
<* ELSE *>
PROCEDURE DrawAnimatedRects (hwnd : HWND;
                             idAni : IDANI_ENUM;
                             lprcFrom : PRECT; (* IN *)
                             lprcTo   : PRECT  (* IN *)) : BOOL;
<* END *>


TYPE CF_TYPE = UINT;

(* Predefined Clipboard Formats *)

CONST CF_TEXT           =  1;
      CF_BITMAP         =  2;
      CF_METAFILEPICT   =  3;
      CF_SYLK           =  4;
      CF_DIF            =  5;
      CF_TIFF           =  6;
      CF_OEMTEXT        =  7;
      CF_DIB            =  8;
      CF_PALETTE        =  9;
      CF_PENDATA        = 10;
      CF_RIFF           = 11;
      CF_WAVE           = 12;
      CF_UNICODETEXT    = 13;
      CF_ENHMETAFILE    = 14;
      CF_HDROP          = 15;
      CF_LOCALE         = 16;
      CF_MAX            = 17;

      CF_OWNERDISPLAY   =  0080h;
      CF_DSPTEXT        =  0081h;
      CF_DSPBITMAP      =  0082h;
      CF_DSPMETAFILEPICT=  0083h;
      CF_DSPENHMETAFILE =  008Eh;

(* "Private" formats don't get GlobalFree()'d *)

      CF_PRIVATEFIRST   =  0200h;
      CF_PRIVATELAST    =  02FFh;

(* "GDIOBJ" formats do get DeleteObject()'d *)

      CF_GDIOBJFIRST    =  0300h;
      CF_GDIOBJLAST     =  03FFh;

(* Values of the fVirt field of the Accelerator table structure *)

<* PUSH *> <* SETSIZE = "1" *>

TYPE FVIRT_ENUM = (FVIRT__FVIRTKEY,  (* 0 *)
                   FVIRT__FNOINVERT, (* 1 *)
                   FVIRT__FSHIFT,    (* 2 *)
                   FVIRT__FCONTROL,  (* 3 *)
                   FVIRT__FALT);     (* 4 *)

TYPE FVIRT_SET = SET OF FVIRT_ENUM;

CONST FVIRTKEY   =  FVIRT_SET {FVIRT__FVIRTKEY};  (* 1 *)
      FNOINVERT  =  FVIRT_SET {FVIRT__FNOINVERT}; (* 2 *)
      FSHIFT     =  FVIRT_SET {FVIRT__FSHIFT};    (* 4 *)
      FCONTROL   =  FVIRT_SET {FVIRT__FCONTROL};  (* 8 *)
      FALT       =  FVIRT_SET {FVIRT__FALT};      (* 16 *)

<* POP *>

TYPE ACCEL = RECORD
                  fVirt   : BYTE;
                  key     : WORD;
                  cmd     : WORD;
             END;

TYPE PAINTSTRUCT = RECORD
                          hdc         : HDC;
                          fErase      : BOOL;
                          rcPaint     : RECT;
                          fRestore    : BOOL;
                          fIncUpdate  : BOOL;
                          rgbReserved : ARRAY [0..31] OF BYTE;
                   END;

TYPE CREATESTRUCTA = RECORD
                            lpCreateParams : PBYTE;
                            hInstance  : HINSTANCE;
                            hMenu      : HMENU;
                            hwndParent : HWND;
                            cy, cx     : INTEGER;
                            y, x       : INTEGER;
                            style      : WS_SET;
                            lpszName   : PSTR;
                            lpszClass  : PSTR;
                            dwExStyle  : WS_EX_SET;
                     END;

     CREATESTRUCTW = RECORD
                            lpCreateParams : PBYTE;
                            hInstance  : HINSTANCE;
                            hMenu      : HMENU;
                            hwndParent : HWND;
                            cy, cx     : INTEGER;
                            y, x       : INTEGER;
                            style      : WS_SET;
                            lpszName   : PWSTR;
                            lpszClass  : PWSTR;
                            dwExStyle  : WS_EX_SET;
                     END;

<* IF DEFINED (UNICODE) THEN *>
      CREATESTRUCT  = CREATESTRUCTW;
      PCREATESTRUCT = PCREATESTRUCTW;
<* ELSE *>
      CREATESTRUCT  = CREATESTRUCTA;
      PCREATESTRUCT = PCREATESTRUCTA;
<* END *>

TYPE WPF_ENUM = (WPF__SETMINPOSITION, WPF__RESTORETOMAXINIZED);
     WPF_SET = SET OF WPF_ENUM;

CONST WPF_SETMINPOSITION     = WPF_SET {WPF__SETMINPOSITION};     (* 0x0001 *)
      WPF_RESTORETOMAXIMIZED = WPF_SET {WPF__RESTORETOMAXINIZED}; (* 0x0002 *)

TYPE WINDOWPLACEMENT = RECORD
                            length  : UINT;
                            flags   : WPF_SET;
                            showCmd : SW_ENUM;
                            ptMinPosition : POINT;
                            ptMaxPosition : POINT;
                            rcNormalPosition : RECT;
                       END;
    PWINDOWPLACEMENT= POINTER TO WINDOWPLACEMENT;

TYPE NM_CODE = UINT;
     NMHDR = RECORD
                    hwndFrom : HWND;
                    idFrom   : UINT;
                    code     : NM_CODE;  (* codes are defined in commctrl.h *)
             END;
    PNMHDR = POINTER TO NMHDR;

TYPE STYLESTRUCT = RECORD
                          styleOld : DWORD; (* both WS_SET and WS_EX_SET can be here *)
                          styleNew : DWORD;
                   END;
    PSTYLESTRUCT = POINTER TO STYLESTRUCT;

(*
 * Owner draw control types
 *)

TYPE ODT_ENUM = (ODT_0,
                 ODT_MENU,
                 ODT_LISTBOX,
                 ODT_COMBOBOX,
                 ODT_BUTTON,
                 ODT_STATIC);

(*
 * Owner draw actions
 *)

TYPE ODA_ENUM = (ODA__DRAWENTIRE, (* 0 *)
                 ODA__SELECT,     (* 1 *)
                 ODA__FOCUS);     (* 2 *)
     ODA_SET = SET OF ODA_ENUM;

CONST ODA_DRAWENTIRE = ODA_SET {ODA__DRAWENTIRE};  (* 0001h *)
      ODA_SELECT     = ODA_SET {ODA__SELECT};      (* 0002h *)
      ODA_FOCUS      = ODA_SET {ODA__FOCUS};       (* 0004h *)

(*
 * Owner draw state
 *)

TYPE ODS_ENUM = (ODS__SELECTED,      (*  0 *)
                 ODS__GRAYED,        (*  1 *)
                 ODS__DISABLED,      (*  2 *)
                 ODS__CHECKED,       (*  3 *)
                 ODS__FOCUS,         (*  4 *)
                 ODS__DEFAULT,       (*  5 *)
                 ODS__6, ODS__7,
                 ODS__8, ODS__9,
                 ODS__10,ODS__11,
                 ODS__COMBOBOXEDIT); (* 12 *)

     ODS_SET = SET OF ODS_ENUM;

CONST ODS_SELECTED     = ODS_SET {ODS__SELECTED};     (* 0x0001 *)
      ODS_GRAYED       = ODS_SET {ODS__GRAYED};       (* 0x0002 *)
      ODS_DISABLED     = ODS_SET {ODS__DISABLED};     (* 0x0004 *)
      ODS_CHECKED      = ODS_SET {ODS__CHECKED};      (* 0x0008 *)
      ODS_FOCUS        = ODS_SET {ODS__FOCUS};        (* 0x0010 *)
      ODS_DEFAULT      = ODS_SET {ODS__DEFAULT};      (* 0x0020 *)
      ODS_COMBOBOXEDIT = ODS_SET {ODS__COMBOBOXEDIT}; (* 0x1000 *)

(*
 * MEASUREITEMSTRUCT for ownerdraw
 *)

TYPE MEASUREITEMSTRUCT = RECORD
                                CtlType    : ODT_ENUM;
                                CtlID      : UINT;
                                itemID     : UINT;
                                itemWidth  : UINT;
                                itemHeight : UINT;
                                itemData   : DWORD;
                         END;

    PMEASUREITEMSTRUCT = POINTER TO MEASUREITEMSTRUCT;

(*
 * DRAWITEMSTRUCT for ownerdraw
 *)

TYPE DRAWITEMSTRUCT = RECORD
                             CtlType    : ODT_ENUM;
                             CtlID      : UINT;
                             itemID     : UINT;
                             itemAction : ODA_SET;
                             itemState  : ODS_SET;
                             hwndItem   : HWND;
                             hDC        : HDC;
                             rcItem     : RECT;
                             itemData   : DWORD;
                      END;
    PDRAWITEMSTRUCT = POINTER TO DRAWITEMSTRUCT;

(*
 * DELETEITEMSTRUCT for ownerdraw
 *)

TYPE DELETEITEMSTRUCT = RECORD
                               CtlType  : ODT_ENUM;
                               CtlID    : UINT;
                               itemID   : UINT;
                               hwndItem : HWND;
                               itemData : UINT;
                        END;
    PDELETEITEMSTRUCT = POINTER TO DELETEITEMSTRUCT;

(*
 * COMPAREITEMSTUCT for ownerdraw sorting
 *)

TYPE COMPAREITEMSTRUCT = RECORD
                                CtlType    : ODT_ENUM;
                                CtlID      : UINT;
                                hwndItem   : HWND;
                                itemID1    : UINT;
                                itemData1  : DWORD;
                                itemID2    : UINT;
                                itemData2  : DWORD;
                                dwLocaleId : DWORD;
                         END;
    PCOMPAREITEMSTRUCT = POINTER TO COMPAREITEMSTRUCT;

PROCEDURE GetMessageA (VAR msg : MSG; hWnd : HWND;
                       MsgFilterMin, MsgFilterMax : UINT) : BOOL;
PROCEDURE GetMessageW (VAR msg : MSG; hWnd : HWND;
                       MsgFilterMin, MsgFilterMax : UINT) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetMessage      = GetMessageW;
<* ELSE *>
      CONST GetMessage      = GetMessageA;
<* END *>

PROCEDURE TranslateMessage (VAR msg : MSG) : BOOL;

PROCEDURE DispatchMessageA (VAR msg : MSG) : LONG;
PROCEDURE DispatchMessageW (VAR msg : MSG) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST DispatchMessage = DispatchMessageW;
<* ELSE *>
      CONST DispatchMessage = DispatchMessageA;
<* END *>

PROCEDURE SetMessageQueue  (MessagesMax : INTEGER) : BOOL;

(* constants for parameter RemoveMsg of PeekMessage *)

TYPE PM_ENUM = (PM_NOREMOVE,    (* 0 *)
                PM_REMOVE,      (* 1 *)
                PM_NOYIELD);    (* 2 *)

PROCEDURE PeekMessageW (VAR msg : MSG; hWnd : HWND;
                        MsgFilterMin, MsgFilterMax : UINT;
                        RemoveMsg : PM_ENUM) : BOOL;
PROCEDURE PeekMessageA (VAR msg : MSG; hWnd : HWND;
                        MsgFilterMin, MsgFilterMax : UINT;
                        RemoveMsg : PM_ENUM) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST PeekMessage     = PeekMessageW;
<* ELSE *>
      CONST PeekMessage     = PeekMessageA;
<* END *>

TYPE MOD_ENUM = (MOD__ALT,     (* 0 *)
                 MOD__CONTROL, (* 1 *)
                 MOD__SHIFT,   (* 2 *)
                 MOD__WIN,     (* 3 *)
                 MOD__4, MOD__5,
                 MOD__6, MOD__7,
                 MOD__8, MOD__9,
                 MOD__IGNORE_ALL_MODIFIER, (* 10 *)
                 MOD__ON_KEYUP,            (* 11 *)
                 MOD__12, MOD__13,
                 MOD__RIGHT,               (* 14 *)
                 MOD__LEFT);               (* 15 *)

     MOD_SET = SET OF MOD_ENUM;

CONST MOD_ALT                 = MOD_SET {MOD__ALT};     (* 0x0001 *)
      MOD_CONTROL             = MOD_SET {MOD__CONTROL}; (* 0x0002 *)
      MOD_SHIFT               = MOD_SET {MOD__SHIFT};   (* 0x0004 *)
      MOD_WIN                 = MOD_SET {MOD__WIN};     (* 0x0008 *)

(* These following originally come from imm.h *)

      MOD_LEFT                = MOD_SET {MOD__LEFT};                (* 0x8000 *)
      MOD_RIGHT               = MOD_SET {MOD__RIGHT};               (* 0x4000 *)

      MOD_ON_KEYUP            = MOD_SET {MOD__ON_KEYUP};            (* 0x0800 *)
      MOD_IGNORE_ALL_MODIFIER = MOD_SET {MOD__IGNORE_ALL_MODIFIER}; (* 0x0400 *)

PROCEDURE RegisterHotKey   (hWnd        : HWND;
                            id          : INTEGER;
                            fsModifiers : MOD_SET;
                            vk          : UINT) : BOOL;

PROCEDURE UnregisterHotKey (hWnd : HWND; id : INTEGER) : BOOL;

CONST IDHOT_SNAPWINDOW  = -1;    (* SHIFT-PRINTSCRN  *)
      IDHOT_SNAPDESKTOP = -2;    (* PRINTSCRN        *)

CONST EW_RESTARTWINDOWS = 0042h;
      EW_REBOOTSYSTEM   = 0043h;
      EW_EXITANDEXECAPP = 0044h;

      ENDSESSION_LOGOFF = 80000000h;


TYPE EWX_ENUM = (EWX__SHUTDOWN,  (* 0 *)
                 EWX__REBOOT,    (* 1 *)
                 EWX__FORCE,     (* 2 *)
                 EWX__POWEROFF); (* 3 *)
     EWX_SET = SET OF EWX_ENUM;

CONST EWX_LOGOFF   = EWX_SET {};              (* 0 *)
      EWX_SHUTDOWN = EWX_SET {EWX__SHUTDOWN}; (* 1 *)
      EWX_REBOOT   = EWX_SET {EWX__REBOOT};   (* 2 *)
      EWX_FORCE    = EWX_SET {EWX__FORCE};    (* 4 *)
      EWX_POWEROFF = EWX_SET {EWX__POWEROFF}; (* 8 *)

(* implemented in RTL because it was macro *)
PROCEDURE ExitWindows (dwReserved : DWORD; Code : INTEGER) : BOOL;

PROCEDURE ExitWindowsEx (uFlags : EWX_SET;
                         dwReserved : DWORD) : BOOL;

PROCEDURE SwapMouseButton (Swap : BOOL) : BOOL;

PROCEDURE GetMessagePos  () : DWORD; (* actually coordinates pair *)
PROCEDURE GetMessageTime () : DWORD; (* actually a time *)
PROCEDURE GetMessageExtraInfo () : DWORD;
PROCEDURE SetMessageExtraInfo (lParam : LPARAM) : LPARAM;

PROCEDURE SendMessageA (hWnd : HWND; Msg : UINT;
                        wParam : WPARAM; lParam : LPARAM) : LRESULT;
PROCEDURE SendMessageW (hWnd : HWND; Msg : UINT;
                        wParam : WPARAM; lParam : LPARAM) : LRESULT;

PROCEDURE SendMessageTimeoutA (hWnd : HWND; Msg : UINT;
                               wParam : WPARAM; lParam : LPARAM;
                               fuFlags : SMTO_SET; TimeOut : UINT;
                               VAR Result : DWORD)
                                                   : LRESULT;
PROCEDURE SendMessageTimeoutW (hWnd : HWND; Msg : UINT;
                               wParam : WPARAM; lParam : LPARAM;
                               fuFlags : SMTO_SET; TimeOut : UINT;
                               VAR Result : DWORD);

PROCEDURE SendNotifyMessageA (hWnd : HWND; Msg : UINT;
                              wParam : WPARAM; lParam : LPARAM) : BOOL;
PROCEDURE SendNotifyMessageW (hWnd : HWND; Msg : UINT;
                              wParam : WPARAM; lParam : LPARAM) : BOOL;

PROCEDURE SendMessageCallbackA (hWnd : HWND; Msg : UINT;
                                wParam : WPARAM; lParam : LPARAM;
                                ResultCallBack : SENDASYNCPROC;
                                Data : DWORD)
                                              : BOOL;
PROCEDURE SendMessageCallbackW (hWnd : HWND; Msg : UINT;
                                wParam : WPARAM; lParam : LPARAM;
                                ResultCallBack : SENDASYNCPROC;
                                Data : DWORD)
                                              : BOOL;


<* IF DEFINED (UNICODE) THEN *>
      CONST SendMessage         = SendMessageW;
            SendMessageTimeOut  = SendMessageTimeoutW;
            SendNotifyMessage   = SendNotifyMessageW;
            SendMessageCallback = SendMessageCallbackW;
<* ELSE *>
      CONST SendMessage         = SendMessageA;
            SendMessageTimeOut  = SendMessageTimeoutA;
            SendNotifyMessage   = SendNotifyMessageA;
            SendMessageCallback = SendMessageCallbackA;
<* END *>

(* Broadcast Special Message Recipient list *)

TYPE BSM_ENUM = (BSM__VXDS,               (* 0 *)
                 BSM__NETDRIVER,          (* 1 *)
                 BSM__INSTALLABLEDRIVERS, (* 2 *)
                 BSM__APPLICATIONS,       (* 3 *)
                 BSM__ALLDESKTOPS);       (* 4 *)
     BSM_SET = SET OF BSM_ENUM;
    PBSM_SET = POINTER TO BSM_SET;

CONST BSM_ALLCOMPONENTS      = BSM_SET {};                        (* 0x00000000 *)
      BSM_VXDS               = BSM_SET {BSM__VXDS};               (* 0x00000001 *)
      BSM_NETDRIVER          = BSM_SET {BSM__NETDRIVER};          (* 0x00000002 *)
      BSM_INSTALLABLEDRIVERS = BSM_SET {BSM__INSTALLABLEDRIVERS}; (* 0x00000004 *)
      BSM_APPLICATIONS       = BSM_SET {BSM__APPLICATIONS};       (* 0x00000008 *)
      BSM_ALLDESKTOPS        = BSM_SET {BSM__ALLDESKTOPS};        (* 0x00000010 *)

(* Broadcast Special Message Flags *)

TYPE BSF_ENUM = (BSF__QUERY,               (* 0 *)
                 BSF__IGNORECURRENTTASK,   (* 1 *)
                 BSF__FLUSHDISK,           (* 2 *)
                 BSF__NOHANG,              (* 3 *)
                 BSF__POSTMESSAGE,         (* 4 *)
                 BSF__FORCEIFHUNG,         (* 5 *)
                 BSF__NOTIMEOUTIFNOTHUNG); (* 6 *)
     BSF_SET = SET OF BSF_ENUM;

CONST BSF_QUERY              = BSF_SET {BSF__QUERY};             (* 0x00000001 *)
      BSF_IGNORECURRENTTASK  = BSF_SET {BSF__IGNORECURRENTTASK}; (* 0x00000002 *)
      BSF_FLUSHDISK          = BSF_SET {BSF__FLUSHDISK};         (* 0x00000004 *)
      BSF_NOHANG             = BSF_SET {BSF__NOHANG};            (* 0x00000008 *)
      BSF_POSTMESSAGE        = BSF_SET {BSF__POSTMESSAGE};       (* 0x00000010 *)
      BSF_FORCEIFHUNG        = BSF_SET {BSF__FORCEIFHUNG};       (* 0x00000020 *)
      BSF_NOTIMEOUTIFNOTHUNG = BSF_SET {BSF__NOTIMEOUTIFNOTHUNG};(* 0x00000040 *)

PROCEDURE BroadcastSystemMessage (dwFlags        : BSF_SET;
                                  lpdwRecipients : PBSM_SET;
                                  uiMessage      : UINT;
                                  wParam         : WPARAM;
                                  lParam         : LPARAM) : LONG;

TYPE BROADCASTSYSMSG = RECORD
                              uiMessage : UINT;
                              wParam : WPARAM;
                              lParam : LPARAM;
                       END;

    PBROADCASTSYSMSG = POINTER TO BROADCASTSYSMSG;

CONST DBWF_LPARAMPOINTER   = 8000h;
CONST BROADCAST_QUERY_DENY = 424D5144h; (* Return this value to deny a query *)

PROCEDURE PostMessageA (hWnd : HWND; Msg : UINT;
                        wParam : WPARAM; lParam : LPARAM) : BOOL;
PROCEDURE PostMessageW (hWnd : HWND; Msg : UINT;
                        wParam : WPARAM; lParam : LPARAM) : BOOL;

PROCEDURE PostThreadMessageA (Thread : DWORD; Msg : UINT;
                              wParam : WPARAM; lParam : LPARAM) : BOOL;
PROCEDURE PostThreadMessageW (Thread : DWORD; Msg : UINT;
                              wParam : WPARAM; lParam : LPARAM) : BOOL;
<* IF DEFINED (UNICODE) THEN *>
      CONST PostMessage       = PostMessageW;
            PostThreadMessage = PostThreadMessageW;
<* ELSE *>
      CONST PostMessage       = PostMessageA;
            PostThreadMessage = PostThreadMessageA;
<* END *>

(*
 * Special HWND value for use with PostMessage() and SendMessage()
 *)

CONST HWND_BROADCAST = SYSTEM.CAST (HWND, 0ffffh);

PROCEDURE AttachThreadInput (idAttach : DWORD;
                             idAttachTo : DWORD; fAttach : BOOL) : BOOL;

PROCEDURE ReplyMessage (lResult : LRESULT) : BOOL;
PROCEDURE WaitMessage  () : BOOL;
PROCEDURE WaitForInputIdle (hProcess : HANDLE; Milliseconds : DWORD) : DWORD;

PROCEDURE DefWindowProcA (hWnd : HWND; Msg : UINT;
                          wParam : WPARAM; lParam : LPARAM) : LRESULT;
PROCEDURE DefWindowProcW (hWnd : HWND; Msg : UINT;
                          wParam : WPARAM; lParam : LPARAM) : LRESULT;

<* IF DEFINED (UNICODE) THEN *>
      CONST DefWindowProc   = DefWindowProcW;
<* ELSE *>
      CONST DefWindowProc   = DefWindowProcA;
<* END *>

PROCEDURE PostQuitMessage (ExitCode : INTEGER);

PROCEDURE CallWindowProcA (PrevWindowFunc : WNDPROC;
                           hWnd : HWND;
                           Msg : UINT;
                           wParam : WPARAM;
                           lParam : LPARAM) : LRESULT;
PROCEDURE CallWindowProcW (PrevWindowFunc : WNDPROC;
                           hWnd : HWND;
                           Msg : UINT;
                           wParam : WPARAM;
                           lParam : LPARAM) : LRESULT;

<* IF DEFINED (UNICODE) THEN *>
      CONST CallWindowProc  = CallWindowProcW;
<* ELSE *>
      CONST CallWindowProc  = CallWindowProcA;
<* END *>

PROCEDURE InSendMessage () : BOOL;

PROCEDURE GetDoubleClickTime () : UINT;
PROCEDURE SetDoubleClickTime (t : UINT) : BOOL;

PROCEDURE RegisterClassA (VAR WndClass : WNDCLASSA) : ATOM;
PROCEDURE RegisterClassW (VAR WndClass : WNDCLASSW) : ATOM;
PROCEDURE UnregisterClassA (ClassName : ATOMSTR;
                            hInstance : HINSTANCE)       : BOOL;
PROCEDURE UnregisterClassW (ClassName : ATOMWSTR;
                            hInstance : HINSTANCE)       : BOOL;

PROCEDURE GetClassInfoA (hInstance : HINSTANCE;
                         ClassName : ATOMSTR;
                         VAR WndClass : WNDCLASSA)     : BOOL;
PROCEDURE GetClassInfoW (hInstance : HINSTANCE;
                         ClassName : ATOMWSTR;
                         VAR WndClass : WNDCLASSW)     : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegisterClass = RegisterClassW;
            UnregisterClass = UnregisterClassW;
            GetClassInfo = GetClassInfoW;
<* ELSE *>
      CONST RegisterClass = RegisterClassA;
            UnregisterClass = UnregisterClassA;
            GetClassInfo = GetClassInfoA;
<* END *>

PROCEDURE RegisterClassExA (VAR WndClass : WNDCLASSEXA) : ATOM;
PROCEDURE RegisterClassExW (VAR WndClass : WNDCLASSEXW) : ATOM;

PROCEDURE GetClassInfoExA (hInstance : HINSTANCE;
                         ClassName : ATOMSTR;
                         VAR WndClass : WNDCLASSEXA)     : BOOL;
PROCEDURE GetClassInfoExW (hInstance : HINSTANCE;
                         ClassName : ATOMWSTR;
                         VAR WndClass : WNDCLASSEXW)     : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegisterClassEx = RegisterClassExW;
            GetClassInfoEx = GetClassInfoW;
<* ELSE *>
      CONST RegisterClassEx = RegisterClassExA;
            GetClassInfoEx = GetClassInfoExA;
<* END *>

CONST  CW_USEDEFAULT = MIN(INTEGER); (* to be used as X and Y *)

(*
 * Special value for CreateWindow, et al.
 *)

CONST HWND_DESKTOP = NIL;

(* CreateWindowA and CreateWindowW were macroes, now in RTL *)

PROCEDURE CreateWindowA (ClassName  : ATOMSTR;
                         WindowName : PCSTR;
                         Style : WS_SET;
                         X, Y, Width, Height : INTEGER;
                         hWndParent : HWND;
                         hNenu : HMENU;
                         hInstance : HINSTANCE;
                         Param : PBYTE
                        )
                           : HWND;

PROCEDURE CreateWindowW (ClassName  : ATOMWSTR;
                         WindowName : PCWSTR;
                         Style : WS_SET;
                         X, Y, Width, Height : INTEGER;
                         hWndParent : HWND;
                         hNenu : HMENU;
                         hInstance : HINSTANCE;
                         Param : PBYTE
                        )
                           : HWND;
<* IF DEFINED (UNICODE) THEN *>
      CONST CreateWindow = CreateWindowW;
<* ELSE *>
      CONST CreateWindow = CreateWindowA;
<* END *>

PROCEDURE CreateWindowExA (ExStyle : WS_EX_SET;
                           ClassName  : ATOMSTR;
                           WindowName : PCSTR;
                           Style : WS_SET;
                           X, Y, Width, Height : INTEGER;
                           hWndParent : HWND;
                           hNenu : HMENU;
                           hInstance : HINSTANCE;
                           Param : PBYTE
                          )
                           : HWND;

PROCEDURE CreateWindowExW (ExStyle : WS_EX_SET;
                           ClassName  : ATOMWSTR;
                           WindowName : PCWSTR;
                           Style : WS_SET;
                           X, Y, Width, Height : INTEGER;
                           hWndParent : HWND;
                           hNenu : HMENU;
                           hInstance : HINSTANCE;
                           Param : PBYTE
                          )
                           : HWND;
<* IF DEFINED (UNICODE) THEN *>
      CONST CreateWindowEx = CreateWindowExW;
<* ELSE *>
      CONST CreateWindowEx = CreateWindowExA;
<* END *>

PROCEDURE IsWindow        (hWnd  : HWND)                    : BOOL;
PROCEDURE IsMenu          (hMenu : HMENU)                   : BOOL;
PROCEDURE IsChild         (hWndParent, hWnd : HWND)         : BOOL;
PROCEDURE DestroyWindow   (hWnd : HWND)                     : BOOL;
PROCEDURE ShowWindow      (hWnd : HWND; CmdShow : SW_ENUM)  : BOOL;
PROCEDURE ShowWindowAsync (hWnd : HWND; CmdShow : SW_ENUM)  : BOOL;
PROCEDURE FlashWindow     (hWnd : HWND; Invert : BOOL)      : BOOL;
PROCEDURE ShowOwnedPopups (hWnd : HWND; fShow  : BOOL)      : BOOL;
PROCEDURE OpenIcon        (hWnd : HWND)                     : BOOL;
PROCEDURE CloseWindow     (hWnd : HWND)                     : BOOL;
PROCEDURE MoveWindow      (hWnd : HWND;
                           X, Y, Width, Height : INTEGER;
                           Repaint : BOOL)                  : BOOL;

PROCEDURE SetWindowPos (hWnd : HWND; hWndInsertAfter : HWND;
                        X, Y, cx, cy : INTEGER;
                        Flags : SWP_SET) : BOOL;

PROCEDURE GetWindowPlacement (hWnd : HWND; VAR wndpl : WINDOWPLACEMENT) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE SetWindowPlacement (hWnd : HWND; wndpl : WINDOWPLACEMENT (*!*) ) : BOOL;
<* ELSE *>
PROCEDURE SetWindowPlacement (hWnd : HWND; wndpl : PWINDOWPLACEMENT (*!*) ) : BOOL;
<* END *>

PROCEDURE BeginDeferWindowPos (NumWindows : INTEGER) : HDWP;
PROCEDURE DeferWindowPos (hWinPosInfo : HDWP;
                          hWnd : HWND;
                          hWndInsertAfter : HWND;
                          x, y, cx, cy : INTEGER;
                          Flags : SWP_SET) : HDWP;

PROCEDURE EndDeferWindowPos (hWinPosInfo : HDWP) : BOOL;

PROCEDURE IsWindowVisible (hWnd : HWND) : BOOL;
PROCEDURE IsIconic (hWnd : HWND) : BOOL;
PROCEDURE AnyPopup () : BOOL;
PROCEDURE BringWindowToTop (hWnd : HWND) : BOOL;
PROCEDURE IsZoomed (hWnd : HWND) : BOOL;

(* SetWindowPos flags defined earlier near WINDOWPOS structure *)

(* Special values for HWND *)

CONST HWND_TOP       = SYSTEM.CAST (HWND, VAL (LONG,  0));
      HWND_BOTTOM    = SYSTEM.CAST (HWND, VAL (LONG,  1));
      HWND_TOPMOST   = SYSTEM.CAST (HWND, VAL (LONG, -1));
      HWND_NOTOPMOST = SYSTEM.CAST (HWND, VAL (LONG, -2));

<* PUSH *> <* ALIGNMENT = "2" *>

(*
 * WARNING:
 * The following structures must NOT be DWORD padded because they are
 * followed by strings, etc that do not have to be DWORD aligned.
 *)

(*
 * original NT 32 bit dialog template:
 *)

TYPE DLGTEMPLATE = RECORD
                        style : WS_SET;
                        dwExtendedStyle : WS_EX_SET;
                        cdit : USHORT;
                        x, y, cx, cy : SHORT;
                   END;
    PDLGTEMPLATE = POINTER TO DLGTEMPLATE;

(* Dialog item template (dit) *)

TYPE DLGITEMTEMPLATE = RECORD
                            style : WS_SET;
                            ExtendedStyle : WS_EX_SET;
                            x, y, cx, cy : SHORT;
                            id : WORD;
                       END;

<* POP *> (* Resume normal (8 byte) alignment *)

PROCEDURE CreateDialogParamA (hInstance : HINSTANCE;
                              TemplateName : RESOURCESTRA;
                              Parent : HWND;
                              lpDialogFunc : DLGPROC;
                              InitParam : LPARAM) : HWND;

PROCEDURE CreateDialogParamW (hInstance : HINSTANCE;
                              TemplateName : RESOURCESTRW;
                              Parent : HWND;
                              lpDialogFunc : DLGPROC;
                              InitParam : LPARAM) : HWND;

(* following two procedures are implemented in RTL *)

PROCEDURE CreateDialogA (hInstance : HINSTANCE;
                         TemplateName : RESOURCESTRA;
                         Parent : HWND;
                         lpDialogFunc : DLGPROC) : HWND;

PROCEDURE CreateDialogW (hInstance : HINSTANCE;
                         TemplateName : RESOURCESTRW;
                         Parent : HWND;
                         lpDialogFunc : DLGPROC) : HWND;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateDialogParam    = CreateDialogParamW;
            CreateDialog         = CreateDialogW;
<* ELSE *>
      CONST CreateDialogParam    = CreateDialogParamA;
            CreateDialog         = CreateDialogA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE CreateDialogIndirectParamA (hInstance : HINSTANCE;
                                      Template : DLGTEMPLATE; (*!*)
                                      Parent : HWND;
                                      DialogFunc : DLGPROC;
                                      InitParam : LPARAM) : HWND;
<* ELSE *>
PROCEDURE CreateDialogIndirectParamA (hInstance : HINSTANCE;
                                      Template : PDLGTEMPLATE; (*!*)
                                      Parent : HWND;
                                      DialogFunc : DLGPROC;
                                      InitParam : LPARAM) : HWND;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE CreateDialogIndirectParamW (hInstance : HINSTANCE;
                                      Template : DLGTEMPLATE; (*!*)
                                      Parent : HWND;
                                      DialogFunc : DLGPROC;
                                      InitParam : LPARAM) : HWND;
<* ELSE *>
PROCEDURE CreateDialogIndirectParamW (hInstance : HINSTANCE;
                                      Template : PDLGTEMPLATE; (*!*)
                                      Parent : HWND;
                                      DialogFunc : DLGPROC;
                                      InitParam : LPARAM) : HWND;
<* END *>

(* following two procedures are implemented in RTL *)

<* IF BACKEND # "C" THEN *>
PROCEDURE CreateDialogIndirectA (hInstance : HINSTANCE;
                                 Template : DLGTEMPLATE; (*!*)
                                 Parent : HWND;
                                 DialogFunc : DLGPROC) : HWND;
<* ELSE *>
PROCEDURE CreateDialogIndirectA (hInstance : HINSTANCE;
                                 Template : PDLGTEMPLATE; (*!*)
                                 Parent : HWND;
                                 DialogFunc : DLGPROC) : HWND;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE CreateDialogIndirectW (hInstance : HINSTANCE;
                                 Template : DLGTEMPLATE; (*!*)
                                 Parent : HWND;
                                 DialogFunc : DLGPROC) : HWND;
<* ELSE *>
PROCEDURE CreateDialogIndirectW (hInstance : HINSTANCE;
                                 Template : PDLGTEMPLATE; (*!*)
                                 Parent : HWND;
                                 DialogFunc : DLGPROC) : HWND;
<* END *>

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateDialogIndirectParam = CreateDialogIndirectParamW;
            CreateDialogIndirect      = CreateDialogIndirectW;
<* ELSE *>
      CONST CreateDialogIndirectParam = CreateDialogIndirectParamA;
            CreateDialogIndirect      = CreateDialogIndirectA;
<* END *>

PROCEDURE DialogBoxParamA (hInstance : HINSTANCE;
                           TemplateName : RESOURCESTRA;
                           Parent : HWND;
                           lpDialogFunc : DLGPROC;
                           InitParam : LPARAM) : INTEGER;
PROCEDURE DialogBoxParamW (hInstance : HINSTANCE;
                           TemplateName : RESOURCESTRW;
                           Parent : HWND;
                           lpDialogFunc : DLGPROC;
                           InitParam : LPARAM) : INTEGER;

(* following two procedures are implemented in RTL *)

PROCEDURE DialogBoxA (hInstance : HINSTANCE;
                      TemplateName : RESOURCESTRA;
                      Parent : HWND;
                      lpDialogFunc : DLGPROC) : INTEGER;
PROCEDURE DialogBoxW (hInstance : HINSTANCE;
                      TemplateName : RESOURCESTRW;
                      Parent : HWND;
                      lpDialogFunc : DLGPROC) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST DialogBoxParam = DialogBoxParamW;
            DialogBox      = DialogBoxW;
<* ELSE *>
      CONST DialogBoxParam = DialogBoxParamA;
            DialogBox      = DialogBoxA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE DialogBoxIndirectParamA (hInstance : HINSTANCE;
                                   Template : DLGTEMPLATE; (*!*)
                                   Parent : HWND;
                                   DialogFunc : DLGPROC;
                                   InitParam : LPARAM) : INTEGER;
<* ELSE *>
PROCEDURE DialogBoxIndirectParamA (hInstance : HINSTANCE;
                                   Template : PDLGTEMPLATE; (*!*)
                                   Parent : HWND;
                                   DialogFunc : DLGPROC;
                                   InitParam : LPARAM) : INTEGER;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE DialogBoxIndirectParamW (hInstance : HINSTANCE;
                                   Template : DLGTEMPLATE; (*!*)
                                   Parent : HWND;
                                   DialogFunc : DLGPROC;
                                   InitParam : LPARAM) : INTEGER;
<* ELSE *>
PROCEDURE DialogBoxIndirectParamW (hInstance : HINSTANCE;
                                   Template : PDLGTEMPLATE; (*!*)
                                   Parent : HWND;
                                   DialogFunc : DLGPROC;
                                   InitParam : LPARAM) : INTEGER;
<* END *>

(* following two procedures are implemented in RTL *)

<* IF BACKEND # "C" THEN *>
PROCEDURE DialogBoxIndirectA (hInstance : HINSTANCE;
                              Template : DLGTEMPLATE; (*!*)
                              Parent : HWND;
                              DialogFunc : DLGPROC) : INTEGER;
<* ELSE *>
PROCEDURE DialogBoxIndirectA (hInstance : HINSTANCE;
                              Template : PDLGTEMPLATE; (*!*)
                              Parent : HWND;
                              DialogFunc : DLGPROC) : INTEGER;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE DialogBoxIndirectW (hInstance : HINSTANCE;
                              Template : DLGTEMPLATE; (*!*)
                              Parent : HWND;
                              DialogFunc : DLGPROC) : INTEGER;
<* ELSE *>
PROCEDURE DialogBoxIndirectW (hInstance : HINSTANCE;
                              Template : PDLGTEMPLATE; (*!*)
                              Parent : HWND;
                              DialogFunc : DLGPROC) : INTEGER;
<* END *>

<* IF DEFINED (UNICODE) THEN *>
      CONST DialogBoxIndirectParam = DialogBoxIndirectParamW;
            DialogBoxIndirect      = DialogBoxIndirectW;
<* ELSE *>
      CONST DialogBoxIndirectParam = DialogBoxIndirectParamA;
            DialogBoxIndirect      = DialogBoxIndirectA;
<* END *>

PROCEDURE EndDialog (hDlg : HWND; Result : INTEGER) : BOOL;
PROCEDURE GetDlgItem (hDlg : HWND; IDDlgItem : INTEGER) : HWND;
PROCEDURE SetDlgItemInt (hDlg : HWND; IDDlgItem : INTEGER;
                         Value : UINT; Signed : BOOL) : BOOL;
PROCEDURE GetDlgItemInt (hDlg : HWND; IDDlgItem : INTEGER;
                         VAR Translated : BOOL; Signed : BOOL) : UINT;
PROCEDURE SetDlgItemTextA (hDlg : HWND; IDDlgItem : INTEGER;
                           String : ARRAY OF CHAR) : BOOL;
PROCEDURE SetDlgItemTextW (hDlg : HWND; IDDlgItem : INTEGER;
                           String : ARRAY OF WCHAR) : BOOL;

PROCEDURE GetDlgItemTextA (hDlg : HWND; IDDlgItem : INTEGER;
                           VAR String : ARRAY OF CHAR;
                           MaxCount : INTEGER) : BOOL;
PROCEDURE GetDlgItemTextW (hDlg : HWND; IDDlgItem : INTEGER;
                           VAR String : ARRAY OF WCHAR;
                           MaxCount : INTEGER) : BOOL;
<* IF DEFINED (UNICODE) THEN *>
      CONST SetDlgItemText = SetDlgItemTextW;
            GetDlgItemText = GetDlgItemTextW;
<* ELSE *>
      CONST SetDlgItemText = SetDlgItemTextA;
            GetDlgItemText = GetDlgItemTextA;
<* END *>

PROCEDURE CheckDlgButton (hDlg : HWND; IDButton : INTEGER; Check : UINT) : BOOL;
PROCEDURE CheckRadioButton (hDlg : HWND;
                            IDFirstButton : INTEGER;
                            IDLastButton  : INTEGER;
                            IDCheckButton : INTEGER) : BOOL;

PROCEDURE IsDlgButtonChecked (hDlg : HWND; IDButton : INTEGER) : UINT;
PROCEDURE SendDlgItemMessageA (hDlg : HWND; IDDlgItem : INTEGER;
                               Msg : UINT; wParam : WPARAM;
                               lParam : LPARAM) : LONG;
PROCEDURE SendDlgItemMessageW (hDlg : HWND; IDDlgItem : INTEGER;
                               Msg : UINT; wParam : WPARAM;
                               lParam : LPARAM) : LONG;
<* IF DEFINED (UNICODE) THEN *>
      CONST SendDlgItemMessage = SendDlgItemMessageW;
<* ELSE *>
      CONST SendDlgItemMessage = SendDlgItemMessageA;
<* END *>

PROCEDURE GetNextDlgGroupItem (hDlg : HWND; hCtl : HWND; Previous : BOOL) : HWND;
PROCEDURE GetNextDlgTabItem   (hDlg : HWND; hCtl : HWND; Previous : BOOL) : HWND;
PROCEDURE GetDlgCtrlID (hWnd : HWND) : INTEGER;
PROCEDURE GetDialogBaseUnits () : LONG;

PROCEDURE DefDlgProcA (hDlg : HWND; Msg : UINT;
                       wParam : WPARAM; lParam : LPARAM) : LRESULT;
PROCEDURE DefDlgProcW (hDlg : HWND; Msg : UINT;
                       wParam : WPARAM; lParam : LPARAM) : LRESULT;
<* IF DEFINED (UNICODE) THEN *>
      CONST DefDlgProc = DefDlgProcW;
<* ELSE *>
      CONST DefDlgProc = DefDlgProcA;
<* END *>

(* Window extra bytes needed for private dialog classes. *)

CONST DLGWINDOWEXTRA = 30;

PROCEDURE CallMsgFilterA (VAR msg : MSG; Code : INTEGER) : BOOL;
PROCEDURE CallMsgFilterW (VAR msg : MSG; Code : INTEGER) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST CallMsgFilter = CallMsgFilterW;
<* ELSE *>
      CONST CallMsgFilter = CallMsgFilterA;
<* END *>

(* Clipboard Manager Functions *)

PROCEDURE OpenClipboard (NewOwner : HWND) : BOOL;
PROCEDURE CloseClipboard () : BOOL;
PROCEDURE GetClipboardOwner () : HWND;
PROCEDURE SetClipboardViewer (NewViewer : HWND) : HWND;
PROCEDURE GetClipboardViewer () : HWND;
PROCEDURE ChangeClipboardChain (Remove, NewNext : HWND) : BOOL;

PROCEDURE SetClipboardData (Format : CF_TYPE; Mem : HANDLE) : HANDLE;
PROCEDURE GetClipboardData (Format : CF_TYPE) : HANDLE;

PROCEDURE RegisterClipboardFormatA (Format : ARRAY OF CHAR) : UINT;
PROCEDURE RegisterClipboardFormatW (Format : ARRAY OF WCHAR) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegisterClipboardFormat = RegisterClipboardFormatW;
<* ELSE *>
      CONST RegisterClipboardFormat = RegisterClipboardFormatA;
<* END *>

PROCEDURE CountClipboardFormats () : INTEGER;
PROCEDURE EnumClipboardFormats (format : CF_TYPE) : CF_TYPE;

PROCEDURE GetClipboardFormatNameA (format : CF_TYPE;
                                   VAR FormatName : ARRAY OF CHAR;
                                   MaxCount : INTEGER) : INTEGER;
PROCEDURE GetClipboardFormatNameW (format : CF_TYPE;
                                   VAR FormatName : ARRAY OF WCHAR;
                                   MaxCount : INTEGER) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetClipboardFormatName  = GetClipboardFormatNameW;
<* ELSE *>
      CONST GetClipboardFormatName  = GetClipboardFormatNameA;
<* END *>

PROCEDURE EmptyClipboard () : BOOL;
PROCEDURE IsClipboardFormatAvailable (format : CF_TYPE) : BOOL;
PROCEDURE GetPriorityClipboardFormat (VAR FormatPriorityList : ARRAY OF UINT;
                                      NFormats : INTEGER) : INTEGER;
PROCEDURE GetOpenClipboardWindow () : HWND;

(* Character Translation Routines *)

PROCEDURE CharToOemA     (Src : ARRAY OF CHAR;  VAR Dst : ARRAY OF CHAR) : BOOL;
PROCEDURE CharToOemW     (Src : ARRAY OF WCHAR; VAR Dst : ARRAY OF CHAR) : BOOL;
PROCEDURE OemToCharA     (Src : ARRAY OF CHAR;  VAR Dst : ARRAY OF CHAR) : BOOL;
PROCEDURE OemToCharW     (Src : ARRAY OF CHAR;  VAR Dst : ARRAY OF WCHAR): BOOL;
PROCEDURE CharToOemBuffA (Src : ARRAY OF CHAR;  VAR Dst : ARRAY OF CHAR;
                          DstLength : DWORD) : BOOL;
PROCEDURE CharToOemBuffW (Src : ARRAY OF WCHAR; VAR Dst : ARRAY OF CHAR; DstLength : DWORD) : BOOL;
PROCEDURE OemToCharBuffA (Src : ARRAY OF CHAR; Dst : ARRAY OF CHAR; DstLength : DWORD) : BOOL;
PROCEDURE OemToCharBuffW (Src : ARRAY OF CHAR; Dst : ARRAY OF WCHAR; DstLength : DWORD) : BOOL;
<* IF DEFINED (UNICODE) THEN *>
      CONST CharToOem = CharToOemW;
            OemToChar = OemToCharW;
            CharToOemBuff = CharToOemBuffW;
            OemToCharBuff = OemToCharBuffW;
<* ELSE *>
      CONST CharToOem = CharToOemA;
            OemToChar = OemToCharA;
            CharToOemBuff = CharToOemBuffA;
            OemToCharBuff = OemToCharBuffA;
<* END *>

PROCEDURE CharUpperA (VAR s : ARRAY OF CHAR)  : PSTR;
PROCEDURE CharUpperW (VAR s : ARRAY OF WCHAR) : PWSTR;
PROCEDURE CharLowerA (VAR s : ARRAY OF CHAR)  : PSTR;
PROCEDURE CharLowerW (VAR s : ARRAY OF WCHAR) : PWSTR;

(* following four procedures are declared in RTL library.
   In original winuser.h there were no those procedures.
   CharUpper and Lower were polymorphic, that is, thay could
   accept both string pointer and single CHAR. Since Modula-2 does not
   allow this, we had to create new functions *)

PROCEDURE CharUpper1A (s : CHAR)  : CHAR;
PROCEDURE CharUpper1W (s : WCHAR) : WCHAR;
PROCEDURE CharLower1A (s : CHAR)  : CHAR;
PROCEDURE CharLower1W (s : WCHAR) : WCHAR;

PROCEDURE CharUpperBuffA (VAR s : ARRAY OF CHAR;  Length : DWORD) : DWORD;
PROCEDURE CharUpperBuffW (VAR s : ARRAY OF WCHAR; Length : DWORD) : DWORD;
PROCEDURE CharLowerBuffA (VAR s : ARRAY OF CHAR;  Length : DWORD) : DWORD;
PROCEDURE CharLowerBuffW (VAR s : ARRAY OF WCHAR; Length : DWORD) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST CharUpper  = CharUpperW;
            CharUpper1 = CharUpper1W;
            CharLower  = CharLowerW;
            CharLower1 = CharLower1W;
            CharUpperBuff = CharUpperBuffW;
            CharLowerBuff = CharLowerBuffW;
<* ELSE *>
      CONST CharUpper  = CharUpperA;
            CharUpper1 = CharUpper1A;
            CharLower  = CharLowerA;
            CharLower1 = CharLower1A;
            CharUpperBuff = CharUpperBuffA;
            CharLowerBuff = CharLowerBuffA;
<* END *>

PROCEDURE CharNextA (cur : PSTR) : PSTR;
PROCEDURE CharNextW (cur : PWSTR) : PWSTR;
PROCEDURE CharPrevA (start, cur : PSTR) : PSTR;
PROCEDURE CharPrevW (start, cur : PWSTR) : PWSTR;
<* IF DEFINED (UNICODE) THEN *>
      CONST CharPrev = CharPrevW;
<* ELSE *>
      CONST CharPrev = CharPrevA;
<* END *>


PROCEDURE CharNextExA (CodePage : WORD;
                       lpCurrentChar : PCSTR;
                       dwFlags : DWORD) : PSTR;

PROCEDURE CharPrevExA (CodePage : WORD;
                       lpStart : PCSTR;
                       lpCurrentChar : PCSTR;
                       dwFlags : DWORD) : PSTR;

CONST AnsiToOem     = CharToOemA;
      OemToAnsi     = OemToCharA;
      AnsiToOemBuff = CharToOemBuffA;
      OemToAnsiBuff = OemToCharBuffA;
      AnsiUpper     = CharUpperA;
      AnsiUpperBuff = CharUpperBuffA;
      AnsiLower     = CharLowerA;
      AnsiLowerBuff = CharLowerBuffA;
      AnsiNext      = CharNextA;
      AnsiPrev      = CharPrevA;

PROCEDURE IsCharAlphaA (ch :  CHAR) : BOOL;
PROCEDURE IsCharAlphaW (ch : WCHAR) : BOOL;
PROCEDURE IsCharAlphaNumericA (ch : CHAR) : BOOL;
PROCEDURE IsCharAlphaNumericW (ch : WCHAR) : BOOL;
PROCEDURE IsCharUpperA (ch : CHAR) : BOOL;
PROCEDURE IsCharUpperW (ch : CHAR) : BOOL;
PROCEDURE IsCharLowerA (ch : CHAR) : BOOL;
PROCEDURE IsCharLowerW (ch : CHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST IsCharAlpha        = IsCharAlphaW;
            IsCharAlphaNumeric = IsCharAlphaNumericW;
            IsCharUpper        = IsCharUpperW;
            IsCharLower        = IsCharLowerW;
<* ELSE *>
      CONST IsCharAlpha        = IsCharAlphaA;
            IsCharAlphaNumeric = IsCharAlphaNumericA;
            IsCharUpper        = IsCharUpperA;
            IsCharLower        = IsCharLowerA;
<* END *>

PROCEDURE SetFocus (hWnd : HWND) : HWND;
PROCEDURE GetActiveWindow ()     : HWND;
PROCEDURE GetFocus ()            : HWND;
PROCEDURE GetKBCodePage () : UINT;
PROCEDURE GetKeyState (VirtKey : INTEGER) : SHORT;
PROCEDURE GetAsyncKeyState(Key : INTEGER) : SHORT;

TYPE KEYBOARDSTATE = ARRAY [0..255] OF BYTE;

PROCEDURE GetKeyboardState (VAR KeyState : KEYBOARDSTATE) : BOOL;
PROCEDURE SetKeyboardState (KeyState : KEYBOARDSTATE) : BOOL;

PROCEDURE GetKeyNameTextA (lParam : LPARAM; VAR String : ARRAY OF CHAR;
                           size : INTEGER) : INTEGER;
PROCEDURE GetKeyNameTextW (lParam : LPARAM; VAR String : ARRAY OF WCHAR;
                           size : INTEGER) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetKeyNameText = GetKeyNameTextW;
<* ELSE *>
      CONST GetKeyNameText = GetKeyNameTextA;
<* END *>

PROCEDURE GetKeyboardType (TypeFlag : INTEGER) : INTEGER;
PROCEDURE ToAscii (VirtKey, ScanCode : UINT;
                   KeyState : KEYBOARDSTATE;
                   Buff : PWORD; Flags : UINT) : INTEGER;
PROCEDURE ToAsciiEx (VirtKey, ScanCode : UINT;
                     KeyState : KEYBOARDSTATE;
                     Buff : PWORD; Flags : UINT; hkl : HKL) : INTEGER;

PROCEDURE ToUnicode (VirtKey, ScanCode : UINT;
                     KeyState : KEYBOARDSTATE;
                     VAR Buff : ARRAY OF WCHAR;
                     BufSize : INTEGER; Flags : UINT) : INTEGER;

PROCEDURE OemKeyScan (OemChar : WORD) : DWORD;

PROCEDURE VkKeyScanA (ch : CHAR) : SHORT;
PROCEDURE VkKeyScanW (ch : WCHAR) : SHORT;

<* IF DEFINED (UNICODE) THEN *>
      CONST VkKeyScan = VkKeyScanW;
<* ELSE *>
      CONST VkKeyScan = VkKeyScanA;
<* END *>

PROCEDURE VkKeyScanExA (ch : CHAR;  hkl : HKL) : SHORT;
PROCEDURE VkKeyScanExW (ch : WCHAR; hkl : HKL) : SHORT;

<* IF DEFINED (UNICODE) THEN *>
      CONST VkKeyScanEx = VkKeyScanExW;
<* ELSE *>
      CONST VkKeyScanEx = VkKeyScanExA;
<* END *>


TYPE KEYEVENTF_ENUM = (KEYEVENTF__EXTENDEDKEY, (* 0 *)
                       KEYEVENTF__KEYUP);      (* 1 *)
     KEYEVENTF_SET = SET OF KEYEVENTF_ENUM;

CONST KEYEVENTF_EXTENDEDKEY = KEYEVENTF_SET {KEYEVENTF__EXTENDEDKEY}; (* 1 *)
      KEYEVENTF_KEYUP       = KEYEVENTF_SET {KEYEVENTF__KEYUP};       (* 2 *)


PROCEDURE keybd_event (Vk, Scan : BYTE;
                       Flags : KEYEVENTF_SET;
                       ExtraInfo : DWORD);

TYPE MOUSEEVENTF_ENUM = (MOUSEEVENTF__MOVE,       (*  0 - mouse move         *)
                         MOUSEEVENTF__LEFTDOWN,   (*  1 - left button down   *)
                         MOUSEEVENTF__LEFTUP,     (*  2 - left button up     *)
                         MOUSEEVENTF__RIGHTDOWN,  (*  3 - right button down  *)
                         MOUSEEVENTF__RIGHTUP,    (*  4 - right button up    *)
                         MOUSEEVENTF__MIDDLEDOWN, (*  5 - middle button down *)
                         MOUSEEVENTF__MIDDLEUP,   (*  6 - middle button up   *)
                         MOUSEEVENTF__7,
                         MOUSEEVENTF__8,
                         MOUSEEVENTF__9,
                         MOUSEEVENTF__10,
                         MOUSEEVENTF__WHEEL,
                         MOUSEEVENTF__12,
                         MOUSEEVENTF__13,
                         MOUSEEVENTF__14,
                         MOUSEEVENTF__ABSOLUTE);  (* 15 - absolute move      *)

     MOUSEEVENTF_SET = SET OF MOUSEEVENTF_ENUM;

CONST MOUSEEVENTF_MOVE       = MOUSEEVENTF_SET {MOUSEEVENTF__MOVE};       (* 0x0001 *)
      MOUSEEVENTF_LEFTDOWN   = MOUSEEVENTF_SET {MOUSEEVENTF__LEFTDOWN};   (* 0x0002 *)
      MOUSEEVENTF_LEFTUP     = MOUSEEVENTF_SET {MOUSEEVENTF__LEFTUP};     (* 0x0004 *)
      MOUSEEVENTF_RIGHTDOWN  = MOUSEEVENTF_SET {MOUSEEVENTF__RIGHTDOWN};  (* 0x0008 *)
      MOUSEEVENTF_RIGHTUP    = MOUSEEVENTF_SET {MOUSEEVENTF__RIGHTUP};    (* 0x0010 *)
      MOUSEEVENTF_MIDDLEDOWN = MOUSEEVENTF_SET {MOUSEEVENTF__MIDDLEDOWN}; (* 0x0020 *)
      MOUSEEVENTF_MIDDLEUP   = MOUSEEVENTF_SET {MOUSEEVENTF__MIDDLEUP};   (* 0x0040 *)
      MOUSEEVENTF_WHEEL      = MOUSEEVENTF_SET {MOUSEEVENTF__WHEEL};      (* 0x0800 *)
      MOUSEEVENTF_ABSOLUTE   = MOUSEEVENTF_SET {MOUSEEVENTF__ABSOLUTE};   (* 0x8000 *)

PROCEDURE mouse_event (dwFlags : MOUSEEVENTF_SET;
                       dx, dy : DWORD;
                       cButtons, dwExtraInfo : DWORD);

PROCEDURE MapVirtualKeyA (Code : UINT; MapType : UINT) : UINT;
PROCEDURE MapVirtualKeyW (Code : UINT; MapType : UINT) : UINT;

PROCEDURE MapVirtualKeyExA (Code : UINT; MapType : UINT; hkl : HKL) : UINT;
PROCEDURE MapVirtualKeyExW (Code : UINT; MapType : UINT; hkl : HKL) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST MapVirtualKey   = MapVirtualKeyW;
            MapVirtualKeyEx = MapVirtualKeyExW;
<* ELSE *>
      CONST MapVirtualKey   = MapVirtualKeyA;
            MapVirtualKeyEx = MapVirtualKeyExA;
<* END *>

PROCEDURE GetInputState () : BOOL;

(*
 * Queue status flags for GetQueueStatus() and MsgWaitForMultipleObjects()
 *)

TYPE QS_ENUM = (QS__KEY,             (* 0 *)
                QS__MOUSEMOVE,       (* 1 *)
                QS__MOUSEBUTTON,     (* 2 *)
                QS__POSTMESSAGE,     (* 3 *)
                QS__TIMER,           (* 4 *)
                QS__PAINT,           (* 5 *)
                QS__SENDMESSAGE,     (* 6 *)
                QS__HOTKEY,          (* 7 *)
                QS__ALLPOSTMESSAGE); (* 8 *)

      QS_SET = SET OF QS_ENUM;

CONST QS_KEY            = QS_SET {QS__KEY};           (* 0x01 *)
      QS_MOUSEMOVE      = QS_SET {QS__MOUSEMOVE};     (* 0x02 *)
      QS_MOUSEBUTTON    = QS_SET {QS__MOUSEBUTTON};   (* 0x04 *)
      QS_POSTMESSAGE    = QS_SET {QS__POSTMESSAGE};   (* 0x08 *)
      QS_TIMER          = QS_SET {QS__TIMER};         (* 0x10 *)
      QS_PAINT          = QS_SET {QS__PAINT};         (* 0x20 *)
      QS_SENDMESSAGE    = QS_SET {QS__SENDMESSAGE};   (* 0x40 *)
      QS_HOTKEY         = QS_SET {QS__HOTKEY};        (* 0x80 *)
      QS_ALLPOSTMESSAGE = QS_SET {QS__ALLPOSTMESSAGE};(* 0x100 *)

      QS_MOUSE        = QS_MOUSEMOVE + QS_MOUSEBUTTON;

      QS_INPUT        = QS_MOUSE + QS_KEY;

      QS_ALLEVENTS    = QS_INPUT + QS_POSTMESSAGE + QS_TIMER +
                        QS_PAINT + QS_HOTKEY;

      QS_ALLINPUT     = QS_SENDMESSAGE + QS_PAINT + QS_TIMER +
                        QS_POSTMESSAGE + QS_MOUSEBUTTON + QS_MOUSEMOVE +
                        QS_HOTKEY + QS_KEY;


PROCEDURE GetQueueStatus (flags : QS_SET) : QS_SET;
PROCEDURE GetCapture () : HWND;
PROCEDURE SetCapture (hwnd : HWND) : HWND;
PROCEDURE ReleaseCapture () : BOOL;

PROCEDURE MsgWaitForMultipleObjects (Count        : DWORD;
                                     Handles      : ARRAY OF HANDLE;
                                     WaitAll      : BOOL;
                                     MilliSeconds : DWORD;
                                     WakeMask     : QS_SET) : DWORD;

TYPE MWMO_ENUM = (MWMO__WAITALL, MWMO__ALERTABLE);
     MWMO_SET = SET OF MWMO_ENUM;

CONST MWMO_WAITALL   = MWMO_SET {MWMO__WAITALL}; (* 0x0001 *)
      MWMO_ALERTABLE = MWMO_SET {MWMO__ALERTABLE}; (* 0x0002 *)

PROCEDURE MsgWaitForMultipleObjectsEx (Count        : DWORD;
                                       Handles      : ARRAY OF HANDLE;
                                       WaitAll      : BOOL;
                                       MilliSeconds : DWORD;
                                       WakeMask     : QS_SET;
                                       Flags        : MWMO_SET) : DWORD;

(*
 * Windows Functions
 *)


PROCEDURE SetTimer (hWnd : HWND; IDEvent : UINT;
                    Elapse : UINT; TimerProc : TIMERPROC) : UINT;

PROCEDURE KillTimer (hWnd : HWND; IdEvent : UINT) : BOOL;

PROCEDURE IsWindowUnicode (hWnd : HWND) : BOOL;
PROCEDURE EnableWindow (jWnd : HWND; Enable : BOOL) : BOOL;
PROCEDURE IsWindowEnabled (hWnd : HWND) : BOOL;

PROCEDURE LoadAcceleratorsA (hInstance : HINSTANCE; TableName : RESOURCESTRA) : HACCEL;
PROCEDURE LoadAcceleratorsW (hInstance : HINSTANCE; TableName : RESOURCESTRW) : HACCEL;

<* IF DEFINED (UNICODE) THEN *>
      CONST LoadAccelerators = LoadAcceleratorsW;
<* ELSE *>
      CONST LoadAccelerators = LoadAcceleratorsA;
<* END *>

PROCEDURE CreateAcceleratorTableA (accel : ARRAY OF ACCEL;
                                   nEntries : INTEGER)       : HACCEL;
PROCEDURE CreateAcceleratorTableW (accel : ARRAY OF ACCEL;
                                   nEntries : INTEGER)       : HACCEL;

PROCEDURE DestroyAcceleratorTable (hAccel : HACCEL) : BOOL;

PROCEDURE CopyAcceleratorTableA (hAccelSrc : HACCEL;
                                 VAR AccelDst : ARRAY OF ACCEL;
                                 AccelEntries : INTEGER) : INTEGER;
PROCEDURE CopyAcceleratorTableW (hAccelSrc : HACCEL;
                                 VAR AccelDst : ARRAY OF ACCEL;
                                 AccelEntries : INTEGER) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateAcceleratorTable = CreateAcceleratorTableW;
            CopyAcceleratorTable = CopyAcceleratorTableW;
<* ELSE *>
      CONST CreateAcceleratorTable = CreateAcceleratorTableA;
            CopyAcceleratorTable = CopyAcceleratorTableA;
<* END *>

PROCEDURE TranslateAcceleratorA (hWnd : HWND; hAccTable : HACCEL;
                                 VAR msg : MSG)                   : BOOL;
PROCEDURE TranslateAcceleratorW (hWnd : HWND; hAccTable : HACCEL;
                                 VAR msg : MSG)                   : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST TranslateAccelerator = TranslateAcceleratorW;
<* ELSE *>
      CONST TranslateAccelerator = TranslateAcceleratorA;
<* END *>

(*
 * GetSystemMetrics() codes
 *)

TYPE SM_ENUM = (SM_CXSCREEN,          (*  0 *)
                SM_CYSCREEN,          (*  1 *)
                SM_CXVSCROLL,         (*  2 *)
                SM_CYHSCROLL,         (*  3 *)
                SM_CYCAPTION,         (*  4 *)
                SM_CXBORDER,          (*  5 *)
                SM_CYBORDER,          (*  6 *)
                SM_CXDLGFRAME,        (*  7 *)
                SM_CYDLGFRAME,        (*  8 *)
                SM_CYVTHUMB,          (*  9 *)
                SM_CXHTHUMB,          (* 10 *)
                SM_CXICON,            (* 11 *)
                SM_CYICON,            (* 12 *)
                SM_CXCURSOR,          (* 13 *)
                SM_CYCURSOR,          (* 14 *)
                SM_CYMENU,            (* 15 *)
                SM_CXFULLSCREEN,      (* 16 *)
                SM_CYFULLSCREEN,      (* 17 *)
                SM_CYKANJIWINDOW,     (* 18 *)
                SM_MOUSEPRESENT,      (* 19 *)
                SM_CYVSCROLL,         (* 20 *)
                SM_CXHSCROLL,         (* 21 *)
                SM_DEBUG,             (* 22 *)
                SM_SWAPBUTTON,        (* 23 *)
                SM_RESERVED1,         (* 24 *)
                SM_RESERVED2,         (* 25 *)
                SM_RESERVED3,         (* 26 *)
                SM_RESERVED4,         (* 27 *)
                SM_CXMIN,             (* 28 *)
                SM_CYMIN,             (* 29 *)
                SM_CXSIZE,            (* 30 *)
                SM_CYSIZE,            (* 31 *)
                SM_CXFRAME,           (* 32 *)
                SM_CYFRAME,           (* 33 *)
                SM_CXMINTRACK,        (* 34 *)
                SM_CYMINTRACK,        (* 35 *)
                SM_CXDOUBLECLK,       (* 36 *)
                SM_CYDOUBLECLK,       (* 37 *)
                SM_CXICONSPACING,     (* 38 *)
                SM_CYICONSPACING,     (* 39 *)
                SM_MENUDROPALIGNMENT, (* 40 *)
                SM_PENWINDOWS,        (* 41 *)
                SM_DBCSENABLED,       (* 42 *)
                SM_CMOUSEBUTTONS,     (* 43 *)
                SM_SECURE,            (* 44 *)
                SM_CXEDGE,            (* 45 *)
                SM_CYEDGE,            (* 46 *)
                SM_CXMINSPACING,      (* 47 *)
                SM_CYMINSPACING,      (* 48 *)
                SM_CXSMICON,          (* 49 *)
                SM_CYSMICON,          (* 50 *)
                SM_CYSMCAPTION,       (* 51 *)
                SM_CXSMSIZE,          (* 52 *)
                SM_CYSMSIZE,          (* 53 *)
                SM_CXMENUSIZE,        (* 54 *)
                SM_CYMENUSIZE,        (* 55 *)
                SM_ARRANGE,           (* 56 *)
                SM_CXMINIMIZED,       (* 57 *)
                SM_CYMINIMIZED,       (* 58 *)
                SM_CXMAXTRACK,        (* 59 *)
                SM_CYMAXTRACK,        (* 60 *)
                SM_CXMAXIMIZED,       (* 61 *)
                SM_CYMAXIMIZED,       (* 62 *)
                SM_NETWORK,           (* 63 *)
                SM_64,
                SM_65,
                SM_66,
                SM_CLEANBOOT,         (* 67 *)
                SM_CXDRAG,            (* 68 *)
                SM_CYDRAG,            (* 69 *)
                SM_SHOWSOUNDS,        (* 70 *)
                SM_CXMENUCHECK,       (* 71 Use instead of GetMenuCheckMarkDimensions()! *)
                SM_CYMENUCHECK,       (* 72 *)
                SM_SLOWMACHINE,       (* 73 *)
                SM_MIDEASTENABLED,    (* 74 *)
                SM_MOUSEWHEELPRESENT, (* 75 *)
                SM_CMETRICS);         (* 76 *)

CONST SM_CXFIXEDFRAME = SM_CXDLGFRAME;  (* win40 name change *)
      SM_CYFIXEDFRAME = SM_CYDLGFRAME;  (* win40 name change *)
      SM_CXSIZEFRAME  = SM_CXFRAME;     (* win40 name change *)
      SM_CYSIZEFRAME  = SM_CYFRAME;     (* win40 name change *)

PROCEDURE GetSystemMetrics (Index : SM_ENUM) : INTEGER;

(* win40  -- A lot of MF_* flags have been renamed as MFT_* and MFS_* flags *)

(* Menu flags for Add/Check/EnableMenuItem *)

TYPE MF_ENUM = (MF__0, MF__1, MF__2, MF__3, MF__4, MF__5, MF__6, MF__7,
                MF__8, MF__9, MF__10, MF__11, MF__12, MF__13, MF__14, MF__15);
     MF_SET = SET OF MF_ENUM;

CONST MF_INSERT          = MF_SET {};           (* 0x00000000L *)
      MF_CHANGE          = MF_SET {MF__7};      (* 0x00000080L *)
      MF_APPEND          = MF_SET {MF__8};      (* 0x00000100L *)
      MF_DELETE          = MF_SET {MF__9};      (* 0x00000200L *)
      MF_REMOVE          = MF_SET {MF__12};     (* 0x00001000L *)

      MF_BYCOMMAND       = MF_SET {};           (* 0x00000000L *)
      MF_BYPOSITION      = MF_SET {MF__10};     (* 0x00000400L *)

      MF_SEPARATOR       = MF_SET {MF__11};     (* 0x00000800L *)

      MF_ENABLED         = MF_SET {};           (* 0x00000000L *)
      MF_GRAYED          = MF_SET {MF__0};      (* 0x00000001L *)
      MF_DISABLED        = MF_SET {MF__1};      (* 0x00000002L *)

      MF_UNCHECKED       = MF_SET {};           (* 0x00000000L *)
      MF_CHECKED         = MF_SET {MF__3};      (* 0x00000008L *)
      MF_USECHECKBITMAPS = MF_SET {MF__9};      (* 0x00000200L *)

      MF_STRING          = MF_SET {};           (* 0x00000000L *)
      MF_BITMAP          = MF_SET {MF__2};      (* 0x00000004L *)
      MF_OWNERDRAW       = MF_SET {MF__8};      (* 0x00000100L *)

      MF_POPUP           = MF_SET {MF__4};      (* 0x00000010L *)
      MF_MENUBARBREAK    = MF_SET {MF__5};      (* 0x00000020L *)
      MF_MENUBREAK       = MF_SET {MF__6};      (* 0x00000040L *)

      MF_UNHILITE        = MF_SET {};           (* 0x00000000L *)
      MF_HILITE          = MF_SET {MF__7};      (* 0x00000080L *)

      MF_DEFAULT         = MF_SET {MF__12};     (* 0x00001000L *)

      MF_SYSMENU         = MF_SET {MF__13};     (* 0x00002000L *)
      MF_HELP            = MF_SET {MF__14};     (* 0x00004000L *)

      MF_RIGHTJUSTIFY    = MF_SET {MF__14};     (* 0x00004000L *)

      MF_MOUSESELECT     = MF_SET {MF__15};     (* 0x00008000L *)

      MF_END             = MF_SET {MF__7};      (* 0x00000080L Obsolete -- only used by old RES files *)

CONST MFT_STRING         = MF_STRING;
      MFT_BITMAP         = MF_BITMAP;
      MFT_MENUBARBREAK   = MF_MENUBARBREAK;
      MFT_MENUBREAK      = MF_MENUBREAK;
      MFT_OWNERDRAW      = MF_OWNERDRAW;
      MFT_RADIOCHECK     = MF_SET {MF__9};      (* 0x00000200L *)
      MFT_SEPARATOR      = MF_SEPARATOR;
      MFT_RIGHTORDER     = MF_SET {MF__13};     (* 0x00002000L *)
      MFT_RIGHTJUSTIFY   = MF_RIGHTJUSTIFY;

(* Menu flags for Add/Check/EnableMenuItem() *)

CONST MFS_GRAYED         = MF_GRAYED + MF_DISABLED; (* 0x00000003L *)
      MFS_DISABLED       = MFS_GRAYED;
      MFS_CHECKED        = MF_CHECKED;
      MFS_HILITE         = MF_HILITE;
      MFS_ENABLED        = MF_ENABLED;
      MFS_UNCHECKED      = MF_UNCHECKED;
      MFS_UNHILITE       = MF_UNHILITE;
      MFS_DEFAULT        = MF_DEFAULT;

PROCEDURE LoadMenuA (hInstance : HINSTANCE; MenuName : RESOURCESTRA) : HMENU;
PROCEDURE LoadMenuW (hInstance : HINSTANCE; MenuName : RESOURCESTRW) : HMENU;
PROCEDURE LoadMenuIndirectA (MenuTemplate : PMENUTEMPLATEA (*!*)) : HMENU;
PROCEDURE LoadMenuIndirectW (MenuTemplate : PMENUTEMPLATEW (*!*)) : HMENU;

<* IF DEFINED (UNICODE) THEN *>
      CONST LoadMenu = LoadMenuW;
            LoadMenuIndirect = LoadMenuIndirectW;
<* ELSE *>
      CONST LoadMenu = LoadMenuA;
            LoadMenuIndirect = LoadMenuIndirectA;
<* END *>


PROCEDURE GetMenu (hWnd : HWND) : HMENU;
PROCEDURE SetMenu (hWnd : HWND; hMenu : HMENU) : BOOL;

PROCEDURE ChangeMenuA (hMenu : HMENU; cmd : UINT;
                       NewItem : PCSTR; (* NIL *)
                       cmdInsert : UINT;
                       flags : MF_SET) : BOOL;
PROCEDURE ChangeMenuW (hMenu : HMENU; cmd : UINT;
                       NewItem : PCWSTR; (* NIL *)
                       cmdInsert : UINT;
                       flags : MF_SET) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ChangeMenu = ChangeMenuW;

<* ELSE *>
      CONST ChangeMenu = ChangeMenuA;
<* END *>

PROCEDURE HiliteMenuItem (hWnd : HWND; hMenu : HMENU;
                          HiliteItem : UINT; flags : MF_SET) : BOOL;

PROCEDURE GetMenuStringA (hMenu : HMENU; IDItem : UINT;
                          VAR [NIL] String : ARRAY OF CHAR;
                          MaxCount : INTEGER;
                          flags : MF_SET) : INTEGER;
PROCEDURE GetMenuStringW (hMenu : HMENU; IDItem : UINT;
                          VAR [NIL] String : ARRAY OF WCHAR;
                          MaxCount : INTEGER;
                          flags : MF_SET) : INTEGER;
<* IF DEFINED (UNICODE) THEN *>
      CONST GetMenuString = GetMenuStringW;
<* ELSE *>
      CONST GetMenuString = GetMenuStringA;
<* END *>

PROCEDURE GetMenuState (hMenu : HMENU; Id : UINT; Flags : MF_SET) : MF_SET;
PROCEDURE DrawMenuBar (hWnd : HWND) : BOOL;
PROCEDURE GetSystemMenu (hWnd : HWND; Reset : BOOL) : HMENU;
PROCEDURE CreateMenu () : HMENU;
PROCEDURE CreatePopupMenu () : HMENU;
PROCEDURE DestroyMenu (hMenu : HMENU) : BOOL;
PROCEDURE CheckMenuItem (hMenu : HMENU; IDCheckItem : UINT;
                         Check : MF_SET) : MF_SET;
PROCEDURE EnableMenuItem (hMenu : HMENU; IDEnableItem : UINT;
                          Enable : MF_SET) : BOOL;
PROCEDURE GetSubMenu (hMenu : HMENU; Pos : INTEGER) : HMENU;
PROCEDURE GetMenuItemID (hMenu : HMENU; Pos : INTEGER) : UINT;
PROCEDURE GetMenuItemCount (hMenu : HMENU) : INTEGER;

PROCEDURE InsertMenuA (hMenu : HMENU; Position : UINT; Flags : MF_SET;
                       IDNewItem : UINT; NewItem : PCSTR (* NIL *)) : BOOL;
PROCEDURE InsertMenuW (hMenu : HMENU; Position : UINT; Flags : MF_SET;
                       IDNewItem : UINT; NewItem : PCWSTR (* NIL *)) : BOOL;

PROCEDURE AppendMenuA (hMenu : HMENU; Flags : MF_SET; IDNewItem : UINT;
                       lpNewItem : PCSTR (* NIL *)) : BOOL;
PROCEDURE AppendMenuW (hMenu : HMENU; Flags : MF_SET; IDNewItem : UINT;
                       lpNewItem : PCWSTR (* NIL *)) : BOOL;

PROCEDURE ModifyMenuA (hMenu : HMENU; Position : UINT; Flags : UINT;
                       IDNewItem : UINT; NewItem : PCSTR (* NIL*)) : BOOL;
PROCEDURE ModifyMenuW (hMenu : HMENU; Position : UINT; Flags : UINT;
                       IDNewItem : UINT; NewItem : PCWSTR (* NIL *)) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST InsertMenu = InsertMenuW;
            AppendMenu = AppendMenuW;
            ModifyMenu = ModifyMenuW;
<* ELSE *>
      CONST InsertMenu = InsertMenuA;
            AppendMenu = AppendMenuA;
            ModifyMenu = ModifyMenuA;
<* END *>

PROCEDURE RemoveMenu (hMenu : HMENU; Position : UINT; Flags : MF_SET) : BOOL;
PROCEDURE DeleteMenu (hMenu : HMENU; Position : UINT; Flags : MF_SET) : BOOL;

PROCEDURE SetMenuItemBitmaps (hMenu : HMENU; Position : UINT;
                              Flags : MF_SET;
                              BitmapUnchecked, BitmapChecked : HBITMAP) : BOOL;

PROCEDURE GetMenuCheckMarkDimensions () : DWORD;

(* Flags for TrackPopupMenu *)

TYPE TPM_ENUM = (TPM__0,            (* 0 *)
                 TPM__RIGHTBUTTON,  (* 1 *)
                 TPM__CENTERALIGN,  (* 2 *)
                 TPM__RIGHTALIGN,   (* 3 *)
                 TPM__VCENTERALIGN, (* 4 *)
                 TPM__BOTTOMALIGN,  (* 5 *)
                 TPM__VERTICAL,     (* 6 - Vert alignment matters more *)
                 TPM__NONOTIFY,     (* 7 - Don't send any notification msgs *)
                 TPM__RETURNCMD);   (* 8 *)

      TPM_SET = SET OF TPM_ENUM;

CONST TPM_LEFTBUTTON   = TPM_SET {};                  (* 0x0000 *)
      TPM_RIGHTBUTTON  = TPM_SET {TPM__RIGHTBUTTON};  (* 0x0002 *)
      TPM_LEFTALIGN    = TPM_SET {};                  (* 0x0000 *)
      TPM_CENTERALIGN  = TPM_SET {TPM__CENTERALIGN};  (* 0x0004 *)
      TPM_RIGHTALIGN   = TPM_SET {TPM__RIGHTALIGN};   (* 0x0008 *)
      TPM_TOPALIGN     = TPM_SET {};                  (* 0x0000 *)
      TPM_VCENTERALIGN = TPM_SET {TPM__VCENTERALIGN}; (* 0x0010 *)
      TPM_BOTTOMALIGN  = TPM_SET {TPM__BOTTOMALIGN};  (* 0x0020 *)
      TPM_HORIZONTAL   = TPM_SET {};                  (* 0x0000 *)
      TPM_VERTICAL     = TPM_SET {TPM__VERTICAL};     (* 0x0040 *)
      TPM_NONOTIFY     = TPM_SET {TPM__NONOTIFY};     (* 0x0080 *)
      TPM_RETURNCMD    = TPM_SET {TPM__RETURNCMD};    (* 0x0100 *)

(* Rect can be NIL *)

PROCEDURE TrackPopupMenu (hMenu : HMENU; Flags : TPM_SET;
                          x, y : INTEGER; Reserved : INTEGER;
                          hWnd : HWND; Rect : PRECT (* IN NIL *)) : BOOL;

(* return codes for WM_MENUCHAR *)

TYPE MNC_ENUM = (MNC_IGNORE,   (* 0 *)
                 MNC_CLOSE,    (* 1 *)
                 MNC_EXECUTE,  (* 2 *)
                 MNC_SELECT);  (* 3 *)

TYPE TPMPARAMS = RECORD
                        cbSize : UINT;     (* Size of structure *)
                        rcExclude : RECT;  (* Screen coordinates of rectangle to exclude when positioning *)
                 END;
    PTPMPARAMS = POINTER TO TPMPARAMS;


PROCEDURE TrackPopupMenuEx (hmenu : HMENU;
                            flags : TPM_SET;
                            x, y  : INTEGER;
                            owner : HWND;
                            ptpm  : PTPMPARAMS (* IN NIL *)) : BOOL;

TYPE MIIM_ENUM = (MIIM__STATE,      (* 0 *)
                  MIIM__ID,         (* 1 *)
                  MIIM__SUBMENU,    (* 2 *)
                  MIIM__CHECKMARKS, (* 3 *)
                  MIIM__TYPE,       (* 4 *)
                  MIIM__DATA);      (* 5 *)

     MIIM_SET = SET OF MIIM_ENUM;

CONST MIIM_STATE       = MIIM_SET {MIIM__STATE     }; (* 0x00000001 *)
      MIIM_ID          = MIIM_SET {MIIM__ID        }; (* 0x00000002 *)
      MIIM_SUBMENU     = MIIM_SET {MIIM__SUBMENU   }; (* 0x00000004 *)
      MIIM_CHECKMARKS  = MIIM_SET {MIIM__CHECKMARKS}; (* 0x00000008 *)
      MIIM_TYPE        = MIIM_SET {MIIM__TYPE      }; (* 0x00000010 *)
      MIIM_DATA        = MIIM_SET {MIIM__DATA      }; (* 0x00000020 *)


TYPE MENUITEMINFOA = RECORD
                            cbSize        : UINT;
                            fMask         : MIIM_SET;
                            fType         : MF_SET;   (* used if MIIM_TYPE *)
                            fState        : MF_SET;   (* used if MIIM_STATE *)
                            wID           : UINT;     (* used if MIIM_ID *)
                            hSubMenu      : HMENU;    (* used if MIIM_SUBMENU *)
                            hbmpChecked   : HBITMAP;  (* used if MIIM_CHECKMARKS *)
                            hbmpUnchecked : HBITMAP;  (* used if MIIM_CHECKMARKS *)
                            dwItemData    : DWORD;    (* used if MIIM_DATA *)
                            dwTypeData    : PSTR;     (* used if MIIM_TYPE *)
                            cch           : UINT;     (* used if MIIM_TYPE *)
                     END;
    PMENUITEMINFOA = POINTER TO MENUITEMINFOA;

    MENUITEMINFOW = RECORD
                            cbSize        : UINT;
                            fMask         : MIIM_SET;
                            fType         : MF_SET;   (* used if MIIM_TYPE *)
                            fState        : MF_SET;   (* used if MIIM_STATE *)
                            wID           : UINT;     (* used if MIIM_ID *)
                            hSubMenu      : HMENU;    (* used if MIIM_SUBMENU *)
                            hbmpChecked   : HBITMAP;  (* used if MIIM_CHECKMARKS *)
                            hbmpUnchecked : HBITMAP;  (* used if MIIM_CHECKMARKS *)
                            dwItemData    : DWORD;    (* used if MIIM_DATA *)
                            dwTypeData    : PWSTR;    (* used if MIIM_TYPE *)
                            cch           : UINT;     (* used if MIIM_TYPE *)
                     END;
    PMENUITEMINFOW = POINTER TO MENUITEMINFOW;

<* IF DEFINED (UNICODE) THEN *>
   TYPE  MENUITEMINFO =   MENUITEMINFOW;
        PMENUITEMINFO =  PMENUITEMINFOW;
<* ELSE *>
   TYPE  MENUITEMINFO =   MENUITEMINFOA;
        PMENUITEMINFO =  PMENUITEMINFOA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE InsertMenuItemA (hmenu      : HMENU;
                           uitem      : UINT;
                           ByPotition : BOOL;
                           info       : MENUITEMINFOA (*!*)) : BOOL;
<* ELSE *>
PROCEDURE InsertMenuItemA (hmenu      : HMENU;
                           uitem      : UINT;
                           ByPotition : BOOL;
                           info       : PMENUITEMINFOA (*!*)) : BOOL;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE InsertMenuItemW (hmenu      : HMENU;
                           uitem      : UINT;
                           ByPotition : BOOL;
                           info       : MENUITEMINFOW (*!*)) : BOOL;
<* ELSE *>
PROCEDURE InsertMenuItemW (hmenu      : HMENU;
                           uitem      : UINT;
                           ByPotition : BOOL;
                           info       : PMENUITEMINFOW (*!*)) : BOOL;
<* END *>

<* IF DEFINED (UNICODE) THEN *>
      CONST InsertMenuItem = InsertMenuItemW;
<* ELSE *>
      CONST InsertMenuItem = InsertMenuItemA;
<* END *>

PROCEDURE GetMenuItemInfoA (hmenu      : HMENU;
                            uItem      : UINT;
                            ByPosition : BOOL;
                            VAR info   : MENUITEMINFOA) : BOOL;

PROCEDURE GetMenuItemInfoW (hmenu      : HMENU;
                            uItem      : UINT;
                            ByPosition : BOOL;
                            VAR info   : MENUITEMINFOW) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetMenuItemInfo = GetMenuItemInfoW;
<* ELSE *>
      CONST GetMenuItemInfo = GetMenuItemInfoA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE SetMenuItemInfoA (hmenu      : HMENU;
                            uItem      : UINT;
                            ByPosition : BOOL;
                            info       : MENUITEMINFOA (*!*)) : BOOL;
<* ELSE *>
PROCEDURE SetMenuItemInfoA (hmenu      : HMENU;
                            uItem      : UINT;
                            ByPosition : BOOL;
                            info       : PMENUITEMINFOA (*!*)) : BOOL;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE SetMenuItemInfoW (hmenu      : HMENU;
                            uItem      : UINT;
                            ByPosition : BOOL;
                            info       : MENUITEMINFOW (*!*)) : BOOL;
<* ELSE *>
PROCEDURE SetMenuItemInfoW (hmenu      : HMENU;
                            uItem      : UINT;
                            ByPosition : BOOL;
                            info       : PMENUITEMINFOW (*!*)) : BOOL;
<* END *>

<* IF DEFINED (UNICODE) THEN *>
      CONST SetMenuItemInfo = SetMenuItemInfoW;
<* ELSE *>
      CONST SetMenuItemInfo = SetMenuItemInfoA;
<* END *>


TYPE GMDI_ENUM = (GMDI__USEDISABLED,   (* 0 *)
                  GMDI__GOINTOPOPUPS); (* 1 *)

     GMDI_SET = SET OF GMDI_ENUM;

CONST GMDI_USEDISABLED  = GMDI_SET {GMDI__USEDISABLED};  (* 0x0001L *)
      GMDI_GOINTOPOPUPS = GMDI_SET {GMDI__GOINTOPOPUPS}; (* 0x0002L *)

PROCEDURE GetMenuDefaultItem (hMenu : HMENU; fByPos : UINT; gmdiFlags : GMDI_SET) : UINT;
PROCEDURE SetMenuDefaultItem (hMenu : HMENU; uItem  : UINT; fByPos : UINT) : BOOL;

PROCEDURE GetMenuItemRect (hWnd : HWND; hMenu : HMENU; uItem : UINT; VAR rcItem : RECT);

(* MenuItemFromPoint has parameter of structure type POINT which is passed
   by value. It had to be implemented in RTL.
*)

<* IF BACKEND # "C" THEN *>
PROCEDURE rtlMenuItemFromPoint (hWnd : HWND; hMenu : HMENU; pt : POINT) : INTEGER;
CONST MenuItemFromPoint = rtlMenuItemFromPoint;
<* ELSE *>
PROCEDURE MenuItemFromPoint (hWnd : HWND; hMenu : HMENU; pt : POINT) : INTEGER;
<* END *>

(*
 * Drag-and-drop support
*)

TYPE DROPSTRUCT = RECORD
                         hwndSource : HWND;
                         hwndSink : HWND;
                         wFmt : DWORD;
                         dwData : DWORD;
                         ptDrop : POINT;
                         dwControlData : DWORD;
                  END;
    PDROPSTRUCT = POINTER TO DROPSTRUCT;

CONST DOF_EXECUTABLE = 8001h;
      DOF_DOCUMENT   = 8002h;
      DOF_DIRECTORY  = 8003h;
      DOF_MULTIPLE   = 8004h;
      DOF_PROGMAN    = 0001h;
      DOF_SHELLDATA  = 0002h;

      DO_DROPFILE    = 454C4946h;
      DO_PRINTFILE   = 544E5250h;

PROCEDURE DragObject (hwndSource : HWND;
                      hwndSink   : HWND;
                      Fmt        : UINT;
                      Data       : DWORD;
                      cursor     : HCURSOR) : DWORD;

(* DragDetect has parameter of structure type POINT which is passed
   by value. It had to be implemented in RTL. *)

<* IF BACKEND # "C" THEN *>
PROCEDURE rtlDragDetect (hwnd : HWND; pt : POINT) : BOOL;
CONST DragDetect = rtlDragDetect;
<* ELSE *>
PROCEDURE DragDetect (hwnd : HWND; pt : POINT) : BOOL;
<* END *>

PROCEDURE DrawIcon (hDC : HDC; X : INTEGER; Y : INTEGER; hIcon : HICON) : BOOL;

(* DrawText Format Flags *)

TYPE DTX_ENUM = (DT__CENTER,           (* 0 *)
                 DT__RIGHT,            (* 1 *)
                 DT__VCENTER,          (* 2 *)
                 DT__BOTTOM,           (* 3 *)
                 DT__WORDBREAK,        (* 4 *)
                 DT__SINGLELINE,       (* 5 *)
                 DT__EXPANDTABS,       (* 6 *)
                 DT__TABSTOP,          (* 7 *)
                 DT__NOCLIP,           (* 8 *)
                 DT__EXTERNALLEADING,  (* 9 *)
                 DT__CALCRECT,         (*10 *)
                 DT__NOPREFIX,         (*11 *)
                 DT__INTERNAL,         (*12 *)
                 DT__EDITCONTROL,      (*13 *)
                 DT__PATH_ELLIPSIS,    (*14 *)
                 DT__END_ELLIPSIS,     (*15 *)
                 DT__MODIFYSTRING,     (*16 *)
                 DT__RTLREADING,       (*17 *)
                 DT__WORD_ELLIPSIS);   (*18 *)

      DT_SET = SET OF DTX_ENUM;

CONST DT_TOP              = DT_SET {};                    (* 0x00000000 *)
      DT_LEFT             = DT_SET {};                    (* 0x00000000 *)
      DT_CENTER           = DT_SET {DT__CENTER};          (* 0x00000001 *)
      DT_RIGHT            = DT_SET {DT__RIGHT};           (* 0x00000002 *)
      DT_VCENTER          = DT_SET {DT__VCENTER};         (* 0x00000004 *)
      DT_BOTTOM           = DT_SET {DT__BOTTOM};          (* 0x00000008 *)
      DT_WORDBREAK        = DT_SET {DT__WORDBREAK};       (* 0x00000010 *)
      DT_SINGLELINE       = DT_SET {DT__SINGLELINE};      (* 0x00000020 *)
      DT_EXPANDTABS       = DT_SET {DT__EXPANDTABS};      (* 0x00000040 *)
      DT_TABSTOP          = DT_SET {DT__TABSTOP};         (* 0x00000080 *)
      DT_NOCLIP           = DT_SET {DT__NOCLIP};          (* 0x00000100 *)
      DT_EXTERNALLEADING  = DT_SET {DT__EXTERNALLEADING}; (* 0x00000200 *)
      DT_CALCRECT         = DT_SET {DT__CALCRECT};        (* 0x00000400 *)
      DT_NOPREFIX         = DT_SET {DT__NOPREFIX};        (* 0x00000800 *)
      DT_INTERNAL         = DT_SET {DT__INTERNAL};        (* 0x00001000 *)
      DT_EDITCONTROL      = DT_SET {DT__EDITCONTROL  };   (* 0x00002000 *)
      DT_PATH_ELLIPSIS    = DT_SET {DT__PATH_ELLIPSIS};   (* 0x00004000 *)
      DT_END_ELLIPSIS     = DT_SET {DT__END_ELLIPSIS };   (* 0x00008000 *)
      DT_MODIFYSTRING     = DT_SET {DT__MODIFYSTRING };   (* 0x00010000 *)
      DT_RTLREADING       = DT_SET {DT__RTLREADING   };   (* 0x00020000 *)
      DT_WORD_ELLIPSIS    = DT_SET {DT__WORD_ELLIPSIS};   (* 0x00040000 *)

TYPE DRAWTEXTPARAMS = RECORD
                              cbSize    : UINT;
                              iTabLength : INTEGER;
                              iLeftMargin : INTEGER;
                              iRightMargin : INTEGER;
                              uiLengthDrawn : UINT;
                      END;
    PDRAWTEXTPARAMS = POINTER TO DRAWTEXTPARAMS;

(* DrawText and DrawTextEx have String declared as PSTR not ARRAY OF CHAR
   because the functions can modify the string in case DT_MODIFYSTRING
   is specified *)

PROCEDURE DrawTextA (hDC : HDC; String : PSTR; Count : INTEGER;
                     VAR Rect : RECT; Format : DT_SET) : INTEGER;

PROCEDURE DrawTextW (hDC : HDC; String : PWSTR; Count : INTEGER;
                     VAR Rect : RECT; Format : DT_SET) : INTEGER;

PROCEDURE DrawTextExA (hDC : HDC; String : PSTR; Count : INTEGER;
                       VAR Rect : RECT; Format : DT_SET;
                       VAR params : DRAWTEXTPARAMS);

PROCEDURE DrawTextExW (hDC : HDC; String : PWSTR; Count : INTEGER;
                       VAR Rect : RECT; Format : DT_SET;
                       VAR params : DRAWTEXTPARAMS);

<* IF DEFINED (UNICODE) THEN *>
      CONST DrawText   = DrawTextW;
            DrawTextEx = DrawTextExW;
<* ELSE *>
      CONST DrawText   = DrawTextA;
            DrawTextEx = DrawTextExA;
<* END *>

PROCEDURE GrayStringA (hDC : HDC; Brush : HBRUSH;
                       OutputFunc : GRAYSTRINGPROC;
                       Data : LPARAM; X, Y : INTEGER;
                       Width, Height : INTEGER) : BOOL;

PROCEDURE GrayStringW (hDC : HDC; Brush : HBRUSH;
                       OutputFunc : GRAYSTRINGPROC;
                       Data : LPARAM; X, Y : INTEGER;
                       Width, Height : INTEGER) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GrayString = GrayStringW;
<* ELSE *>
      CONST GrayString = GrayStringA;
<* END *>


(* Monolithic state-drawing routine *)

(* State type *)

TYPE DSS_ENUM = (DSS__0, DSS__1,
                 DSS__2, DSS__3,
                 DSS__UNION,       (* 4 *) (* Gray string appearance *)
                 DSS__DISABLED,    (* 5 *)
                 DSS__6,
                 DSS__MONO,        (* 7 *)
                 DSS__8, DSS__9,
                 DSS__10,DSS__11,
                 DSS__12,DSS__13,
                 DSS__14,
                 DSS__RIGHT);      (* 15 *)

     DSS_SET = SET OF DSS_ENUM;

CONST DSS_NORMAL   = DSS_SET {};                   (* 0x0000 *)
      DSS_UNION    = DSS_SET {DSS__UNION};         (* 0x0010 *)
      DSS_DISABLED = DSS_SET {DSS__DISABLED};      (* 0x0020 *)
      DSS_MONO     = DSS_SET {DSS__MONO};          (* 0x0080 *)
      DSS_RIGHT    = DSS_SET {DSS__RIGHT};         (* 0x8000 *)

(* Image type *)

CONST DST_COMPLEX     = DSS_SET {};                (* 0x0000 *)
      DST_TEXT        = DSS_SET {DSS__0};          (* 0x0001 *)
      DST_PREFIXTEXT  = DSS_SET {DSS__1};          (* 0x0002 *)
      DST_ICON        = DSS_SET {DSS__0, DSS__1};  (* 0x0003 *)
      DST_BITMAP      = DSS_SET {DSS__2};          (* 0x0004 *)


PROCEDURE DrawStateA (hDC : HDC; hBrush : HBRUSH;
                     outputFunc : DRAWSTATEPROC;
                     lData : LPARAM;
                     wData : WPARAM;
                     x, y, cx, cy : INTEGER;
                     flags : DSS_SET);

PROCEDURE DrawStateW (hDC : HDC; hBrush : HBRUSH;
                     outputFunc : DRAWSTATEPROC;
                     lData : LPARAM;
                     wData : WPARAM;
                     x, y, cx, cy : INTEGER;
                     flags : DSS_SET);


<* IF DEFINED (UNICODE) THEN *>
      CONST DrawState = DrawStateW;
<* ELSE *>
      CONST DrawState = DrawStateA;
<* END *>


PROCEDURE TabbedTextOutA (hDC : HDC; X, Y : INTEGER;
                          String : ARRAY OF CHAR;
                          Count : INTEGER;
                          TabPositions : INTEGER;
                          TabStopPositions : ARRAY OF INTEGER;
                          TabOrigin : INTEGER) : LONG;

PROCEDURE TabbedTextOutW (hDC : HDC; X, Y : INTEGER;
                          String : ARRAY OF WCHAR;
                          Count : INTEGER;
                          TabPositions : INTEGER;
                          TabStopPositions : ARRAY OF INTEGER;
                          TabOrigin : INTEGER) : LONG;

PROCEDURE GetTabbedTextExtentA (hDC : HDC; String : ARRAY OF CHAR;
                                 Count : INTEGER; TabPositions : INTEGER;
                                 TabStopPositions : ARRAY OF INTEGER) : DWORD;
PROCEDURE GetTabbedTextExtentW (hDC : HDC; String : ARRAY OF WCHAR;
                                 Count : INTEGER; TabPositions : INTEGER;
                                 TabStopPositions : ARRAY OF INTEGER) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST TabbedTextOut = TabbedTextOutW;
            GetTabbedTextExtent = GetTabbedTextExtentW;
<* ELSE *>
      CONST TabbedTextOut = TabbedTextOutA;
            GetTabbedTextExtent = GetTabbedTextExtentA;
<* END *>

PROCEDURE UpdateWindow    (hWnd : HWND) : BOOL;
PROCEDURE SetActiveWindow (hwnd : HWND) : HWND;
PROCEDURE GetForegroundWindow () : HWND;
PROCEDURE PaintDesktop (hdc : HDC) : BOOL;
PROCEDURE SetForegroundWindow (hwnd : HWND) : BOOL;
PROCEDURE WindowFromDC (hDC : HDC) : HWND;
PROCEDURE GetDC (hWnd : HWND) : HDC;

(* GetDCEx flags *)

TYPE DCX_ENUM = (DCX__WINDOW,            (* 0*)
                 DCX__CACHE,             (* 1*)
                 DCX__NORESETATTRS,      (* 2*)
                 DCX__CLIPCHILDREN,      (* 3*)
                 DCX__CLIPSIBLINGS,      (* 4*)
                 DCX__PARENTCLIP,        (* 5*)

                 DCX__EXCLUDERGN,        (* 6*)
                 DCX__INTERSECTRGN,      (* 7*)

                 DCX__EXCLUDEUPDATE,     (* 8*)
                 DCX__INTERSECTUPDATE,   (* 9*)

                 DCX__LOCKWINDOWUPDATE,  (*10*)
                 DCX__11, DCX__12, DCX__13, DCX__14, DCX__15,
                 DCX__16, DCX__17, DCX__18, DCX__19, DCX__20,
                 DCX__VALIDATE);         (*21*)
     DCX_SET = SET OF DCX_ENUM;

CONST DCX_WINDOW           = DCX_SET {DCX__WINDOW};           (* 0x00000001L *)
      DCX_CACHE            = DCX_SET {DCX__CACHE};            (* 0x00000002L *)
      DCX_NORESETATTRS     = DCX_SET {DCX__NORESETATTRS};     (* 0x00000004L *)
      DCX_CLIPCHILDREN     = DCX_SET {DCX__CLIPCHILDREN};     (* 0x00000008L *)
      DCX_CLIPSIBLINGS     = DCX_SET {DCX__CLIPSIBLINGS};     (* 0x00000010L *)
      DCX_PARENTCLIP       = DCX_SET {DCX__PARENTCLIP};       (* 0x00000020L *)

      DCX_EXCLUDERGN       = DCX_SET {DCX__EXCLUDERGN};       (* 0x00000040L *)
      DCX_INTERSECTRGN     = DCX_SET {DCX__INTERSECTRGN};     (* 0x00000080L *)

      DCX_EXCLUDEUPDATE    = DCX_SET {DCX__EXCLUDEUPDATE};    (* 0x00000100L *)
      DCX_INTERSECTUPDATE  = DCX_SET {DCX__INTERSECTUPDATE};  (* 0x00000200L *)

      DCX_LOCKWINDOWUPDATE = DCX_SET {DCX__LOCKWINDOWUPDATE}; (* 0x00000400L *)

      DCX_VALIDATE         = DCX_SET {DCX__VALIDATE};         (* 0x00200000L *)


PROCEDURE GetDCEx (hWnd : HWND; RgnClip : HRGN; flags : DCX_SET) : HDC;

PROCEDURE GetWindowDC (hWnd : HWND) : HDC;
PROCEDURE ReleaseDC (hWnd : HWND; hDC : HDC) : BOOL;

PROCEDURE BeginPaint (hWnd : HWND; VAR Paint : PAINTSTRUCT) : HDC;
PROCEDURE EndPaint   (hWnd : HWND; VAR Paint : PAINTSTRUCT) : BOOL;

PROCEDURE GetUpdateRect (hWnd : HWND; VAR [NIL] Rect : RECT; bErase : BOOL) : BOOL;

PROCEDURE GetUpdateRgn (hWnd : HWND; hRgn : HRGN; Erase : BOOL) : INTEGER;
         (* in fact, returns region flag, defined in GDI *)

PROCEDURE SetWindowRgn (hWnd : HWND; hRgn : HRGN; bRedraw : BOOL) : INTEGER;
PROCEDURE GetWindowRgn (hWnd : HWND; hRgn : HRGN) : INTEGER;

PROCEDURE ExcludeUpdateRgn (hDC : HDC; hWnd : HWND) : INTEGER;
PROCEDURE InvalidateRect (hWnd : HWND; Rect : PRECT (* IN NIL *); Erase : BOOL) : BOOL;
PROCEDURE   ValidateRect (hWnd : HWND; Rect : PRECT (* IN NIL *)) : BOOL;
PROCEDURE InvalidateRgn (hWnd : HWND; hRgn : HRGN; Erase : BOOL) : BOOL;
PROCEDURE   ValidateRgn (hWnd : HWND; hRgn : HRGN; Erase : BOOL) : BOOL;

(* RedrawWindow flags *)

TYPE RDW_ENUM = (RDW__INVALIDATE,        (* 0 *)
                 RDW__INTERNALPAINT,     (* 1 *)
                 RDW__ERASE,             (* 2 *)

                 RDW__VALIDATE,          (* 3 *)
                 RDW__NOINTERNALPAINT,   (* 4 *)
                 RDW__NOERASE,           (* 5 *)

                 RDW__NOCHILDREN,        (* 6 *)
                 RDW__ALLCHILDREN,       (* 7 *)

                 RDW__UPDATENOW,         (* 8 *)
                 RDW__ERASENOW,          (* 9 *)

                 RDW__FRAME,             (*10 *)
                 RDW__NOFRAME);          (*11 *)
     RDW_SET = SET OF RDW_ENUM;

CONST RDW_INVALIDATE      = RDW_SET {RDW__INVALIDATE};      (* 0x0001 *)
      RDW_INTERNALPAINT   = RDW_SET {RDW__INTERNALPAINT};   (* 0x0002 *)
      RDW_ERASE           = RDW_SET {RDW__ERASE};           (* 0x0004 *)

      RDW_VALIDATE        = RDW_SET {RDW__VALIDATE};        (* 0x0008 *)
      RDW_NOINTERNALPAINT = RDW_SET {RDW__NOINTERNALPAINT}; (* 0x0010 *)
      RDW_NOERASE         = RDW_SET {RDW__NOERASE};         (* 0x0020 *)

      RDW_NOCHILDREN      = RDW_SET {RDW__NOCHILDREN};      (* 0x0040 *)
      RDW_ALLCHILDREN     = RDW_SET {RDW__ALLCHILDREN};     (* 0x0080 *)

      RDW_UPDATENOW       = RDW_SET {RDW__UPDATENOW};       (* 0x0100 *)
      RDW_ERASENOW        = RDW_SET {RDW__ERASENOW};        (* 0x0200 *)

      RDW_FRAME           = RDW_SET {RDW__FRAME};           (* 0x0400 *)
      RDW_NOFRAME         = RDW_SET {RDW__NOFRAME};         (* 0x0800 *)

PROCEDURE RedrawWindow (hWnd : HWND; RectUpdate : PRECT; (* IN NIL *)
                        RgnUpdate : HRGN; flags : RDW_SET) : BOOL;


PROCEDURE LockWindowUpdate (hWndLock : HWND) : BOOL;

PROCEDURE ScrollWindow (hWnd : HWND;
                        XAmount, YAmount : INTEGER;
                        Rect, ClipRect : PRECT (* IN NIL *)) : BOOL;

<* IF BACKEND # "C" THEN *>
PROCEDURE ScrollDC (hDC : HDC;
                    dx, dy : INTEGER;
                    Scroll : RECT;
                    Clip : PRECT; (* IN NIL *)
                    RgnUpdate : HRGN;
                    VAR [NIL] RectUpdate : RECT) : BOOL;
<* ELSE *>
PROCEDURE ScrollDC (hDC : HDC;
                    dx, dy : INTEGER;
                    Scroll : PRECT;
                    Clip : PRECT; (* IN NIL *)
                    RgnUpdate : HRGN;
                    VAR [NIL] RectUpdate : RECT) : BOOL;
<* END *>


TYPE SCRW_ENUM = (SCRW__SCROLLCHILDREN,  (* 0 *)
                  SCRW__INVALIDATE,      (* 1 *)
                  SCRW__ERASE);          (* 2 *)

     SCRW_SET = SET OF SCRW_ENUM;

     (* type is called SCRW for not mixing it with SW_ENUM that is
        ShowWindow parameter type; SW_ constants leaved as they were for
        compatibility
     *)

CONST SW_SCROLLCHILDREN = SCRW_SET {SCRW__SCROLLCHILDREN}; (* 0x0001 - Scroll children within *lprcScroll. *)
      SW_INVALIDATE     = SCRW_SET {SCRW__INVALIDATE};     (* 0x0002 - Invalidate after scrolling *)
      SW_ERASE          = SCRW_SET {SCRW__ERASE};          (* 0x0004 - If SW_INVALIDATE, don't send WM_ERASEBACKGROUND *)

PROCEDURE ScrollWindowEx (hWnd : HWND;
                          dx, dy : INTEGER;
                          Scroll, Clip : PRECT; (* IN NIL *)
                          RgnUpdate : HRGN;
                          VAR [NIL] RectUpdate : RECT;
                          flags : SCRW_SET)
                                            : INTEGER;

PROCEDURE SetScrollPos (hWnd : HWND; Bar : SB_TYPE;
                        Pos : INTEGER; Redraw : BOOL) : INTEGER;
PROCEDURE GetScrollPos   (hWnd : HWND; Bar : SB_TYPE) : INTEGER;
PROCEDURE SetScrollRange (hWnd : HWND; Bar : SB_TYPE;
                          MinPos, MaxPos : INTEGER; Redraw : BOOL) : BOOL;
PROCEDURE GetScrollRange (hWnd : HWND; Bar : SB_TYPE;
                          VAR MinPos, MaxPos : INTEGER) : BOOL;
PROCEDURE ShowScrollBar   (hWnd : HWND; Bar : SB_TYPE; Show : BOOL) : BOOL;


(*
 * EnableScrollBar() flags
 *)

TYPE ESB_ENUM = (ESB__DISABLE_LEFT,   (* 0 *)
                 ESB__DISABLE_RIGHT); (* 1 *)

     ESB_SET = SET OF ESB_ENUM;

CONST ESB_ENABLE_BOTH   = ESB_SET {};                    (* 0x0000 *)
      ESB_DISABLE_LEFT  = ESB_SET {ESB__DISABLE_LEFT};   (* 0x0001 *)
      ESB_DISABLE_RIGHT = ESB_SET {ESB__DISABLE_RIGHT};  (* 0x0002 *)
      ESB_DISABLE_BOTH  = ESB_SET {ESB__DISABLE_LEFT,
                                   ESB__DISABLE_RIGHT};  (* 0x0003 *)

      ESB_DISABLE_UP   = ESB_DISABLE_LEFT;  (* 0x0001 *)
      ESB_DISABLE_DOWN = ESB_DISABLE_RIGHT; (* 0x0002 *)

      ESB_DISABLE_LTUP = ESB_DISABLE_LEFT;
      ESB_DISABLE_RTDN = ESB_DISABLE_RIGHT;


PROCEDURE EnableScrollBar (hWnd   : HWND;
                           Bar    : SB_TYPE;
                           Arrpws : ESB_SET) : BOOL;


PROCEDURE SetPropA (hWnd : HWND; String : ATOMSTR; Data : HANDLE) : BOOL;
PROCEDURE SetPropW (hWnd : HWND; String : ATOMWSTR; Data : HANDLE) : BOOL;
PROCEDURE GetPropA (hWnd : HWND; String : ATOMSTR) : HANDLE;
PROCEDURE GetPropW (hWnd : HWND; String : ATOMWSTR) : HANDLE;
PROCEDURE RemovePropA (hWnd : HWND; String : ATOMSTR) : HANDLE;
PROCEDURE RemovePropW (hWnd : HWND; String : ATOMWSTR) : HANDLE;
PROCEDURE EnumPropExA (hWnd : HWND; EnumFunc : PROPENUMPROCEXA; lParam : LPARAM) : INTEGER;
PROCEDURE EnumPropExW (hWnd : HWND; EnumFunc : PROPENUMPROCEXW; lParam : LPARAM) : INTEGER;
PROCEDURE EnumPropsA (hWnd : HWND; EnumFunc : PROPENUMPROCA) : INTEGER;
PROCEDURE EnumPropsW (hWnd : HWND; EnumFunc : PROPENUMPROCW) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetProp = SetPropW;
            GetProp = GetPropW;
            RemoveProp = RemovePropW;
            EnumPropEx = EnumPropExW;
            EnumProps  = EnumPropsW;
<* ELSE *>
      CONST SetProp = SetPropA;
            GetProp = GetPropA;
            RemoveProp = RemovePropA;
            EnumPropEx = EnumPropExA;
            EnumProps  = EnumPropsA;
<* END *>

PROCEDURE SetWindowTextA (hWnd : HWND; String : ARRAY OF CHAR) : BOOL;
PROCEDURE SetWindowTextW (hWnd : HWND; String : ARRAY OF WCHAR) : BOOL;

PROCEDURE GetWindowTextA (hWnd : HWND;
                          VAR String : ARRAY OF CHAR;
                          MaxCount : INTEGER) : INTEGER;
PROCEDURE GetWindowTextW (hWnd : HWND;
                          VAR String : ARRAY OF WCHAR;
                          MaxCount : INTEGER) : INTEGER;

PROCEDURE GetWindowTextLengthA (hWnd : HWND) : INTEGER;
PROCEDURE GetWindowTextLengthW (hWnd : HWND) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetWindowText = SetWindowTextW;
            GetWindowText = GetWindowTextW;
            GetWindowTextLength = GetWindowTextLengthW;
<* ELSE *>
      CONST SetWindowText = SetWindowTextA;
            GetWindowText = GetWindowTextA;
            GetWindowTextLength = GetWindowTextLengthA;
<* END *>

PROCEDURE GetClientRect (hWnd : HWND; VAR Rect : RECT) : BOOL;
PROCEDURE GetWindowRect (hWnd : HWND; VAR Rect : RECT) : BOOL;
PROCEDURE AdjustWindowRect   (VAR Rect : RECT; Style : WS_SET; Menu : BOOL) : BOOL;
PROCEDURE AdjustWindowRectEx (VAR Rect : RECT; Style : WS_SET; Menu : BOOL;
                              ExStyle : WS_EX_SET) : BOOL;

TYPE HELPINFO_ENUM = (HELPINFO_0,
                      HELPINFO_WINDOW,    (* 0x0001 *)
                      HELPINFO_MENUITEM); (* 0x0002 *)

(* Structure pointed to by lParam of WM_HELP *)

TYPE HELPINFO =
     RECORD
            cbSize       : UINT;          (* Size in bytes of this struct  *)
            iContextType : HELPINFO_ENUM; (* Either HELPINFO_WINDOW or HELPINFO_MENUITEM *)
            iCtrlId      : INTEGER;       (* Control Id or a Menu item Id. *)
            hItemHandle  : HANDLE;        (* hWnd of control or hMenu.     *)
            dwContextId  : DWORD;         (* Context Id associated with this item  *)
            MousePos     : POINT;         (* Mouse Position in screen co-ordinates *)
     END;
     PHELPINFO = POINTER TO HELPINFO;

PROCEDURE SetWindowContextHelpId (hwnd  : HWND; id : DWORD) : BOOL;
PROCEDURE GetWindowContextHelpId (hwnd  : HWND) : DWORD;
PROCEDURE SetMenuContextHelpId   (hmenu : HMENU; id : DWORD) : BOOL;
PROCEDURE GetMenuContextHelpId   (hmenu : HMENU) : DWORD;

(* MessageBox Flags *)

TYPE MB_ENUM = (MB__0,  MB__1,  MB__2,  MB__3,  MB__4,  MB__5,  MB__6,  MB__7,
                MB__8,  MB__9,  MB__10, MB__11, MB__12, MB__13, MB__14, MB__15,
                MB__16, MB__17, MB__18, MB__19, MB__20, MB__21, MB__22, MB__23,
                MB__24, MB__25, MB__26, MB__27, MB__28, MB__29, MB__30, MB__31);
     MB_SET = SET OF MB_ENUM;

CONST MB_OK                  = MB_SET {};               (* 0x00000000L *)
      MB_OKCANCEL            = MB_SET {MB__0};          (* 0x00000001L *)
      MB_ABORTRETRYIGNORE    = MB_SET {MB__1};          (* 0x00000002L *)
      MB_YESNOCANCEL         = MB_SET {MB__1,MB__0};    (* 0x00000003L *)
      MB_YESNO               = MB_SET {MB__2};          (* 0x00000004L *)
      MB_RETRYCANCEL         = MB_SET {MB__2,MB__0};    (* 0x00000005L *)

      MB_ICONHAND            = MB_SET {MB__4};          (* 0x00000010L *)
      MB_ICONQUESTION        = MB_SET {MB__5};          (* 0x00000020L *)
      MB_ICONEXCLAMATION     = MB_SET {MB__4,MB__5};    (* 0x00000030L *)
      MB_ICONASTERISK        = MB_SET {MB__6};          (* 0x00000040L *)

      MB_USERICON            = MB_SET {MB__7};          (* 0x00000080L *)

      MB_ICONWARNING         = MB_ICONEXCLAMATION;
      MB_ICONERROR           = MB_ICONHAND;

      MB_ICONINFORMATION     = MB_ICONASTERISK;
      MB_ICONSTOP            = MB_ICONHAND;

      MB_DEFBUTTON1          = MB_SET {};               (* 0x00000000L *)
      MB_DEFBUTTON2          = MB_SET {MB__8};          (* 0x00000100L *)
      MB_DEFBUTTON3          = MB_SET {MB__9};          (* 0x00000200L *)
      MB_DEFBUTTON4          = MB_SET {MB__8,MB__9};    (* 0x00000300L *)

      MB_APPLMODAL           = MB_SET {};               (* 0x00000000L *)
      MB_SYSTEMMODAL         = MB_SET {MB__12};         (* 0x00001000L *)
      MB_TASKMODAL           = MB_SET {MB__13};         (* 0x00002000L *)
      MB_HELP                = MB_SET {MB__14};         (* 0x00004000L *)

      MB_NOFOCUS             = MB_SET {MB__15};         (* 0x00008000L *)
      MB_SETFOREGROUND       = MB_SET {MB__16};         (* 0x00010000L *)
      MB_DEFAULT_DESKTOP_ONLY= MB_SET {MB__17};         (* 0x00020000L *)

      MB_TOPMOST             = MB_SET {MB__18};         (* 0x00040000L *)
      MB_RIGHT               = MB_SET {MB__19};         (* 0x00080000L *)
      MB_RTLREADING          = MB_SET {MB__20};         (* 0x00100000L *)

      MB_SERVICE_NOTIFICATION= MB_SET {MB__21};         (* 0x00200000L *)
      MB_SERVICE_NOTIFICATION_NT3X = MB_SET {MB__18};   (* 0x00040000L *)

      MB_TYPEMASK            = MB_SET {MB__0..MB__3};   (* 0x0000000FL *)
      MB_ICONMASK            = MB_SET {MB__4..MB__7};   (* 0x000000F0L *)
      MB_DEFMASK             = MB_SET {MB__8..MB__11};  (* 0x00000F00L *)
      MB_MODEMASK            = MB_SET {MB__12,MB__13};  (* 0x00003000L *)
      MB_MISCMASK            = MB_SET {MB__14,MB__15};  (* 0x0000C000L *)

PROCEDURE MessageBoxA (hWnd : HWND;
                       Text : ARRAY OF CHAR;
                       Caption : PCSTR; (* NIL *)
                       Type : MB_SET) : INTEGER;
PROCEDURE MessageBoxW (hWnd : HWND;
                       Text : ARRAY OF WCHAR;
                       Caption : PCWSTR; (* NIL *)
                       Type : MB_SET) : INTEGER;

PROCEDURE MessageBoxExA (hWnd : HWND;
                         Text : ARRAY OF CHAR;
                         Caption : PCSTR; (* NIL *)
                         Type : MB_SET;
                         LanguageId : WORD) : INTEGER;
PROCEDURE MessageBoxExW (hWnd : HWND;
                         Text : ARRAY OF CHAR;
                         Caption : PCWSTR; (* NIL *)
                         Type : MB_SET;
                         LanguageId : WORD) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST  MessageBox   = MessageBoxW;
             MessageBoxEx = MessageBoxExW;
<* ELSE *>
      CONST  MessageBox   = MessageBoxA;
             MessageBoxEx = MessageBoxExA;
<* END *>

TYPE MSGBOXCALLBACK = PROCEDURE (VAR HELPINFO);

TYPE MSGBOXPARAMSA = RECORD
                            cbSize             : UINT;
                            hwndOwner          : HWND;
                            hInstance          : HINSTANCE;
                            lpszText           : PCSTR;
                            lpszCaption        : PCSTR;
                            dwStyle            : MB_SET;
                            lpszIcon           : RESOURCESTRA;
                            dwContextHelpId    : DWORD;
                            lpfnMsgBoxCallback : MSGBOXCALLBACK;
                            dwLanguageId       : DWORD;
                     END;
    PMSGBOXPARAMSA = POINTER TO MSGBOXPARAMSA;

TYPE MSGBOXPARAMSW = RECORD
                            cbSize             : UINT;
                            hwndOwner          : HWND;
                            hInstance          : HINSTANCE;
                            lpszText           : PCWSTR;
                            lpszCaption        : PCWSTR;
                            dwStyle            : MB_SET;
                            lpszIcon           : RESOURCESTRW;
                            dwContextHelpId    : DWORD;
                            lpfnMsgBoxCallback : MSGBOXCALLBACK;
                            dwLanguageId       : DWORD;
                     END;
    PMSGBOXPARAMSW = POINTER TO MSGBOXPARAMSA;

PROCEDURE MessageBoxIndirectA (VAR param : MSGBOXPARAMSA) : INTEGER;
PROCEDURE MessageBoxIndirectW (VAR param : MSGBOXPARAMSW) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      TYPE    MSGBOXPARAMS =  MSGBOXPARAMSW;
             PMSGBOXPARAMS = PMSGBOXPARAMSW;
      CONST  MessageBoxIndirect = MessageBoxIndirectW;
<* ELSE *>
      TYPE    MSGBOXPARAMS =  MSGBOXPARAMSA;
             PMSGBOXPARAMS = PMSGBOXPARAMSA;
      CONST  MessageBoxIndirect = MessageBoxIndirectA;
<* END *>


PROCEDURE MessageBeep (Type : MB_SET) : BOOL;

 (* MB_ICONASTERISK, MB_ICONEXCLAMATION, MB_ICONHAND,
    MB_ICONQUESTION, MB_OK, MB_SPEAKER allowed
 *)

CONST MB_SPEAKER = - MB_SET {};


PROCEDURE ShowCursor (Show : BOOL) : INTEGER;
PROCEDURE SetCursorPos (X, Y : INTEGER) : BOOL;
PROCEDURE SetCursor (Cursor : HCURSOR) : HCURSOR;
PROCEDURE GetCursorPos (VAR Point : POINT) : BOOL;
PROCEDURE ClipCursor (Rect : PRECT (* IN NIL *)) : BOOL;
PROCEDURE GetClipCursor (VAR Rect : RECT) : BOOL;
PROCEDURE GetCursor () : HCURSOR;

PROCEDURE CreateCaret (hWnd : HWND; Bitmap : HBITMAP;
                       Width, Height : INTEGER) : BOOL;
PROCEDURE GetCaretBlinkTime() : UINT;
PROCEDURE SetCaretBlinkTime(MSeconds : UINT) : BOOL;
PROCEDURE DestroyCaret () : BOOL;
PROCEDURE HideCaret (Hwnd : HWND) : BOOL;
PROCEDURE ShowCaret (Hwnd : HWND) : BOOL;
PROCEDURE SetCaretPos (X, Y : INTEGER) : BOOL;
PROCEDURE GetCaretPos (VAR Point : POINT) : BOOL;

PROCEDURE ClientToScreen (hWnd : HWND; VAR Point : POINT) : BOOL;
PROCEDURE ScreenToClient (hWnd : HWND; VAR Point : POINT) : BOOL;
PROCEDURE MapWindowPoints (From, To : HWND;
                           VAR Points : ARRAY OF POINT;
                           NPoints : UINT) : INTEGER;

(* These two procedures had parameter of structure type POINT which is passed
   by value. It had to be implemented in RTL.
*)

<* IF BACKEND # "C" THEN *>
PROCEDURE rtlWindowFromPoint (pt : POINT) : HWND;
CONST WindowFromPoint = rtlWindowFromPoint;
<* ELSE *>
PROCEDURE WindowFromPoint (pt : POINT) : HWND;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE rtlChildWindowFromPoint (Parent: HWND; pt : POINT) : HWND;
CONST ChildWindowFromPoint = rtlChildWindowFromPoint;
<* ELSE *>
PROCEDURE ChildWindowFromPoint (Parent: HWND; pt : POINT) : HWND;
<* END *>

TYPE CWP_ENUM = (CWP__SKIPINVISIBLE,    (* 0 *)
                 CWP__SKIPDISABLED,     (* 1 *)
                 CWP__SKIPTRANSPARENT); (* 2 *)
     CWP_SET = SET OF CWP_ENUM;

CONST CWP_ALL             = CWP_SET {};                     (* 0x0000 *)
      CWP_SKIPINVISIBLE   = CWP_SET {CWP__SKIPINVISIBLE};   (* 0x0001 *)
      CWP_SKIPDISABLED    = CWP_SET {CWP__SKIPDISABLED};    (* 0x0002 *)
      CWP_SKIPTRANSPARENT = CWP_SET {CWP__SKIPTRANSPARENT}; (* 0x0004 *)

(* ChildWindowFromPointEx had parameter of structure type POINT which is passed
   by value. It had to be implemented in RTL. *)

<* IF BACKEND # "C" THEN *>
PROCEDURE rtlChildWindowFromPointEx (Parent  : HWND; pt : POINT; flags : CWP_SET) : HWND;
CONST ChildWindowFromPointEx = rtlChildWindowFromPointEx;
<* ELSE *>
PROCEDURE ChildWindowFromPointEx (Parent  : HWND; pt : POINT; flags : CWP_SET) : HWND;
<* END *>

TYPE CTLCOLOR_ENUM = (CTLCOLOR_MSGBOX,        (* 0 *)
                      CTLCOLOR_EDIT,          (* 1 *)
                      CTLCOLOR_LISTBOX,       (* 2 *)
                      CTLCOLOR_BTN,           (* 3 *)
                      CTLCOLOR_DLG,           (* 4 *)
                      CTLCOLOR_SCROLLBAR,     (* 5 *)
                      CTLCOLOR_STATIC,        (* 6 *)
                      CTLCOLOR_MAX);          (* 7 *)

TYPE COLOR_TYPE = (COLOR_SCROLLBAR,           (*  0 *)
                   COLOR_BACKGROUND,          (*  1 *)
                   COLOR_ACTIVECAPTION,       (*  2 *)
                   COLOR_INACTIVECAPTION,     (*  3 *)
                   COLOR_MENU,                (*  4 *)
                   COLOR_WINDOW,              (*  5 *)
                   COLOR_WINDOWFRAME,         (*  6 *)
                   COLOR_MENUTEXT,            (*  7 *)
                   COLOR_WINDOWTEXT,          (*  8 *)
                   COLOR_CAPTIONTEXT,         (*  9 *)
                   COLOR_ACTIVEBORDER,        (* 10 *)
                   COLOR_INACTIVEBORDER,      (* 11 *)
                   COLOR_APPWORKSPACE,        (* 12 *)
                   COLOR_HIGHLIGHT,           (* 13 *)
                   COLOR_HIGHLIGHTTEXT,       (* 14 *)
                   COLOR_BTNFACE,             (* 15 *)
                   COLOR_BTNSHADOW,           (* 16 *)
                   COLOR_GRAYTEXT,            (* 17 *)
                   COLOR_BTNTEXT,             (* 18 *)
                   COLOR_INACTIVECAPTIONTEXT, (* 19 *)
                   COLOR_BTNHIGHLIGHT,        (* 20 *)
                   COLOR_3DDKSHADOW,          (* 21 *)
                   COLOR_3DLIGHT,             (* 22 *)
                   COLOR_INFOTEXT,            (* 23 *)
                   COLOR_INFOBK               (* 24 *)
     );

CONST COLOR_DESKTOP     = COLOR_BACKGROUND;
      COLOR_3DFACE      = COLOR_BTNFACE;
      COLOR_3DSHADOW    = COLOR_BTNSHADOW;
      COLOR_3DHIGHLIGHT = COLOR_BTNHIGHLIGHT;
      COLOR_3DHILIGHT   = COLOR_BTNHIGHLIGHT;
      COLOR_BTNHILIGHT  = COLOR_BTNHIGHLIGHT;

PROCEDURE GetSysColor (Index : COLOR_TYPE) : COLORREF;
PROCEDURE GetSysColorBrush (Index : COLOR_TYPE) : HBRUSH;

PROCEDURE SetSysColors (NElements : INTEGER;
                        Elements  : ARRAY OF COLOR_TYPE;
                        RgbValues : ARRAY OF COLORREF) : BOOL;

<* IF BACKEND # "C" THEN *>
PROCEDURE DrawFocusRect (hDC : HDC; Rect : RECT (*!*)) : BOOL;
<* ELSE *>
PROCEDURE DrawFocusRect (hDC : HDC; Rect : PRECT (*!*)) : BOOL;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE FillRect      (hDC : HDC; Rect : RECT (*!*); Brush : HBRUSH) : BOOL;
<* ELSE *>
PROCEDURE FillRect      (hDC : HDC; Rect : PRECT (*!*); Brush : HBRUSH) : BOOL;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE FrameRect     (hDC : HDC; Rect : RECT (*!*); Brush : HBRUSH) : BOOL;
<* ELSE *>
PROCEDURE FrameRect     (hDC : HDC; Rect : PRECT (*!*); Brush : HBRUSH) : BOOL;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE InvertRect    (hDC : HDC; Rect : RECT (*!*)) : BOOL;
<* ELSE *>
PROCEDURE InvertRect    (hDC : HDC; Rect : PRECT (*!*)) : BOOL;
<* END *>
PROCEDURE SetRect       (VAR Rect : RECT; Left, Top, Right, Bottom : INTEGER) : BOOL;
PROCEDURE SetRectEmpty  (VAR Dst  : RECT) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE CopyRect      (VAR Dst  : RECT; Src : RECT (*!*)) : BOOL;
<* ELSE *>
PROCEDURE CopyRect      (VAR Dst  : RECT; Src : PRECT (*!*)) : BOOL;
<* END *>
PROCEDURE InflateRect   (VAR Rect : RECT; dx, dy : INTEGER) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE IntersectRect (VAR Dst  : RECT; Src1, Src2 : RECT (*!*)) : BOOL;
<* ELSE *>
PROCEDURE IntersectRect (VAR Dst  : RECT; Src1, Src2 : PRECT (*!*)) : BOOL;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE UnionRect     (VAR Dst  : RECT; Src1, Src2 : RECT (*!*)) : BOOL;
<* ELSE *>
PROCEDURE UnionRect     (VAR Dst  : RECT; Src1, Src2 : PRECT (*!*)) : BOOL;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE SubtractRect  (VAR Dst  : RECT; Src1, Src2 : RECT (*!*)) : BOOL;
<* ELSE *>
PROCEDURE SubtractRect  (VAR Dst  : RECT; Src1, Src2 : PRECT (*!*)) : BOOL;
<* END *>
PROCEDURE OffsetRect (VAR Dst : RECT; dx, dy : INTEGER) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE IsRectEmpty (Rect : RECT (*!*)) : BOOL;
<* ELSE *>
PROCEDURE IsRectEmpty (Rect : PRECT (*!*)) : BOOL;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE EqualRect (Rect1, Rect2 : RECT (*!*)) : BOOL;
<* ELSE *>
PROCEDURE EqualRect (Rect1, Rect2 : PRECT (*!*)) : BOOL;
<* END *>

(* PtInRect had parameter of structure type POINT which is passed
   by value. It had to be implemented in RTL.
*)

<* IF BACKEND # "C" THEN *>
PROCEDURE rtlPtInRect (Rect : RECT; pt : POINT) : BOOL;
CONST PtInRect = rtlPtInRect;
<* ELSE *>
PROCEDURE PtInRect (Rect : PRECT; pt : POINT) : BOOL;
<* END *>

PROCEDURE GetWindowWord (hWnd : HWND; Index : INTEGER) : WORD;
PROCEDURE SetWindowWord (hWnd : HWND; Index : INTEGER; NewWord : WORD) : WORD;

PROCEDURE GetWindowLongA (hWnd : HWND; Index : INTEGER) : DWORD;
PROCEDURE GetWindowLongW (hWnd : HWND; Index : INTEGER) : DWORD;

(* These two in RTL; included specially for Modula-2 *)
PROCEDURE GetWindowPtrA (hWnd : HWND; Index : INTEGER) : SYSTEM.ADDRESS;
PROCEDURE GetWindowPtrW (hWnd : HWND; Index : INTEGER) : SYSTEM.ADDRESS;

PROCEDURE SetWindowLongA (hWnd : HWND; Index : INTEGER; NewLong : DWORD) : DWORD;
PROCEDURE SetWindowLongW (hWnd : HWND; Index : INTEGER; NewLong : DWORD) : DWORD;

(* These two in RTL; included specially for Modula-2 *)
PROCEDURE SetWindowPtrA (hWnd : HWND; Index : INTEGER; NewLong : SYSTEM.ADDRESS) : SYSTEM.ADDRESS;
PROCEDURE SetWindowPtrW (hWnd : HWND; Index : INTEGER; NewLong : SYSTEM.ADDRESS) : SYSTEM.ADDRESS;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetWindowLong = SetWindowLongW;
            GetWindowLong = GetWindowLongW;
            SetWindowPtr  = SetWindowPtrW;
            GetWindowPtr  = GetWindowPtrW;
<* ELSE *>
      CONST SetWindowLong = SetWindowLongA;
            GetWindowLong = GetWindowLongA;
            SetWindowPtr  = SetWindowPtrA;
            GetWindowPtr  = GetWindowPtrA;
<* END *>

PROCEDURE GetClassWord  (hWnd : HWND; Index : INTEGER) : WORD;
PROCEDURE SetClassWord  (hWnd : HWND; Index : INTEGER; NewWord : WORD) : WORD;
PROCEDURE GetClassLongA (hWnd : HWND; Index : INTEGER) : DWORD;
PROCEDURE GetClassLongW (hWnd : HWND; Index : INTEGER) : DWORD;
PROCEDURE SetClassLongA (hWnd : HWND; Index : INTEGER; NewLong : DWORD) : DWORD;
PROCEDURE SetClassLongW (hWnd : HWND; Index : INTEGER; NewLong : DWORD) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetClassLong = GetClassLongW;
            SetClassLong = SetClassLongW;
<* ELSE *>
      CONST GetClassLong = GetClassLongA;
            SetClassLong = SetClassLongA;
<* END *>

PROCEDURE GetDesktopWindow () : HWND;
PROCEDURE GetParent (hWnd : HWND) : HWND;
PROCEDURE SetParent (hWndChild : HWND; hWndNewParent : HWND) : HWND;


PROCEDURE EnumChildWindows (Parent : HWND; EnumProc : WNDENUMPROC;
                            lParam : LPARAM) : BOOL;

PROCEDURE FindWindowA (ClassName : ATOMSTR;  WindowName : PCSTR  (* NIL *)) : HWND;
PROCEDURE FindWindowW (ClassName : ATOMWSTR; WindowName : PCWSTR (* NIL *)) : HWND;

<* IF DEFINED (UNICODE) THEN *>
      CONST FindWindow = FindWindowW;
<* ELSE *>
      CONST FindWindow = FindWindowA;
<* END *>

PROCEDURE FindWindowExA (parent : HWND; ChildAfter : HWND;
                         Class : ATOMSTR; WindowName : PCSTR (* NIL *)) : HWND;

PROCEDURE FindWindowExW (parent : HWND; ChildAfter : HWND;
                         Class : ATOMWSTR; WindowName : PCSTR (* NIL *)) : HWND;

<* IF DEFINED (UNICODE) THEN *>
      CONST FindWindowEx = FindWindowExW;
<* ELSE *>
      CONST FindWindowEx = FindWindowExA;
<* END *>

PROCEDURE EnumWindows (EnumProc : WNDENUMPROC; lParam : LPARAM) : BOOL;
PROCEDURE EnumThreadWindows (ThreadId : DWORD; EnumProc : WNDENUMPROC;
                             lParam : LPARAM) : BOOL;

PROCEDURE GetClassNameA (hWnd : HWND; VAR ClassName : ARRAY OF CHAR;
                         MaxCount : INTEGER) : INTEGER;
PROCEDURE GetClassNameW (hWnd : HWND; VAR ClassName : ARRAY OF WCHAR;
                         MaxCount : INTEGER) : INTEGER;
<* IF DEFINED (UNICODE) THEN *>
      CONST GetClassName = GetClassNameW;
<* ELSE *>
      CONST GetClassName = GetClassNameA;
<* END *>

PROCEDURE GetTopWindow (hWnd : HWND) : HWND;
PROCEDURE GetWindowThreadProcessId (hWnd : HWND;
                                    VAR [NIL] ProcessId : DWORD) : DWORD;

PROCEDURE GetLastActivePopup (hWnd : HWND) : HWND;

(* GetWindow() Constants *)

TYPE GW_ENUM = (GW_HWNDFIRST, (* 0 *)
                GW_HWNDLAST,  (* 1 *)
                GW_HWNDNEXT,  (* 2 *)
                GW_HWNDPREV,  (* 3 *)
                GW_OWNER,     (* 4 *)
                GW_CHILD);    (* 5 *)

CONST GW_MAX = GW_CHILD;

PROCEDURE GetWindow     (hWnd : HWND; Cmd : GW_ENUM) : HWND;
(*
PROCEDURE GetNextWindow (hWnd : HWND; Cmd : GW_ENUM) : HWND;
*)
CONST GetNextWindow = GetWindow;

PROCEDURE SetWindowsHookA (FilterType : INTEGER; pfnFilterProc : HOOKPROC) : HHOOK;
PROCEDURE SetWindowsHookW (FilterType : INTEGER; pfnFilterProc : HOOKPROC) : HHOOK;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetWindowsHook = SetWindowsHookW;
<* ELSE *>
      CONST SetWindowsHook = SetWindowsHookA;
<* END *>

PROCEDURE UnhookWindowsHook (Code : INTEGER; pfnFilterProc : HOOKPROC) : BOOL;

PROCEDURE SetWindowsHookExA (idHook     : INTEGER;
                             lpfn       : HOOKPROC;
                             hmod       : HINSTANCE;
                             dwThreadId : DWORD) : HHOOK;

PROCEDURE SetWindowsHookExW (idHook     : INTEGER;
                             lpfn       : HOOKPROC;
                             hmod       : HINSTANCE;
                             dwThreadId : DWORD) : HHOOK;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetWindowsHookEx = SetWindowsHookExW;
<* ELSE *>
      CONST SetWindowsHookEx = SetWindowsHookExA;
<* END *>

PROCEDURE UnhookWindowsHookEx (hhk : HHOOK) : BOOL;
PROCEDURE CallNextHookEx (hhk    : HHOOK;
                          Code   : INTEGER;
                          wParam : WPARAM;
                          lParam : LPARAM) : LRESULT;

PROCEDURE CheckMenuRadioItem (hmenu   : HMENU;
                              idFirst : UINT;
                              idLast  : UINT;
                              idCheck : UINT;
                              flags : MF_SET) : BOOL;

(* Menu item resource format *)

TYPE MENUITEMTEMPLATEHEADER = RECORD
                                     versionNumber : WORD;
                                     offset : WORD;
                              END;

TYPE MENUITEMTEMPLATE = RECORD
                               mtOption : WORD;
                               mtID     : WORD;
                               mtString : ARRAY [0..0] OF WCHAR;
                        END;

(*
 * System Menu Command Values
 *)

CONST SC_SIZE         = 0F000h;
      SC_MOVE         = 0F010h;
      SC_MINIMIZE     = 0F020h;
      SC_MAXIMIZE     = 0F030h;
      SC_NEXTWINDOW   = 0F040h;
      SC_PREVWINDOW   = 0F050h;
      SC_CLOSE        = 0F060h;
      SC_VSCROLL      = 0F070h;
      SC_HSCROLL      = 0F080h;
      SC_MOUSEMENU    = 0F090h;
      SC_KEYMENU      = 0F100h;
      SC_ARRANGE      = 0F110h;
      SC_RESTORE      = 0F120h;
      SC_TASKLIST     = 0F130h;
      SC_SCREENSAVE   = 0F140h;
      SC_HOTKEY       = 0F150h;
      SC_DEFAULT      = 0F160h;
      SC_MONITORPOWER = 0F170h;
      SC_CONTEXTHELP  = 0F180h;
      SC_SEPARATOR    = 0F00Fh;
(*
 * Obsolete names
 *)
      SC_ICON         = SC_MINIMIZE;
      SC_ZOOM         = SC_MAXIMIZE;

(*
 * Resource Loading Routines
 *)

PROCEDURE LoadBitmapA (hInstance : HINSTANCE; BitmapName : RESOURCESTRA)  : HBITMAP;
PROCEDURE LoadBitmapW (hInstance : HINSTANCE; BitmapName : RESOURCESTRW) : HBITMAP;

PROCEDURE LoadCursorA (hInstance : HINSTANCE; CursorName : RESOURCESTRA)  : HCURSOR;
PROCEDURE LoadCursorW (hInstance : HINSTANCE; CursorName : RESOURCESTRW) : HCURSOR;

PROCEDURE LoadCursorFromFileA (FileName : ARRAY OF CHAR)  : HCURSOR;
PROCEDURE LoadCursorFromFileW (FileName : ARRAY OF WCHAR) : HCURSOR;

<* IF DEFINED (UNICODE) THEN *>
      CONST LoadBitmap         = LoadBitmapW;
            LoadCursor         = LoadCursorW;
            LoadCursorFromFile = LoadCursorFromFileW;
<* ELSE *>
      CONST LoadBitmap         = LoadBitmapA;
            LoadCursor         = LoadCursorA;
            LoadCursorFromFile = LoadCursorFromFileA;
<* END *>

PROCEDURE CreateCursor (hInst : HINSTANCE;
                        xHotSpot, yHotSpot,
                        Width, Height : INTEGER;
                        ANDPlane : PBYTE;
                        XORPlane : PBYTE) : HCURSOR;

PROCEDURE DestroyCursor (hCursor : HCURSOR) : BOOL;

(* defined in RTL *)

PROCEDURE CopyCursor (hCursor : HCURSOR) : HCURSOR;

(* Standard Cursor IDs *)

CONST IDC_ARROW       = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32512));
      IDC_IBEAM       = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32513));
      IDC_WAIT        = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32514));
      IDC_CROSS       = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32515));
      IDC_UPARROW     = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32516));
      IDC_SIZE        = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32640)); (* OBSOLETE: use IDC_SIZEALL *)
      IDC_ICON        = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32641)); (* OBSOLETE: use IDC_ARROW *)
      IDC_SIZENWSE    = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32642));
      IDC_SIZENESW    = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32643));
      IDC_SIZEWE      = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32644));
      IDC_SIZENS      = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32645));
      IDC_SIZEALL     = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32646));
      IDC_NO          = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32648));
      IDC_HAND        = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32649));
      IDC_APPSTARTING = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32650));
      IDC_HELP        = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32651));

PROCEDURE SetSystemCursor (hcur : HCURSOR; id : DWORD) : BOOL;

TYPE ICONINFO = RECORD
                      fIcon : BOOL;
                      xHotspot,
                      yHotspot : DWORD;
                      Mask,
                      Color : HBITMAP;
                END;
    PICONINFO = ICONINFO;

PROCEDURE LoadIconA (hInstance : HINSTANCE; IconName : RESOURCESTRA) : HICON;
PROCEDURE LoadIconW (hInstance : HINSTANCE; IconName : RESOURCESTRW) : HICON;

<* IF DEFINED (UNICODE) THEN *>
      CONST LoadIcon = LoadIconW;
<* ELSE *>
      CONST LoadIcon = LoadIconA;
<* END *>

PROCEDURE CreateIcon (hInstance : HINSTANCE; Width, Height : INTEGER;
                      Planes, BitsPixel : BYTE;
                      ANDbits : ARRAY OF SYSTEM.BYTE;
                      XORbits : ARRAY OF SYSTEM.BYTE) : HICON;

PROCEDURE DestroyIcon (hIcon : HICON) : BOOL;

PROCEDURE LookupIconIdFromDirectory   (presbits : PBYTE; fIcon : BOOL) : INTEGER;

TYPE LR_ENUM = (LR__MONOCHROME,       (*  0 *)
                LR__COLOR,            (*  1 *)
                LR__COPYRETURNORG,    (*  2 *)
                LR__COPYDELETEORG,    (*  3 *)
                LR__LOADFROMFILE,     (*  4 *)
                LR__LOADTRANSPARENT,  (*  5 *)
                LR__DEFAULTSIZE,      (*  6 *)
                LR__VGACOLOR,
                LR__8, LR__9,
                LR__10, LR__11,
                LR__LOADMAP3DCOLORS,  (* 12 *)
                LR__CREATEDIBSECTION, (* 13 *)
                LR__COPYFROMRESOURCE, (* 14 *)
                LR__SHARED);          (* 15 *)

     LR_SET = SET OF LR_ENUM;

CONST LR_DEFAULTCOLOR     = LR_SET {};                      (* 0x0000 *)
      LR_MONOCHROME       = LR_SET {LR__MONOCHROME       }; (* 0x0001 *)
      LR_COLOR            = LR_SET {LR__COLOR            }; (* 0x0002 *)
      LR_COPYRETURNORG    = LR_SET {LR__COPYRETURNORG    }; (* 0x0004 *)
      LR_COPYDELETEORG    = LR_SET {LR__COPYDELETEORG    }; (* 0x0008 *)
      LR_LOADFROMFILE     = LR_SET {LR__LOADFROMFILE     }; (* 0x0010 *)
      LR_LOADTRANSPARENT  = LR_SET {LR__LOADTRANSPARENT  }; (* 0x0020 *)
      LR_DEFAULTSIZE      = LR_SET {LR__DEFAULTSIZE      }; (* 0x0040 *)
      LR_VGACOLOR         = LR_SET {LR__VGACOLOR         }; (* 0x0080 *)
      LR_LOADMAP3DCOLORS  = LR_SET {LR__LOADMAP3DCOLORS  }; (* 0x1000 *)
      LR_CREATEDIBSECTION = LR_SET {LR__CREATEDIBSECTION }; (* 0x2000 *)
      LR_COPYFROMRESOURCE = LR_SET {LR__COPYFROMRESOURCE }; (* 0x4000 *)
      LR_SHARED           = LR_SET {LR__SHARED           }; (* 0x8000 *)


PROCEDURE LookupIconIdFromDirectoryEx (presbits : PBYTE; fIcon : BOOL;
                                       cxDesired, cyDesired : INTEGER;
                                       Flags : LR_SET) : INTEGER;
PROCEDURE CreateIconFromResource (presbits : PBYTE; ResSize : DWORD;
                                  fIcon : BOOL; Ver : DWORD) : HICON;
PROCEDURE CreateIconFromResourceEx (presbits : PBYTE; ResSize : DWORD;
                                    fIcon : BOOL; Ver : DWORD;
                                    cxDesired, cyDesired : INTEGER;
                                    Flags : LR_SET) : HICON;

(* Icon/Cursor header *)

TYPE CURSORSHAPE = RECORD
                          xHotSpot  : INTEGER;
                          yHotSpot  : INTEGER;
                          cx        : INTEGER;
                          cy        : INTEGER;
                          cbWidth   : INTEGER;
                          Planes    : BYTE;
                          BitsPixel : BYTE;
                   END;
    PCURSORSHAPE = POINTER TO CURSORSHAPE;

TYPE IMAGE_TYPE = (IMAGE_BITMAP,       (* 0 *)
                   IMAGE_ICON,         (* 1 *)
                   IMAGE_CURSOR,       (* 2 *)
                   IMAGE_ENHMETAFILE); (* 3 *)

PROCEDURE LoadImageA (instance  : HINSTANCE;
                      name      : RESOURCESTRA;
                      type      : IMAGE_TYPE;
                      cxDesired,
                      cyDesired : INTEGER;
                      flags     : LR_SET) : HANDLE;

PROCEDURE LoadImageW (instance  : HINSTANCE;
                      name      : RESOURCESTRW;
                      type      : IMAGE_TYPE;
                      cxDesired,
                      cyDesired : INTEGER;
                      flags     : LR_SET) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST LoadImage = LoadImageW;
<* ELSE *>
      CONST LoadImage = LoadImageA;
<* END *>

PROCEDURE CopyImage (hImage : HANDLE;
                     type   : IMAGE_TYPE;
                     cxDesired,
                     cyDesired : INTEGER;
                     flags     : LR_SET) : HANDLE;

TYPE DI_ENUM = (DI__MASK,         (* 0 *)
                DI__IMAGE,        (* 1 *)
                DI__COMPAT,       (* 2 *)
                DI__DEFAULTSIZE); (* 3 *)
     DI_SET = SET OF DI_ENUM;

CONST DI_MASK        = DI_SET {DI__MASK};        (* 0x0001 *)
      DI_IMAGE       = DI_SET {DI__IMAGE};       (* 0x0002 *)
      DI_COMPAT      = DI_SET {DI__COMPAT};      (* 0x0004 *)
      DI_DEFAULTSIZE = DI_SET {DI__DEFAULTSIZE}; (* 0x0008 *)

      DI_NORMAL      = DI_MASK + DI_IMAGE;

PROCEDURE DrawIconEx (hDC                : HDC;
                      x, y               : INTEGER;
                      hIcon              : HICON;
                      cx, cy             : INTEGER;
                      istepIfAniCur      : UINT;
                      hbrFlickerFreeDraw : HBRUSH;
                      diFlags            : DI_SET) : BOOL;


<* IF BACKEND # "C" THEN *>
PROCEDURE CreateIconIndirect (iconinfo : ICONINFO (*!*)) : HICON;
<* ELSE *>
PROCEDURE CreateIconIndirect (iconinfo : PICONINFO (*!*)) : HICON;
<* END *>
PROCEDURE CopyIcon           (hIcon : HICON) : HICON;
PROCEDURE GetIconInfo        (hIcon : HICON; VAR iconinfo : ICONINFO) : BOOL;

CONST RES_ICON    = 1;
      RES_CURSOR  = 2;

(* OEM Resource Ordinal Numbers *)

CONST OBM_CLOSE         =  32754;
      OBM_UPARROW       =  32753;
      OBM_DNARROW       =  32752;
      OBM_RGARROW       =  32751;
      OBM_LFARROW       =  32750;
      OBM_REDUCE        =  32749;
      OBM_ZOOM          =  32748;
      OBM_RESTORE       =  32747;
      OBM_REDUCED       =  32746;
      OBM_ZOOMD         =  32745;
      OBM_RESTORED      =  32744;
      OBM_UPARROWD      =  32743;
      OBM_DNARROWD      =  32742;
      OBM_RGARROWD      =  32741;
      OBM_LFARROWD      =  32740;
      OBM_MNARROW       =  32739;
      OBM_COMBO         =  32738;
      OBM_UPARROWI      =  32737;
      OBM_DNARROWI      =  32736;
      OBM_RGARROWI      =  32735;
      OBM_LFARROWI      =  32734;

      OBM_OLD_CLOSE     =  32767;
      OBM_SIZE          =  32766;
      OBM_OLD_UPARROW   =  32765;
      OBM_OLD_DNARROW   =  32764;
      OBM_OLD_RGARROW   =  32763;
      OBM_OLD_LFARROW   =  32762;
      OBM_BTSIZE        =  32761;
      OBM_CHECK         =  32760;
      OBM_CHECKBOXES    =  32759;
      OBM_BTNCORNERS    =  32758;
      OBM_OLD_REDUCE    =  32757;
      OBM_OLD_ZOOM      =  32756;
      OBM_OLD_RESTORE   =  32755;

      OCR_NORMAL        =  32512;
      OCR_IBEAM         =  32513;
      OCR_WAIT          =  32514;
      OCR_CROSS         =  32515;
      OCR_UP            =  32516;
      OCR_SIZE          =  32640;   (* OBSOLETE: use OCR_SIZEALL *)
      OCR_ICON          =  32641;   (* OBSOLETE: use OCR_NORMAL  *)
      OCR_SIZENWSE      =  32642;
      OCR_SIZENESW      =  32643;
      OCR_SIZEWE        =  32644;
      OCR_SIZENS        =  32645;
      OCR_SIZEALL       =  32646;
      OCR_ICOCUR        =  32647;
      OCR_NO            =  32648; (* not in win3.1 *)
      OCR_APPSTARTING   =  32650;

      OIC_SAMPLE        =  32512;
      OIC_HAND          =  32513;
      OIC_QUES          =  32514;
      OIC_BANG          =  32515;
      OIC_NOTE          =  32516;
      OIC_WINLOGO       =  32517;
      OIC_WARNING       =  OIC_BANG;
      OIC_ERROR         =  OIC_HAND;
      OIC_INFORMATION   =  OIC_NOTE;

CONST ORD_LANGDRIVER = 1;  (* The ordinal number for the entry point of
                           ** language drivers.
                           *)

(* Standard Icon IDs *)

CONST IDI_APPLICATION   = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32512));
      IDI_HAND          = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32513));
      IDI_QUESTION      = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32514));
      IDI_EXCLAMATION   = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32515));
      IDI_ASTERISK      = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32516));
      IDI_WINLOGO       = SYSTEM.CAST (RESOURCESTR, VAL (ULONG, 32517));
      IDI_WARNING       = IDI_EXCLAMATION;
      IDI_ERROR         = IDI_HAND;
      IDI_INFORMATION   = IDI_ASTERISK;

PROCEDURE LoadStringA (hInstance  : HINSTANCE;
                       uID        : UINT;
                       VAR Buffer : ARRAY OF CHAR;
                       nBufferMax : INTEGER) : INTEGER;

PROCEDURE LoadStringW (hInstance  : HINSTANCE;
                       uID        : UINT;
                       VAR Buffer : ARRAY OF WCHAR;
                       nBufferMax : INTEGER) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST LoadString = LoadStringW;
<* ELSE *>
      CONST LoadString = LoadStringA;
<* END *>


(* Dialog Box Command IDs *)

CONST IDOK      = 1;
      IDCANCEL  = 2;
      IDABORT   = 3;
      IDRETRY   = 4;
      IDIGNORE  = 5;
      IDYES     = 6;
      IDNO      = 7;
      IDCLOSE   = 8;
      IDHELP    = 9;


(*
 * Control Manager Structures and Definitions
 *)

(* Edit Control Styles *)

CONST ES_LEFT             = WS_SET { };       (* 0x0000L *)
      ES_CENTER           = WS_SET {WS__0};   (* 0x0001L *)
      ES_RIGHT            = WS_SET {WS__1};   (* 0x0002L *)
      ES_MULTILINE        = WS_SET {WS__2};   (* 0x0004L *)
      ES_UPPERCASE        = WS_SET {WS__3};   (* 0x0008L *)
      ES_LOWERCASE        = WS_SET {WS__4};   (* 0x0010L *)
      ES_PASSWORD         = WS_SET {WS__5};   (* 0x0020L *)
      ES_AUTOVSCROLL      = WS_SET {WS__6};   (* 0x0040L *)
      ES_AUTOHSCROLL      = WS_SET {WS__7};   (* 0x0080L *)
      ES_NOHIDESEL        = WS_SET {WS__8};   (* 0x0100L *)
      ES_OEMCONVERT       = WS_SET {WS__10};  (* 0x0400L *)
      ES_READONLY         = WS_SET {WS__11};  (* 0x0800L *)
      ES_WANTRETURN       = WS_SET {WS__12};  (* 0x1000L *)
      ES_NUMBER           = WS_SET {WS__13};  (* 0x2000L *)

(* Edit Control Notification Codes *)

CONST EN_SETFOCUS         = 0100h;
      EN_KILLFOCUS        = 0200h;
      EN_CHANGE           = 0300h;
      EN_UPDATE           = 0400h;
      EN_ERRSPACE         = 0500h;
      EN_MAXTEXT          = 0501h;
      EN_HSCROLL          = 0601h;
      EN_VSCROLL          = 0602h;

(* Edit control EM_SETMARGIN parameters *)

CONST EC_LEFTMARGIN       = 00001h;
      EC_RIGHTMARGIN      = 00002h;
      EC_USEFONTINFO      = 0ffffh;

(*
 * Edit Control Messages
 *)

CONST EM_GETSEL               = 00B0h;
      EM_SETSEL               = 00B1h;
      EM_GETRECT              = 00B2h;
      EM_SETRECT              = 00B3h;
      EM_SETRECTNP            = 00B4h;
      EM_SCROLL               = 00B5h;
      EM_LINESCROLL           = 00B6h;
      EM_SCROLLCARET          = 00B7h;
      EM_GETMODIFY            = 00B8h;
      EM_SETMODIFY            = 00B9h;
      EM_GETLINECOUNT         = 00BAh;
      EM_LINEINDEX            = 00BBh;
      EM_SETHANDLE            = 00BCh;
      EM_GETHANDLE            = 00BDh;
      EM_GETTHUMB             = 00BEh;
      EM_LINELENGTH           = 00C1h;
      EM_REPLACESEL           = 00C2h;
      EM_GETLINE              = 00C4h;
      EM_LIMITTEXT            = 00C5h;
      EM_CANUNDO              = 00C6h;
      EM_UNDO                 = 00C7h;
      EM_FMTLINES             = 00C8h;
      EM_LINEFROMCHAR         = 00C9h;
      EM_SETTABSTOPS          = 00CBh;
      EM_SETPASSWORDCHAR      = 00CCh;
      EM_EMPTYUNDOBUFFER      = 00CDh;
      EM_GETFIRSTVISIBLELINE  = 00CEh;
      EM_SETREADONLY          = 00CFh;
      EM_SETWORDBREAKPROC     = 00D0h;
      EM_GETWORDBREAKPROC     = 00D1h;
      EM_GETPASSWORDCHAR      = 00D2h;
      EM_SETMARGINS           = 00D3h;
      EM_GETMARGINS           = 00D4h;
      EM_SETLIMITTEXT         = EM_LIMITTEXT; (* win40 Name change *)
      EM_GETLIMITTEXT         = 00D5h;
      EM_POSFROMCHAR          = 00D6h;
      EM_CHARFROMPOS          = 00D7h;

(* EM_SETWORDBREAKPROC sends in LPARAM and EM_GETWORDBREAKPROC returns as
   LRESULT pointer to WORDBREAKPROC
*)

(* WB_ constants defined earlier near EDITWORDBREAKPROC *)

(* Button Control Styles *)

CONST BS_PUSHBUTTON      = WS_SET {                       };  (* 0x00L *)
      BS_DEFPUSHBUTTON   = WS_SET {                  WS__0};  (* 0x01L *)
      BS_CHECKBOX        = WS_SET {            WS__1      };  (* 0x02L *)
      BS_AUTOCHECKBOX    = WS_SET {            WS__1,WS__0};  (* 0x03L *)
      BS_RADIOBUTTON     = WS_SET {      WS__2            };  (* 0x04L *)
      BS_3STATE          = WS_SET {      WS__2,      WS__0};  (* 0x05L *)
      BS_AUTO3STATE      = WS_SET {      WS__2,WS__1      };  (* 0x06L *)
      BS_GROUPBOX        = WS_SET {      WS__2,WS__1,WS__0};  (* 0x07L *)
      BS_USERBUTTON      = WS_SET {WS__3                  };  (* 0x08L *)
      BS_AUTORADIOBUTTON = WS_SET {WS__3,            WS__0};  (* 0x09L *)
      BS_OWNERDRAW       = WS_SET {WS__3,      WS__1,WS__0};  (* 0x0BL *)
      BS_LEFTTEXT        = WS_SET {WS__5};                    (* 0x20L *)
      BS_TEXT            = WS_SET {};                         (* 0x00000000L *)
      BS_ICON            = WS_SET {WS__6};                    (* 0x00000040L *)
      BS_BITMAP          = WS_SET {WS__7};                    (* 0x00000080L *)
      BS_LEFT            = WS_SET {WS__8};                    (* 0x00000100L *)
      BS_RIGHT           = WS_SET {WS__9};                    (* 0x00000200L *)
      BS_CENTER          = WS_SET {WS__8, WS__9};             (* 0x00000300L *)
      BS_TOP             = WS_SET {WS__10};                   (* 0x00000400L *)
      BS_BOTTOM          = WS_SET {WS__11};                   (* 0x00000800L *)
      BS_VCENTER         = WS_SET {WS__22, WS__10};           (* 0x00000C00L *)
      BS_PUSHLIKE        = WS_SET {WS__12};                   (* 0x00001000L *)
      BS_MULTILINE       = WS_SET {WS__13};                   (* 0x00002000L *)
      BS_NOTIFY          = WS_SET {WS__14};                   (* 0x00004000L *)
      BS_FLAT            = WS_SET {WS__15};                   (* 0x00008000L *)
      BS_RIGHTBUTTON     = BS_LEFTTEXT;

(* User Button Notification Codes *)

CONST BN_CLICKED         = 0;
      BN_PAINT           = 1;
      BN_HILITE          = 2;
      BN_UNHILITE        = 3;
      BN_DISABLE         = 4;
      BN_DOUBLECLICKED   = 5;
      BN_PUSHED          = BN_HILITE;
      BN_UNPUSHED        = BN_UNHILITE;
      BN_DBLLCLK         = BN_DOUBLECLICKED;
      BN_SETFOCUS        = 6;
      BN_KILLFOCUS       = 7;


(*
 * Button Control Messages
 *)

CONST BM_GETCHECK        = 00F0h;
      BM_SETCHECK        = 00F1h;
      BM_GETSTATE        = 00F2h;
      BM_SETSTATE        = 00F3h;
      BM_SETSTYLE        = 00F4h;
      BM_CLICK           = 00F5h;
      BM_GETIMAGE        = 00F6h;
      BM_SETIMAGE        = 00F7h;

TYPE  BST_ENUM = (BST__CHECKED,       (* 0 *)
                  BST__INDETERMINATE, (* 1 *)
                  BST__PUSHED,        (* 2 *)
                  BST__FOCUS);        (* 3 *)
      BST_SET = SET OF BST_ENUM;

CONST BST_UNCHECKED      = BST_SET {};                   (* 0x0000 *)
      BST_CHECKED        = BST_SET {BST__CHECKED};       (* 0x0001 *)
      BST_INDETERMINATE  = BST_SET {BST__INDETERMINATE}; (* 0x0002 *)
      BST_PUSHED         = BST_SET {BST__PUSHED};        (* 0x0004 *)
      BST_FOCUS          = BST_SET {BST__FOCUS};         (* 0x0008 *)

(* Static Control Constants *)

CONST SS_LEFT           = WS_SET {                             }; (* 0x00000000L *)
      SS_CENTER         = WS_SET {                        WS__0}; (* 0x00000001L *)
      SS_RIGHT          = WS_SET {                  WS__1      }; (* 0x00000002L *)
      SS_ICON           = WS_SET {                  WS__1,WS__0}; (* 0x00000003L *)
      SS_BLACKRECT      = WS_SET {            WS__2            }; (* 0x00000004L *)
      SS_GRAYRECT       = WS_SET {            WS__2,      WS__0}; (* 0x00000005L *)
      SS_WHITERECT      = WS_SET {            WS__2,WS__1      }; (* 0x00000006L *)
      SS_BLACKFRAME     = WS_SET {            WS__2,WS__1,WS__0}; (* 0x00000007L *)
      SS_GRAYFRAME      = WS_SET {      WS__3                  }; (* 0x00000008L *)
      SS_WHITEFRAME     = WS_SET {      WS__3,            WS__0}; (* 0x00000009L *)
      SS_USERITEM       = WS_SET {      WS__3,      WS__1      }; (* 0x0000000AL *)
      SS_SIMPLE         = WS_SET {      WS__3,      WS__1,WS__0}; (* 0x0000000BL *)
      SS_LEFTNOWORDWRAP = WS_SET {      WS__3,WS__2            }; (* 0x0000000CL *)
      SS_OWNERDRAW      = WS_SET {      WS__3,WS__2,      WS__0}; (* 0x0000000DL *)
      SS_ENHMETAFILE    = WS_SET {      WS__3,WS__2,WS__1,WS__0}; (* 0x0000000FL *)
      SS_ETCHEDHORZ     = WS_SET {WS__4                        }; (* 0x00000010L *)
      SS_ETCHEDVERT     = WS_SET {WS__4,                  WS__0}; (* 0x00000011L *)
      SS_ETCHEDFRAME    = WS_SET {WS__4,            WS__1      }; (* 0x00000012L *)
      SS_TYPEMASK       = WS_SET {WS__4,WS__3,WS__2,WS__1,WS__0}; (* 0x0000001FL *)
      SS_NOPREFIX       = WS_SET {WS__7};                         (* 0x00000080L *)
      SS_NOTIFY         = WS_SET {WS__8};                         (* 0x00000100L *)
      SS_CENTERIMAGE    = WS_SET {WS__9};                         (* 0x00000200L *)
      SS_RIGHTJUST      = WS_SET {WS__10};                        (* 0x00000400L *)
      SS_REALSIZEIMAGE  = WS_SET {WS__11};                        (* 0x00000800L *)
      SS_SUNKEN         = WS_SET {WS__12};                        (* 0x00001000L *)
      SS_ENDELLIPSIS    = WS_SET {WS__14};                        (* 0x00004000L *)
      SS_PATHELLIPSIS   = WS_SET {WS__15};                        (* 0x00008000L *)
      SS_WORDELLIPSIS   = WS_SET {WS__15,WS__14};                 (* 0x0000C000L *)
      SS_ELLIPSISMASK   = WS_SET {WS__15,WS__14};                 (* 0x0000C000L *)

(*
 * Static Control Mesages
 *)

CONST STM_SETICON        = 0170h;
      STM_GETICON        = 0171h;
      STM_SETIMAGE       = 0172h;
      STM_GETIMAGE       = 0173h;
      STM_MSGMAX         = 0174h;

(*
 * Static Control Notifications
 *)

CONST STN_CLICKED        = 0;
      STN_DBLCLK         = 1;
      STN_ENABLE         = 2;
      STN_DISABLE        = 3;

(* Dialog window class *)

CONST  WC_DIALOG = SYSTEM.CAST (ATOMSTR, VAL (DWORD, 8002h));

(* Get/SetWindowWord/Long offsets for use with WC_DIALOG windows *)

CONST DWL_MSGRESULT = 0;
      DWL_DLGPROC   = 4;
      DWL_USER      = 8;

(* Dialog Manager Routines *)

PROCEDURE IsDialogMessageA (hDlg : HWND; VAR Msg : MSG) : BOOL;
PROCEDURE IsDialogMessageW (hDlg : HWND; VAR Msg : MSG) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST IsDialogMessage = IsDialogMessageW;
<* ELSE *>
      CONST IsDialogMessage = IsDialogMessageA;
<* END *>

PROCEDURE MapDialogRect (hDlg : HWND; VAR Rect : RECT) : BOOL;


(* DlgDirList, DlgDirListComboBox flags values *)

TYPE DDL_ENUM = (DDL__READONLY,   (* 0 *)
                 DDL__HIDDEN,     (* 1 *)
                 DDL__SYSTEM,     (* 2 *)
                 DDL__3,
                 DDL__DIRECTORY,  (* 4 *)
                 DDL__ARCHIVE,    (* 5 *)
                 DDL__6,  DDL__7,  DDL__8, DDL__9,
                 DDL__10, DDL__11, DDL__12,
                 DDL__POSTMSGS,   (* 13 *)
                 DDL__DRIVES,     (* 14 *)
                 DDL__EXCLUSIVE); (* 15 *)
      DDL_SET = SET OF DDL_ENUM;

CONST DDL_READWRITE       = DDL_SET { };                (* 0x0000 *)
      DDL_READONLY        = DDL_SET {DDL__READONLY};    (* 0x0001 *)
      DDL_HIDDEN          = DDL_SET {DDL__HIDDEN};      (* 0x0002 *)
      DDL_SYSTEM          = DDL_SET {DDL__SYSTEM};      (* 0x0004 *)
      DDL_DIRECTORY       = DDL_SET {DDL__DIRECTORY};   (* 0x0010 *)
      DDL_ARCHIVE         = DDL_SET {DDL__ARCHIVE};     (* 0x0020 *)

      DDL_POSTMSGS        = DDL_SET {DDL__POSTMSGS};    (* 0x2000 *)
      DDL_DRIVES          = DDL_SET {DDL__DRIVES};      (* 0x4000 *)
      DDL_EXCLUSIVE       = DDL_SET {DDL__EXCLUSIVE};   (* 0x8000 *)


PROCEDURE DlgDirListA (hDlg : HWND; VAR PathSpec : ARRAY OF CHAR;
                       IDListBox : INTEGER; IDStaticPath : INTEGER;
                       FileType : DDL_SET) : INTEGER;
PROCEDURE DlgDirListW (hDlg : HWND; VAR PathSpec : ARRAY OF WCHAR;
                       IDListBox : INTEGER; IDStaticPath : INTEGER;
                       FileType : DDL_SET) : INTEGER;

PROCEDURE DlgDirSelectExA (hDlg : HWND; VAR String : ARRAY OF CHAR;
                           Count : INTEGER; IDListBox : INTEGER) : BOOL;
PROCEDURE DlgDirSelectExW (hDlg : HWND; VAR String : ARRAY OF WCHAR;
                           Count : INTEGER; IDListBox : INTEGER) : BOOL;

PROCEDURE DlgDirListComboBoxA (hDlg : HWND; VAR PathSpec : ARRAY OF CHAR;
                               IDComboBox : INTEGER; IDStaticPath : INTEGER;
                               Filetype : DDL_SET) : INTEGER;
PROCEDURE DlgDirListComboBoxW (hDlg : HWND; VAR PathSpec : ARRAY OF WCHAR;
                               IDComboBox : INTEGER; IDStaticPath : INTEGER;
                               Filetype : DDL_SET) : INTEGER;

PROCEDURE DlgDirSelectComboBoxExA (hDlg : HWND; VAR String : ARRAY OF CHAR;
                                   Count : INTEGER; IDComboBox : INTEGER) : BOOL;
PROCEDURE DlgDirSelectComboBoxExW (hDlg : HWND; VAR String : ARRAY OF WCHAR;
                                   Count : INTEGER; IDComboBox : INTEGER) : BOOL;


<* IF DEFINED (UNICODE) THEN *>
      CONST DlgDirList = DlgDirListW;
            DlgDirSelectEx = DlgDirSelectExW;
            DlgDirListComboBox = DlgDirListComboBoxW;
            DlgDirSelectComboBoxEx = DlgDirSelectComboBoxExW;
<* ELSE *>
      CONST DlgDirList = DlgDirListA;
            DlgDirSelectEx = DlgDirSelectExA;
            DlgDirListComboBox = DlgDirListComboBoxA;
            DlgDirSelectComboBoxEx = DlgDirSelectComboBoxExA;
<* END *>


(* Dialog Styles *)

CONST DS_ABSALIGN         = WS_SET {WS__0};   (* 0x0001L *)
      DS_SYSMODAL         = WS_SET {WS__1};   (* 0x0002L *)
      DS_LOCALEDIT        = WS_SET {WS__5};   (* 0x0020L *) (* Edit items get Local storage. *)
      DS_SETFONT          = WS_SET {WS__6};   (* 0x0040L *) (* User specified font for Dlg controls *)
      DS_MODALFRAME       = WS_SET {WS__7};   (* 0x0080L *) (* Can be combined with WS_CAPTION  *)
      DS_NOIDLEMSG        = WS_SET {WS__8};   (* 0x0100L *) (* WM_ENTERIDLE message will not be sent *)
      DS_SETFOREGROUND    = WS_SET {WS__9};   (* 0x0200L *) (* not in win3.1 *)
      DS_3DLOOK           = WS_SET {WS__2};   (* 0x0004L *)
      DS_FIXEDSYS         = WS_SET {WS__3};   (* 0x0008L *)
      DS_NOFAILCREATE     = WS_SET {WS__4};   (* 0x0010L *)
      DS_CONTROL          = WS_SET {WS__10};  (* 0x0400L *)
      DS_CENTER           = WS_SET {WS__11};  (* 0x0800L *)
      DS_CENTERMOUSE      = WS_SET {WS__12};  (* 0x1000L *)
      DS_CONTEXTHELP      = WS_SET {WS__13};  (* 0x2000L *)


CONST DM_GETDEFID   = WM_USER+0;
      DM_SETDEFID   = WM_USER+1;
      DM_REPOSITION = WM_USER+2;

      PSM_PAGEINFO      =  WM_USER+100;
      PSM_SHEETINFO     =  WM_USER+101;

      PSI_SETACTIVE     =  0001h;
      PSI_KILLACTIVE    =  0002h;
      PSI_APPLY         =  0003h;
      PSI_RESET         =  0004h;
      PSI_HASHELP       =  0005h;
      PSI_HELP          =  0006h;

      PSI_CHANGED       =  0001h;
      PSI_GUISTART      =  0002h;
      PSI_REBOOT        =  0003h;
      PSI_GETSIBLINGS   =  0004h;

(* Returned in HIWORD () of DM_GETDEFID result if msg is supported *)

CONST DC_HASDEFID  = 534Bh;

(* Dialog Codes (return value of WM_GETDLGCODE *)

TYPE DLGC_ENUM = (DLGC__WANTARROWS,      (* 0 - Control wants arrow keys         *)
                  DLGC__WANTTAB,         (* 1 - Control wants tab keys           *)
                  DLGC__WANTALLKEYS,     (* 2 - Control wants all keys           *)
                  DLGC__HASSETSEL,       (* 3 - Understands EM_SETSEL message    *)
                  DLGC__DEFPUSHBUTTON,   (* 4 - Default pushbutton               *)
                  DLGC__UNDEFPUSHBUTTON, (* 5 - Non-default pushbutton           *)
                  DLGC__RADIOBUTTON,     (* 6 - Radio button                     *)
                  DLGC__WANTCHARS,       (* 7 - Want WM_CHAR messages            *)
                  DLGC__STATIC,          (* 8 - Static item: don't include       *)
                  DLGC__9, DLGC__10,
                  DLGC__11,DLGC__12,
                  DLGC__BUTTON);         (* 13- Button item: can be checked      *)

CONST DLGC__WANTMESSAGE = DLGC__WANTALLKEYS; (* 2 *)

TYPE  DLGC_SET = SET OF DLGC_ENUM;

(* Dialog Codes (return value of WM_GETDLGCODE *)

CONST DLGC_WANTARROWS      = DLGC_SET {DLGC__WANTARROWS      }; (* 0001h *)
      DLGC_WANTTAB         = DLGC_SET {DLGC__WANTTAB         }; (* 0002h *)
      DLGC_WANTALLKEYS     = DLGC_SET {DLGC__WANTALLKEYS     }; (* 0004h *)
      DLGC_WANTMESSAGE     = DLGC_SET {DLGC__WANTMESSAGE     }; (* 0004h *)
      DLGC_HASSETSEL       = DLGC_SET {DLGC__HASSETSEL       }; (* 0008h *)
      DLGC_DEFPUSHBUTTON   = DLGC_SET {DLGC__DEFPUSHBUTTON   }; (* 0010h *)
      DLGC_UNDEFPUSHBUTTON = DLGC_SET {DLGC__UNDEFPUSHBUTTON }; (* 0020h *)
      DLGC_RADIOBUTTON     = DLGC_SET {DLGC__RADIOBUTTON     }; (* 0040h *)
      DLGC_WANTCHARS       = DLGC_SET {DLGC__WANTCHARS       }; (* 0080h *)
      DLGC_STATIC          = DLGC_SET {DLGC__STATIC          }; (* 0100h *)
      DLGC_BUTTON          = DLGC_SET {DLGC__BUTTON          }; (* 2000h *)

CONST LB_CTLCODE = 0;

(*
 * Listbox messages Return Values
 *)

CONST LB_OKAY     = SYSTEM.CAST (LRESULT, VAL (LONG, 0));
      LB_ERR      = SYSTEM.CAST (LRESULT, VAL (LONG, -1));
      LB_ERRSPACE = SYSTEM.CAST (LRESULT, VAL (LONG, -2));

(* Listbox Notification Codes *)

CONST LBN_ERRSPACE       = -2;
      LBN_SELCHANGE      =  1;
      LBN_DBLCLK         =  2;
      LBN_SELCANCEL      =  3;
      LBN_SETFOCUS       =  4;
      LBN_KILLFOCUS      =  5;

(*
 * Listbox messages
 *)

CONST LB_ADDSTRING            = 0180h;
      LB_INSERTSTRING         = 0181h;
      LB_DELETESTRING         = 0182h;
      LB_SELITEMRANGEEX       = 0183h;
      LB_RESETCONTENT         = 0184h;
      LB_SETSEL               = 0185h;
      LB_SETCURSEL            = 0186h;
      LB_GETSEL               = 0187h;
      LB_GETCURSEL            = 0188h;
      LB_GETTEXT              = 0189h;
      LB_GETTEXTLEN           = 018Ah;
      LB_GETCOUNT             = 018Bh;
      LB_SELECTSTRING         = 018Ch;
      LB_DIR                  = 018Dh;
      LB_GETTOPINDEX          = 018Eh;
      LB_FINDSTRING           = 018Fh;
      LB_GETSELCOUNT          = 0190h;
      LB_GETSELITEMS          = 0191h;
      LB_SETTABSTOPS          = 0192h;
      LB_GETHORIZONTALEXTENT  = 0193h;
      LB_SETHORIZONTALEXTENT  = 0194h;
      LB_SETCOLUMNWIDTH       = 0195h;
      LB_ADDFILE              = 0196h;
      LB_SETTOPINDEX          = 0197h;
      LB_GETITEMRECT          = 0198h;
      LB_GETITEMDATA          = 0199h;
      LB_SETITEMDATA          = 019Ah;
      LB_SELITEMRANGE         = 019Bh;
      LB_SETANCHORINDEX       = 019Ch;
      LB_GETANCHORINDEX       = 019Dh;
      LB_SETCARETINDEX        = 019Eh;
      LB_GETCARETINDEX        = 019Fh;
      LB_SETITEMHEIGHT        = 01A0h;
      LB_GETITEMHEIGHT        = 01A1h;
      LB_FINDSTRINGEXACT      = 01A2h;
      LB_SETLOCALE            = 01A5h;
      LB_GETLOCALE            = 01A6h;
      LB_SETCOUNT             = 01A7h;
      LB_INITSTORAGE          = 01A8h;
      LB_ITEMFROMPOINT        = 01A9h;
      LB_MSGMAX               = 01B0h;

(* Listbox Styles *)

CONST LBS_NOTIFY            = WS_SET {WS__0};   (* 0x0001L *)
      LBS_SORT              = WS_SET {WS__1};   (* 0x0002L *)
      LBS_NOREDRAW          = WS_SET {WS__2};   (* 0x0004L *)
      LBS_MULTIPLESEL       = WS_SET {WS__3};   (* 0x0008L *)
      LBS_OWNERDRAWFIXED    = WS_SET {WS__4};   (* 0x0010L *)
      LBS_OWNERDRAWVARIABLE = WS_SET {WS__5};   (* 0x0020L *)
      LBS_HASSTRINGS        = WS_SET {WS__6};   (* 0x0040L *)
      LBS_USETABSTOPS       = WS_SET {WS__7};   (* 0x0080L *)
      LBS_NOINTEGRALHEIGHT  = WS_SET {WS__8};   (* 0x0100L *)
      LBS_MULTICOLUMN       = WS_SET {WS__9};   (* 0x0200L *)
      LBS_WANTKEYBOARDINPUT = WS_SET {WS__10};  (* 0x0400L *)
      LBS_EXTENDEDSEL       = WS_SET {WS__11};  (* 0x0800L *)
      LBS_DISABLENOSCROLL   = WS_SET {WS__12};  (* 0x1000L *)
      LBS_NODATA            = WS_SET {WS__13};  (* 0x2000L *)
      LBS_NOSEL             = WS_SET {WS__14};  (* 0x4000L *)
      LBS_STANDARD          = LBS_NOTIFY + LBS_SORT + WS_VSCROLL + WS_BORDER;

(*
 * Combo Box return Values
 *)

CONST CB_OKAY     = SYSTEM.CAST (LRESULT, VAL (LONG, 0));
      CB_ERR      = SYSTEM.CAST (LRESULT, VAL (LONG, -1));
      CB_ERRSPACE = SYSTEM.CAST (LRESULT, VAL (LONG, -2));

(* Combo Box Notification Codes *)

CONST CBN_ERRSPACE       = -1;
      CBN_SELCHANGE      =  1;
      CBN_DBLCLK         =  2;
      CBN_SETFOCUS       =  3;
      CBN_KILLFOCUS      =  4;
      CBN_EDITCHANGE     =  5;
      CBN_EDITUPDATE     =  6;
      CBN_DROPDOWN       =  7;
      CBN_CLOSEUP        =  8;
      CBN_SELENDOK       =  9;
      CBN_SELENDCANCEL   = 10;

(* Combo Box styles *)

CONST CBS_SIMPLE            = WS_SET {WS__0};       (* 0x0001L *)
      CBS_DROPDOWN          = WS_SET {WS__1};       (* 0x0002L *)
      CBS_DROPDOWNLIST      = WS_SET {WS__1,WS__0}; (* 0x0003L *)
      CBS_OWNERDRAWFIXED    = WS_SET {WS__4};       (* 0x0010L *)
      CBS_OWNERDRAWVARIABLE = WS_SET {WS__5};       (* 0x0020L *)
      CBS_AUTOHSCROLL       = WS_SET {WS__6};       (* 0x0040L *)
      CBS_OEMCONVERT        = WS_SET {WS__7};       (* 0x0080L *)
      CBS_SORT              = WS_SET {WS__8};       (* 0x0100L *)
      CBS_HASSTRINGS        = WS_SET {WS__9};       (* 0x0200L *)
      CBS_NOINTEGRALHEIGHT  = WS_SET {WS__10};      (* 0x0400L *)
      CBS_DISABLENOSCROLL   = WS_SET {WS__11};      (* 0x0800L *)
      CBS_UPPERCASE         = WS_SET {WS__13};      (* 0x2000L *)
      CBS_LOWERCASE         = WS_SET {WS__14};      (* 0x4000L *)

(*
 * Combo Box messages
 *)

CONST CB_GETEDITSEL               = 0140h;
      CB_LIMITTEXT                = 0141h;
      CB_SETEDITSEL               = 0142h;
      CB_ADDSTRING                = 0143h;
      CB_DELETESTRING             = 0144h;
      CB_DIR                      = 0145h;
      CB_GETCOUNT                 = 0146h;
      CB_GETCURSEL                = 0147h;
      CB_GETLBTEXT                = 0148h;
      CB_GETLBTEXTLEN             = 0149h;
      CB_INSERTSTRING             = 014Ah;
      CB_RESETCONTENT             = 014Bh;
      CB_FINDSTRING               = 014Ch;
      CB_SELECTSTRING             = 014Dh;
      CB_SETCURSEL                = 014Eh;
      CB_SHOWDROPDOWN             = 014Fh;
      CB_GETITEMDATA              = 0150h;
      CB_SETITEMDATA              = 0151h;
      CB_GETDROPPEDCONTROLRECT    = 0152h;
      CB_SETITEMHEIGHT            = 0153h;
      CB_GETITEMHEIGHT            = 0154h;
      CB_SETEXTENDEDUI            = 0155h;
      CB_GETEXTENDEDUI            = 0156h;
      CB_GETDROPPEDSTATE          = 0157h;
      CB_FINDSTRINGEXACT          = 0158h;
      CB_SETLOCALE                = 0159h;
      CB_GETLOCALE                = 015Ah;
      CB_GETTOPINDEX              = 015Bh;
      CB_SETTOPINDEX              = 015Ch;
      CB_GETHORIZONTALEXTENT      = 015Dh;
      CB_SETHORIZONTALEXTENT      = 015Eh;
      CB_GETDROPPEDWIDTH          = 015Fh;
      CB_SETDROPPEDWIDTH          = 0160h;
      CB_INITSTORAGE              = 0161h;
      CB_MSGMAX                   = 0162h;

(* Scroll Bar Styles  *)

CONST SBS_HORZ                    = WS_SET { };      (* 0x0000L *)
      SBS_VERT                    = WS_SET {WS__0};  (* 0x0001L *)
      SBS_TOPALIGN                = WS_SET {WS__1};  (* 0x0002L *)
      SBS_LEFTALIGN               = WS_SET {WS__1};  (* 0x0002L *)
      SBS_BOTTOMALIGN             = WS_SET {WS__2};  (* 0x0004L *)
      SBS_RIGHTALIGN              = WS_SET {WS__2};  (* 0x0004L *)
      SBS_SIZEBOXTOPLEFTALIGN     = WS_SET {WS__1};  (* 0x0002L *)
      SBS_SIZEBOXBOTTOMRIGHTALIGN = WS_SET {WS__2};  (* 0x0004L *)
      SBS_SIZEBOX                 = WS_SET {WS__3};  (* 0x0008L *)
      SBS_SIZEGRIP                = WS_SET {WS__4};  (* 0x0010L *)

(*
 * Scroll bar messages
 *)

CONST SBM_SETPOS                  = 00E0h;
      SBM_GETPOS                  = 00E1h;
      SBM_SETRANGE                = 00E2h;
      SBM_SETRANGEREDRAW          = 00E6h;
      SBM_GETRANGE                = 00E3h;
      SBM_ENABLE_ARROWS           = 00E4h;
      SBM_SETSCROLLINFO           = 00E9h;
      SBM_GETSCROLLINFO           = 00EAh;

TYPE SIF_ENUM = (SIF__RANGE,           (* 0 *)
                 SIF__PAGE,            (* 1 *)
                 SIF__POS,             (* 2 *)
                 SIF__DISABLENOSCROLL, (* 3 *)
                 SIF__TRACKPOS);       (* 4 *)

     SIF_SET = SET OF SIF_ENUM;

CONST SIF_RANGE           = SIF_SET {SIF__RANGE           }; (* 0x0001 *)
      SIF_PAGE            = SIF_SET {SIF__PAGE            }; (* 0x0002 *)
      SIF_POS             = SIF_SET {SIF__POS             }; (* 0x0004 *)
      SIF_DISABLENOSCROLL = SIF_SET {SIF__DISABLENOSCROLL }; (* 0x0008 *)
      SIF_TRACKPOS        = SIF_SET {SIF__TRACKPOS        }; (* 0x0010 *)

      SIF_ALL = SIF_RANGE + SIF_PAGE + SIF_POS + SIF_TRACKPOS;

TYPE SCROLLINFO = RECORD
                         cbSize    : UINT;
                         fMask     : SIF_SET;
                         nMin      : INTEGER;
                         nMax      : INTEGER;
                         nPage     : UINT;
                         nPos      : INTEGER;
                         nTrackPos : INTEGER;
                  END;
    PSCROLLINFO = POINTER TO SCROLLINFO;

<* IF BACKEND # "C" THEN *>
PROCEDURE SetScrollInfo (hwnd : HWND; sbtype : SB_TYPE;
                         si : SCROLLINFO (*!*); redraw : BOOL) : INTEGER;
<* ELSE *>
PROCEDURE SetScrollInfo (hwnd : HWND; sbtype : SB_TYPE;
                         si : PSCROLLINFO (*!*); redraw : BOOL) : INTEGER;
<* END *>
PROCEDURE GetScrollInfo (hwnd : HWND; sbtype : SB_TYPE;
                         VAR si : SCROLLINFO) : BOOL;

(* MDI client style *)

CONST MDIS_ALLCHILDSTYLES = WS_SET {WS__0};

(* wParam Flags for WM_MDITILE and WM_MDICASCADE messages. *)

CONST MDITILE_VERTICAL     =  0;  (* not in win3.1 *)
      MDITILE_HORIZONTAL   =  1;  (* not in win3.1 *)
      MDITILE_SKIPDISABLED =  2;  (* not in win3.1 *)

TYPE MDICREATESTRUCTA = RECORD
                             szClass : PCSTR;
                             szTitle : PCSTR;
                             hOwner  : HANDLE;
                             x, y,
                             cx, cy  : INTEGER;
                             style   : DWORD;
                             lParam  : LPARAM;      (* app-defined stuff *)
                        END;
    PMDICREATESTRUCTA = POINTER TO MDICREATESTRUCT;

TYPE MDICREATESTRUCTW = RECORD
                             szClass : PCWSTR;
                             szTitle : PCWSTR;
                             hOwner  : HANDLE;
                             x, y,
                             cx, cy  : INTEGER;
                             style   : DWORD;
                             lParam  : LPARAM;      (* app-defined stuff *)
                        END;
    PMDICREATESTRUCTW = POINTER TO MDICREATESTRUCT;


<* IF DEFINED (UNICODE) THEN *>
      TYPE MDICREATESTRUCT  = MDICREATESTRUCTW;
           PMDICREATESTRUCT = PMDICREATESTRUCTW;
<* ELSE *>
      TYPE MDICREATESTRUCT  = MDICREATESTRUCTA;
           PMDICREATESTRUCT = PMDICREATESTRUCTA;

<* END *>

TYPE CLIENTCREATESTRUCT = RECORD
                               hWindowMenu : HANDLE;
                               idFirstChild : UINT;
                          END;

PROCEDURE DefFrameProcA (hWnd : HWND; hWndMDIClient : HWND;
                         Msg : UINT; wParam : WPARAM; lParam : LPARAM) : LRESULT;
PROCEDURE DefFrameProcW (hWnd : HWND; hWndMDIClient : HWND;
                         Msg : UINT; wParam : WPARAM; lParam : LPARAM) : LRESULT;

PROCEDURE DefMDIChildProcA (hWnd : HWND; Msg : UINT;
                            wParam : WPARAM; lParam : LPARAM) : LRESULT;
PROCEDURE DefMDIChildProcW (hWnd : HWND; Msg : UINT;
                            wParam : WPARAM; lParam : LPARAM) : LRESULT;

<* IF DEFINED (UNICODE) THEN *>
      CONST DefFrameProc    = DefFrameProcW;
            DefMDIChildProc = DefMDIChildProcW;
<* ELSE *>
      CONST DefFrameProc    = DefFrameProcA;
            DefMDIChildProc = DefMDIChildProcA;
<* END *>

PROCEDURE TranslateMDISysAccel (WndClient : HWND; VAR Msg : MSG) : BOOL;

PROCEDURE ArrangeIconicWindows (hWnd : HWND) : UINT;

PROCEDURE CreateMDIWindowA (ClassName     : ATOMSTR;
                            WindowName    : ARRAY OF CHAR;
                            Style         : WS_SET;
                            X, Y,
                            Width, Height : INTEGER;
                            hWndParent    : HWND;
                            hInstance     : HINSTANCE;
                            lParam        : LPARAM)    : HWND;

PROCEDURE CreateMDIWindowW (lpClassName   : ATOMWSTR;
                            lpWindowName  : ARRAY OF WCHAR;
                            Style         : WS_SET;
                            X, Y,
                            Width, Height : INTEGER;
                            hWndParent    : HWND;
                            hInstance     : HINSTANCE;
                            lParam        : LPARAM)    : HWND;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateMDIWindow = CreateMDIWindowW;
<* ELSE *>
      CONST CreateMDIWindow = CreateMDIWindowA;
<* END *>


PROCEDURE TileWindows    (Parent : HWND;
                          wHow   : UINT;
                          Rect   : PRECT; (* NIL *)
                          cKids  : UINT;
                          VAR [NIL] Kids : ARRAY OF HWND) : WORD;

PROCEDURE CascadeWindows (Parent : HWND;
                          wHow   : UINT;
                          Rect   : PRECT; (* NIL *)
                          cKids  : UINT;
                          VAR [NIL] Kids : ARRAY OF HWND) : WORD;

TYPE HELPPOLY = DWORD;

TYPE MULTIKEYHELPA = RECORD
                            mkSize      : DWORD;
                            mkKeylist   : CHAR;
                            szKeyphrase : ARRAY [0..0] OF CHAR;
                     END;
    PMULTIKEYHELPA = POINTER TO MULTIKEYHELPA;

     MULTIKEYHELPW = RECORD
                            mkSize      : DWORD;
                            mkKeylist   : WCHAR;
                            szKeyphrase : ARRAY [0..0] OF WCHAR;
                     END;
    PMULTIKEYHELPW = POINTER TO MULTIKEYHELPW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE MULTIKEYHELP  = MULTIKEYHELPW;
           PMULTIKEYHELP = PMULTIKEYHELPW;
<* ELSE *>
      TYPE MULTIKEYHELP  = MULTIKEYHELPA;
           PMULTIKEYHELP = PMULTIKEYHELPA;
<* END *>


TYPE HELPWININFOA = RECORD
                           wStructSize  : INTEGER;
                           x, y, dx, dy : INTEGER;
                           wMax         : INTEGER;
                           rgchMember   : ARRAY [0..1] OF CHAR;
                    END;
    PHELPWININFOA = POINTER TO HELPWININFOA;

TYPE HELPWININFOW = RECORD
                           wStructSize  : INTEGER;
                           x, y, dx, dy : INTEGER;
                           wMax         : INTEGER;
                           rgchMember   : ARRAY [0..1] OF WCHAR;
                    END;
    PHELPWININFOW = POINTER TO HELPWININFOW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE HELPWININFO  = HELPWININFOW;
           PHELPWININFO = PHELPWININFOW;
<* ELSE *>
      TYPE HELPWININFO  = HELPWININFOA;
           PHELPWININFO = PHELPWININFOA;
<* END *>

(*
 * Commands to pass to WinHelp()
 *)
CONST HELP_CONTEXT      = 0001h;  (* Display topic in ulTopic *)
      HELP_QUIT         = 0002h;  (* Terminate help *)
      HELP_INDEX        = 0003h;  (* Display index *)
      HELP_CONTENTS     = 0003h;
      HELP_HELPONHELP   = 0004h;  (* Display help on using help *)
      HELP_SETINDEX     = 0005h;  (* Set current Index for multi index help *)
      HELP_SETCONTENTS  = 0005h;
      HELP_CONTEXTPOPUP = 0008h;
      HELP_FORCEFILE    = 0009h;
      HELP_KEY          = 0101h;  (* Display topic for keyword in offabData *)
      HELP_COMMAND      = 0102h;
      HELP_PARTIALKEY   = 0105h;
      HELP_MULTIKEY     = 0201h;
      HELP_SETWINPOS    = 0203h;
      HELP_CONTEXTMENU  = 000Ah;
      HELP_FINDER       = 000Bh;
      HELP_WM_HELP      = 000Ch;
      HELP_SETPOPUP_POS = 000Dh;

      HELP_TCARD              = 8000h;
      HELP_TCARD_DATA         = 0010h;
      HELP_TCARD_OTHER_CALLER = 0011h;

(* These are in winhelp.h in Win95. *)
      IDH_NO_HELP             = 28440;
      IDH_MISSING_CONTEXT     = 28441; (* Control doesn't have matching help context *)
      IDH_GENERIC_HELP_BUTTON = 28442; (* Property sheet help button *)
      IDH_OK                  = 28443;
      IDH_CANCEL              = 28444;
      IDH_HELP                = 28445;


PROCEDURE WinHelpA (hWndMain : HWND;
                    lpszHelp : ARRAY OF CHAR;
                    uCommand : UINT;
                    dwData   : DWORD) : BOOL;

PROCEDURE WinHelpW (hWndMain : HWND;
                    lpszHelp : ARRAY OF WCHAR;
                    uCommand : UINT;
                    dwData   : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST WinHelp = WinHelpW;
<* ELSE *>
      CONST WinHelp = WinHelpA;
<* END *>

(*
 * Parameter for SystemParametersInfo()
 *)

TYPE SPI_ACTION = UINT;

CONST SPI_GETBEEP               =  1;
      SPI_SETBEEP               =  2;
      SPI_GETMOUSE              =  3;
      SPI_SETMOUSE              =  4;
      SPI_GETBORDER             =  5;
      SPI_SETBORDER             =  6;
      SPI_GETKEYBOARDSPEED      =  0;
      SPI_SETKEYBOARDSPEED      = 11;
      SPI_LANGDRIVER            = 12;
      SPI_ICONHORIZONTALSPACING = 13;
      SPI_GETSCREENSAVETIMEOUT  = 14;
      SPI_SETSCREENSAVETIMEOUT  = 15;
      SPI_GETSCREENSAVEACTIVE   = 16;
      SPI_SETSCREENSAVEACTIVE   = 17;
      SPI_GETGRIDGRANULARITY    = 18;
      SPI_SETGRIDGRANULARITY    = 19;
      SPI_SETDESKWALLPAPER      = 20;
      SPI_SETDESKPATTERN        = 21;
      SPI_GETKEYBOARDDELAY      = 22;
      SPI_SETKEYBOARDDELAY      = 23;
      SPI_ICONVERTICALSPACING   = 24;
      SPI_GETICONTITLEWRAP      = 25;
      SPI_SETICONTITLEWRAP      = 26;
      SPI_GETMENUDROPALIGNMENT  = 27;
      SPI_SETMENUDROPALIGNMENT  = 28;
      SPI_SETDOUBLECLKWIDTH     = 29;
      SPI_SETDOUBLECLKHEIGHT    = 30;
      SPI_GETICONTITLELOGFONT   = 31;
      SPI_SETDOUBLECLICKTIME    = 32;
      SPI_SETMOUSEBUTTONSWAP    = 33;
      SPI_SETICONTITLELOGFONT   = 34;
      SPI_GETFASTTASKSWITCH     = 35;
      SPI_SETFASTTASKSWITCH     = 36;
      SPI_SETDRAGFULLWINDOWS    = 37;
      SPI_GETDRAGFULLWINDOWS    = 38;
      SPI_GETNONCLIENTMETRICS   = 41;
      SPI_SETNONCLIENTMETRICS   = 42;
      SPI_GETMINIMIZEDMETRICS   = 43;
      SPI_SETMINIMIZEDMETRICS   = 44;
      SPI_GETICONMETRICS        = 45;
      SPI_SETICONMETRICS        = 46;
      SPI_SETWORKAREA           = 47;
      SPI_GETWORKAREA           = 48;
      SPI_SETPENWINDOWS         = 49;

      SPI_GETHIGHCONTRAST       = 66;
      SPI_SETHIGHCONTRAST       = 67;
      SPI_GETKEYBOARDPREF       = 68;
      SPI_SETKEYBOARDPREF       = 69;
      SPI_GETSCREENREADER       = 70;
      SPI_SETSCREENREADER       = 71;
      SPI_GETANIMATION          = 72;
      SPI_SETANIMATION          = 73;
      SPI_GETFONTSMOOTHING      = 74;
      SPI_SETFONTSMOOTHING      = 75;
      SPI_SETDRAGWIDTH          = 76;
      SPI_SETDRAGHEIGHT         = 77;
      SPI_SETHANDHELD           = 78;
      SPI_GETLOWPOWERTIMEOUT    = 79;
      SPI_GETPOWEROFFTIMEOUT    = 80;
      SPI_SETLOWPOWERTIMEOUT    = 81;
      SPI_SETPOWEROFFTIMEOUT    = 82;
      SPI_GETLOWPOWERACTIVE     = 83;
      SPI_GETPOWEROFFACTIVE     = 84;
      SPI_SETLOWPOWERACTIVE     = 85;
      SPI_SETPOWEROFFACTIVE     = 86;
      SPI_SETCURSORS            = 87;
      SPI_SETICONS              = 88;
      SPI_GETDEFAULTINPUTLANG   = 89;
      SPI_SETDEFAULTINPUTLANG   = 90;
      SPI_SETLANGTOGGLE         = 91;
      SPI_GETWINDOWSEXTENSION   = 92;
      SPI_SETMOUSETRAILS        = 93;
      SPI_GETMOUSETRAILS        = 94;
      SPI_SCREENSAVERRUNNING    = 97;

      SPI_GETFILTERKEYS         = 50;
      SPI_SETFILTERKEYS         = 51;
      SPI_GETTOGGLEKEYS         = 52;
      SPI_SETTOGGLEKEYS         = 53;
      SPI_GETMOUSEKEYS          = 54;
      SPI_SETMOUSEKEYS          = 55;
      SPI_GETSHOWSOUNDS         = 56;
      SPI_SETSHOWSOUNDS         = 57;
      SPI_GETSTICKYKEYS         = 58;
      SPI_SETSTICKYKEYS         = 59;
      SPI_GETACCESSTIMEOUT      = 60;
      SPI_SETACCESSTIMEOUT      = 61;
      SPI_GETSERIALKEYS         = 62;
      SPI_SETSERIALKEYS         = 63;
      SPI_GETSOUNDSENTRY        = 64;
      SPI_SETSOUNDSENTRY        = 65;
      SPI_GETSNAPTODEFBUTTON    = 95;
      SPI_SETSNAPTODEFBUTTON    = 96;
      SPI_GETMOUSEHOVERWIDTH    = 98;
      SPI_SETMOUSEHOVERWIDTH    = 99;
      SPI_GETMOUSEHOVERHEIGHT   =100;
      SPI_SETMOUSEHOVERHEIGHT   =101;
      SPI_GETMOUSEHOVERTIME     =102;
      SPI_SETMOUSEHOVERTIME     =103;
      SPI_GETWHEELSCROLLLINES   =104;
      SPI_SETWHEELSCROLLLINES   =105;

TYPE  SPIF_ENUM = (SPIF__UPDATEINIFILE,     (* 0 *)
                   SPIF__SENDWININICHANGE); (* 1 *)
      SPIF_SET = SET OF SPIF_ENUM;

CONST SPIF_UPDATEINIFILE    = SPIF_SET {SPIF__UPDATEINIFILE};    (* 0x0001 *)
      SPIF_SENDWININICHANGE = SPIF_SET {SPIF__SENDWININICHANGE}; (* 0x0002 *)
      SPIF_SENDCHANGE       = SPIF_SENDWININICHANGE;

CONST METRICS_USEDEFAULT = -1;

TYPE NONCLIENTMETRICSA = RECORD
                                cbSize           : UINT;
                                iBorderWidth     : INTEGER;
                                iScrollWidth     : INTEGER;
                                iScrollHeight    : INTEGER;
                                iCaptionWidth    : INTEGER;
                                iCaptionHeight   : INTEGER;
                                lfCaptionFont    : LOGFONTA;
                                iSmCaptionWidth  : INTEGER;
                                iSmCaptionHeight : INTEGER;
                                lfSmCaptionFont  : LOGFONTA;
                                iMenuWidth       : INTEGER;
                                iMenuHeight      : INTEGER;
                                lfMenuFont       : LOGFONTA;
                                lfStatusFont     : LOGFONTA;
                                lfMessageFont    : LOGFONTA;
                         END;
    PNONCLIENTMETRICSA = POINTER TO NONCLIENTMETRICSA;

     NONCLIENTMETRICSW = RECORD
                                cbSize           : UINT;
                                iBorderWidth     : INTEGER;
                                iScrollWidth     : INTEGER;
                                iScrollHeight    : INTEGER;
                                iCaptionWidth    : INTEGER;
                                iCaptionHeight   : INTEGER;
                                lfCaptionFont    : LOGFONTW;
                                iSmCaptionWidth  : INTEGER;
                                iSmCaptionHeight : INTEGER;
                                lfSmCaptionFont  : LOGFONTW;
                                iMenuWidth       : INTEGER;
                                iMenuHeight      : INTEGER;
                                lfMenuFont       : LOGFONTW;
                                lfStatusFont     : LOGFONTW;
                                lfMessageFont    : LOGFONTW;
                         END;
    PNONCLIENTMETRICSW = POINTER TO NONCLIENTMETRICSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE NONCLIENTMETRICS  = NONCLIENTMETRICSW;
           PNONCLIENTMETRICS = PNONCLIENTMETRICSW;
<* ELSE *>
      TYPE NONCLIENTMETRICS  = NONCLIENTMETRICSA;
           PNONCLIENTMETRICS = PNONCLIENTMETRICSA;
<* END *>


(* Positions and directions of minimized windows;
   for use in MINIMIZEDMETRICS structure and SM_ARRANGE values in
   GetSystemMetrics ()
*)


TYPE ARW_ENUM = (ARW__0, ARW__1, ARW__2, ARW__3);
     ARW_SET  = SET OF ARW_ENUM;

CONST ARW_BOTTOMLEFT   = ARW_SET {                              }; (* 0x0000L *)
      ARW_BOTTOMRIGHT  = ARW_SET {                        ARW__0}; (* 0x0001L *)
      ARW_TOPLEFT      = ARW_SET {                ARW__1        }; (* 0x0002L *)
      ARW_TOPRIGHT     = ARW_SET {                ARW__1, ARW__0}; (* 0x0003L *)
      ARW_STARTMASK    = ARW_SET {                ARW__1, ARW__0}; (* 0x0003L *)
      ARW_STARTRIGHT   = ARW_SET {                        ARW__0}; (* 0x0001L *)
      ARW_STARTTOP     = ARW_SET {                ARW__1        }; (* 0x0002L *)

      ARW_LEFT         = ARW_SET {                              }; (* 0x0000L *)
      ARW_RIGHT        = ARW_SET {                              }; (* 0x0000L *)
      ARW_UP           = ARW_SET {        ARW__2                }; (* 0x0004L *)
      ARW_DOWN         = ARW_SET {        ARW__2                }; (* 0x0004L *)
      ARW_HIDE         = ARW_SET {ARW__3                        }; (* 0x0008L *)

      ARW_VALID        = ARW_SET {ARW__3, ARW__2, ARW__1, ARW__0}; (* 0x000FL *)

TYPE MINIMIZEDMETRICS = RECORD
                               cbSize : UINT;
                               iWidth : INTEGER;
                               iHorzGap : INTEGER;
                               iVertGap : INTEGER;
                               iArrange : ARW_SET;
                        END;
    PMINIMIZEDMETRICS = POINTER TO MINIMIZEDMETRICS;

TYPE ICONMETRICSA = RECORD
                           cbSize       : UINT;
                           iHorzSpacing : INTEGER;
                           iVertSpacing : INTEGER;
                           iTitleWrap   : INTEGER;
                           lfFont       : LOGFONTA;
                    END;
    PICONMETRICSA = POINTER TO ICONMETRICSA;

TYPE ICONMETRICSW = RECORD
                           cbSize       : UINT;
                           iHorzSpacing : INTEGER;
                           iVertSpacing : INTEGER;
                           iTitleWrap   : INTEGER;
                           lfFont       : LOGFONTW;
                    END;
    PICONMETRICSW = POINTER TO ICONMETRICSA;

<* IF DEFINED (UNICODE) THEN *>
      TYPE ICONMETRICS  = ICONMETRICSW;
           PICONMETRICS = PICONMETRICSW;
<* ELSE *>
      TYPE ICONMETRICS  = ICONMETRICSA;
           PICONMETRICS = PICONMETRICSA;
<* END *>

TYPE ANIMATIONINFO  = RECORD
                             cbSize      : UINT;
                             iMinAnimate : INTEGER;
                      END;
    PANIMATIONINFO = POINTER TO ANIMATIONINFO;

(* flags for SERIALKEYS dwFlags field *)

TYPE SERKF_ENUM = (SERKF__SERIALKEYSON, (* 0 *)
                   SERKF__AVAILABLE,    (* 1 *)
                   SERKF__INDICATOR);   (* 2 *)

     SERKF_SET = SET OF SERKF_ENUM;

CONST SERKF_SERIALKEYSON = SERKF_SET {SERKF__SERIALKEYSON}; (* 0x00000001 *)
      SERKF_AVAILABLE    = SERKF_SET {SERKF__AVAILABLE   }; (* 0x00000002 *)
      SERKF_INDICATOR    = SERKF_SET {SERKF__INDICATOR   }; (* 0x00000004 *)


TYPE SERIALKEYSA = RECORD
                          cbSize         : UINT;
                          dwFlags        : SERKF_SET;
                          lpszActivePort : PSTR;
                          lpszPort       : PSTR;
                          iBaudRate      : UINT;
                          iPortState     : UINT;
                          iActive        : UINT;
     END;
    PSERIALKEYSA = POINTER TO SERIALKEYSA;

     SERIALKEYSW = RECORD
                          cbSize         : UINT;
                          dwFlags        : SERKF_SET;
                          lpszActivePort : PWSTR;
                          lpszPort       : PWSTR;
                          iBaudRate      : UINT;
                          iPortState     : UINT;
                          iActive        : UINT;
     END;
    PSERIALKEYSW = POINTER TO SERIALKEYSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE SERIALKEYS  = SERIALKEYSW;
           PSERIALKEYS = PSERIALKEYSW;
<* ELSE *>
      TYPE SERIALKEYS  = SERIALKEYSA;
           PSERIALKEYS = PSERIALKEYSA;
<* END *>

(* flags for HIGHCONTRAST dwFlags field *)

TYPE HCF_ENUM = (HCF__HIGHCONTRASTON,   (* 0 *)
                 HCF__AVAILABLE,        (* 1 *)
                 HCF__HOTKEYACTIVE,     (* 2 *)
                 HCF__CONFIRMHOTKEY,    (* 3 *)
                 HCF__HOTKEYSOUND,      (* 4 *)
                 HCF__INDICATOR,        (* 5 *)
                 HCF__HOTKEYAVAILABLE); (* 6 *)
     HCF_SET = SET OF HCF_ENUM;

CONST HCF_HIGHCONTRASTON  = HCF_SET {HCF__HIGHCONTRASTON  }; (* 0x00000001 *)
      HCF_AVAILABLE       = HCF_SET {HCF__AVAILABLE       }; (* 0x00000002 *)
      HCF_HOTKEYACTIVE    = HCF_SET {HCF__HOTKEYACTIVE    }; (* 0x00000004 *)
      HCF_CONFIRMHOTKEY   = HCF_SET {HCF__CONFIRMHOTKEY   }; (* 0x00000008 *)
      HCF_HOTKEYSOUND     = HCF_SET {HCF__HOTKEYSOUND     }; (* 0x00000010 *)
      HCF_INDICATOR       = HCF_SET {HCF__INDICATOR       }; (* 0x00000020 *)
      HCF_HOTKEYAVAILABLE = HCF_SET {HCF__HOTKEYAVAILABLE }; (* 0x00000040 *)

TYPE HIGHCONTRASTA = RECORD
                            cbSize  : UINT;
                            dwFlags : HCF_SET;
                            lpszDefaultScheme : PSTR;
                     END;
    PHIGHCONTRASTA = POINTER TO HIGHCONTRASTA;

     HIGHCONTRASTW = RECORD
                            cbSize  : UINT;
                            dwFlags : HCF_SET;
                            lpszDefaultScheme : PWSTR;
                     END;
    PHIGHCONTRASTW = POINTER TO HIGHCONTRASTW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE HIGHCONTRAST  = HIGHCONTRASTW;
           PHIGHCONTRAST = PHIGHCONTRASTW;
<* ELSE *>
      TYPE HIGHCONTRAST  = HIGHCONTRASTA;
           PHIGHCONTRAST = PHIGHCONTRASTA;
<* END *>


(* Flags for ChangeDisplaySettings *)

TYPE CDS_ENUM = (CDS__UPDATEREGISTRY, (* 0 *)
                 CDS__TEST,           (* 1 *)
                 CDS__FULLSCREEN,     (* 2 *)
                 CDS__GLOBAL,         (* 3 *)
                 CDS__SET_PRIMARY,    (* 4 *)
                 CDS__5,CDS__6,CDS__7,CDS__8,
                 CDS__9,CDS__10,CDS__11,CDS__12,
                 CDS__13,CDS__14,CDS__15,CDS__16,
                 CDS__17,CDS__18,CDS__19,CDS__20,
                 CDS__21,CDS__22,CDS__23,CDS__24,
                 CDS__25,CDS__26,CDS__27,
                 CDS__NORESET,        (* 28 *)
                 CDS__SETRECT,        (* 29 *)
                 CDS__RESET);         (* 30 *)

     CDS_SET = SET OF CDS_ENUM;

CONST CDS_UPDATEREGISTRY  = CDS_SET {CDS__UPDATEREGISTRY}; (* 0x00000001 *)
      CDS_TEST            = CDS_SET {CDS__TEST          }; (* 0x00000002 *)
      CDS_FULLSCREEN      = CDS_SET {CDS__FULLSCREEN    }; (* 0x00000004 *)
      CDS_GLOBAL          = CDS_SET {CDS__GLOBAL        }; (* 0x00000008 *)
      CDS_SET_PRIMARY     = CDS_SET {CDS__SET_PRIMARY   }; (* 0x00000010 *)
      CDS_RESET           = CDS_SET {CDS__RESET         }; (* 0x40000000 *)
      CDS_SETRECT         = CDS_SET {CDS__SETRECT       }; (* 0x20000000 *)
      CDS_NORESET         = CDS_SET {CDS__NORESET       }; (* 0x10000000 *)

(* Return values  for ChangeDisplaySettings *)

CONST DISP_CHANGE_SUCCESSFUL  =  0;
      DISP_CHANGE_RESTART     =  1;
      DISP_CHANGE_FAILED      = -1;
      DISP_CHANGE_BADMODE     = -2;
      DISP_CHANGE_NOTUPDATED  = -3;
      DISP_CHANGE_BADFLAGS    = -4;
      DISP_CHANGE_BADPARAM    = -5;

PROCEDURE ChangeDisplaySettingsA (lpDevMode : PDEVMODEA (* IN NIL *); dwFlags : CDS_SET) : LONG;
PROCEDURE ChangeDisplaySettingsW (lpDevMode : PDEVMODEW (* IN NIL *); dwFlags : CDS_SET) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST ChangeDisplaySettings = ChangeDisplaySettingsW;
<* ELSE *>
      CONST ChangeDisplaySettings = ChangeDisplaySettingsA;
<* END *>

PROCEDURE ChangeDisplaySettingsExA (lpszDeviceName : PCSTR;
                                    lpDevMode : PDEVMODEA (* IN NIL *);
                                    hwnd : HWND;
                                    dwFlags : CDS_SET;
                                    lparam : PVOID) : LONG;
PROCEDURE ChangeDisplaySettingsExW (lpszDeviceName : PCWSTR;
                                    lpDevMode : PDEVMODEW (* IN NIL *);
                                    hwnd : HWND;
                                    dwFlags : CDS_SET;
                                    lparam : PVOID) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST ChangeDisplaySettingsEx = ChangeDisplaySettingsExW;
<* ELSE *>
      CONST ChangeDisplaySettingsEx = ChangeDisplaySettingsExA;
<* END *>

CONST ENUM_CURRENT_SETTINGS  = SYSTEM.CAST (DWORD, VAL (LONG, -1));
      ENUM_REGISTRY_SETTINGS = SYSTEM.CAST (DWORD, VAL (LONG, -2));

PROCEDURE EnumDisplaySettingsA (lpszDeviceName : PCSTR; (* NIL *)
                                iModeNum : DWORD;
                                VAR DevMode : DEVMODEA) : BOOL;

PROCEDURE EnumDisplaySettingsW (lpszDeviceName : PCWSTR; (* NIL *)
                                iModeNum : DWORD;
                                VAR DevMode : DEVMODEW) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumDisplaySettings = EnumDisplaySettingsW;
<* ELSE *>
      CONST EnumDisplaySettings = EnumDisplaySettingsA;
<* END *>

PROCEDURE SystemParametersInfoA (uiAction : SPI_ACTION;
                                 uiParam  : UINT;
                                 pvParam  : PVOID;
                                 fWinIni  : UINT) : BOOL;

PROCEDURE SystemParametersInfoW (uiAction : SPI_ACTION;
                                 uiParam  : UINT;
                                 pvParam  : PVOID;
                                 fWinIni  : UINT) : BOOL;
<* IF DEFINED (UNICODE) THEN *>
      CONST SystemParametersInfo = SystemParametersInfoW;
<* ELSE *>
      CONST SystemParametersInfo = SystemParametersInfoA;
<* END *>


(*
 * Accessibility support
 *)

(*
 * FILTERKEYS dwFlags field
 *)

TYPE FKF_ENUM = (FKF__FILTERKEYSON,   (* 0 *)
                 FKF__AVAILABLE,      (* 1 *)
                 FKF__HOTKEYACTIVE,   (* 2 *)
                 FKF__CONFIRMHOTKEY,  (* 3 *)
                 FKF__HOTKEYSOUND,    (* 4 *)
                 FKF__INDICATOR,      (* 5 *)
                 FKF__CLICKON);       (* 6 *)

     FKF_SET = SET OF FKF_ENUM;

CONST FKF_FILTERKEYSON    = FKF_SET {FKF__FILTERKEYSON }; (* 0x00000001 *)
      FKF_AVAILABLE       = FKF_SET {FKF__AVAILABLE    }; (* 0x00000002 *)
      FKF_HOTKEYACTIVE    = FKF_SET {FKF__HOTKEYACTIVE }; (* 0x00000004 *)
      FKF_CONFIRMHOTKEY   = FKF_SET {FKF__CONFIRMHOTKEY}; (* 0x00000008 *)
      FKF_HOTKEYSOUND     = FKF_SET {FKF__HOTKEYSOUND  }; (* 0x00000010 *)
      FKF_INDICATOR       = FKF_SET {FKF__INDICATOR    }; (* 0x00000020 *)
      FKF_CLICKON         = FKF_SET {FKF__CLICKON      }; (* 0x00000040 *)

TYPE FILTERKEYS = RECORD
                         cbSize      : UINT;
                         dwFlags     : FKF_SET;
                         iWaitMSec   : DWORD;          (* Acceptance Delay   *)
                         iDelayMSec  : DWORD;          (* Delay Until Repeat *)
                         iRepeatMSec : DWORD;          (* Repeat Rate        *)
                         iBounceMSec : DWORD;          (* Debounce Time      *)
                  END;
    PFILTERKEYS = POINTER TO FILTERKEYS;

(*
 * STICKYKEYS dwFlags field
 *)
TYPE SKF_ENUM = (SKF__STICKYKEYSON,    (* 0 *)
                 SKF__AVAILABLE,       (* 1 *)
                 SKF__HOTKEYACTIVE,    (* 2 *)
                 SKF__CONFIRMHOTKEY,   (* 3 *)
                 SKF__HOTKEYSOUND,     (* 4 *)
                 SKF__INDICATOR,       (* 5 *)
                 SKF__AUDIBLEFEEDBACK, (* 6 *)
                 SKF__TRISTATE,        (* 7 *)
                 SKF__TWOKEYSOFF);     (* 8 *)

     SKF_SET = SET OF SKF_ENUM;

CONST SKF_STICKYKEYSON    = SKF_SET {SKF__STICKYKEYSON   }; (* 0x00000001 *)
      SKF_AVAILABLE       = SKF_SET {SKF__AVAILABLE      }; (* 0x00000002 *)
      SKF_HOTKEYACTIVE    = SKF_SET {SKF__HOTKEYACTIVE   }; (* 0x00000004 *)
      SKF_CONFIRMHOTKEY   = SKF_SET {SKF__CONFIRMHOTKEY  }; (* 0x00000008 *)
      SKF_HOTKEYSOUND     = SKF_SET {SKF__HOTKEYSOUND    }; (* 0x00000010 *)
      SKF_INDICATOR       = SKF_SET {SKF__INDICATOR      }; (* 0x00000020 *)
      SKF_AUDIBLEFEEDBACK = SKF_SET {SKF__AUDIBLEFEEDBACK}; (* 0x00000040 *)
      SKF_TRISTATE        = SKF_SET {SKF__TRISTATE       }; (* 0x00000080 *)
      SKF_TWOKEYSOFF      = SKF_SET {SKF__TWOKEYSOFF     }; (* 0x00000100 *)


TYPE STICKYKEYS = RECORD
                         cbSiz   : UINT;
                         dwFlags : SKF_SET;
                  END;
    PSTICKYKEYS = POINTER TO STICKYKEYS;

(*
 * MOUSEKEYS dwFlags field
 *)

TYPE MKF_ENUM = (MKF__MOUSEKEYSON,     (* 0 *)
                 MKF__AVAILABLE,       (* 1 *)
                 MKF__HOTKEYACTIVE,    (* 2 *)
                 MKF__CONFIRMHOTKEY,   (* 3 *)
                 MKF__HOTKEYSOUND,     (* 4 *)
                 MKF__INDICATOR,       (* 5 *)
                 MKF__MODIFIERS,       (* 6 *)
                 MKF__REPLACENUMBERS); (* 7 *)

     MKF_SET = SET OF MKF_ENUM;

CONST MKF_MOUSEKEYSON     = MKF_SET {MKF__MOUSEKEYSON    }; (* 0x00000001 *)
      MKF_AVAILABLE       = MKF_SET {MKF__AVAILABLE      }; (* 0x00000002 *)
      MKF_HOTKEYACTIVE    = MKF_SET {MKF__HOTKEYACTIVE   }; (* 0x00000004 *)
      MKF_CONFIRMHOTKEY   = MKF_SET {MKF__CONFIRMHOTKEY  }; (* 0x00000008 *)
      MKF_HOTKEYSOUND     = MKF_SET {MKF__HOTKEYSOUND    }; (* 0x00000010 *)
      MKF_INDICATOR       = MKF_SET {MKF__INDICATOR      }; (* 0x00000020 *)
      MKF_MODIFIERS       = MKF_SET {MKF__MODIFIERS      }; (* 0x00000040 *)
      MKF_REPLACENUMBERS  = MKF_SET {MKF__REPLACENUMBERS }; (* 0x00000080 *)


TYPE MOUSEKEYS = RECORD
                        cbSize          : UINT;
                        dwFlags         : MKF_SET;
                        iMaxSpeed       : DWORD;
                        iTimeToMaxSpeed : DWORD;
                        iCtrlSpeed      : DWORD;
                        dwReserved1     : DWORD;
                        dwReserved2     : DWORD;
                 END;
    PMOUSEKEYS = POINTER TO MOUSEKEYS;

(*
 * ACCESSTIMEOUT dwFlags field
 *)
TYPE ATF_ENUM = (ATF__TIMEOUTON,      (* 0 *)
                 ATF__ONOFFFEEDBACK); (* 1 *)
     ATF_SET = SET OF ATF_ENUM;

CONST ATF_TIMEOUTON     = ATF_SET {ATF__TIMEOUTON};     (* 0x00000001 *)
      ATF_ONOFFFEEDBACK = ATF_SET {ATF__ONOFFFEEDBACK}; (* 0x00000002 *)


TYPE ACCESSTIMEOUT = RECORD
                            cbSize : UINT;
                            dwFlags : ATF_SET;
                            iTimeOutMSec : DWORD;
                     END;
    PACCESSTIMEOUT = POINTER TO ACCESSTIMEOUT;

(* values for SOUNDSENTRY iFSGrafEffect field *)

TYPE SSGF_ENUM = (SSGF_NONE,       (* 0 *)
                  SSGF_0, SSGF_1,
                  SSGF_DISPLAY);   (* 3 *)

(* values for SOUNDSENTRY iFSTextEffect field *)

TYPE SSTF_ENUM = (SSTF_NONE,     (* 0 *)
                  SSTF_CHARS,    (* 1 *)
                  SSTF_BORDER,   (* 2 *)
                  SSTF_DISPLAY); (* 3 *)

(* values for SOUNDSENTRY iWindowsEffect field *)

TYPE SSWF_ENUM = (SSWF_NONE,    (* 0 *)
                  SSWF_TITLE,   (* 1 *)
                  SSWF_WINDOW,  (* 2 *)
                  SSWF_DISPLAY, (* 3 *)
                  SSWF_CUSTOM); (* 4 *)


(*
 * SOUNDSENTRY dwFlags field
 *)
TYPE SSF_ENUM = (SSF__SOUNDSENTRYON, (* 0 *)
                 SSF__AVAILABLE,     (* 1 *)
                 SSF__INDICATOR);    (* 2 *)
     SSF_SET = SET OF SSF_ENUM;

CONST SSF_SOUNDSENTRYON   = SSF_SET {SSF__SOUNDSENTRYON}; (* 0x00000001 *)
      SSF_AVAILABLE       = SSF_SET {SSF__AVAILABLE    }; (* 0x00000002 *)
      SSF_INDICATOR       = SSF_SET {SSF__INDICATOR    }; (* 0x00000004 *)

TYPE SOUNDSENTRYA = RECORD
                           cbSize                 : UINT;
                           dwFlags                : SSF_SET;
                           iFSTextEffect          : SSTF_ENUM;
                           iFSTextEffectMSec      : DWORD;
                           iFSTextEffectColorBits : DWORD;
                           iFSGrafEffect          : SSGF_ENUM;
                           iFSGrafEffectMSec      : DWORD;
                           iFSGrafEffectColor     : DWORD;
                           iWindowsEffect         : SSWF_ENUM;
                           iWindowsEffectMSec     : DWORD;
                           lpszWindowsEffectDLL   : PSTR;
                           iWindowsEffectOrdinal  : DWORD;
                    END;
    PSOUNDSENTRYA = POINTER TO SOUNDSENTRYA;

TYPE SOUNDSENTRYW = RECORD
                           cbSize                 : UINT;
                           dwFlags                : SSF_SET;
                           iFSTextEffect          : SSTF_ENUM;
                           iFSTextEffectMSec      : DWORD;
                           iFSTextEffectColorBits : DWORD;
                           iFSGrafEffect          : SSGF_ENUM;
                           iFSGrafEffectMSec      : DWORD;
                           iFSGrafEffectColor     : DWORD;
                           iWindowsEffect         : SSWF_ENUM;
                           iWindowsEffectMSec     : DWORD;
                           lpszWindowsEffectDLL   : PWSTR;
                           iWindowsEffectOrdinal  : DWORD;
                    END;
    PSOUNDSENTRYW = POINTER TO SOUNDSENTRYW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE SOUNDSENTRY  = SOUNDSENTRYW;
           PSOUNDSENTRY = PSOUNDSENTRYW;
<* ELSE *>
      TYPE SOUNDSENTRY  = SOUNDSENTRYA;
           PSOUNDSENTRY = PSOUNDSENTRYA;
<* END *>

(*
 * TOGGLEKEYS dwFlags field
 *)

TYPE TKF_ENUM = (TKF__TOGGLEKEYSON,  (* 0 *)
                 TKF__AVAILABLE,     (* 1 *)
                 TKF__HOTKEYACTIVE,  (* 2 *)
                 TKF__CONFIRMHOTKEY, (* 3 *)
                 TKF__HOTKEYSOUND,   (* 4 *)
                 TKF__INDICATOR);    (* 5 *)

     TKF_SET = SET OF TKF_ENUM;

CONST TKF_TOGGLEKEYSON    = TKF_SET {TKF__TOGGLEKEYSON   }; (* 0x00000001 *)
      TKF_AVAILABLE       = TKF_SET {TKF__AVAILABLE      }; (* 0x00000002 *)
      TKF_HOTKEYACTIVE    = TKF_SET {TKF__HOTKEYACTIVE   }; (* 0x00000004 *)
      TKF_CONFIRMHOTKEY   = TKF_SET {TKF__CONFIRMHOTKEY  }; (* 0x00000008 *)
      TKF_HOTKEYSOUND     = TKF_SET {TKF__HOTKEYSOUND    }; (* 0x00000010 *)
      TKF_INDICATOR       = TKF_SET {TKF__INDICATOR      }; (* 0x00000020 *)


TYPE TOGGLEKEYS = RECORD
                         cbSize : UINT;
                         dwFlags : TKF_SET;
                  END;
    PTOGGLEKEYS = POINTER TO TOGGLEKEYS;


(*
 * Set debug level
 *)

PROCEDURE SetDebugErrorLevel (dwLevel : DWORD);

PROCEDURE SetLastErrorEx (dwErrCode : DWORD; dwType : SLE_ENUM);


(****************************************************************************
*                                                                           *
* WinNLS.def -- NLS procedure declarations, constant definitions and macros *
*                                                                           *
* Copyright (c) 1991-1995, Microsoft Corp. All rights reserved.             *
*                                                                           *
****************************************************************************)



(****************************************************************************
* Constants
*
* Define all constants for the NLS component here.
****************************************************************************)


(*
 *  String Length Maximums.
 *)

CONST MAX_LEADBYTES        = 12;             (* 5 ranges, 2 bytes ea., 0 term. *)
      MAX_DEFAULTCHAR      = 2;              (* single or double byte *)


(*
 *  MBCS and Unicode Translation Flags.
 *)

(* Flags for MultiByteToWideChar function *)

TYPE MULTIBYTE_ENUM = (MB__PRECOMPOSED,        (* 0 - use precomposed chars *)
                       MB__COMPOSITE,          (* 1 - use composite chars *)
                       MB__USEGLYPHCHARS,      (* 2 - use glyph chars, not ctrl chars *)
                       MB__ERR_INVALID_CHARS); (* 3 - error for invalid chars *)
     MULTIBYTE_SET = SET OF MULTIBYTE_ENUM;

CONST MB_PRECOMPOSED       = MULTIBYTE_SET {MB__PRECOMPOSED};       (* 00000001h *)
      MB_COMPOSITE         = MULTIBYTE_SET {MB__COMPOSITE};         (* 00000002h *)
      MB_USEGLYPHCHARS     = MULTIBYTE_SET {MB__USEGLYPHCHARS};     (* 00000004h *)
      MB_ERR_INVALID_CHARS = MULTIBYTE_SET {MB__ERR_INVALID_CHARS}; (* 00000008h *)


(* WideCharToMultiByte flags *)

TYPE WC_ENUM = (WC__0, WC__1,
                WC__2, WC__3,
                WC__DISCARDNS,       (* 4 - discard non-spacing chars *)
                WC__SEPCHARS,        (* 5 - generate separate chars *)
                WC__DEFAULTCHAR,     (* 6 - replace w/ default char *)
                WC__7,
                WC__DEFAULTCHECK,    (* 8 - check for default char *)
                WC__COMPOSITECHECK); (* 9 - convert composite to precomposed *)

     WC_SET = SET OF WC_ENUM;

CONST WC_DEFAULTCHECK   = WC_SET {WC__DEFAULTCHECK  }; (* 00000100h *)
      WC_COMPOSITECHECK = WC_SET {WC__COMPOSITECHECK}; (* 00000200h *)
      WC_DISCARDNS      = WC_SET {WC__DISCARDNS     }; (* 00000010h *)
      WC_SEPCHARS       = WC_SET {WC__SEPCHARS      }; (* 00000020h *)
      WC_DEFAULTCHAR    = WC_SET {WC__DEFAULTCHAR   }; (* 00000040h *)

(*
 *  Character Type Flags.
 *)

TYPE CT_ENUM = (CT__CTYPE1,  (* 0 - ctype 1 information *)
                CT__CTYPE2,  (* 1 - ctype 2 information *)
                CT__CTYPE3); (* 2 - ctype 3 information *)

     CT_SET = SET OF CT_ENUM;

CONST CT_CTYPE1 = CT_SET {CT__CTYPE1}; (* 00000001h *)
      CT_CTYPE2 = CT_SET {CT__CTYPE2}; (* 00000002h *)
      CT_CTYPE3 = CT_SET {CT__CTYPE3}; (* 00000004h *)

(*
 *  CType 1 Flag Bits.
 *)

CONST C1_UPPER             = 0001h;         (* upper case *)
      C1_LOWER             = 0002h;         (* lower case *)
      C1_DIGIT             = 0004h;         (* decimal digits *)
      C1_SPACE             = 0008h;         (* spacing characters *)
      C1_PUNCT             = 0010h;         (* punctuation characters *)
      C1_CNTRL             = 0020h;         (* control characters *)
      C1_BLANK             = 0040h;         (* blank characters *)
      C1_XDIGIT            = 0080h;         (* other digits *)
      C1_ALPHA             = 0100h;         (* any linguistic character *)

(*
 *  CType 2 Flag Bits.
 *)
      C2_LEFTTORIGHT       = 0001h;         (* left to right *)
      C2_RIGHTTOLEFT       = 0002h;         (* right to left *)

      C2_EUROPENUMBER      = 0003h;         (* European number, digit *)
      C2_EUROPESEPARATOR   = 0004h;         (* European numeric separator *)
      C2_EUROPETERMINATOR  = 0005h;         (* European numeric terminator *)
      C2_ARABICNUMBER      = 0006h;         (* Arabic number *)
      C2_COMMONSEPARATOR   = 0007h;         (* common numeric separator *)

      C2_BLOCKSEPARATOR    = 0008h;         (* block separator *)
      C2_SEGMENTSEPARATOR  = 0009h;         (* segment separator *)
      C2_WHITESPACE        = 000Ah;         (* white space *)
      C2_OTHERNEUTRAL      = 000Bh;         (* other neutrals *)

      C2_NOTAPPLICABLE     = 0000h;         (* no implicit directionality *)

(*
 *  CType 3 Flag Bits.
 *)

      C3_NONSPACING        = 0001h;         (* nonspacing character *)
      C3_DIACRITIC         = 0002h;         (* diacritic mark *)
      C3_VOWELMARK         = 0004h;         (* vowel mark *)
      C3_SYMBOL            = 0008h;         (* symbols *)

      C3_KATAKANA          = 0010h;         (* katakana character *)
      C3_HIRAGANA          = 0020h;         (* hiragana character *)
      C3_HALFWIDTH         = 0040h;         (* half width character *)
      C3_FULLWIDTH         = 0080h;         (* full width character *)
      C3_IDEOGRAPH         = 0100h;         (* ideographic character *)
      C3_KASHIDA           = 0200h;         (* Arabic kashida character *)
      C3_LEXICAL           = 0400h;         (* lexical character *)

      C3_ALPHA             = 8000h;         (* any linguistic char (C1_ALPHA) *)

      C3_NOTAPPLICABLE     = 0000h;         (* ctype 3 is not applicable *)

(*
 *  String Flags.
 *)

TYPE SFLAGS_ENUM = (SFLAGS__0,  SFLAGS__1,  SFLAGS__2,  SFLAGS__3,
                    SFLAGS__4,  SFLAGS__5,  SFLAGS__6,  SFLAGS__7,
                    SFLAGS__8,  SFLAGS__9,  SFLAGS__10, SFLAGS__11,
                    SFLAGS__12, SFLAGS__13, SFLAGS__14, SFLAGS__15,
                    SFLAGS__16, SFLAGS__17, SFLAGS__18, SFLAGS__19,
                    SFLAGS__20, SFLAGS__21, SFLAGS__22, SFLAGS__23);

     SFLAGS_SET = SET OF SFLAGS_ENUM;

CONST NORM__IGNORECASE     = SFLAGS__0;  (* ignore case *)
      NORM__IGNORENONSPACE = SFLAGS__1;  (* ignore nonspacing chars *)
      NORM__IGNORESYMBOLS  = SFLAGS__2;  (* ignore symbols *)
      NORM__IGNOREKANATYPE = SFLAGS__16; (* ignore kanatype *)
      NORM__IGNOREWIDTH    = SFLAGS__17; (* ignore width *)

TYPE NORM_SET = SFLAGS_SET;

CONST NORM_IGNORECASE     = NORM_SET {NORM__IGNORECASE    }; (* 00000001h *)
      NORM_IGNORENONSPACE = NORM_SET {NORM__IGNORENONSPACE}; (* 00000002h *)
      NORM_IGNORESYMBOLS  = NORM_SET {NORM__IGNORESYMBOLS }; (* 00000004h *)
      NORM_IGNOREKANATYPE = NORM_SET {NORM__IGNOREKANATYPE}; (* 00010000h *)
      NORM_IGNOREWIDTH    = NORM_SET {NORM__IGNOREWIDTH   }; (* 00020000h *)

(* Locale Independent Mapping Flags. *) 

TYPE MAP_ENUM = (MAP__0, MAP__1,
                 MAP__2, MAP__3,
                 MAP__FOLDCZONE,   (* 4 - fold compatibility zone chars *)
                 MAP__PRECOMPOSED, (* 5 - convert to precomposed chars *)
                 MAP__COMPOSITE,   (* 6 - convert to composite chars *)
                 MAP__FOLDDIGITS); (* 7 - all digits to ASCII 0-9 *)

     MAP_SET = SET OF MAP_ENUM;

CONST MAP_FOLDCZONE   = MAP_SET {MAP__FOLDCZONE  }; (* 00000010h *)
      MAP_PRECOMPOSED = MAP_SET {MAP__PRECOMPOSED}; (* 00000020h *)
      MAP_COMPOSITE   = MAP_SET {MAP__COMPOSITE  }; (* 00000040h *)
      MAP_FOLDDIGITS  = MAP_SET {MAP__FOLDDIGITS }; (* 00000080h *)

(*
 *  Locale Dependent Mapping Flags.
 *)

CONST LCMAP__LOWERCASE = SFLAGS__8;   (* lower case letters *)
      LCMAP__UPPERCASE = SFLAGS__9;   (* upper case letters *)
      LCMAP__SORTKEY   = SFLAGS__10;  (* WC sort key (normalize) *)
      LCMAP__BYTEREV   = SFLAGS__11;  (* byte reversal *)

      LCMAP__HIRAGANA  = SFLAGS__20;  (* map katakana to hiragana *)
      LCMAP__KATAKANA  = SFLAGS__21;  (* map hiragana to katakana *)
      LCMAP__HALFWIDTH = SFLAGS__22;  (* map double byte to single byte *)
      LCMAP__FULLWIDTH = SFLAGS__23;  (* map single byte to double byte *)

CONST LCMAP_LOWERCASE         = SFLAGS_SET {LCMAP__LOWERCASE}; (* 00000100h *)
      LCMAP_UPPERCASE         = SFLAGS_SET {LCMAP__UPPERCASE}; (* 00000200h *)
      LCMAP_SORTKEY           = SFLAGS_SET {LCMAP__SORTKEY  }; (* 00000400h *)
      LCMAP_BYTEREV           = SFLAGS_SET {LCMAP__BYTEREV  }; (* 00000800h *)

      LCMAP_HIRAGANA          = SFLAGS_SET {LCMAP__HIRAGANA }; (* 00100000h *)
      LCMAP_KATAKANA          = SFLAGS_SET {LCMAP__KATAKANA }; (* 00200000h *)
      LCMAP_HALFWIDTH         = SFLAGS_SET {LCMAP__HALFWIDTH}; (* 00400000h *)
      LCMAP_FULLWIDTH         = SFLAGS_SET {LCMAP__FULLWIDTH}; (* 00800000h *)



(*
 *  Locale Enumeration Flags.
 *)

TYPE LCID_ENUM_TYPE = (LCID_0,
                       LCID_INSTALLED,  (* 00000001h - installed locale ids *)
                       LCID_SUPPORTED); (* 00000002h - supported locale ids *)

(*
 *  Code Page Enumeration Flags.
 *)

TYPE CP_ENUM_TYPE = (CP_0,
                     CP_INSTALLED,  (* 00000001h - installed code page ids *)
                     CP_SUPPORTED); (* 00000002h - supported code page ids *)


(*
 *  Sorting Flags.
 *
 *    WORD Sort:    culturally correct sort
 *                  hyphen and apostrophe are special cased
 *                  example: "coop" and "co-op" will sort together in a list
 *
 *                        co_op     <-------  underscore (symbol)
 *                        coat
 *                        comb
 *                        coop
 *                        co-op     <-------  hyphen (punctuation)
 *                        cork
 *                        went
 *                        were
 *                        we're     <-------  apostrophe (punctuation)
 *
 *
 *    STRING Sort:  hyphen and apostrophe will sort with all other symbols
 *
 *                        co-op     <-------  hyphen (punctuation)
 *                        co_op     <-------  underscore (symbol)
 *                        coat
 *                        comb
 *                        coop
 *                        cork
 *                        we're     <-------  apostrophe (punctuation)
 *                        went
 *                        were
 *)



CONST SORT__STRINGSORT = SFLAGS__12; (* use string sort method *)

CONST SORT_STRINGSORT = SFLAGS_SET {SORT__STRINGSORT}; (* 00001000h *)


(*
 *  Code Page Default Values.
 *)

CONST CP_ACP               = 0;              (* default to ANSI code page *)
      CP_OEMCP             = 1;              (* default to OEM  code page *)
      CP_MACCP             = 2;              (* default to MAC  code page *)

(*
 *  Country Codes.
 *)

CONST CTRY_DEFAULT                     = 0;

      CTRY_AUSTRALIA                   = 61;      (* Australia *)
      CTRY_AUSTRIA                     = 43;      (* Austria *)
      CTRY_BELGIUM                     = 32;      (* Belgium *)
      CTRY_BRAZIL                      = 55;      (* Brazil *)
      CTRY_BULGARIA                    = 359;     (* Bulgaria *)
      CTRY_CANADA                      = 2;       (* Canada *)
      CTRY_CROATIA                     = 385;     (* Croatia *)
      CTRY_CZECH                       = 42;      (* Czech Republic *)
      CTRY_DENMARK                     = 45;      (* Denmark *)
      CTRY_FINLAND                     = 358;     (* Finland *)
      CTRY_FRANCE                      = 33;      (* France *)
      CTRY_GERMANY                     = 49;      (* Germany *)
      CTRY_GREECE                      = 30;      (* Greece *)
      CTRY_HONG_KONG                   = 852;     (* Hong Kong *)
      CTRY_HUNGARY                     = 36;      (* Hungary *)
      CTRY_ICELAND                     = 354;     (* Iceland *)
      CTRY_IRELAND                     = 353;     (* Ireland *)
      CTRY_ITALY                       = 39;      (* Italy *)
      CTRY_JAPAN                       = 81;      (* Japan *)
      CTRY_MEXICO                      = 52;      (* Mexico *)
      CTRY_NETHERLANDS                 = 31;      (* Netherlands *)
      CTRY_NEW_ZEALAND                 = 64;      (* New Zealand *)
      CTRY_NORWAY                      = 47;      (* Norway *)
      CTRY_POLAND                      = 48;      (* Poland *)
      CTRY_PORTUGAL                    = 351;     (* Portugal *)
      CTRY_PRCHINA                     = 86;      (* Peoples' Republic of China *)
      CTRY_ROMANIA                     = 40;      (* Romania *)
      CTRY_RUSSIA                      = 7;       (* Russia *)
      CTRY_SINGAPORE                   = 65;      (* Singapore *)
      CTRY_SLOVAK                      = 42;      (* Slovak Republic *)
      CTRY_SLOVENIA                    = 386;     (* Slovenia *)
      CTRY_SOUTH_KOREA                 = 82;      (* South Korea *)
      CTRY_SPAIN                       = 34;      (* Spain *)
      CTRY_SWEDEN                      = 46;      (* Sweden *)
      CTRY_SWITZERLAND                 = 41;      (* Switzerland *)
      CTRY_TAIWAN                      = 886;     (* Taiwan *)
      CTRY_TURKEY                      = 90;      (* Turkey *)
      CTRY_UNITED_KINGDOM              = 44;      (* United Kingdom *)
      CTRY_UNITED_STATES               = 1;       (* United States *)


(*
 *  Locale Types.
 *
 *  These types are used for the GetLocaleInfoW NLS API routine.
 *
 *  LOCALE_NOUSEROVERRIDE is also used in GetTimeFormatW and GetDateFormatW.
 *
 *  LOCALE_USE_CP_ACP is used in many of the A (Ansi) apis that need to do
 *  string translation.
 *)


CONST LOCALE_NOUSEROVERRIDE       = 80000000h;   (* do not use user overrides *)
      LOCALE_USE_CP_ACP           = 40000000h;   (* use the system ACP *)

      LOCALE_ILANGUAGE            = 00000001h;   (* language id *)
      LOCALE_SLANGUAGE            = 00000002h;   (* localized name of language *)
      LOCALE_SENGLANGUAGE         = 00001001h;   (* English name of language *)
      LOCALE_SABBREVLANGNAME      = 00000003h;   (* abbreviated language name *)
      LOCALE_SNATIVELANGNAME      = 00000004h;   (* native name of language *)
      LOCALE_ICOUNTRY             = 00000005h;   (* country code *)
      LOCALE_SCOUNTRY             = 00000006h;   (* localized name of country *)
      LOCALE_SENGCOUNTRY          = 00001002h;   (* English name of country *)
      LOCALE_SABBREVCTRYNAME      = 00000007h;   (* abbreviated country name *)
      LOCALE_SNATIVECTRYNAME      = 00000008h;   (* native name of country *)
      LOCALE_IDEFAULTLANGUAGE     = 00000009h;   (* default language id *)
      LOCALE_IDEFAULTCOUNTRY      = 0000000Ah;   (* default country code *)
      LOCALE_IDEFAULTCODEPAGE     = 0000000Bh;   (* default oem code page *)
      LOCALE_IDEFAULTANSICODEPAGE = 00001004h;   (* default ansi code page *)

      LOCALE_SLIST                = 0000000Ch;   (* list item separator *)
      LOCALE_IMEASURE             = 0000000Dh;   (* 0 = metric, 1 = US *)

      LOCALE_SDECIMAL             = 0000000Eh;   (* decimal separator *)
      LOCALE_STHOUSAND            = 0000000Fh;   (* thousand separator *)
      LOCALE_SGROUPING            = 00000010h;   (* digit grouping *)
      LOCALE_IDIGITS              = 00000011h;   (* number of fractional digits *)
      LOCALE_ILZERO               = 00000012h;   (* leading zeros for decimal *)
      LOCALE_INEGNUMBER           = 00001010h;   (* negative number mode *)
      LOCALE_SNATIVEDIGITS        = 00000013h;   (* native ascii 0-9 *)

      LOCALE_SCURRENCY            = 00000014h;   (* local monetary symbol *)
      LOCALE_SINTLSYMBOL          = 00000015h;   (* intl monetary symbol *)
      LOCALE_SMONDECIMALSEP       = 00000016h;   (* monetary decimal separator *)
      LOCALE_SMONTHOUSANDSEP      = 00000017h;   (* monetary thousand separator *)
      LOCALE_SMONGROUPING         = 00000018h;   (* monetary grouping *)
      LOCALE_ICURRDIGITS          = 00000019h;   (* # local monetary digits *)
      LOCALE_IINTLCURRDIGITS      = 0000001Ah;   (* # intl monetary digits *)
      LOCALE_ICURRENCY            = 0000001Bh;   (* positive currency mode *)
      LOCALE_INEGCURR             = 0000001Ch;   (* negative currency mode *)

      LOCALE_SDATE                = 0000001Dh;   (* date separator *)
      LOCALE_STIME                = 0000001Eh;   (* time separator *)
      LOCALE_SSHORTDATE           = 0000001Fh;   (* short date format string *)
      LOCALE_SLONGDATE            = 00000020h;   (* long date format string *)
      LOCALE_STIMEFORMAT          = 00001003h;   (* time format string *)
      LOCALE_IDATE                = 00000021h;   (* short date format ordering *)
      LOCALE_ILDATE               = 00000022h;   (* long date format ordering *)
      LOCALE_ITIME                = 00000023h;   (* time format specifier *)
      LOCALE_ITIMEMARKPOSN        = 00001005h;   (* time marker position *)
      LOCALE_ICENTURY             = 00000024h;   (* century format specifier (short date) *)
      LOCALE_ITLZERO              = 00000025h;   (* leading zeros in time field *)
      LOCALE_IDAYLZERO            = 00000026h;   (* leading zeros in day field (short date) *)
      LOCALE_IMONLZERO            = 00000027h;   (* leading zeros in month field (short date) *)
      LOCALE_S1159                = 00000028h;   (* AM designator *)
      LOCALE_S2359                = 00000029h;   (* PM designator *)

      LOCALE_ICALENDARTYPE        = 00001009h;   (* type of calendar specifier *)
      LOCALE_IOPTIONALCALENDAR    = 0000100Bh;   (* additional calendar types specifier *)
      LOCALE_IFIRSTDAYOFWEEK      = 0000100Ch;   (* first day of week specifier *)
      LOCALE_IFIRSTWEEKOFYEAR     = 0000100Dh;   (* first week of year specifier *)

      LOCALE_SDAYNAME1            = 0000002Ah;   (* long name for Monday *)
      LOCALE_SDAYNAME2            = 0000002Bh;   (* long name for Tuesday *)
      LOCALE_SDAYNAME3            = 0000002Ch;   (* long name for Wednesday *)
      LOCALE_SDAYNAME4            = 0000002Dh;   (* long name for Thursday *)
      LOCALE_SDAYNAME5            = 0000002Eh;   (* long name for Friday *)
      LOCALE_SDAYNAME6            = 0000002Fh;   (* long name for Saturday *)
      LOCALE_SDAYNAME7            = 00000030h;   (* long name for Sunday *)
      LOCALE_SABBREVDAYNAME1      = 00000031h;   (* abbreviated name for Monday *)
      LOCALE_SABBREVDAYNAME2      = 00000032h;   (* abbreviated name for Tuesday *)
      LOCALE_SABBREVDAYNAME3      = 00000033h;   (* abbreviated name for Wednesday *)
      LOCALE_SABBREVDAYNAME4      = 00000034h;   (* abbreviated name for Thursday *)
      LOCALE_SABBREVDAYNAME5      = 00000035h;   (* abbreviated name for Friday *)
      LOCALE_SABBREVDAYNAME6      = 00000036h;   (* abbreviated name for Saturday *)
      LOCALE_SABBREVDAYNAME7      = 00000037h;   (* abbreviated name for Sunday *)
      LOCALE_SMONTHNAME1          = 00000038h;   (* long name for January *)
      LOCALE_SMONTHNAME2          = 00000039h;   (* long name for February *)
      LOCALE_SMONTHNAME3          = 0000003Ah;   (* long name for March *)
      LOCALE_SMONTHNAME4          = 0000003Bh;   (* long name for April *)
      LOCALE_SMONTHNAME5          = 0000003Ch;   (* long name for May *)
      LOCALE_SMONTHNAME6          = 0000003Dh;   (* long name for June *)
      LOCALE_SMONTHNAME7          = 0000003Eh;   (* long name for July *)
      LOCALE_SMONTHNAME8          = 0000003Fh;   (* long name for August *)
      LOCALE_SMONTHNAME9          = 00000040h;   (* long name for September *)
      LOCALE_SMONTHNAME10         = 00000041h;   (* long name for October *)
      LOCALE_SMONTHNAME11         = 00000042h;   (* long name for November *)
      LOCALE_SMONTHNAME12         = 00000043h;   (* long name for December *)
      LOCALE_SMONTHNAME13         = 0000100Eh;   (* long name for 13th month (if exists) *)
      LOCALE_SABBREVMONTHNAME1    = 00000044h;   (* abbreviated name for January *)
      LOCALE_SABBREVMONTHNAME2    = 00000045h;   (* abbreviated name for February *)
      LOCALE_SABBREVMONTHNAME3    = 00000046h;   (* abbreviated name for March *)
      LOCALE_SABBREVMONTHNAME4    = 00000047h;   (* abbreviated name for April *)
      LOCALE_SABBREVMONTHNAME5    = 00000048h;   (* abbreviated name for May *)
      LOCALE_SABBREVMONTHNAME6    = 00000049h;   (* abbreviated name for June *)
      LOCALE_SABBREVMONTHNAME7    = 0000004Ah;   (* abbreviated name for July *)
      LOCALE_SABBREVMONTHNAME8    = 0000004Bh;   (* abbreviated name for August *)
      LOCALE_SABBREVMONTHNAME9    = 0000004Ch;   (* abbreviated name for September *)
      LOCALE_SABBREVMONTHNAME10   = 0000004Dh;   (* abbreviated name for October *)
      LOCALE_SABBREVMONTHNAME11   = 0000004Eh;   (* abbreviated name for November *)
      LOCALE_SABBREVMONTHNAME12   = 0000004Fh;   (* abbreviated name for December *)
      LOCALE_SABBREVMONTHNAME13   = 0000100Fh;   (* abbreviated name for 13th month (if exists) *)

      LOCALE_SPOSITIVESIGN        = 00000050h;   (* positive sign *)
      LOCALE_SNEGATIVESIGN        = 00000051h;   (* negative sign *)
      LOCALE_IPOSSIGNPOSN         = 00000052h;   (* positive sign position *)
      LOCALE_INEGSIGNPOSN         = 00000053h;   (* negative sign position *)
      LOCALE_IPOSSYMPRECEDES      = 00000054h;   (* mon sym precedes pos amt *)
      LOCALE_IPOSSEPBYSPACE       = 00000055h;   (* mon sym sep by space from pos amt *)
      LOCALE_INEGSYMPRECEDES      = 00000056h;   (* mon sym precedes neg amt *)
      LOCALE_INEGSEPBYSPACE       = 00000057h;   (* mon sym sep by space from neg amt *)

      LOCALE_FONTSIGNATURE        = 00000058h; (* font signature *)


(*
 *  Time Flags for GetTimeFormatW.
 *)

TYPE TIME_ENUM = (TIME__NOMINUTESORSECONDS, (* 0 - do not use minutes or seconds *)
                  TIME__NOSECONDS,          (* 1 - do not use seconds *)
                  TIME__NOTIMEMARKER,       (* 2 - do not use time marker *)
                  TIME__FORCE24HOURFORMAT); (* 3 - always use 24 hour format *)

     TIME_SET = SET OF TIME_ENUM;

CONST TIME_NOMINUTESORSECONDS = TIME_SET {TIME__NOMINUTESORSECONDS}; (* 00000001h *)
      TIME_NOSECONDS          = TIME_SET {TIME__NOSECONDS         }; (* 00000002h *)
      TIME_NOTIMEMARKER       = TIME_SET {TIME__NOTIMEMARKER      }; (* 00000004h *)
      TIME_FORCE24HOURFORMAT  = TIME_SET {TIME__FORCE24HOURFORMAT }; (* 00000008h *)

(*
 *  Date Flags for GetDateFormatW.
 *)

TYPE DATE_ENUM = (DATE__SHORTDATE,         (* 0 - use short date picture *)
                  DATE__LONGDATE,          (* 1 - use long date picture *)
                  DATE__USE_ALT_CALENDAR); (* 2 - use alternate calendar (if any) *)

     DATE_SET = SET OF DATE_ENUM;

CONST DATE_SHORTDATE        = DATE_SET {DATE__SHORTDATE       }; (* 00000001h *)
      DATE_LONGDATE         = DATE_SET {DATE__LONGDATE        }; (* 00000002h *)
      DATE_USE_ALT_CALENDAR = DATE_SET {DATE__USE_ALT_CALENDAR}; (* 00000004h *)


(*
 *  Calendar Types.
 *
 *  These types are used for the GetALTCalendarInfoW NLS API routine.
 *)

CONST CAL_ICALINTVALUE           = 00000001h;   (* calendar type *)
      CAL_SCALNAME               = 00000002h;   (* native name of calendar *)
      CAL_IYEAROFFSETRANGE       = 00000003h;   (* starting years of eras *)
      CAL_SERASTRING             = 00000004h;   (* era name for IYearOffsetRanges *)
      CAL_SSHORTDATE             = 00000005h;   (* short date format string *)
      CAL_SLONGDATE              = 00000006h;   (* long date format string *)
      CAL_SDAYNAME1              = 00000007h;   (* native name for Monday *)
      CAL_SDAYNAME2              = 00000008h;   (* native name for Tuesday *)
      CAL_SDAYNAME3              = 00000009h;   (* native name for Wednesday *)
      CAL_SDAYNAME4              = 0000000ah;   (* native name for Thursday *)
      CAL_SDAYNAME5              = 0000000bh;   (* native name for Friday *)
      CAL_SDAYNAME6              = 0000000ch;   (* native name for Saturday *)
      CAL_SDAYNAME7              = 0000000dh;   (* native name for Sunday *)
      CAL_SABBREVDAYNAME1        = 0000000eh;   (* abbreviated name for Monday *)
      CAL_SABBREVDAYNAME2        = 0000000fh;   (* abbreviated name for Tuesday *)
      CAL_SABBREVDAYNAME3        = 00000010h;   (* abbreviated name for Wednesday *)
      CAL_SABBREVDAYNAME4        = 00000011h;   (* abbreviated name for Thursday *)
      CAL_SABBREVDAYNAME5        = 00000012h;   (* abbreviated name for Friday *)
      CAL_SABBREVDAYNAME6        = 00000013h;   (* abbreviated name for Saturday *)
      CAL_SABBREVDAYNAME7        = 00000014h;   (* abbreviated name for Sunday *)
      CAL_SMONTHNAME1            = 00000015h;   (* native name for January *)
      CAL_SMONTHNAME2            = 00000016h;   (* native name for February *)
      CAL_SMONTHNAME3            = 00000017h;   (* native name for March *)
      CAL_SMONTHNAME4            = 00000018h;   (* native name for April *)
      CAL_SMONTHNAME5            = 00000019h;   (* native name for May *)
      CAL_SMONTHNAME6            = 0000001ah;   (* native name for June *)
      CAL_SMONTHNAME7            = 0000001bh;   (* native name for July *)
      CAL_SMONTHNAME8            = 0000001ch;   (* native name for August *)
      CAL_SMONTHNAME9            = 0000001dh;   (* native name for September *)
      CAL_SMONTHNAME10           = 0000001eh;   (* native name for October *)
      CAL_SMONTHNAME11           = 0000001fh;   (* native name for November *)
      CAL_SMONTHNAME12           = 00000020h;   (* native name for December *)
      CAL_SMONTHNAME13           = 00000021h;   (* native name for 13th month (if any) *)
      CAL_SABBREVMONTHNAME1      = 00000022h;   (* abbreviated name for January *)
      CAL_SABBREVMONTHNAME2      = 00000023h;   (* abbreviated name for February *)
      CAL_SABBREVMONTHNAME3      = 00000024h;   (* abbreviated name for March *)
      CAL_SABBREVMONTHNAME4      = 00000025h;   (* abbreviated name for April *)
      CAL_SABBREVMONTHNAME5      = 00000026h;   (* abbreviated name for May *)
      CAL_SABBREVMONTHNAME6      = 00000027h;   (* abbreviated name for June *)
      CAL_SABBREVMONTHNAME7      = 00000028h;   (* abbreviated name for July *)
      CAL_SABBREVMONTHNAME8      = 00000029h;   (* abbreviated name for August *)
      CAL_SABBREVMONTHNAME9      = 0000002ah;   (* abbreviated name for September *)
      CAL_SABBREVMONTHNAME10     = 0000002bh;   (* abbreviated name for October *)
      CAL_SABBREVMONTHNAME11     = 0000002ch;   (* abbreviated name for November *)
      CAL_SABBREVMONTHNAME12     = 0000002dh;   (* abbreviated name for December *)
      CAL_SABBREVMONTHNAME13     = 0000002eh;   (* abbreviated name for 13th month (if any) *)


(*
 *  Calendar Enumeration Value.
 *)

CONST ENUM_ALL_CALENDARS = 0ffffffffh;   (* enumerate all calendars *)


(*
 *  Calendar ID Values.
 *)

CONST CAL_GREGORIAN    = 1;         (* Gregorian (localized) calendar *)
      CAL_GREGORIAN_US = 2;         (* Gregorian (U.S.) calendar *)
      CAL_JAPAN        = 3;         (* Japanese Emperor Era calendar *)
      CAL_TAIWAN       = 4;         (* Republic of China Era calendar *)
      CAL_KOREA        = 5;         (* Korean Tangun Era calendar *)


(***************************************************************************
*
*    Define all types for the NLS component here.
*
***************************************************************************)

(*
 *  Locale type constant.
 *)

TYPE LCTYPE = DWORD;

(*
 *  Calendar type constant.
 *)

TYPE CALTYPE = DWORD;

(*
 *  Calendar ID.
 *)

TYPE CALID = DWORD;


(*
 *  CP Info.
 *)

TYPE CPINFO = RECORD
                     MaxCharSize : UINT;                                (* max length (bytes) of a char *)
                     DefaultChar : ARRAY [0..MAX_DEFAULTCHAR-1] OF BYTE; (* default character *)
                     LeadByte    : ARRAY [0..MAX_LEADBYTES-1]   OF BYTE; (* lead byte ranges *)
              END;
    PCPINFO = POINTER TO CPINFO;


(*
 *  Number format.
 *)

TYPE NUMBERFMTA =
     RECORD
          NumDigits     : UINT;         (* number of decimal digits *)
          LeadingZero   : UINT;         (* if leading zero in decimal fields *)
          Grouping      : UINT;         (* group size left of decimal *)
          lpDecimalSep  : PSTR;         (* ptr to decimal separator string *)
          lpThousandSep : PSTR;         (* ptr to thousand separator string *)
          NegativeOrder : UINT;         (* negative number ordering *)
     END;
     PNUMBERFMTA = POINTER TO NUMBERFMTA;
    PCNUMBERFMTA = POINTER TO NUMBERFMTA;

TYPE NUMBERFMTW =
     RECORD
            NumDigits     : UINT;       (* number of decimal digits *)
            LeadingZero   : UINT;       (* if leading zero in decimal fields *)
            Grouping      : UINT;       (* group size left of decimal *)
            lpDecimalSep  : PWSTR;      (* ptr to decimal separator string *)
            lpThousandSep : PWSTR;      (* ptr to thousand separator string *)
            NegativeOrder : UINT;       (* negative number ordering *)
     END;
     PNUMBERFMTW = POINTER TO NUMBERFMTW;
    PCNUMBERFMTW = POINTER TO NUMBERFMTW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE NUMBERFMT  = NUMBERFMTW;
      TYPE PNUMBERFMT = PNUMBERFMTW;
<* ELSE *>
      TYPE NUMBERFMT  = NUMBERFMTA;
      TYPE PNUMBERFMT = PNUMBERFMTA;
<* END *>

(*
 *  Currency format.
 *)

TYPE CURRENCYFMTA =
     RECORD
            NumDigits        : UINT;    (* number of decimal digits *)
            LeadingZero      : UINT;    (* if leading zero in decimal fields *)
            Grouping         : UINT;    (* group size left of decimal *)
            lpDecimalSep     : PSTR;    (* ptr to decimal separator string *)
            lpThousandSep    : PSTR;    (* ptr to thousand separator string *)
            NegativeOrder    : UINT;    (* negative currency ordering *)
            PositiveOrder    : UINT;    (* positive currency ordering *)
            lpCurrencySymbol : PSTR;    (* ptr to currency symbol string *)
     END;
     PCURRENCYFMTA = POINTER TO CURRENCYFMTA;
    PCCURRENCYFMTA = POINTER TO CURRENCYFMTA;

TYPE CURRENCYFMTW =
     RECORD
            NumDigits        : UINT;    (* number of decimal digits *)
            LeadingZero      : UINT;    (* if leading zero in decimal fields *)
            Grouping         : UINT;    (* group size left of decimal *)
            lpDecimalSep     : PWSTR;   (* ptr to decimal separator string *)
            lpThousandSep    : PWSTR;   (* ptr to thousand separator string *)
            NegativeOrder    : UINT;    (* negative currency ordering *)
            PositiveOrder    : UINT;    (* positive currency ordering *)
            lpCurrencySymbol : PWSTR;   (* ptr to currency symbol string *)
     END;
     PCURRENCYFMTW = POINTER TO CURRENCYFMTW;
    PCCURRENCYFMTW = POINTER TO CURRENCYFMTW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  CURRENCYFMT =  CURRENCYFMTW;
      TYPE PCURRENCYFMT = PCURRENCYFMTW;
<* ELSE *>
      TYPE  CURRENCYFMT =  CURRENCYFMTA;
      TYPE PCURRENCYFMT = PCURRENCYFMTA;
<* END *>


(*
 *  Enumeration function constants.
 *)

TYPE LOCALE_ENUMPROCA   = PROCEDURE (PSTR) : BOOL;
     CODEPAGE_ENUMPROCA = PROCEDURE (PSTR) : BOOL;
     DATEFMT_ENUMPROCA  = PROCEDURE (PSTR) : BOOL;
     TIMEFMT_ENUMPROCA  = PROCEDURE (PSTR) : BOOL;
     CALINFO_ENUMPROCA  = PROCEDURE (PSTR) : BOOL;

TYPE LOCALE_ENUMPROCW   = PROCEDURE (PWSTR) : BOOL;
     CODEPAGE_ENUMPROCW = PROCEDURE (PWSTR) : BOOL;
     DATEFMT_ENUMPROCW  = PROCEDURE (PWSTR) : BOOL;
     TIMEFMT_ENUMPROCW  = PROCEDURE (PWSTR) : BOOL;
     CALINFO_ENUMPROCW  = PROCEDURE (PWSTR) : BOOL;


<* IF DEFINED (UNICODE) THEN *>
      TYPE LOCALE_ENUMPROC    = LOCALE_ENUMPROCW;
           CODEPAGE_ENUMPROC  = CODEPAGE_ENUMPROCW;
           DATEFMT_ENUMPROC   = DATEFMT_ENUMPROCW;
           TIMEFMT_ENUMPROC   = TIMEFMT_ENUMPROCW;
           CALINFO_ENUMPROC   = CALINFO_ENUMPROCW;
<* ELSE *>
      TYPE LOCALE_ENUMPROC    = LOCALE_ENUMPROCA;
           CODEPAGE_ENUMPROC  = CODEPAGE_ENUMPROCA;
           DATEFMT_ENUMPROC   = DATEFMT_ENUMPROCA;
           TIMEFMT_ENUMPROC   = TIMEFMT_ENUMPROCA;
           CALINFO_ENUMPROC   = CALINFO_ENUMPROCA;
<* END *>


(***************************************************************************
* Function Prototypes
*
* Only prototypes for the NLS APIs should go here.
****************************************************************************)

(*
 *  Code Page Dependent APIs.
 *)

PROCEDURE IsValidCodePage(CodePage : UINT) : BOOL;

PROCEDURE GetACP () : BOOL;
PROCEDURE GetOEMCP (): UINT;

PROCEDURE GetCPInfo(CodePage : UINT; VAR lpCPInfo : CPINFO) : BOOL;

PROCEDURE IsDBCSLeadByte (TestChar : BYTE) : BOOL;

PROCEDURE IsDBCSLeadByteEx (CodePage : UINT; TestChar : BYTE) : BOOL;

PROCEDURE MultiByteToWideChar (CodePage        : UINT;
                               dwFlags         : MULTIBYTE_SET;
                               MultiByteStr    : ARRAY OF CHAR;
                               cchMultiByte    : INTEGER;
                               VAR WideCharStr : ARRAY OF WCHAR;
                               cchWideChar     : INTEGER) : INTEGER ;

PROCEDURE WideCharToMultiByte (CodePage          : UINT;
                               dwFlags           : WC_SET;
                               WideCharStr       : ARRAY OF WCHAR;
                               cchWideChar       : INTEGER;
                               VAR MultiByteStr  : ARRAY OF CHAR;
                               cchMultiByte      : INTEGER;
                               lpDefaultChar     : PCHAR;
                               lpUsedDefaultChar : PBOOL) : INTEGER;

(*
 *  Locale Dependent APIs.
 *)

PROCEDURE CompareStringA (Locale     : LCID;
                          dwCmpFlags : SFLAGS_SET;
                          String1    : ARRAY OF CHAR;
                          cchCount1  : INTEGER;
                          String2    : ARRAY OF CHAR;
                          cchCount2  : INTEGER) : INTEGER;

PROCEDURE CompareStringW (Locale     : LCID;
                          dwCmpFlags : SFLAGS_SET;
                          String1    : ARRAY OF WCHAR;
                          cchCount1  : INTEGER;
                          String2    : ARRAY OF WCHAR;
                          cchCount2  : INTEGER) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST CompareString = CompareStringW;
<* ELSE *>
      CONST CompareString = CompareStringA;
<* END *>

PROCEDURE LCMapStringA (Locale      : LCID;
                        MapFlags    : SFLAGS_SET;
                        SrcStr      : ARRAY OF CHAR;
                        cchSrc      : INTEGER;
                        VAR DestStr : ARRAY OF CHAR;
                        cchDest     : INTEGER) : INTEGER;

PROCEDURE LCMapStringW (Locale      : LCID;
                        MapFlags    : SFLAGS_SET;
                        SrcStr      : ARRAY OF WCHAR;
                        cchSrc      : INTEGER;
                        VAR DestStr : ARRAY OF WCHAR;
                        cchDest     : INTEGER) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST LCMapString = LCMapStringW;
<* ELSE *>
      CONST LCMapString = LCMapStringA;
<* END *>

PROCEDURE GetLocaleInfoA (Locale   : LCID;
                          LCType   : LCTYPE;
                          LCData   : PSTR;
                          cchData  : INTEGER) : INTEGER;

PROCEDURE GetLocaleInfoW (Locale   : LCID;
                          LCType   : LCTYPE;
                          lpLCData : PWSTR;
                          cchData  : INTEGER) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetLocaleInfo  = GetLocaleInfoW;
<* ELSE *>
      CONST GetLocaleInfo  = GetLocaleInfoA;
<* END *>

PROCEDURE SetLocaleInfoA (Locale : LCID;
                          LCType : LCTYPE;
                          LCData : ARRAY OF CHAR) : BOOL;

PROCEDURE SetLocaleInfoW (Locale : LCID;
                          LCType : LCTYPE;
                          LCData : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetLocaleInfo = SetLocaleInfoW;
<* ELSE *>
      CONST SetLocaleInfo  = SetLocaleInfoA;
<* END *>

PROCEDURE GetTimeFormatA (Locale    : LCID;
                          Flags     : TIME_SET;
                          lpTime    : PSYSTEMTIME; (* IN NIL *)
                          lpFormat  : PCSTR;
                          lpTimeStr : PSTR;
                          cchTime   : INTEGER) : INTEGER;

PROCEDURE GetTimeFormatW (Locale    : LCID;
                          Flags     : TIME_SET;
                          lpTime    : PSYSTEMTIME; (* IN NIL *)
                          lpFormat  : PCWSTR;
                          lpTimeStr : PWSTR;
                          cchTime   : INTEGER) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetTimeFormat = GetTimeFormatW;
<* ELSE *>
      CONST GetTimeFormat = GetTimeFormatA;
<* END *>

PROCEDURE GetDateFormatA (Locale    : LCID;
                          Flags     : DATE_SET;
                          lpTime    : PSYSTEMTIME; (* IN NIL *)
                          lpFormat  : PCSTR;
                          lpDateStr : PSTR;
                          cchDate   : INTEGER) : INTEGER;

PROCEDURE GetDateFormatW (Locale    : LCID;
                          Flags     : TIME_SET;
                          lpTime    : PSYSTEMTIME; (* IN NIL *)
                          lpFormat  : PCWSTR;
                          lpDateStr : PWSTR;
                          cchDate   : INTEGER) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetDateFormat = GetDateFormatW;
<* ELSE *>
      CONST GetDateFormat = GetDateFormatA;
<* END *>

PROCEDURE GetNumberFormatA (Locale    : LCID;
                            dwFlags   : DWORD;
                            Value     : ARRAY OF CHAR;
                            Format    : PCNUMBERFMTA;
                            NumberStr : PSTR;
                            cchNumber : INTEGER) : INTEGER;

PROCEDURE GetNumberFormatW (Locale    : LCID;
                            dwFlags   : DWORD;
                            Value     : ARRAY OF WCHAR;
                            Format    : PCNUMBERFMTW;
                            NumberStr : PWSTR;
                            cchNumber : INTEGER) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetNumberFormat = GetNumberFormatW;
<* ELSE *>
      CONST GetNumberFormat = GetNumberFormatA;
<* END *>

PROCEDURE GetCurrencyFormatA (Locale      : LCID;
                              dwFlags     : DWORD;
                              Value       : ARRAY OF CHAR;
                              Format      : PCCURRENCYFMTA;
                              CurrencyStr : PSTR;
                              cchCurrency : INTEGER) : INTEGER;

PROCEDURE GetCurrencyFormatW (Locale      : LCID;
                              dwFlags     : DWORD;
                              Value       : ARRAY OF WCHAR;
                              Format      : PCCURRENCYFMTW;
                              CurrencyStr : PWSTR;
                              cchCurrency : INTEGER) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetCurrencyFormat = GetCurrencyFormatW;
<* ELSE *>
      CONST GetCurrencyFormat = GetCurrencyFormatA;
<* END *>

PROCEDURE EnumCalendarInfoA (pCalInfoEnumProc : CALINFO_ENUMPROCA;
                             Locale   : LCID;
                             Calendar : CALID;
                             CalType  : CALTYPE) : BOOL;

PROCEDURE EnumCalendarInfoW (CalInfoEnumProc : CALINFO_ENUMPROCW;
                             Locale   : LCID;
                             Calendar : CALID;
                             CalType  : CALTYPE) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumCalendarInfo = EnumCalendarInfoW;
<* ELSE *>
      CONST EnumCalendarInfo = EnumCalendarInfoA;
<* END *>

PROCEDURE EnumTimeFormatsA (TimeFmtEnumProc : TIMEFMT_ENUMPROCA;
                            Locale    : LCID;
                            dwFlags   : DWORD) : BOOL;

PROCEDURE EnumTimeFormatsW (TimeFmtEnumProc : TIMEFMT_ENUMPROCW;
                            Locale    : LCID;
                            dwFlags   : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumTimeFormats = EnumTimeFormatsW;
<* ELSE *>
      CONST EnumTimeFormats = EnumTimeFormatsA;
<* END *>

PROCEDURE EnumDateFormatsA (DateFmtEnumProc : DATEFMT_ENUMPROCA;
                            Locale  : LCID;
                            Flags   : DATE_SET) : BOOL;

PROCEDURE EnumDateFormatsW (DateFmtEnumProc : DATEFMT_ENUMPROCW;
                            Locale : LCID;
                            Flags  : DATE_SET) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumDateFormats = EnumDateFormatsW;
<* ELSE *>
      CONST EnumDateFormats = EnumDateFormatsA;
<* END *>

PROCEDURE IsValidLocale (Locale : LCID; Flags : LCID_ENUM_TYPE) : BOOL;
PROCEDURE ConvertDefaultLocale (Locale : LCID) : LCID;
PROCEDURE GetThreadLocale () : LCID;
PROCEDURE SetThreadLocale (Locale : LCID) : BOOL;
PROCEDURE GetSystemDefaultLangID () : LANGID;
PROCEDURE GetUserDefaultLangID   () : LANGID;
PROCEDURE GetSystemDefaultLCID   () : LCID;
PROCEDURE GetUserDefaultLCID     () : LCID;

(*
 *  Locale Independent APIs.
 *)

PROCEDURE GetStringTypeExA (Locale     : LCID;
                            dwInfoType : CT_SET;
                            lpSrcStr   : ARRAY OF CHAR;
                            cchSrc     : INTEGER;
                            lpCharType : PWORD) : BOOL;

PROCEDURE GetStringTypeExW (Locale     : LCID;
                            dwInfoType : CT_SET;
                            lpSrcStr   : ARRAY OF WCHAR;
                            cchSrc     : INTEGER;
                            lpCharType : PWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetStringTypeEx = GetStringTypeExW;
<* ELSE *>
      CONST GetStringTypeEx = GetStringTypeExA;
<* END *>

(*
 *  NOTE: The parameters for GetStringTypeA and GetStringTypeW are
 *        NOT the same.  The W version was shipped in NT 3.1.  The
 *        A version was then shipped in 16-bit OLE with the wrong
 *        parameters (ported from Win95).  To be compatible, we
 *        must break the relationship between the A and W versions
 *        of GetStringType.  There will be NO function call for the
 *        generic GetStringType.
 *
 *        GetStringTypeEx (above) should be used instead.
 *)

PROCEDURE GetStringTypeA (Locale     : LCID;
                          dwInfoType : CT_SET;
                          lpSrcStr   : ARRAY OF CHAR;
                          cchSrc     : INTEGER;
                          lpCharType : PWORD) : BOOL;

PROCEDURE GetStringTypeW (dwInfoType : CT_SET;
                          lpSrcStr   : ARRAY OF WCHAR;
                          cchSrc     : INTEGER;
                          lpCharType : PWORD) : BOOL;

PROCEDURE FoldStringA (dwMapFlags : MAP_SET;
                       SrcStr     : ARRAY OF CHAR;
                       cchSrc     : INTEGER;
                       DestStr    : PSTR;
                       cchDest    : INTEGER) : INTEGER;

PROCEDURE FoldStringW (dwMapFlags : MAP_SET;
                       SrcStr     : ARRAY OF WCHAR;
                       cchSrc     : INTEGER;
                       DestStr    : PWSTR;
                       cchDest    : INTEGER) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST FoldString = FoldStringW;
<* ELSE *>
      CONST FoldString = FoldStringA;
<* END *>

PROCEDURE EnumSystemLocalesA (LocaleEnumProc : LOCALE_ENUMPROCA;
                              Flags : LCID_ENUM_TYPE) : BOOL;

PROCEDURE EnumSystemLocalesW (LocaleEnumProc : LOCALE_ENUMPROCW;
                              Flags : LCID_ENUM_TYPE) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumSystemLocales = EnumSystemLocalesW;
<* ELSE *>
      CONST EnumSystemLocales = EnumSystemLocalesA;
<* END *>

PROCEDURE EnumSystemCodePagesA (CodePageEnumProc : CODEPAGE_ENUMPROCA;
                                Flags : CP_ENUM_TYPE) : BOOL;

PROCEDURE EnumSystemCodePagesW (CodePageEnumProc : CODEPAGE_ENUMPROCW;
                                Flags : CP_ENUM_TYPE) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumSystemCodePages = EnumSystemCodePagesW;
<* ELSE *>
      CONST EnumSystemCodePages = EnumSystemCodePagesA;
<* END *>


(*
    This module contains the public data structures, data types,
    and procedures exported by the NT console subsystem.
*)


TYPE COORD = RECORD
                    X : SHORT;
                    Y : SHORT;
             END;
    PCOORD = POINTER TO COORD;

TYPE SMALL_RECT = RECORD
                         Left   : SHORT;
                         Top    : SHORT;
                         Right  : SHORT;
                         Bottom : SHORT;
                  END;
    PSMALL_RECT = POINTER TO SMALL_RECT;
   PCSMALL_RECT = POINTER TO SMALL_RECT;

(*
** ControlKeyState flags
*)

TYPE CONTROLKEYSTATE_ENUM = (
      RIGHT__ALT_PRESSED,    (* 0 - the right alt key is pressed.  *)
      LEFT__ALT_PRESSED,     (* 1 - the left alt key is pressed.   *)
      RIGHT__CTRL_PRESSED,   (* 2 - the right ctrl key is pressed. *)
      LEFT__CTRL_PRESSED,    (* 3 - the left ctrl key is pressed.  *)
      SHIFT__PRESSED,        (* 4 - the shift key is pressed.      *)
      NUMLOCK__ON,           (* 5 - the numlock light is on.       *)
      SCROLLLOCK__ON,        (* 6 - the scrolllock light is on.    *)
      CAPSLOCK__ON,          (* 7 - the capslock light is on.      *)
      ENHANCED__KEY);        (* 8 - the key is enhanced.           *)

TYPE CONTROLKEYSTATE_SET = SET OF CONTROLKEYSTATE_ENUM;

CONST RIGHT_ALT_PRESSED  = CONTROLKEYSTATE_SET {RIGHT__ALT_PRESSED};  (* 0x0001 *)
      LEFT_ALT_PRESSED   = CONTROLKEYSTATE_SET {LEFT__ALT_PRESSED};   (* 0x0002 *)
      RIGHT_CTRL_PRESSED = CONTROLKEYSTATE_SET {RIGHT__CTRL_PRESSED}; (* 0x0004 *)
      LEFT_CTRL_PRESSED  = CONTROLKEYSTATE_SET {LEFT__CTRL_PRESSED};  (* 0x0008 *)
      SHIFT_PRESSED      = CONTROLKEYSTATE_SET {SHIFT__PRESSED};      (* 0x0010 *)
      NUMLOCK_ON         = CONTROLKEYSTATE_SET {NUMLOCK__ON};         (* 0x0020 *)
      SCROLLLOCK_ON      = CONTROLKEYSTATE_SET {SCROLLLOCK__ON};      (* 0x0040 *)
      CAPSLOCK_ON        = CONTROLKEYSTATE_SET {CAPSLOCK__ON};        (* 0x0080 *)
      ENHANCED_KEY       = CONTROLKEYSTATE_SET {ENHANCED__KEY};       (* 0x0100 *)

TYPE KEY_EVENT_RECORD = RECORD
                               bKeyDown         : BOOL;
                               wRepeatCount     : WORD;
                               wVirtualKeyCode  : WORD;
                               wVirtualScanCode : WORD;
                               uChar            : RECORD
                                                  CASE : BOOLEAN OF
                                                  | TRUE  : UnicodeChar : WCHAR;
                                                  | FALSE : AsciiChar   : CHAR;
                                                  END;
                                                  END;
                               dwControlKeyState     : CONTROLKEYSTATE_SET;
                        END;
    PKEY_EVENT_RECORD = POINTER TO KEY_EVENT_RECORD;

(*
** ButtonState flags
*)

TYPE BUTTONSTATE_ENUM = (FROM__LEFT_1ST_BUTTON_PRESSED,  (* 0 *)
                         RIGHTMOST__BUTTON_PRESSED,      (* 1 *)
                         FROM__LEFT_2ND_BUTTON_PRESSED,  (* 2 *)
                         FROM__LEFT_3RD_BUTTON_PRESSED,  (* 3 *)
                         FROM__LEFT_4TH_BUTTON_PRESSED); (* 4 *)
     BUTTONSTATE_SET = SET OF BUTTONSTATE_ENUM;

CONST FROM_LEFT_1ST_BUTTON_PRESSED = BUTTONSTATE_SET {FROM__LEFT_1ST_BUTTON_PRESSED}; (* 0x0001 *)
      RIGHTMOST_BUTTON_PRESSED     = BUTTONSTATE_SET {RIGHTMOST__BUTTON_PRESSED    }; (* 0x0002 *)
      FROM_LEFT_2ND_BUTTON_PRESSED = BUTTONSTATE_SET {FROM__LEFT_2ND_BUTTON_PRESSED}; (* 0x0004 *)
      FROM_LEFT_3RD_BUTTON_PRESSED = BUTTONSTATE_SET {FROM__LEFT_3RD_BUTTON_PRESSED}; (* 0x0008 *)
      FROM_LEFT_4TH_BUTTON_PRESSED = BUTTONSTATE_SET {FROM__LEFT_4TH_BUTTON_PRESSED}; (* 0x0010 *)

(*
** EventFlags
*)

TYPE EVENTFLAGS_ENUM = (MOUSE__MOVED,   (* 0 *)
                        DOUBLE__CLICK,  (* 1 *)
                        MOUSE__WHEELED);(* 2 *)

     EVENTFLAGS_SET = SET OF EVENTFLAGS_ENUM;

CONST MOUSE_MOVED  = EVENTFLAGS_SET {MOUSE__MOVED};   (* 0x0001 *)
      DOUBLE_CLICK = EVENTFLAGS_SET {DOUBLE__CLICK};  (* 0x0002 *)

TYPE MOUSE_EVENT_RECORD = RECORD
                                 dwMousePosition   : COORD;
                                 dwButtonState     : BUTTONSTATE_SET;
                                 dwControlKeyState : CONTROLKEYSTATE_SET;
                                 dwEventFlags      : EVENTFLAGS_SET;
                          END;
    PMOUSE_EVENT_RECORD = POINTER TO MOUSE_EVENT_RECORD;


TYPE WINDOW_BUFFER_SIZE_RECORD = RECORD
                                        dwSize : COORD;
                                 END;
    PWINDOW_BUFFER_SIZE_RECORD = POINTER TO WINDOW_BUFFER_SIZE_RECORD;

TYPE MENU_EVENT_RECORD = RECORD
                                dwCommandId : UINT;
                         END;
    PMENU_EVENT_RECORD = POINTER TO MENU_EVENT_RECORD;

TYPE FOCUS_EVENT_RECORD = RECORD
                                 bSetFocus : BOOL;
                          END;
    PFOCUS_EVENT_RECORD = POINTER TO FOCUS_EVENT_RECORD;

(*
**  EventType flags:
*)

(* This type hasn't been converted into setbecause it doesn't have set
   semantics: only one bit may be set at a time; it is also intended to be used 
   as a variant record key field which isn't allowed for set type
*)

TYPE  EVENTTYPE = WORD;

CONST KEY_EVENT                = EVENTTYPE (0001H);
      MOUSE_EVENT              = EVENTTYPE (0002H);
      WINDOW_BUFFER_SIZE_EVENT = EVENTTYPE (0004H);
      MENU_EVENT               = EVENTTYPE (0008h);
      FOCUS_EVENT              = EVENTTYPE (0010H);

TYPE INPUT_RECORD = RECORD
       EventType : EVENTTYPE;
       Event: RECORD
              CASE : EVENTTYPE OF
              | KEY_EVENT                : KeyEvent              : KEY_EVENT_RECORD;
              | MOUSE_EVENT              : MouseEvent            : MOUSE_EVENT_RECORD;
              | WINDOW_BUFFER_SIZE_EVENT : WindowBufferSizeEvent : WINDOW_BUFFER_SIZE_RECORD;
              | MENU_EVENT               : MenuEvent             : MENU_EVENT_RECORD ;
              | FOCUS_EVENT              : FocusEvent            : FOCUS_EVENT_RECORD;
              END;
              END;
     END;
     PINPUT_RECORD = POINTER TO INPUT_RECORD;

(*
** Attributes flags:
*)

<* PUSH *> <* SETSIZE = "2" *>

TYPE CHAR_ATTRIBUTES_ENUM = (FOREGROUND__BLUE,       (* 0 - text color contains blue.        *)
                             FOREGROUND__GREEN,      (* 1 - text color contains green.       *)
                             FOREGROUND__RED,        (* 2 - text color contains red.         *)
                             FOREGROUND__INTENSITY,  (* 3 - text color is intensified.       *)
                             BACKGROUND__BLUE,       (* 4 - background color contains blue.  *)
                             BACKGROUND__GREEN,      (* 5 - background color contains green. *)
                             BACKGROUND__RED,        (* 6 - background color contains red.   *)
                             BACKGROUND__INTENSITY); (* 7 - background color is intensified. *)

       CHAR_ATTRIBUTES_SET = SET OF CHAR_ATTRIBUTES_ENUM;

CONST FOREGROUND_BLUE      = CHAR_ATTRIBUTES_SET {FOREGROUND__BLUE};      (* 0001h *)
      FOREGROUND_GREEN     = CHAR_ATTRIBUTES_SET {FOREGROUND__GREEN};     (* 0002h *)
      FOREGROUND_RED       = CHAR_ATTRIBUTES_SET {FOREGROUND__RED};       (* 0004h *)
      FOREGROUND_INTENSITY = CHAR_ATTRIBUTES_SET {FOREGROUND__INTENSITY}; (* 0008h *)
      BACKGROUND_BLUE      = CHAR_ATTRIBUTES_SET {BACKGROUND__BLUE};      (* 0010h *)
      BACKGROUND_GREEN     = CHAR_ATTRIBUTES_SET {BACKGROUND__GREEN};     (* 0020h *)
      BACKGROUND_RED       = CHAR_ATTRIBUTES_SET {BACKGROUND__RED};       (* 0040h *)
      BACKGROUND_INTENSITY = CHAR_ATTRIBUTES_SET {BACKGROUND__INTENSITY}; (* 0080h *)

<* POP *>

TYPE CHAR_INFO = RECORD
                        Char: RECORD
                              CASE : BOOLEAN OF
                              | TRUE  : UnicodeChar : WCHAR;
                              | FALSE : AsciiChar   : CHAR;
                              END;
                              END;
                        Attributes : CHAR_ATTRIBUTES_SET;
                 END;
    PCHAR_INFO = POINTER TO CHAR_INFO;


TYPE CONSOLE_SCREEN_BUFFER_INFO = RECORD
                                         dwSize              : COORD;
                                         dwCursorPosition    : COORD;
                                         wAttributes         : CHAR_ATTRIBUTES_SET;
                                         srWindow            : SMALL_RECT;
                                         dwMaximumWindowSize : COORD;
                                  END;
    PCONSOLE_SCREEN_BUFFER_INFO = POINTER TO CONSOLE_SCREEN_BUFFER_INFO;

TYPE CONSOLE_CURSOR_INFO = RECORD
                                  dwSize   : DWORD;
                                  bVisible : BOOL;
                           END;
    PCONSOLE_CURSOR_INFO = POINTER TO CONSOLE_CURSOR_INFO;

(*
** typedef for ctrl-c handler routines
*)

TYPE CTRL_TYPE = (CTRL_C_EVENT,         (* 0 *)
                  CTRL_BREAK_EVENT,     (* 1 *)
                  CTRL_CLOSE_EVENT,     (* 2 *)
                  CTRL_TYPE_3,          (* 3 is reserved! *)
                  CTRL_TYPE_4,          (* 4 is reserved! *)
                  CTRL_LOGOFF_EVENT,    (* 5 *)
                  CTRL_SHUTDOWN_EVENT); (* 6 *)

TYPE PHANDLER_ROUTINE = PROCEDURE (CTRL_TYPE) : BOOL;

(* Console mode flags *)

TYPE CONSOLE_MODE_ENUM = (CONSOLE_MODE_0,
                          CONSOLE_MODE_1,
                          CONSOLE_MODE_2,
                          CONSOLE_MODE_3,
                          CONSOLE_MODE_4);

    CONSOLE_MODE_SET = SET OF CONSOLE_MODE_ENUM;

(*
**  Input Mode flags:
*)

CONST ENABLE__PROCESSED_INPUT = CONSOLE_MODE_0;
      ENABLE__LINE_INPUT      = CONSOLE_MODE_1;
      ENABLE__ECHO_INPUT      = CONSOLE_MODE_2;
      ENABLE__WINDOW_INPUT    = CONSOLE_MODE_3;
      ENABLE__MOUSE_INPUT     = CONSOLE_MODE_4;

TYPE INPUT_MODE_SET = CONSOLE_MODE_SET;

CONST ENABLE_PROCESSED_INPUT = INPUT_MODE_SET {ENABLE__PROCESSED_INPUT}; (* 0x0001 *)
      ENABLE_LINE_INPUT      = INPUT_MODE_SET {ENABLE__LINE_INPUT     }; (* 0x0002 *)
      ENABLE_ECHO_INPUT      = INPUT_MODE_SET {ENABLE__ECHO_INPUT     }; (* 0x0004 *)
      ENABLE_WINDOW_INPUT    = INPUT_MODE_SET {ENABLE__WINDOW_INPUT   }; (* 0x0008 *)
      ENABLE_MOUSE_INPUT     = INPUT_MODE_SET {ENABLE__MOUSE_INPUT    }; (* 0x0010 *)

(*
** Output Mode flags:
*)

CONST ENABLE__PROCESSED_OUTPUT   = CONSOLE_MODE_0;
      ENABLE__WRAP_AT_EOL_OUTPUT = CONSOLE_MODE_1;

TYPE OUTPUT_MODE_SET = CONSOLE_MODE_SET;

CONST ENABLE_PROCESSED_OUTPUT    = OUTPUT_MODE_SET {ENABLE__PROCESSED_OUTPUT};   (* 0x0001 *)
      ENABLE_WRAP_AT_EOL_OUTPUT  = OUTPUT_MODE_SET {ENABLE__WRAP_AT_EOL_OUTPUT}; (* 0x0002 *)

(*
** direct API definitions.
*)


PROCEDURE PeekConsoleInputA (hConsoleInput : HANDLE;
                             VAR Buffer    : ARRAY OF INPUT_RECORD;
                             nLength       : DWORD;
                             VAR NumberOfEventsRead : DWORD) : BOOL;

PROCEDURE PeekConsoleInputW (hConsoleInput : HANDLE;
                             VAR Buffer    : ARRAY OF INPUT_RECORD;
                             nLength       : DWORD;
                             VAR NumberOfEventsRead : DWORD) : BOOL;

<* IF DEFINED  (UNICODE) THEN *>
      CONST PeekConsoleInput = PeekConsoleInputW;
<* ELSE *>
      CONST PeekConsoleInput = PeekConsoleInputA;
<* END *>

PROCEDURE ReadConsoleInputA (hConsoleInput : HANDLE;
                             VAR Buffer    : ARRAY OF INPUT_RECORD;
                             nLength       : DWORD;
                             VAR NumberOfEventsRead : DWORD) : BOOL;

PROCEDURE ReadConsoleInputW (hConsoleInput : HANDLE;
                             VAR Buffer    : ARRAY OF INPUT_RECORD;
                             nLength       : DWORD;
                             VAR NumberOfEventsRead : DWORD) : BOOL;

<* IF DEFINED  (UNICODE) THEN *>
      CONST ReadConsoleInput = ReadConsoleInputW;
<* ELSE *>
      CONST ReadConsoleInput = ReadConsoleInputA;
<* END *>

PROCEDURE WriteConsoleInputA (hConsoleInput : HANDLE;
                              Buffer        : ARRAY OF INPUT_RECORD;
                              nLength       : DWORD;
                              VAR NumberOfEventsWritten : DWORD) : BOOL;

PROCEDURE WriteConsoleInputW (hConsoleInput : HANDLE;
                              Bufrer        : ARRAY OF INPUT_RECORD;
                              nLength       : DWORD;
                              VAR lpNumberOfEventsWritten : DWORD) : BOOL;

<* IF DEFINED  (UNICODE) THEN *>
      CONST WriteConsoleInput = WriteConsoleInputW;
<* ELSE *>
      CONST WriteConsoleInput = WriteConsoleInputA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE rtlReadConsoleOutputA (hConsoleOutput : HANDLE;
                                 VAR Buffer     : ARRAY OF CHAR_INFO;
                                 dwBufferSize   : COORD;
                                 dwBufferCoord  : COORD;
                                 VAR ReadRegion : SMALL_RECT) : BOOL;

PROCEDURE rtlReadConsoleOutputW (hConsoleOutput : HANDLE;
                                 VAR Buffer     : ARRAY OF CHAR_INFO;
                                 dwBufferSize   : COORD;
                                 dwBufferCoord  : COORD;
                                 VAR ReadRegion : SMALL_RECT) : BOOL;

CONST ReadConsoleOutputA = rtlReadConsoleOutputA;
      ReadConsoleOutputW = rtlReadConsoleOutputW;

<* IF DEFINED (UNICODE) THEN *>
      CONST ReadConsoleOutput = ReadConsoleOutputW;
<* ELSE *>
      CONST ReadConsoleOutput = ReadConsoleOutputA;
<* END *>
<* ELSE *> (* BACKEND *)
PROCEDURE ReadConsoleOutput (hConsoleOutput : HANDLE;
                             VAR Buffer     : ARRAY OF CHAR_INFO;
                             dwBufferSize   : COORD;
                             dwBufferCoord  : COORD;
                             VAR ReadRegion : SMALL_RECT) : BOOL;
<* END *> (* BACKEND *)

<* IF BACKEND # "C" THEN *>
PROCEDURE rtlWriteConsoleOutputA (hConsoleOutput  : HANDLE;
                                  Buffer          : ARRAY OF CHAR_INFO;
                                  dwBufferSize    : COORD;
                                  dwBufferCoord   : COORD;
                                  VAR WriteRegion : SMALL_RECT) : BOOL;

PROCEDURE rtlWriteConsoleOutputW (hConsoleOutput  : HANDLE;
                                  Buffer          : ARRAY OF CHAR_INFO;
                                  dwBufferSize    : COORD;
                                  dwBufferCoord   : COORD;
                                  VAR WriteRegion : SMALL_RECT) : BOOL;

CONST WriteConsoleOutputA = rtlWriteConsoleOutputA;
      WriteConsoleOutputW = rtlWriteConsoleOutputW;

<* IF DEFINED  (UNICODE) THEN *>
      CONST WriteConsoleOutput = WriteConsoleOutputW;
<* ELSE *>
      CONST WriteConsoleOutput = WriteConsoleOutputA;
<* END *>
<* ELSE *> (* BACKEND *)
PROCEDURE WriteConsoleOutput (hConsoleOutput  : HANDLE;
                              Buffer          : ARRAY OF CHAR_INFO;
                              dwBufferSize    : COORD;
                              dwBufferCoord   : COORD;
                              VAR WriteRegion : SMALL_RECT) : BOOL;
<* END *> (* BACKEND *)

<* IF BACKEND # "C" THEN *>
PROCEDURE rtlReadConsoleOutputCharacterA (hConsoleOutput : HANDLE;
                                          VAR Character  : ARRAY OF CHAR;
                                          nLength        : DWORD;
                                          dwReadCoord    : COORD;
                                          VAR NumberOfCharsRead : DWORD) : BOOL;

PROCEDURE rtlReadConsoleOutputCharacterW (hConsoleOutput : HANDLE;
                                          VAR Character  : ARRAY OF WCHAR;
                                          nLength        : DWORD;
                                          dwReadCoord    : COORD;
                                          VAR NumberOfCharsRead : DWORD) : BOOL;

CONST ReadConsoleOutputCharacterA = rtlReadConsoleOutputCharacterA;
      ReadConsoleOutputCharacterW = rtlReadConsoleOutputCharacterW;

<* IF DEFINED  (UNICODE) THEN *>
      CONST ReadConsoleOutputCharacter = ReadConsoleOutputCharacterW;
<* ELSE *>
      CONST ReadConsoleOutputCharacter = ReadConsoleOutputCharacterA;
<* END *>
<* ELSE *> (* BACKEND *)
PROCEDURE ReadConsoleOutputCharacter (hConsoleOutput : HANDLE;
                                      VAR Character  : ARRAY OF WCHAR;
                                      nLength        : DWORD;
                                      dwReadCoord    : COORD;
                                      VAR NumberOfCharsRead : DWORD) : BOOL;
<* END *> (* BACKEND *)

<* IF BACKEND # "C" THEN *>
PROCEDURE rtlReadConsoleOutputAttribute (hConsoleOutput        : HANDLE;
                                         VAR Attribute         : ARRAY OF CHAR_ATTRIBUTES_SET;
                                         nLength               : DWORD;
                                         dwReadCoord           : COORD;
                                         VAR NumberOfAttrsRead : DWORD) : BOOL;

CONST ReadConsoleOutputAttribute = rtlReadConsoleOutputAttribute;

PROCEDURE rtlWriteConsoleOutputCharacterA (hConsoleOutput : HANDLE;
                                           Character      : ARRAY OF CHAR;
                                           nLength        : DWORD;
                                           dwWriteCoord   : COORD;
                                           VAR NumberOfCharsWritten : DWORD) : BOOL;

PROCEDURE rtlWriteConsoleOutputCharacterW (hConsoleOutput : HANDLE;
                                           Character      : ARRAY OF WCHAR;
                                           nLength        : DWORD;
                                           dwWriteCoord   : COORD;
                                           VAR NumberOfCharsWritten : DWORD) : BOOL;

CONST WriteConsoleOutputCharacterW = rtlWriteConsoleOutputCharacterW;
      WriteConsoleOutputCharacterA = rtlWriteConsoleOutputCharacterA;

<* IF DEFINED  (UNICODE) THEN *>
      CONST WriteConsoleOutputCharacter = WriteConsoleOutputCharacterW;
<* ELSE *>
      CONST WriteConsoleOutputCharacter = WriteConsoleOutputCharacterA;
<* END *>


PROCEDURE rtlWriteConsoleOutputAttribute (hConsoleOutput : HANDLE;
                                          Attribute      : ARRAY OF CHAR_ATTRIBUTES_SET;
                                          nLength        : DWORD;
                                          dwWriteCoord   : COORD;
                                          VAR NumberOfAttrsWritten : DWORD) : BOOL;

CONST WriteConsoleOutputAttribute = rtlWriteConsoleOutputAttribute;

PROCEDURE rtlFillConsoleOutputCharacterA (hConsoleOutput : HANDLE;
                                          cCharacter     : CHAR;
                                          nLength        : DWORD;
                                          dwWriteCoord   : COORD;
                                          VAR NumberOfCharsWritten : DWORD) : BOOL;

PROCEDURE rtlFillConsoleOutputCharacterW (hConsoleOutput : HANDLE;
                                          cCharacter     : WCHAR;
                                          nLength        : DWORD;
                                          dwWriteCoord   : COORD;
                                          VAR NumberOfCharsWritten : DWORD) : BOOL;

CONST FillConsoleOutputCharacterA = rtlFillConsoleOutputCharacterA;
      FillConsoleOutputCharacterW = rtlFillConsoleOutputCharacterW;

<* IF DEFINED  (UNICODE) THEN *>
      CONST FillConsoleOutputCharacter = FillConsoleOutputCharacterW;
<* ELSE *>
      CONST FillConsoleOutputCharacter = FillConsoleOutputCharacterA;
<* END *>

PROCEDURE rtlFillConsoleOutputAttribute (hConsoleOutput : HANDLE;
                                      wAttribute     : CHAR_ATTRIBUTES_SET;
                                      nLength        : DWORD;
                                      dwWriteCoord   : COORD;
                                      VAR NumberOfAttrsWritten : DWORD) : BOOL;

CONST FillConsoleOutputAttribute = rtlFillConsoleOutputAttribute;

<* ELSE *> (* BACKEND *)

PROCEDURE ReadConsoleOutputAttribute (hConsoleOutput        : HANDLE;
                                      VAR Attribute         : ARRAY OF CHAR_ATTRIBUTES_SET;
                                      nLength               : DWORD;
                                      dwReadCoord           : COORD;
                                      VAR NumberOfAttrsRead : DWORD) : BOOL;

PROCEDURE WriteConsoleOutputCharacter (hConsoleOutput : HANDLE;
                                       Character      : ARRAY OF CHAR;
                                       nLength        : DWORD;
                                       dwWriteCoord   : COORD;
                                       VAR NumberOfCharsWritten : DWORD) : BOOL;

PROCEDURE WriteConsoleOutputAttribute (hConsoleOutput : HANDLE;
                                       Attribute      : ARRAY OF CHAR_ATTRIBUTES_SET;
                                       nLength        : DWORD;
                                       dwWriteCoord   : COORD;
                                       VAR NumberOfAttrsWritten : DWORD) : BOOL;

PROCEDURE FillConsoleOutputCharacter (hConsoleOutput : HANDLE;
                                      cCharacter     : CHAR;
                                      nLength        : DWORD;
                                      dwWriteCoord   : COORD;
                                      VAR NumberOfCharsWritten : DWORD) : BOOL;

PROCEDURE FillConsoleOutputAttribute (hConsoleOutput : HANDLE;
                                      wAttribute     : CHAR_ATTRIBUTES_SET;
                                      nLength        : DWORD;
                                      dwWriteCoord   : COORD;
                                      VAR NumberOfAttrsWritten : DWORD) : BOOL;
<* END *> (* BACKEND *)

PROCEDURE GetConsoleMode (hConsoleHandle : HANDLE;
                          VAR Mode       : CONSOLE_MODE_SET) : BOOL;

PROCEDURE GetNumberOfConsoleInputEvents (hConsoleInput      : HANDLE;
                                         VAR NumberOfEvents : DWORD) : BOOL;

PROCEDURE GetConsoleScreenBufferInfo (hConsoleOutput : HANDLE;
                                      VAR ConsoleScreenBufferInfo : CONSOLE_SCREEN_BUFFER_INFO
                                     ) : BOOL;

<* IF BACKEND # "C" THEN *>
PROCEDURE rtlGetLargestConsoleWindowSize (hConsoleOutput : HANDLE) : COORD;
CONST GetLargestConsoleWindowSize = rtlGetLargestConsoleWindowSize;
<* ELSE *>
PROCEDURE GetLargestConsoleWindowSize (hConsoleOutput : HANDLE) : COORD;
<* END *>

PROCEDURE GetConsoleCursorInfo (hConsoleOutput : HANDLE;
                                VAR ConsoleCursorInfo : CONSOLE_CURSOR_INFO) : BOOL;

PROCEDURE GetNumberOfConsoleMouseButtons (VAR NumberOfMouseButtons : DWORD) : BOOL;

PROCEDURE SetConsoleMode (hConsoleHandle : HANDLE;
                          dwMode         : CONSOLE_MODE_SET) : BOOL;

PROCEDURE SetConsoleActiveScreenBuffer (hConsoleOutput : HANDLE) : BOOL;

PROCEDURE FlushConsoleInputBuffer (hConsoleInput : HANDLE) : BOOL;

<* IF BACKEND # "C" THEN *>
PROCEDURE rtlSetConsoleScreenBufferSize (hConsoleOutput : HANDLE;
                                         dwSize         : COORD) : BOOL;
CONST SetConsoleScreenBufferSize = rtlSetConsoleScreenBufferSize;
PROCEDURE rtlSetConsoleCursorPosition (hConsoleOutput   : HANDLE;
                                       dwCursorPosition : COORD) : BOOL;
CONST SetConsoleCursorPosition = rtlSetConsoleCursorPosition;
<* ELSE *>
PROCEDURE SetConsoleScreenBufferSize (hConsoleOutput : HANDLE;
                                      dwSize         : COORD) : BOOL;
PROCEDURE SetConsoleCursorPosition (hConsoleOutput   : HANDLE;
                                    dwCursorPosition : COORD) : BOOL;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE SetConsoleCursorInfo (hConsoleOutput    : HANDLE;
                                ConsoleCursorInfo : CONSOLE_CURSOR_INFO) : BOOL;
<* ELSE *>
PROCEDURE SetConsoleCursorInfo (hConsoleOutput    : HANDLE;
                                ConsoleCursorInfo : PCONSOLE_CURSOR_INFO) : BOOL;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE rtlScrollConsoleScreenBufferA (hConsoleOutput      : HANDLE;
                                         ScrollRectangle     : SMALL_RECT;
                                         ClipRectangle       : PCSMALL_RECT; (* IN *) (* can be NIL *)
                                         dwDestinationOrigin : COORD;
                                         Fill                : CHAR_INFO) : BOOL;

PROCEDURE rtlScrollConsoleScreenBufferW (hConsoleOutput      : HANDLE;
                                         ScrollRectangle     : SMALL_RECT;
                                         ClipRectangle       : PCSMALL_RECT; (* IN *) (* can be NIL *)
                                         dwDestinationOrigin : COORD;
                                         Fill                : CHAR_INFO) : BOOL;

CONST ScrollConsoleScreenBufferA = rtlScrollConsoleScreenBufferA;
      ScrollConsoleScreenBufferW = rtlScrollConsoleScreenBufferW;

<* IF DEFINED  (UNICODE) THEN *>
      CONST ScrollConsoleScreenBuffer = ScrollConsoleScreenBufferW;
<* ELSE *>
      CONST ScrollConsoleScreenBuffer = ScrollConsoleScreenBufferA;
<* END *>
<* ELSE *>
PROCEDURE ScrollConsoleScreenBuffer (hConsoleOutput      : HANDLE;
                                     ScrollRectangle     : PCSMALL_RECT;
                                     ClipRectangle       : PCSMALL_RECT; (* IN *) (* can be NIL *)
                                     dwDestinationOrigin : COORD;
                                     Fill                : PCHAR_INFO) : BOOL;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE SetConsoleWindowInfo (hConsoleOutput : HANDLE;
                                bAbsolute      : BOOL;
                                ConsoleWindow  : SMALL_RECT) : BOOL;
<* ELSE *>
PROCEDURE SetConsoleWindowInfo (hConsoleOutput : HANDLE;
                                bAbsolute      : BOOL;
                                ConsoleWindow  : PSMALL_RECT) : BOOL;
<* END *>

PROCEDURE SetConsoleTextAttribute (hConsoleOutput : HANDLE;
                                   wAttributes    : CHAR_ATTRIBUTES_SET) : BOOL;

PROCEDURE SetConsoleCtrlHandler (HandlerRoutine : PHANDLER_ROUTINE;
                                 Add            : BOOL) : BOOL;

PROCEDURE GenerateConsoleCtrlEvent (dwCtrlEvent      : CTRL_TYPE;
                                    dwProcessGroupId : DWORD) : BOOL;


PROCEDURE AllocConsole () : BOOL;
PROCEDURE FreeConsole  () : BOOL;

PROCEDURE GetConsoleTitleA (lpConsoleTitle : PSTR;
                            nSize          : DWORD) : DWORD;

PROCEDURE GetConsoleTitleW (lpConsoleTitle : PWSTR;
                            nSize          : DWORD) : DWORD;

<* IF DEFINED  (UNICODE) THEN *>
      CONST GetConsoleTitle = GetConsoleTitleW;
<* ELSE *>
      CONST GetConsoleTitle = GetConsoleTitleA;
<* END *>

PROCEDURE SetConsoleTitleA (ConsoleTitle : ARRAY OF CHAR) : BOOL;

PROCEDURE SetConsoleTitleW (ConsoleTitle : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED  (UNICODE) THEN *>
      CONST SetConsoleTitle = SetConsoleTitleW;
<* ELSE *>
      CONST SetConsoleTitle = SetConsoleTitleA;
<* END *>

PROCEDURE ReadConsoleA (hConsoleInput         : HANDLE;
                        lpBuffer              : PVOID;
                        nNumberOfCharsToRead  : DWORD;
                        VAR NumberOfCharsRead : DWORD;
                        Reserved              : PVOID) : BOOL;

PROCEDURE ReadConsoleW (hConsoleInput         : HANDLE;
                        lpBuffer              : PVOID;
                        nNumberOfCharsToRead  : DWORD;
                        VAR NumberOfCharsRead : DWORD;
                        Reserved              : PVOID) : BOOL;

<* IF DEFINED  (UNICODE) THEN *>
      CONST ReadConsole = ReadConsoleW;
<* ELSE *>
      CONST ReadConsole = ReadConsoleA;
<* END *>

PROCEDURE WriteConsoleA (hConsoleOutput           : HANDLE;
                         Buffer                   : LPCVOID;
                         nNumberOfCharsToWrite    : DWORD;
                         VAR NumberOfCharsWritten : DWORD;
                         Reserved                 : PVOID) : BOOL;

PROCEDURE WriteConsoleW (hConsoleOutput           : HANDLE;
                         Buffer                   : LPCVOID;
                         nNumberOfCharsToWrite    : DWORD;
                         VAR NumberOfCharsWritten : DWORD;
                         Reserved                 : PVOID) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST WriteConsole = WriteConsoleW;
<* ELSE *>
      CONST WriteConsole = WriteConsoleA;
<* END *>

CONST CONSOLE_TEXTMODE_BUFFER = 1;

PROCEDURE CreateConsoleScreenBuffer (DesiredAccess : ACCESS_MASK;
                                     dwShareMode   : FILE_SHARE_MODE;
                                     lpSecurityAttributes : PSECURITY_ATTRIBUTES; (* IN *)
                                     dwFlags       : DWORD;
                                     lpScreenBufferData : PVOID) : HANDLE;

PROCEDURE GetConsoleCP () : UINT;
PROCEDURE SetConsoleCP (wCodePageID : UINT) : BOOL;
PROCEDURE GetConsoleOutputCP () : UINT;
PROCEDURE SetConsoleOutputCP (wCodePageID : UINT) : BOOL;



(******************************************************************************
*                                                                             *
* WinVer.def -  Version management functions, types, and definitions          *
*                                                                             *
*               Import file for VER.DLL.  This library is                     *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
******************************************************************************)


(* ----- Symbols ----- *)

CONST VS_FILE_INFO    = RT_VERSION;
      VS_VERSION_INFO = 1;
      VS_USER_DEFINED = 100;

(* ----- VS_VERSION.dwFileFlags ----- *)

CONST VS_FFI_SIGNATURE       =0FEEF04BDh;
      VS_FFI_STRUCVERSION    = 00010000h;
      VS_FFI_FILEFLAGSMASK   = 0000003Fh;

(* ----- VS_VERSION.dwFileFlags ----- *)

TYPE VS_FF_ENUM = (VS_FF__DEBUG,         (* 0 *)
                   VS_FF__PRERELEASE,    (* 1 *)
                   VS_FF__PATCHED,       (* 2 *)
                   VS_FF__PRIVATEBUILD,  (* 3 *)
                   VS_FF__INFOINFERRED,  (* 4 *)
                   VS_FF__SPECIALBUILD); (* 5 *)

     VS_FF_SET = SET OF VS_FF_ENUM;

CONST VS_FF_DEBUG            = VS_FF_SET {VS_FF__DEBUG       }; (* 00000001h *)
      VS_FF_PRERELEASE       = VS_FF_SET {VS_FF__PRERELEASE  }; (* 00000002h *)
      VS_FF_PATCHED          = VS_FF_SET {VS_FF__PATCHED     }; (* 00000004h *)
      VS_FF_PRIVATEBUILD     = VS_FF_SET {VS_FF__PRIVATEBUILD}; (* 00000008h *)
      VS_FF_INFOINFERRED     = VS_FF_SET {VS_FF__INFOINFERRED}; (* 00000010h *)
      VS_FF_SPECIALBUILD     = VS_FF_SET {VS_FF__SPECIALBUILD}; (* 00000020h *)

(* ----- VS_VERSION.dwFileOS ----- *)

TYPE VOS_TYPE = DWORD;

CONST VOS_UNKNOWN            = 00000000h;
      VOS_DOS                = 00010000h;
      VOS_OS216              = 00020000h;
      VOS_OS232              = 00030000h;
      VOS_NT                 = 00040000h;

      VOS__BASE              = 00000000h;
      VOS__WINDOWS16         = 00000001h;
      VOS__PM16              = 00000002h;
      VOS__PM32              = 00000003h;
      VOS__WINDOWS32         = 00000004h;

      VOS_DOS_WINDOWS16      = 00010001h;
      VOS_DOS_WINDOWS32      = 00010004h;
      VOS_OS216_PM16         = 00020002h;
      VOS_OS232_PM32         = 00030003h;
      VOS_NT_WINDOWS32       = 00040004h;

(* ----- VS_VERSION.dwFileType ----- *)

TYPE VFT_TYPE = (VFT_UNKNOWN,     (* 0 *)
                 VFT_APP,         (* 1 *)
                 VFT_DLL,         (* 2 *)
                 VFT_DRV,         (* 3 *)
                 VFT_FONT,        (* 4 *)
                 VFT_VXD,         (* 5 *)
                 VFT_6,
                 VFT_STATIC_LIB); (* 7 *)

(* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- *)

TYPE VFT2_TYPE = (VFT2_UNKNOWN,          (* 00000000 *)
                  VFT2_DRV_PRINTER,      (* 00000001 *)
                  VFT2_DRV_KEYBOARD,     (* 00000002 *)
                  VFT2_DRV_LANGUAGE,     (* 00000003 *)
                  VFT2_DRV_DISPLAY,      (* 00000004 *)
                  VFT2_DRV_MOUSE,        (* 00000005 *)
                  VFT2_DRV_NETWORK,      (* 00000006 *)
                  VFT2_DRV_SYSTEM,       (* 00000007 *)
                  VFT2_DRV_INSTALLABLE,  (* 00000008 *)
                  VFT2_DRV_SOUND,        (* 00000009 *)
                  VFT2_DRV_COMM,         (* 0000000A *)
                  VFT2_DRV_INPUTMETHOD); (* 0000000B *)

(* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- *)

CONST VFT2_FONT_RASTER       = VFT2_DRV_PRINTER;  (* 00000001h *)
      VFT2_FONT_VECTOR       = VFT2_DRV_KEYBOARD; (* 00000002h *)
      VFT2_FONT_TRUETYPE     = VFT2_DRV_LANGUAGE; (* 00000003h *)

(* ----- VerFindFile() flags ----- *)

TYPE VFFF_TYPE = (VFFF_0,
                  VFFF_ISSHAREDFILE); (* 0001h *)

TYPE VFF_ENUM = (VFF__CURNEDEST,     (* 0 *)
                 VFF__FILEINUSE,     (* 1 *)
                 VFF__BUFFTOOSMALL); (* 2 *)

      VFF_SET = SET OF VFF_ENUM;

CONST VFF_CURNEDEST          = VFF_SET {VFF__CURNEDEST};    (* 0001h *)
      VFF_FILEINUSE          = VFF_SET {VFF__FILEINUSE};    (* 0002h *)
      VFF_BUFFTOOSMALL       = VFF_SET {VFF__BUFFTOOSMALL}; (* 0004h *)

(* ----- VerInstallFile() flags ----- *)

TYPE VIFF_ENUM = (VIFF__FORCEINSTALL,   (* 0 *)
                  VIFF__DONTDELETEOLD); (* 1 *)

     VIFF_SET = SET OF VIFF_ENUM;

CONST VIFF_FORCEINSTALL      = VIFF_SET {VIFF__FORCEINSTALL }; (* 0001h *)
      VIFF_DONTDELETEOLD     = VIFF_SET {VIFF__DONTDELETEOLD}; (* 0002h *)

TYPE VIF_ENUM = (VIF__TEMPFILE,           (*  0 *)
                 VIF__MISMATCH,           (*  1 *)
                 VIF__SRCOLD,             (*  2 *)

                 VIF__DIFFLANG,           (*  3 *)
                 VIF__DIFFCODEPG,         (*  4 *)
                 VIF__DIFFTYPE,           (*  5 *)

                 VIF__WRITEPROT,          (*  6 *)
                 VIF__FILEINUSE,          (*  7 *)
                 VIF__OUTOFSPACE,         (*  8 *)
                 VIF__ACCESSVIOLATION,    (*  9 *)
                 VIF__SHARINGVIOLATION,   (* 10 *)
                 VIF__CANNOTCREATE,       (* 11 *)
                 VIF__CANNOTDELETE,       (* 12 *)
                 VIF__CANNOTRENAME,       (* 13 *)
                 VIF__CANNOTDELETECUR,    (* 14 *)
                 VIF__OUTOFMEMORY,        (* 15 *)

                 VIF__CANNOTREADSRC,      (* 16 *)
                 VIF__CANNOTREADDST,      (* 17 *)

                 VIF__BUFFTOOSMALL);      (* 18 *)

     VIF_SET = SET OF VIF_ENUM;

CONST VIF_TEMPFILE         = VIF_SET {VIF__TEMPFILE        }; (* 00000001h *)
      VIF_MISMATCH         = VIF_SET {VIF__MISMATCH        }; (* 00000002h *)
      VIF_SRCOLD           = VIF_SET {VIF__SRCOLD          }; (* 00000004h *)

      VIF_DIFFLANG         = VIF_SET {VIF__DIFFLANG        }; (* 00000008h *)
      VIF_DIFFCODEPG       = VIF_SET {VIF__DIFFCODEPG      }; (* 00000010h *)
      VIF_DIFFTYPE         = VIF_SET {VIF__DIFFTYPE        }; (* 00000020h *)

      VIF_WRITEPROT        = VIF_SET {VIF__WRITEPROT       }; (* 00000040h *)
      VIF_FILEINUSE        = VIF_SET {VIF__FILEINUSE       }; (* 00000080h *)
      VIF_OUTOFSPACE       = VIF_SET {VIF__OUTOFSPACE      }; (* 00000100h *)
      VIF_ACCESSVIOLATION  = VIF_SET {VIF__ACCESSVIOLATION }; (* 00000200h *)
      VIF_SHARINGVIOLATION = VIF_SET {VIF__SHARINGVIOLATION}; (* 00000400h *)
      VIF_CANNOTCREATE     = VIF_SET {VIF__CANNOTCREATE    }; (* 00000800h *)
      VIF_CANNOTDELETE     = VIF_SET {VIF__CANNOTDELETE    }; (* 00001000h *)
      VIF_CANNOTRENAME     = VIF_SET {VIF__CANNOTRENAME    }; (* 00002000h *)
      VIF_CANNOTDELETECUR  = VIF_SET {VIF__CANNOTDELETECUR }; (* 00004000h *)
      VIF_OUTOFMEMORY      = VIF_SET {VIF__OUTOFMEMORY     }; (* 00008000h *)

      VIF_CANNOTREADSRC    = VIF_SET {VIF__CANNOTREADSRC   }; (* 00010000h *)
      VIF_CANNOTREADDST    = VIF_SET {VIF__CANNOTREADDST   }; (* 00020000h *)

      VIF_BUFFTOOSMALL     = VIF_SET {VIF__BUFFTOOSMALL    }; (* 00040000h *)

(* ----- Types and structures ----- *)

TYPE VS_FIXEDFILEINFO =
               RECORD
                      dwSignature        : DWORD;     (* e.g. 0xfeef04bd *)
                      dwStrucVersion     : DWORD;     (* e.g. 0x00000042 = "0.42" *)
                      dwFileVersionMS    : DWORD;     (* e.g. 0x00030075 = "3.75" *)
                      dwFileVersionLS    : DWORD;     (* e.g. 0x00000031 = "0.31" *)
                      dwProductVersionMS : DWORD;     (* e.g. 0x00030010 = "3.10" *)
                      dwProductVersionLS : DWORD;     (* e.g. 0x00000031 = "0.31" *)
                      dwFileFlagsMask    : VS_FF_SET; (* = 0x3F for version "0.42" *)
                      dwFileFlags        : VS_FF_SET; (* e.g. VFF_DEBUG | VFF_PRERELEASE *)
                      dwFileOS           : VOS_TYPE;  (* e.g. VOS_DOS_WINDOWS16 *)
                      dwFileType         : VFT_TYPE;  (* e.g. VFT_DRIVER *)
                      dwFileSubtype      : VFT2_TYPE; (* e.g. VFT2_DRV_KEYBOARD *)
                      dwFileDateMS       : DWORD;     (* e.g. 0 *)
                      dwFileDateLS       : DWORD;     (* e.g. 0 *)
               END;


(* ----- Function prototypes ----- *)

PROCEDURE VerFindFileA (uFlags         : VFFF_TYPE;
                        FileName       : ARRAY OF CHAR;
                        WinDir         : ARRAY OF CHAR;
                        AppDir         : ARRAY OF CHAR;
                        VAR CurDir     : ARRAY OF CHAR;
                        VAR CurDirLen  : UINT;
                        VAR DestDir    : ARRAY OF CHAR;
                        VAR DestDirLen : UINT) : VFF_SET;

PROCEDURE VerFindFileW (uFlags         : VFFF_TYPE;
                        FileName       : ARRAY OF WCHAR;
                        WinDir         : ARRAY OF WCHAR;
                        AppDir         : ARRAY OF WCHAR;
                        VAR CurDir     : ARRAY OF WCHAR;
                        VAR CurDirLen  : UINT;
                        VAR DestDir    : ARRAY OF WCHAR;
                        VAR DestDirLen : UINT) : VFF_SET;

<* IF DEFINED (UNICODE) THEN *>
      CONST VerFindFile = VerFindFileW;
<* ELSE *>
      CONST VerFindFile = VerFindFileA;
<* END *>

PROCEDURE VerInstallFileA (uFlags         : VIFF_SET;
                           SrcFileName    : ARRAY OF CHAR;
                           DestFileName   : ARRAY OF CHAR;
                           SrcDir         : ARRAY OF CHAR;
                           DestDir        : ARRAY OF CHAR;
                           CurDir         : ARRAY OF CHAR;
                           VAR TmpFile    : ARRAY OF CHAR;
                           VAR TmpFileLen : UINT)
                                                  : VIF_SET;

PROCEDURE VerInstallFileW (uFlags         : VIFF_SET;
                           SrcFileName    : ARRAY OF WCHAR;
                           DestFileName   : ARRAY OF WCHAR;
                           SrcDir         : ARRAY OF WCHAR;
                           DestDir        : ARRAY OF WCHAR;
                           CurDir         : ARRAY OF WCHAR;
                           VAR TmpFile    : ARRAY OF WCHAR;
                           VAR TmpFileLen : UINT)
                                                  : VIF_SET;

<* IF DEFINED (UNICODE) THEN *>
      CONST VerInstallFile = VerInstallFileW;
<* ELSE *>
      CONST VerInstallFile = VerInstallFileA;
<* END *>

(* Returns size of version info in bytes *)

PROCEDURE GetFileVersionInfoSizeA (Filename   : ARRAY OF CHAR; (* Filename of version stamped file *)
                                   VAR Handle : DWORD          (* Information for use by GetFileVersionInfo *)
                                                      ) : DWORD;

(* Returns size of version info in bytes *)

PROCEDURE GetFileVersionInfoSizeW (Filename   : ARRAY OF WCHAR;
                                   VAR Handle : DWORD
                                                      ) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetFileVersionInfoSize = GetFileVersionInfoSizeW;
<* ELSE *>
      CONST GetFileVersionInfoSize = GetFileVersionInfoSizeA;
<* END *>

(* Read version info into buffer *)

PROCEDURE GetFileVersionInfoA (Filename : ARRAY OF CHAR; (* Filename of version stamped file *)
                               dwHandle : DWORD;   (* Information from GetFileVersionSize *)
                               dwLen    : DWORD;   (* Length of buffer for info *)
                               lpData   : PVOID    (* Buffer to place the data structure *)
                                                ) : BOOL;

PROCEDURE GetFileVersionInfoW (Filename : ARRAY OF WCHAR;
                               dwHandle : DWORD;
                               dwLen    : DWORD;
                               lpData   : PVOID) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetFileVersionInfo = GetFileVersionInfoW;
<* ELSE *>
      CONST GetFileVersionInfo = GetFileVersionInfoA;
<* END *>

PROCEDURE VerLanguageNameA (wLang    : DWORD;
                            VAR Lang : ARRAY OF CHAR;
                            nSize    : DWORD) : DWORD;

PROCEDURE VerLanguageNameW (wLang    : DWORD;
                            VAR Lang : ARRAY OF WCHAR;
                            nSize    : DWORD) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST VerLanguageName = VerLanguageNameW;
<* ELSE *>
      CONST VerLanguageName = VerLanguageNameA;
<* END *>

PROCEDURE VerQueryValueA (pBlock       : LPCVOID;
                          SubBlock     : ARRAY OF CHAR;
                          VAR lpBuffer : PVOID;
                          VAR Len      : UINT) : BOOL;

PROCEDURE VerQueryValueW (pBlock       : LPCVOID;
                          SubBlock     : ARRAY OF WCHAR;
                          VAR lpBuffer : PVOID;
                          VAR Len      : UINT) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST VerQueryValue = VerQueryValueW;
<* ELSE *>
      CONST VerQueryValue = VerQueryValueA;
<* END *>


(* WinReg.def

Abstract:

    This module contains the function prototypes and constant, type and
    structure definitions for the Windows 32-Bit Registry API.

--*)



(*
** Requested Key access mask type.
*)

TYPE REGSAM = ACCESS_MASK;

(*
** Type definitions.
*)

TYPE  HKEY = POINTER TO RECORD END;
     PHKEY = POINTER TO HKEY;

(*
** Reserved Key Handles.
*)

CONST HKEY_CLASSES_ROOT       = SYSTEM.CAST (HKEY, VAL (CARDINAL, 80000000h));
      HKEY_CURRENT_USER       = SYSTEM.CAST (HKEY, VAL (CARDINAL, 80000001h));
      HKEY_LOCAL_MACHINE      = SYSTEM.CAST (HKEY, VAL (CARDINAL, 80000002h));
      HKEY_USERS              = SYSTEM.CAST (HKEY, VAL (CARDINAL, 80000003h));
      HKEY_PERFORMANCE_DATA   = SYSTEM.CAST (HKEY, VAL (CARDINAL, 80000004h));
      HKEY_CURRENT_CONFIG     = SYSTEM.CAST (HKEY, VAL (CARDINAL, 80000005h));
      HKEY_DYN_DATA           = SYSTEM.CAST (HKEY, VAL (CARDINAL, 80000006h));


CONST PROVIDER_KEEPS_VALUE_LENGTH = 1;

TYPE VALCONTEXT = RECORD
                         valuelen      : INTEGER; (* the total length of this value *)
                         value_context : PVOID;   (* provider's context *)
                         val_buff_ptr  : PVOID;   (* where in the ouput buffer the value is. *)
                  END;
    PVALCONTEXT = POINTER TO VALCONTEXT;

TYPE PVALUEA = RECORD                              (* Provider supplied value/context. *)
                      pv_valuename     : PSTR;     (* The value name pointer *)
                      pv_valuelen      : INTEGER;
                      pv_value_context : PVOID;
                      pv_type          : REG_TYPE;
               END;
    PPVALUEA = POINTER TO PVALUEA;

TYPE PVALUEW = RECORD
                      pv_valuename     : PWSTR;
                      pv_valuelen      : INTEGER;
                      pv_value_context : PVOID;
                      pv_type          : REG_TYPE;
               END;
    PPVALUEW = POINTER TO PVALUEW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE PVALUE  =  PVALUEW;
      TYPE PPVALUE = PPVALUEW;
<* ELSE *>
      TYPE PVALUE  =  PVALUEA;
      TYPE PPVALUE = PPVALUEA;
<* END *>

TYPE PQUERYHANDLER = PROCEDURE ["C"] (PVOID       (* keycontext   *),
                                      PVALCONTEXT (* val_list     *),
                                      DWORD       (* num_vals     *),
                                      PVOID       (* outputbuffer *),
                                      VAR DWORD   (* total_outlen *),
                                      DWORD       (* input_blen   *)) : DWORD;

TYPE REG_PROVIDER = RECORD
                           pi_R0_1val     : PQUERYHANDLER;
                           pi_R0_allvals  : PQUERYHANDLER;
                           pi_R3_1val     : PQUERYHANDLER;
                           pi_R3_allvals  : PQUERYHANDLER;
                           pi_flags       : DWORD;    (* capability flags (none defined yet). *)
                           pi_key_context : PVOID;
                    END;
        PPROVIDER = POINTER TO REG_PROVIDER;

TYPE VALENTA = RECORD
                      ve_valuename : PSTR;
                      ve_valuelen  : DWORD;
                      ve_valueptr  : DWORD;
                      ve_type      : REG_TYPE;
               END;

    PVALENTA = POINTER TO VALENTA;

TYPE VALENTW = RECORD
                      ve_valuename : PWSTR;
                      ve_valuelen  : DWORD;
                      ve_valueptr  : DWORD;
                      ve_type      : REG_TYPE;
               END;

    PVALENTW = POINTER TO VALENTW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  VALENT =  VALENTW;
      TYPE PVALENT = PVALENTW;
<* ELSE *>
      TYPE  VALENT =  VALENTA;
      TYPE PVALENT = PVALENTA;
<* END *>

(*
** Default values for parameters that do not exist in the Win 3.1
** compatible APIs.
*)

CONST WIN31_CLASS = NIL;

(*
** API Prototypes.
*)

PROCEDURE RegCloseKey (hKey : HKEY) : LONG;

PROCEDURE RegConnectRegistryA (MachineName  : PCSTR; (* NIL *)
                               hKey         : HKEY;
                               VAR hkResult : HKEY) : LONG;

PROCEDURE RegConnectRegistryW (MachineName  : PCWSTR; (* NIL *)
                               hKey         : HKEY;
                               VAR hkResult : HKEY) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegConnectRegistry = RegConnectRegistryW;
<* ELSE *>
      CONST RegConnectRegistry = RegConnectRegistryA;
<* END *>

PROCEDURE RegCreateKeyA (hKey        : HKEY;
                         SubKey      : PCSTR; (* NIL *)
                         VAR hResult : HKEY) : LONG;

PROCEDURE RegCreateKeyW (hKey        : HKEY;
                         SubKey      : PCWSTR; (* NIL *)
                         VAR kResult : HKEY) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegCreateKey = RegCreateKeyW;
<* ELSE *>
      CONST RegCreateKey = RegCreateKeyA;
<* END *>

PROCEDURE RegCreateKeyExA (hKey                 : HKEY;
                           SubKey               : ARRAY OF CHAR;
                           Reserved             : DWORD;
                           lpClass              : PCSTR; (* NIL *)
                           dwOptions            : REG_OPTION_SET;
                           samDesired           : REGSAM;
                           lpSecurityAttributes : PSECURITY_ATTRIBUTES;
                           VAR Result           : HKEY;
                           VAR lpdwDisposition  : REG_DISPOSITION) : LONG;

PROCEDURE RegCreateKeyExW (hKey                 : HKEY;
                           SubKey               : ARRAY OF WCHAR;
                           Reserved             : DWORD;
                           lpClass              : PCWSTR; (* NIL *)
                           dwOptions            : REG_OPTION_SET;
                           samDesired           : REGSAM;
                           lpSecurityAttributes : PSECURITY_ATTRIBUTES;
                           VAR Result           : HKEY;
                           VAR lpdwDisposition  : REG_DISPOSITION) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegCreateKeyEx = RegCreateKeyExW;
<* ELSE *>
      CONST RegCreateKeyEx = RegCreateKeyExA;
<* END *>

PROCEDURE RegDeleteKeyA (hKey : HKEY; SubKey : ARRAY OF CHAR)  : LONG;
PROCEDURE RegDeleteKeyW (hKey : HKEY; SubKey : ARRAY OF WCHAR) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegDeleteKey = RegDeleteKeyW;
<* ELSE *>
      CONST RegDeleteKey = RegDeleteKeyA;
<* END *>

PROCEDURE RegDeleteValueA (hKey : HKEY; ValueName : PCSTR)  : LONG;  (* NIL *)
PROCEDURE RegDeleteValueW (hKey : HKEY; ValueName : PCWSTR) : LONG;  (* NIL *)

<* IF DEFINED (UNICODE) THEN *>
      CONST RegDeleteValue = RegDeleteValueW;
<* ELSE *>
      CONST RegDeleteValue = RegDeleteValueA;
<* END *>

PROCEDURE RegEnumKeyA (hKey     : HKEY;
                       dwIndex  : DWORD;
                       VAR Name : ARRAY OF WCHAR;
                       cbName   : DWORD) : LONG;

PROCEDURE RegEnumKeyW (hKey     : HKEY;
                       dwIndex  : DWORD;
                       VAR Name : ARRAY OF WCHAR;
                       cbName   : DWORD) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegEnumKey = RegEnumKeyW;
<* ELSE *>
      CONST RegEnumKey = RegEnumKeyA;
<* END *>

PROCEDURE RegEnumKeyExA (hKey                : HKEY;
                         dwIndex             : DWORD;
                         VAR Name            : ARRAY OF CHAR;
                         VAR cbName          : DWORD;
                         lpReserved          : PDWORD;
                         VAR [NIL] Class     : ARRAY OF CHAR;
                         VAR [NIL] cbClass   : DWORD;
                         VAR ftLastWriteTime : FILETIME) : LONG;

PROCEDURE RegEnumKeyExW (hKey                : HKEY;
                         dwIndex             : DWORD;
                         VAR Name            : ARRAY OF WCHAR;
                         VAR cbName          : DWORD;
                         lpReserved          : PDWORD;
                         VAR [NIL] Class     : ARRAY OF WCHAR;
                         VAR [NIL] cbClass   : DWORD;
                         VAR ftLastWriteTime : FILETIME) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegEnumKeyEx = RegEnumKeyExW;
<* ELSE *>
      CONST RegEnumKeyEx = RegEnumKeyExA;
<* END *>

PROCEDURE RegEnumValueA (hKey             : HKEY;
                         dwIndex          : DWORD;
                         VAR ValueName    : ARRAY OF CHAR;
                         VAR cbValueName  : DWORD;
                         lpReserved       : PDWORD;
                         VAR [NIL] Type   : REG_TYPE;
                         lpData           : PBYTE;
                         VAR [NIL] cbData : DWORD) : LONG;

PROCEDURE RegEnumValueW (hKey             : HKEY;
                         dwIndex          : DWORD;
                         VAR ValueName    : ARRAY OF WCHAR;
                         VAR cbValueName  : DWORD;
                         lpReserved       : PDWORD;
                         VAR [NIL] Type   : REG_TYPE;
                         lpData           : PBYTE;
                         VAR [NIL] cbData : DWORD) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegEnumValue = RegEnumValueW;
<* ELSE *>
      CONST RegEnumValue = RegEnumValueA;
<* END *>

PROCEDURE RegFlushKey (hKey : HKEY) : LONG;

PROCEDURE RegGetKeySecurity (hKey                     : HKEY;
                             SecurityInformation      : SECURITY_INFORMATION;
                             SecurityDescriptor       : PSECURITY_DESCRIPTOR;
                             VAR cbSecurityDescriptor : DWORD) : LONG;

PROCEDURE RegLoadKeyA (hKey   : HKEY;
                       SubKey : ARRAY OF CHAR;
                       File   : ARRAY OF CHAR) : LONG;

PROCEDURE RegLoadKeyW (hKey   : HKEY;
                       SubKey : ARRAY OF WCHAR;
                       File   : ARRAY OF WCHAR) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegLoadKey = RegLoadKeyW;
<* ELSE *>
      CONST RegLoadKey = RegLoadKeyA;
<* END *>

PROCEDURE RegNotifyChangeKeyValue (hKey           : HKEY;
                                   bWatchSubtree  : BOOL;
                                   dwNotifyFilter : REG_NOTIFY_SET;
                                   hEvent         : HANDLE;
                                   fAsynchronus   : BOOL) : LONG;

PROCEDURE RegOpenKeyA (hKey         : HKEY;
                       lpSubKey     : PCSTR; (* NIL *)
                       VAR hkResult : HKEY) : LONG;

PROCEDURE RegOpenKeyW (hKey         : HKEY;
                       lpSubKey     : PCWSTR; (* NIL *)
                       VAR hkResult : HKEY) : LONG;


<* IF DEFINED (UNICODE) THEN *>
      CONST RegOpenKey = RegOpenKeyW;
<* ELSE *>
      CONST RegOpenKey = RegOpenKeyA;
<* END *>

PROCEDURE RegOpenKeyExA (hKey         : HKEY;
                         SubKey       : PCSTR;  (* NIL *)
                         ulOptions    : DWORD;        (* reserved *)
                         samDesired   : REGSAM;
                         VAR hkResult : HKEY) : LONG;

PROCEDURE RegOpenKeyExW (hKey         : HKEY;
                         SubKey       : PCWSTR; (* NIL *)
                         ulOptions    : DWORD;        (* reserved *)
                         samDesired   : REGSAM;
                         VAR hkResult : HKEY) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegOpenKeyEx = RegOpenKeyExW;
<* ELSE *>
      CONST RegOpenKeyEx = RegOpenKeyExA;
<* END *>

PROCEDURE RegQueryInfoKeyA (hKey                           : HKEY;
                            VAR [NIL] Class                : ARRAY OF CHAR;
                            VAR [NIL] cbClass              : DWORD;
                            lpReserved                     : PDWORD;
                            VAR [NIL] SubKeys              : DWORD;
                            VAR [NIL] cbMaxSubKeyLen       : DWORD;
                            VAR [NIL] cbMaxClassLen        : DWORD;
                            VAR [NIL] cValues              : DWORD;
                            VAR [NIL] cbMaxValueNameLen    : DWORD;
                            VAR [NIL] cbMaxValueLen        : DWORD;
                            VAR [NIL] cbSecurityDescriptor : DWORD;
                            VAR [NIL] ftLastWriteTime      : FILETIME) : LONG;

PROCEDURE RegQueryInfoKeyW (hKey                           : HKEY;
                            VAR [NIL] Class                : ARRAY OF WCHAR;
                            VAR [NIL] cbClass              : DWORD;
                            lpReserved                     : PDWORD;
                            VAR [NIL] SubKeys              : DWORD;
                            VAR [NIL] cbMaxSubKeyLen       : DWORD;
                            VAR [NIL] cbMaxClassLen        : DWORD;
                            VAR [NIL] cValues              : DWORD;
                            VAR [NIL] cbMaxValueNameLen    : DWORD;
                            VAR [NIL] cbMaxValueLen        : DWORD;
                            VAR [NIL] cbSecurityDescriptor : DWORD;
                            VAR [NIL] ftLastWriteTime      : FILETIME) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegQueryInfoKey = RegQueryInfoKeyW;
<* ELSE *>
      CONST RegQueryInfoKey = RegQueryInfoKeyA;
<* END *>

PROCEDURE RegQueryValueA (hKey            : HKEY;
                          SubKey          : PCSTR; (* NIL *)
                          VAR [NIL] Value : ARRAY OF CHAR;
                          VAR cbValue     : LONG)
                                                  : LONG;

PROCEDURE RegQueryValueW (hKey            : HKEY;
                          SubKey          : PCWSTR; (* NIL *)
                          VAR [NIL] Value : ARRAY OF WCHAR;
                          VAR cbValue     : LONG)
                                                  : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegQueryValue = RegQueryValueW;
<* ELSE *>
      CONST RegQueryValue = RegQueryValueA;
<* END *>

PROCEDURE RegQueryMultipleValuesA (hKey               : HKEY;
                                   VAR val_list       : ARRAY OF VALENTA;
                                   num_vals           : DWORD;
                                   VAR [NIL] ValueBuf : ARRAY OF CHAR;
                                   VAR dwTotsize      : DWORD)
                                                               : LONG;

PROCEDURE RegQueryMultipleValuesW (hKey               : HKEY;
                                   VAR val_list       : ARRAY OF VALENTW;
                                   num_vals           : DWORD;
                                   VAR [NIL] ValueBuf : ARRAY OF WCHAR;
                                   VAR dwTotsize      : DWORD)
                                                               : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegQueryMultipleValues = RegQueryMultipleValuesW;
<* ELSE *>
      CONST RegQueryMultipleValues = RegQueryMultipleValuesA;
<* END *>

PROCEDURE RegQueryValueExA (hKey       : HKEY;
                            ValueName  : ARRAY OF CHAR;
                            lpReserved : PDWORD;
                            VAR lpType : REG_TYPE;
                            lpData     : PBYTE;
                            VAR cbData : DWORD) : LONG;

PROCEDURE RegQueryValueExW (hKey       : HKEY;
                            ValueName  : ARRAY OF WCHAR;
                            lpReserved : PDWORD;
                            VAR lpType : REG_TYPE;
                            lpData     : PBYTE;
                            VAR cbData : DWORD) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegQueryValueEx = RegQueryValueExW;
<* ELSE *>
      CONST RegQueryValueEx = RegQueryValueExA;
<* END *>

PROCEDURE RegReplaceKeyA (hKey    : HKEY;
                          SubKey  : PCWSTR; (* NIL *)
                          NewFile : ARRAY OF CHAR;
                          OldFile : ARRAY OF CHAR) : LONG;

PROCEDURE RegReplaceKeyW (hKey    : HKEY;
                          SubKey  : PCWSTR; (* NIL *)
                          NewFile : ARRAY OF WCHAR;
                          OldFile : ARRAY OF WCHAR) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegReplaceKey = RegReplaceKeyW;
<* ELSE *>
      CONST RegReplaceKey = RegReplaceKeyA;
<* END *>

PROCEDURE RegRestoreKeyA (hKey    : HKEY;
                          File    : ARRAY OF CHAR;
                          dwFlags : REG_RESTORE_SET) : LONG;

PROCEDURE RegRestoreKeyW (hKey    : HKEY;
                          File    : ARRAY OF WCHAR;
                          dwFlags : REG_RESTORE_SET) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegRestoreKey = RegRestoreKeyW;
<* ELSE *>
      CONST RegRestoreKey = RegRestoreKeyA;
<* END *>

PROCEDURE RegSaveKeyA (hKey : HKEY;
                       File : ARRAY OF CHAR;
                       lpSecurityAttributes : PSECURITY_ATTRIBUTES) : LONG;

PROCEDURE RegSaveKeyW (hKey : HKEY;
                       File : ARRAY OF WCHAR;
                       lpSecurityAttributes : PSECURITY_ATTRIBUTES) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegSaveKey = RegSaveKeyW;
<* ELSE *>
      CONST RegSaveKey = RegSaveKeyA;
<* END *>

PROCEDURE RegSetKeySecurity (hKey                : HKEY;
                             SecurityInformation : SECURITY_INFORMATION;
                             SecurityDescriptor  : PSECURITY_DESCRIPTOR) : LONG;

PROCEDURE RegSetValueA (hKey   : HKEY;
                        SubKey : PCSTR; (* NIL *)
                        Type   : REG_TYPE;
                        Data   : ARRAY OF CHAR;
                        cbData : DWORD) : LONG;

PROCEDURE RegSetValueW (hKey   : HKEY;
                        SubKey : PCWSTR; (* NIL *)
                        Type   : REG_TYPE;
                        Data   : ARRAY OF WCHAR;
                        cbData : DWORD) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegSetValue = RegSetValueW;
<* ELSE *>
      CONST RegSetValue = RegSetValueA;
<* END *>

PROCEDURE RegSetValueExA (hKey      : HKEY;
                          ValueName : PSTR; (* NIL *)
                          Reserved  : DWORD;
                          dwType    : REG_TYPE;
                          lpData    : PCBYTE;
                          cbData    : DWORD) : LONG;

PROCEDURE RegSetValueExW (hKey      : HKEY;
                          ValueName : PWSTR; (* NIL *)
                          Reserved  : DWORD;
                          dwType    : REG_TYPE;
                          lpData    : PCBYTE;
                          cbData    : DWORD) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegSetValueEx = RegSetValueExW;
<* ELSE *>
      CONST RegSetValueEx = RegSetValueExA;
<* END *>

PROCEDURE RegUnLoadKeyA (hKey   : HKEY;
                         SubKey : ARRAY OF CHAR) : LONG;

PROCEDURE RegUnLoadKeyW (hKey   : HKEY;
                         SubKey : ARRAY OF WCHAR) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegUnLoadKey = RegUnLoadKeyW;
<* ELSE *>
      CONST RegUnLoadKey = RegUnLoadKeyA;
<* END *>

(*
** Remoteable System Shutdown APIs
*)

PROCEDURE InitiateSystemShutdownA (MachineName          : PCSTR; (* NIL *)
                                   Message              : PCSTR; (* NIL *)
                                   dwTimeout            : DWORD;
                                   bForceAppsClosed     : BOOL;
                                   bRebootAfterShutdown : BOOL) : BOOL;

PROCEDURE InitiateSystemShutdownW (MachineName          : PCWSTR; (* NIL *)
                                   Message              : PCWSTR; (* NIL *)
                                   dwTimeout            : DWORD;
                                   bForceAppsClosed     : BOOL;
                                   bRebootAfterShutdown : BOOL) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST InitiateSystemShutdown = InitiateSystemShutdownW;
<* ELSE *>
      CONST InitiateSystemShutdown = InitiateSystemShutdownA;
<* END *>

PROCEDURE AbortSystemShutdownA (MachineName   : PCSTR)  : BOOL;  (* NIL *)
PROCEDURE AbortSystemShutdownW (lpMachineName : PCWSTR) : BOOL;  (* NIL *)

<* IF DEFINED (UNICODE) THEN *>
      CONST AbortSystemShutdown = AbortSystemShutdownW;
<* ELSE *>
      CONST AbortSystemShutdown = AbortSystemShutdownA;
<* END *>


(* WinNetwk.def

    Standard WINNET Import File for WIN32
*)



(*
** Network types
*)

CONST WNNC_NET_MSNET      = 00010000h;
      WNNC_NET_LANMAN     = 00020000h;
      WNNC_NET_NETWARE    = 00030000h;
      WNNC_NET_VINES      = 00040000h;
      WNNC_NET_10NET      = 00050000h;
      WNNC_NET_LOCUS      = 00060000h;
      WNNC_NET_SUN_PC_NFS = 00070000h;
      WNNC_NET_LANSTEP    = 00080000h;
      WNNC_NET_9TILES     = 00090000h;
      WNNC_NET_LANTASTIC  = 000A0000h;
      WNNC_NET_AS400      = 000B0000h;
      WNNC_NET_FTP_NFS    = 000C0000h;
      WNNC_NET_PATHWORKS  = 000D0000h;
      WNNC_NET_LIFENET    = 000E0000h;
      WNNC_NET_POWERLAN   = 000F0000h;
      WNNC_NET_BWNFS      = 00100000h;
      WNNC_NET_COGENT     = 00110000h;
      WNNC_NET_FARALLON   = 00120000h;
      WNNC_NET_APPLETALK  = 00130000h;
      WNNC_NET_INTERGRAPH = 00140000h;

(*
**  Network Resources.
*)

TYPE RESOURCESCOPE_TYPE = (RESOURCE_SCOPE_0,
                           RESOURCE_CONNECTED,  (* 00000001h *)
                           RESOURCE_GLOBALNET,  (* 00000002h *)
                           RESOURCE_REMEMBERED, (* 00000003h *)
                           RESOURCE_RECENT,     (* 00000004h *)
                           RESOURCE_CONTEXT);   (* 00000005h *)

TYPE RESOURCETYPE_TYPE = BITSET;

CONST RESOURCETYPE_ANY        = { }; (* 0x00000000 *)
      RESOURCETYPE_DISK       = {0}; (* 0x00000001 *)
      RESOURCETYPE_PRINT      = {1}; (* 0x00000002 *)
      RESOURCETYPE_RESERVED   = {3}; (* 0x00000008 *)
      RESOURCETYPE_UNKNOWN    = {0..31}; (* 0xFFFFFFFF *)


TYPE RESOURCEUSAGE_TYPE = BITSET;

CONST RESOURCEUSAGE_CONNECTABLE   = {0}; (* 00000001h *)
      RESOURCEUSAGE_CONTAINER     = {1}; (* 00000002h *)
      RESOURCEUSAGE_NOLOCALDEVICE = {2}; (* 00000004h *)
      RESOURCEUSAGE_SIBLING       = {3}; (* 00000008h *)

      RESOURCEUSAGE_ALL = RESOURCEUSAGE_CONNECTABLE + RESOURCEUSAGE_CONTAINER;

      RESOURCEUSAGE_RESERVED      = {0}; (* 80000000h *)

TYPE RESOURCEDISPLAYTYPE_TYPE = (RESOURCEDISPLAYTYPE_GENERIC,    (* 0x00000000h *)
                                 RESOURCEDISPLAYTYPE_DOMAIN,     (* 0x00000001h *)
                                 RESOURCEDISPLAYTYPE_SERVER,     (* 0x00000002h *)
                                 RESOURCEDISPLAYTYPE_SHARE,      (* 0x00000003h *)
                                 RESOURCEDISPLAYTYPE_FILE,       (* 0x00000004h *)
                                 RESOURCEDISPLAYTYPE_GROUP,      (* 0x00000005h *)
                                 RESOURCEDISPLAYTYPE_NETWORK,    (* 0x00000006h *)
                                 RESOURCEDISPLAYTYPE_ROOT,       (* 0x00000007h *)
                                 RESOURCEDISPLAYTYPE_SHAREADMIN, (* 0x00000008h *)
                                 RESOURCEDISPLAYTYPE_DIRECTORY,  (* 0x00000009h *)
                                 RESOURCEDISPLAYTYPE_TREE);      (* 0x0000000Ah *)

TYPE NETRESOURCEA = RECORD
                           dwScope       : RESOURCESCOPE_TYPE;
                           dwType        : RESOURCETYPE_TYPE;
                           dwDisplayType : RESOURCEDISPLAYTYPE_TYPE;
                           dwUsage       : RESOURCEUSAGE_TYPE;
                           lpLocalName   : PSTR;
                           lpRemoteName  : PSTR;
                           lpComment     : PSTR;
                           lpProvider    : PSTR;
                    END;
    PNETRESOURCEA = POINTER TO NETRESOURCEA;

TYPE NETRESOURCEW = RECORD
                           dwScope       : RESOURCESCOPE_TYPE;
                           dwType        : RESOURCETYPE_TYPE;
                           dwDisplayType : RESOURCEDISPLAYTYPE_TYPE;
                           dwUsage       : RESOURCEUSAGE_TYPE;
                           lpLocalName   : PWSTR;
                           lpRemoteName  : PWSTR;
                           lpComment     : PWSTR;
                           lpProvider    : PWSTR;
                    END;
    PNETRESOURCEW = POINTER TO NETRESOURCEW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  NETRESOURCE =  NETRESOURCEW;
      TYPE PNETRESOURCE = PNETRESOURCEW;
<* ELSE *>
      TYPE  NETRESOURCE =  NETRESOURCEA;
      TYPE PNETRESOURCE = PNETRESOURCEA;
<* END *>

(*
**  Network Connections.
*)

CONST NETPROPERTY_PERSISTENT = 1;

TYPE CONNECT_ENUM = (CONNECT__UPDATE_PROFILE, (* 0 *)
                     CONNECT__UPDATE_RECENT,  (* 1 *)
                     CONNECT__TEMPORARY,      (* 2 *)
                     CONNECT__INTERACTIVE,    (* 3 *)
                     CONNECT__PROMPT,         (* 4 *)
                     CONNECT__NEED_DRIVE,     (* 5 *)
                     CONNECT__REFCOUNT,       (* 6 *)
                     CONNECT__REDIRECT,       (* 7 *)
                     CONNECT__LOCALDRIVE,     (* 8 *)
                     CONNECT__CURRENT_MEDIA); (* 9 *)

     CONNECT_SET = SET OF CONNECT_ENUM;

CONST CONNECT_UPDATE_PROFILE = CONNECT_SET {CONNECT__UPDATE_PROFILE}; (* 0x00000001 *)
      CONNECT_UPDATE_RECENT  = CONNECT_SET {CONNECT__UPDATE_RECENT};  (* 0x00000002 *)
      CONNECT_TEMPORARY      = CONNECT_SET {CONNECT__TEMPORARY};      (* 0x00000004 *)
      CONNECT_INTERACTIVE    = CONNECT_SET {CONNECT__INTERACTIVE};    (* 0x00000008 *)
      CONNECT_PROMPT         = CONNECT_SET {CONNECT__PROMPT};         (* 0x00000010 *)
      CONNECT_NEED_DRIVE     = CONNECT_SET {CONNECT__NEED_DRIVE};     (* 0x00000020 *)
      CONNECT_REFCOUNT       = CONNECT_SET {CONNECT__REFCOUNT};       (* 0x00000040 *)
      CONNECT_REDIRECT       = CONNECT_SET {CONNECT__REDIRECT};       (* 0x00000080 *)
      CONNECT_LOCALDRIVE     = CONNECT_SET {CONNECT__LOCALDRIVE};     (* 0x00000100 *)
      CONNECT_CURRENT_MEDIA  = CONNECT_SET {CONNECT__CURRENT_MEDIA};  (* 0x00000200 *)


PROCEDURE WNetAddConnectionA (RemoteName : ARRAY OF CHAR;
                              Password   : PCSTR;
                              LocalName  : PCSTR) : DWORD;

PROCEDURE WNetAddConnectionW (RemoteName : ARRAY OF WCHAR;
                              Password   : PCWSTR;
                              LocalName  : PCWSTR) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST WNetAddConnection = WNetAddConnectionW;
<* ELSE *>
      CONST WNetAddConnection = WNetAddConnectionA;
<* END *>


PROCEDURE WNetAddConnection2A (VAR NetResource : NETRESOURCEA;
                               Password        : PCSTR;
                               UserName        : PCSTR;
                               dwFlags         : CONNECT_SET) : DWORD;

PROCEDURE WNetAddConnection2W (VAR NetResource : NETRESOURCEW;
                               Password        : PCWSTR;
                               UserName        : PCWSTR;
                               dwFlags         : CONNECT_SET) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST WNetAddConnection2 = WNetAddConnection2W;
<* ELSE *>
      CONST WNetAddConnection2 = WNetAddConnection2A;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE WNetAddConnection3A (hwndOwner   : HWND;
                               NetResource : NETRESOURCEA;
                               Password    : PCSTR;
                               UserName    : PCSTR;
                               dwFlags     : CONNECT_SET) : DWORD;
<* ELSE *>
PROCEDURE WNetAddConnection3A (hwndOwner   : HWND;
                               NetResource : PNETRESOURCEA;
                               Password    : PCSTR;
                               UserName    : PCSTR;
                               dwFlags     : CONNECT_SET) : DWORD;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE WNetAddConnection3W (hwndOwner   : HWND;
                               NetResource : NETRESOURCEW;
                               Password    : PCWSTR;
                               UserName    : PCWSTR;
                               dwFlags     : CONNECT_SET) : DWORD;
<* ELSE *>
PROCEDURE WNetAddConnection3W (hwndOwner   : HWND;
                               NetResource : PNETRESOURCEW;
                               Password    : PCWSTR;
                               UserName    : PCWSTR;
                               dwFlags     : CONNECT_SET) : DWORD;
<* END *>

<* IF DEFINED (UNICODE) THEN *>
      CONST WNetAddConnection3 = WNetAddConnection3W;
<* ELSE *>
      CONST WNetAddConnection3 = WNetAddConnection3A;
<* END *>

PROCEDURE WNetCancelConnectionA (lpName :  ARRAY OF CHAR; fForce : BOOL) : DWORD;
PROCEDURE WNetCancelConnectionW (lpName : ARRAY OF WCHAR; fForce : BOOL) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST WNetCancelConnection = WNetCancelConnectionW;
<* ELSE *>
      CONST WNetCancelConnection = WNetCancelConnectionA;
<* END *>

PROCEDURE WNetCancelConnection2A (lpName  : ARRAY OF CHAR;
                                  dwFlags : CONNECT_SET;
                                  fForce  : BOOL) : DWORD;

PROCEDURE WNetCancelConnection2W (lpName  : ARRAY OF WCHAR;
                                  dwFlags : CONNECT_SET;
                                  fForce  : BOOL) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST WNetCancelConnection2 = WNetCancelConnection2W;
<* ELSE *>
      CONST WNetCancelConnection2 = WNetCancelConnection2A;
<* END *>

PROCEDURE WNetGetConnectionA (LocalName  : ARRAY OF CHAR;
                              RemoteName : STRING;
                              VAR Length : DWORD) : DWORD;

PROCEDURE WNetGetConnectionW (LocalName  : ARRAY OF WCHAR;
                              RemoteName : WSTRING;
                              VAR Length : DWORD) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST WNetGetConnection = WNetGetConnectionW;
<* ELSE *>
      CONST WNetGetConnection = WNetGetConnectionA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE WNetUseConnectionA (hwndOwner     : HWND;
                             NetResource    : NETRESOURCEA;
                             UserID         : PCSTR;
                             Password       : PCSTR;
                             dwFlags        : CONNECT_SET;
                             AccessName     : PSTR;
                             VAR BufferSize : DWORD;
                             VAR Result     : DWORD) : DWORD;
<* ELSE *>
PROCEDURE WNetUseConnectionA (hwndOwner     : HWND;
                             NetResource    : PNETRESOURCEA;
                             UserID         : PCSTR;
                             Password       : PCSTR;
                             dwFlags        : CONNECT_SET;
                             AccessName     : PSTR;
                             VAR BufferSize : DWORD;
                             VAR Result     : DWORD) : DWORD;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE WNetUseConnectionW (hwndOwner     : HWND;
                             NetResource    : NETRESOURCEA;
                             UserID         : PCWSTR;
                             Password       : PCWSTR;
                             dwFlags        : CONNECT_SET;
                             AccessName     : PWSTR;
                             VAR BufferSize : DWORD;
                             VAR Result     : DWORD) : DWORD;
<* ELSE *>
PROCEDURE WNetUseConnectionW (hwndOwner     : HWND;
                             NetResource    : PNETRESOURCEA;
                             UserID         : PCWSTR;
                             Password       : PCWSTR;
                             dwFlags        : CONNECT_SET;
                             AccessName     : PWSTR;
                             VAR BufferSize : DWORD;
                             VAR Result     : DWORD) : DWORD;
<* END *>

<* IF DEFINED (UNICODE) THEN *>
      CONST WNetUseConnection = WNetUseConnectionW;
<* ELSE *>
      CONST WNetUseConnection = WNetUseConnectionA;
<* END *>

PROCEDURE WNetSetConnectionA (Name       : ARRAY OF CHAR;
                              Properties : DWORD;
                              pvValues   : PVOID) : DWORD;

PROCEDURE WNetSetConnectionW (Name       : ARRAY OF WCHAR;
                              Properties : DWORD;
                              pvValues   : PVOID) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST WNetSetConnection = WNetSetConnectionW;
<* ELSE *>
      CONST WNetSetConnection = WNetSetConnectionA;
<* END *>

(*
**  Network Connection Dialogs.
*)

PROCEDURE WNetConnectionDialog (hwnd   : HWND;
                                dwType : RESOURCETYPE_TYPE) : DWORD;

PROCEDURE WNetDisconnectDialog (hwnd   : HWND;
                                dwType : RESOURCETYPE_TYPE) : DWORD;



TYPE CONNDLG_ENUM = (CONNDLG__RO_PATH,      (* 0 - Resource path should be read-only    *)
                     CONNDLG__CONN_POINT,   (* 1 - Netware -style movable connection point enabled *)
                     CONNDLG__USE_MRU,      (* 2 - Use MRU combobox  *)
                     CONNDLG__HIDE_BOX,     (* 3 - Hide persistent connect checkbox  *)
                     CONNDLG__PERSIST,      (* 4 - Force persistent connection *)
                     CONNDLG__NOT_PERSIST); (* 5 - Force connection NOT persistent *)

     CONNDLG_SET = SET OF CONNDLG_ENUM;


CONST CONNDLG_RO_PATH     = CONNDLG_SET {CONNDLG__RO_PATH   }; (* 0x00000001 *)
      CONNDLG_CONN_POINT  = CONNDLG_SET {CONNDLG__CONN_POINT}; (* 0x00000002 *)
      CONNDLG_USE_MRU     = CONNDLG_SET {CONNDLG__USE_MRU   }; (* 0x00000004 *)
      CONNDLG_HIDE_BOX    = CONNDLG_SET {CONNDLG__HIDE_BOX  }; (* 0x00000008 *)

(*
 * NOTE:  Set at most ONE of the below flags.  If neither flag is set,
 *        then the persistence is set to whatever the user chose during
 *        a previous connection
 *)

      CONNDLG_PERSIST     = CONNDLG_SET {CONNDLG__PERSIST    }; (* 0x00000010 *)
      CONNDLG_NOT_PERSIST = CONNDLG_SET {CONNDLG__NOT_PERSIST}; (* 0x00000020 *)

TYPE CONNECTDLGSTRUCTA  =
     RECORD
          cbStructure : DWORD;         (* size of this structure in bytes *)
          hwndOwner   : HWND;          (* owner window for the dialog *)
          lpConnRes   : PNETRESOURCEA; (* Requested Resource info    *)
          dwFlags     : CONNDLG_SET;   (* flags (see below) *)
          dwDevNum    : DWORD;         (* number of devices connected to *)
     END;
    PCONNECTDLGSTRUCTA = POINTER TO CONNECTDLGSTRUCTA;

TYPE CONNECTDLGSTRUCTW  =
     RECORD
          cbStructure : DWORD;         (* size of this structure in bytes *)
          hwndOwner   : HWND;          (* owner window for the dialog *)
          lpConnRes   : PNETRESOURCEW; (* Requested Resource info    *)
          dwFlags     : CONNDLG_SET;   (* flags (see below) *)
          dwDevNum    : DWORD;         (* number of devices connected to *)
     END;
    PCONNECTDLGSTRUCTW = POINTER TO CONNECTDLGSTRUCTW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE CONNECTDLGSTRUCT  =  CONNECTDLGSTRUCTW;
      TYPE PCONNECTDLGSTRUCT = PCONNECTDLGSTRUCTW;
<* ELSE *>
      TYPE CONNECTDLGSTRUCT  =  CONNECTDLGSTRUCTA;
      TYPE PCONNECTDLGSTRUCT = PCONNECTDLGSTRUCTA;
<* END *>

PROCEDURE WNetConnectionDialog1A (VAR ConnDlgStruct : CONNECTDLGSTRUCTA) : DWORD;
PROCEDURE WNetConnectionDialog1W (VAR ConnDlgStruct : CONNECTDLGSTRUCTW) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST WNetConnectionDialog1 = WNetConnectionDialog1W;
<* ELSE *>
      CONST WNetConnectionDialog1 = WNetConnectionDialog1A;
<* END *>


TYPE DISC_ENUM = (DISC__UPDATE_PROFILE, (* 0 *)
                  DISC__1, DISC__2,
                  DISC__3, DISC__4,
                  DISC__5,
                  DISC__NO_FORCE);      (* 6 *)

     DISC_SET = SET OF DISC_ENUM;

CONST DISC_UPDATE_PROFILE = DISC_SET {DISC__UPDATE_PROFILE}; (* 0x00000001 *)
      DISC_NO_FORCE       = DISC_SET {DISC__NO_FORCE};       (* 0x00000040 *)

TYPE DISCDLGSTRUCTA =
     RECORD
          cbStructure  : DWORD;     (* size of this structure in bytes *)
          hwndOwner    : HWND;      (* owner window for the dialog *)
          lpLocalName  : PSTR;      (* local device name *)
          lpRemoteName : PSTR;      (* network resource name *)
          dwFlags      : DISC_SET;  (* flags *)
     END;
    PDISCDLGSTRUCTA = POINTER TO DISCDLGSTRUCTA;

TYPE DISCDLGSTRUCTW =
     RECORD
          cbStructure  : DWORD;     (* size of this structure in bytes *)
          hwndOwner    : HWND;      (* owner window for the dialog *)
          lpLocalName  : PWSTR;     (* local device name *)
          lpRemoteName : PWSTR;     (* network resource name *)
          dwFlags      : DISC_SET;  (* flags *)
     END;
    PDISCDLGSTRUCTW = POINTER TO DISCDLGSTRUCTW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  DISCDLGSTRUCT =  DISCDLGSTRUCTW;
      TYPE PDISCDLGSTRUCT = PDISCDLGSTRUCTW;
<* ELSE *>
      TYPE  DISCDLGSTRUCT =  DISCDLGSTRUCTA;
      TYPE PDISCDLGSTRUCT = PDISCDLGSTRUCTA;
<* END *>

PROCEDURE WNetDisconnectDialog1A (VAR ConnDlgStruct : DISCDLGSTRUCTA) : DWORD;
PROCEDURE WNetDisconnectDialog1W (VAR ConnDlgStruct : DISCDLGSTRUCTW) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST WNetDisconnectDialog1 = WNetDisconnectDialog1W;
<* ELSE *>
      CONST WNetDisconnectDialog1 = WNetDisconnectDialog1A;
<* END *>

(*
**  Network Browsing.
*)

PROCEDURE WNetOpenEnumA (dwScope : RESOURCESCOPE_TYPE;
                         dwType  : RESOURCETYPE_TYPE;
                         dwUsage : RESOURCEUSAGE_TYPE;
                         VAR [NIL] NetResource : NETRESOURCEA;
                         VAR hEnum : HANDLE) : DWORD;

PROCEDURE WNetOpenEnumW (dwScope : RESOURCESCOPE_TYPE;
                         dwType  : RESOURCETYPE_TYPE;
                         dwUsage : RESOURCEUSAGE_TYPE;
                         VAR [NIL] NetResource : NETRESOURCEW;
                         VAR hEnum : HANDLE) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST WNetOpenEnum = WNetOpenEnumW;
<* ELSE *>
      CONST WNetOpenEnum = WNetOpenEnumA;
<* END *>

PROCEDURE WNetEnumResourceA (hEnum          : HANDLE;
                             VAR Count      : DWORD;
                             Buffer         : PVOID;
                             VAR BufferSize : DWORD) : DWORD;

PROCEDURE WNetEnumResourceW (hEnum          : HANDLE;
                             VAR Count      : DWORD;
                             Buffer         : PVOID;
                             VAR BufferSize : DWORD) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST WNetEnumResource = WNetEnumResourceW;
<* ELSE *>
      CONST WNetEnumResource = WNetEnumResourceA;
<* END *>

PROCEDURE WNetCloseEnum (hEnum : HANDLE) : DWORD;


(*
**  Universal Naming.
*)

TYPE NAME_INFO_ENUM = (NAME_INFO_0,
                       UNIVERSAL_NAME_INFO_LEVEL, (* 0x00000001 *)
                       REMOTE_NAME_INFO_LEVEL);   (* 0x00000002 *)

TYPE UNIVERSAL_NAME_INFOA = RECORD
                                   UniversalName : PSTR;
                            END;
    PUNIVERSAL_NAME_INFOA = POINTER TO UNIVERSAL_NAME_INFOA;

TYPE UNIVERSAL_NAME_INFOW = RECORD
                                   UniversalName : PWSTR;
                            END;
    PUNIVERSAL_NAME_INFOW = POINTER TO UNIVERSAL_NAME_INFOW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE UNIVERSAL_NAME_INFO  =  UNIVERSAL_NAME_INFOW;
      TYPE PUNIVERSAL_NAME_INFO = PUNIVERSAL_NAME_INFOW;
<* ELSE *>
      TYPE UNIVERSAL_NAME_INFO  =  UNIVERSAL_NAME_INFOA;
      TYPE PUNIVERSAL_NAME_INFO = PUNIVERSAL_NAME_INFOA;
<* END *>

TYPE REMOTE_NAME_INFOA = RECORD
                                lpUniversalName  : PSTR;
                                lpConnectionName : PSTR;
                                lpRemainingPath  : PSTR;
                         END;
    PREMOTE_NAME_INFOA = POINTER TO REMOTE_NAME_INFOA;

TYPE REMOTE_NAME_INFOW = RECORD
                                lpUniversalName  : PWSTR;
                                lpConnectionName : PWSTR;
                                lpRemainingPath  : PWSTR;
                         END;
    PREMOTE_NAME_INFOW = POINTER TO REMOTE_NAME_INFOW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  REMOTE_NAME_INFO =  REMOTE_NAME_INFOW;
      TYPE PREMOTE_NAME_INFO = PREMOTE_NAME_INFOW;
<* ELSE *>
      TYPE  REMOTE_NAME_INFO =  REMOTE_NAME_INFOA;
      TYPE PREMOTE_NAME_INFO = PREMOTE_NAME_INFOA;
<* END *>

PROCEDURE WNetGetUniversalNameA (LocalPath      : ARRAY OF CHAR;
                                 dwInfoLevel    : NAME_INFO_ENUM;
                                 Buffer         : PVOID;
                                 VAR BufferSize : DWORD) : DWORD;

PROCEDURE WNetGetUniversalNameW (LocalPath      : ARRAY OF WCHAR;
                                 dwInfoLevel    : NAME_INFO_ENUM;
                                 Buffer         : PVOID;
                                 VAR BufferSize : DWORD) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST WNetGetUniversalName = WNetGetUniversalNameW;
<* ELSE *>
      CONST WNetGetUniversalName = WNetGetUniversalNameA;
<* END *>


(*
**  Authentication and Logon/Logoff.
*)

PROCEDURE WNetGetUserA (Name       : PCSTR;
                        UserName   : PSTR;
                        VAR Length : DWORD) : DWORD;

PROCEDURE WNetGetUserW (Name       : PCWSTR;
                        UserName   : PWSTR;
                        VAR Length : DWORD) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST WNetGetUser = WNetGetUserW;
<* ELSE *>
      CONST WNetGetUser = WNetGetUserA;
<* END *>


(*
** Other.
*)

CONST WNFMT_MULTILINE         = 01h;
      WNFMT_ABBREVIATED       = 02h;
      WNFMT_INENUM            = 10h;
      WNFMT_CONNECTION        = 20h;

PROCEDURE WNetGetProviderNameA (dwNetType : DWORD;
                                ProviderName : STRING;
                                VAR  lpBufferSize : DWORD) : DWORD;

PROCEDURE WNetGetProviderNameW (dwNetType : DWORD;
                                ProviderName : WSTRING;
                                VAR  lpBufferSize : DWORD) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST WNetGetProviderName = WNetGetProviderNameW;
<* ELSE *>
      CONST WNetGetProviderName = WNetGetProviderNameA;
<* END *>

TYPE NETINFOSTRUCT  = RECORD
                             cbStructure       : DWORD;
                             dwProviderVersion : DWORD;
                             dwStatus          : DWORD;
                             dwCharacteristics : DWORD;
                             dwHandle          : DWORD;
                             wNetType          : WORD;
                             dwPrinters        : DWORD;
                             dwDrives          : DWORD;
                      END;
     PNETINFOSTRUCT = POINTER TO NETINFOSTRUCT;

CONST NETINFO_DLL16      = 00000001h;  (* Provider running as 16 bit Winnet Driver *)
      NETINFO_DISKRED    = 00000004h;  (* Provider requires disk redirections to connect *)
      NETINFO_PRINTERRED = 00000008h;  (* Provider requires printer redirections to connect *)


PROCEDURE WNetGetNetworkInformationA (Provider : ARRAY OF CHAR;
                                      VAR lpNetInfoStruct : NETINFOSTRUCT) : DWORD;

PROCEDURE WNetGetNetworkInformationW (Provider : ARRAY OF WCHAR;
                                      VAR lpNetInfoStruct : NETINFOSTRUCT) : DWORD;
<* IF DEFINED (UNICODE) THEN *>
      CONST WNetGetNetworkInformation = WNetGetNetworkInformationW;
<* ELSE *>
      CONST WNetGetNetworkInformation = WNetGetNetworkInformationA;
<* END *>

(*
**  User Profiles.
*)

TYPE PFNGETPROFILEPATHA = PROCEDURE ((* pszUsername : *) PCSTR,
                                     (* pszBuffer   : *) PSTR,
                                     (* cbBuffer    : *) UINT) : UINT;

TYPE PFNGETPROFILEPATHW = PROCEDURE ((* pszUsername : *) PCWSTR,
                                     (* pszBuffer   : *) PWSTR,
                                     (* cbBuffer    : *) UINT) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      TYPE PFNGETPROFILEPATH = PFNGETPROFILEPATHW;
<* ELSE *>
      TYPE PFNGETPROFILEPATH = PFNGETPROFILEPATHA;
<* END *>

TYPE PFNRECONCILEPROFILEA = PROCEDURE ((* CentralFile : *) PCSTR,
                                       (* LocalFile :   *) PCSTR,
                                       (* dwFlags :     *) DWORD) : UINT;

TYPE PFNRECONCILEPROFILEW = PROCEDURE ((* CentralFile : *) PCWSTR,
                                       (* LocalFile :   *) PCWSTR,
                                       (* dwFlags :     *) DWORD) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      TYPE PFNRECONCILEPROFILE = PFNRECONCILEPROFILEW;
<* ELSE *>
      TYPE PFNRECONCILEPROFILE = PFNRECONCILEPROFILEA;
<* END *>

CONST RP_LOGON   = 01h;  (* if set, do for logon, else for logoff *)
      RP_INIFILE = 02h;  (* if set, reconcile .INI file, else reg. hive *)

(*
**  Policies.
*)

TYPE PFNPROCESSPOLICIESA = PROCEDURE ( (* hwnd         : *) HWND,
                                       (* Path         : *) PCSTR,
                                       (* Username     : *) PCSTR,
                                       (* ComputerName : *) PCSTR,
                                       (* dwFlags      : *) DWORD) : BOOL;

TYPE PFNPROCESSPOLICIESW = PROCEDURE ( (* hwnd         : *) HWND,
                                       (* Path         : *) PCWSTR,
                                       (* Username     : *) PCWSTR,
                                       (* ComputerName : *) PCWSTR,
                                       (* dwFlags      : *) DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      TYPE PFNPROCESSPOLICIES = PFNPROCESSPOLICIESW;
<* ELSE *>
      TYPE PFNPROCESSPOLICIES = PFNPROCESSPOLICIESA;
<* END *>

CONST PP_DISPLAYERRORS = 01h; (* if set, display error messages, else fail silently if error *)

(*
**  Error handling.
*)

PROCEDURE WNetGetLastErrorA (VAR Error     : DWORD;
                             ErrorBuf      : PSTR;
                             nErrorBufSize : DWORD;
                             lpNameBuf     : PSTR;
                             nNameBufSize  : DWORD) : DWORD;

PROCEDURE WNetGetLastErrorW (VAR Error     : DWORD;
                             ErrorBuf      : PWSTR;
                             nErrorBufSize : DWORD;
                             lpNameBuf     : PWSTR;
                             nNameBufSize  : DWORD) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST WNetGetLastError = WNetGetLastErrorW;
<* ELSE *>
      CONST WNetGetLastError = WNetGetLastErrorA;
<* END *>

(*
**  STATUS CODES
*)

(* General *)

CONST WN_SUCCESS                    = NO_ERROR;
      WN_NO_ERROR                   = NO_ERROR;
      WN_NOT_SUPPORTED              = ERROR_NOT_SUPPORTED;
      WN_CANCEL                     = ERROR_CANCELLED;
      WN_RETRY                      = ERROR_RETRY;
      WN_NET_ERROR                  = ERROR_UNEXP_NET_ERR;
      WN_MORE_DATA                  = ERROR_MORE_DATA;
      WN_BAD_POINTER                = ERROR_INVALID_ADDRESS;
      WN_BAD_VALUE                  = ERROR_INVALID_PARAMETER;
      WN_BAD_USER                   = ERROR_BAD_USERNAME;
      WN_BAD_PASSWORD               = ERROR_INVALID_PASSWORD;
      WN_ACCESS_DENIED              = ERROR_ACCESS_DENIED;
      WN_FUNCTION_BUSY              = ERROR_BUSY;
      WN_WINDOWS_ERROR              = ERROR_UNEXP_NET_ERR;
      WN_OUT_OF_MEMORY              = ERROR_NOT_ENOUGH_MEMORY;
      WN_NO_NETWORK                 = ERROR_NO_NETWORK;
      WN_EXTENDED_ERROR             = ERROR_EXTENDED_ERROR;
      WN_BAD_LEVEL                  = ERROR_INVALID_LEVEL;
      WN_BAD_HANDLE                 = ERROR_INVALID_HANDLE;
      WN_NOT_INITIALIZING           = ERROR_ALREADY_INITIALIZED;
      WN_NO_MORE_DEVICES            = ERROR_NO_MORE_DEVICES;

(* Connection *)

      WN_NOT_CONNECTED              = ERROR_NOT_CONNECTED;
      WN_OPEN_FILES                 = ERROR_OPEN_FILES;
      WN_DEVICE_IN_USE              = ERROR_DEVICE_IN_USE;
      WN_BAD_NETNAME                = ERROR_BAD_NET_NAME;
      WN_BAD_LOCALNAME              = ERROR_BAD_DEVICE;
      WN_ALREADY_CONNECTED          = ERROR_ALREADY_ASSIGNED;
      WN_DEVICE_ERROR               = ERROR_GEN_FAILURE;
      WN_CONNECTION_CLOSED          = ERROR_CONNECTION_UNAVAIL;
      WN_NO_NET_OR_BAD_PATH         = ERROR_NO_NET_OR_BAD_PATH;
      WN_BAD_PROVIDER               = ERROR_BAD_PROVIDER;
      WN_CANNOT_OPEN_PROFILE        = ERROR_CANNOT_OPEN_PROFILE;
      WN_BAD_PROFILE                = ERROR_BAD_PROFILE;
      WN_BAD_DEV_TYPE               = ERROR_BAD_DEV_TYPE;
      WN_DEVICE_ALREADY_REMEMBERED  = ERROR_DEVICE_ALREADY_REMEMBERED;

(* Enumeratio *)

      WN_NO_MORE_ENTRIES            = ERROR_NO_MORE_ITEMS;
      WN_NOT_CONTAINER              = ERROR_NOT_CONTAINER;

(* Authentication *)

      WN_NOT_AUTHENTICATED          = ERROR_NOT_AUTHENTICATED;
      WN_NOT_LOGGED_ON              = ERROR_NOT_LOGGED_ON;
      WN_NOT_VALIDATED              = ERROR_NO_LOGON_SERVERS;

(*
**  For Shell
*)

TYPE NETCONNECTINFOSTRUCT  = RECORD
                                    cbStructure   : DWORD;
                                    dwFlags       : DWORD;
                                    dwSpeed       : DWORD;
                                    dwDelay       : DWORD;
                                    dwOptDataSize : DWORD;
                             END;
    PNETCONNECTINFOSTRUCT = POINTER TO NETCONNECTINFOSTRUCT;

TYPE WNCON_ENUM = (WNCON__FORNETCARD, (* 0 *)
                   WNCON__NOTROUTED,  (* 1 *)
                   WNCON__SLOWLINK,   (* 2 *)
                   WNCON__DYNAMIC);   (* 3 *)

     WNCON_SET = SET OF WNCON_ENUM;

CONST WNCON_FORNETCARD = WNCON_SET {WNCON__FORNETCARD}; (* 0x00000001 *)
      WNCON_NOTROUTED  = WNCON_SET {WNCON__NOTROUTED }; (* 0x00000002 *)
      WNCON_SLOWLINK   = WNCON_SET {WNCON__SLOWLINK  }; (* 0x00000004 *)
      WNCON_DYNAMIC    = WNCON_SET {WNCON__DYNAMIC   }; (* 0x00000008 *)

PROCEDURE MultinetGetConnectionPerformanceA (
               VAR NetResource : NETRESOURCEA;
               VAR NetConnectInfoStruct : NETCONNECTINFOSTRUCT) : DWORD;

PROCEDURE MultinetGetConnectionPerformanceW (
               VAR NetResource : NETRESOURCEW;
               VAR NetConnectInfoStruct : NETCONNECTINFOSTRUCT) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST MultinetGetConnectionPerformance = MultinetGetConnectionPerformanceW;
<* ELSE *>
      CONST MultinetGetConnectionPerformance = MultinetGetConnectionPerformanceA;
<* END *>


(*****************************************************************************
*                                                                            *
* cderr.def -     Common dialog error return codes                           *
*                                                                            *
*****************************************************************************)

CONST CDERR_DIALOGFAILURE    = 0FFFFh;

      CDERR_GENERALCODES     = 0000h;
      CDERR_STRUCTSIZE       = 0001h;
      CDERR_INITIALIZATION   = 0002h;
      CDERR_NOTEMPLATE       = 0003h;
      CDERR_NOHINSTANCE      = 0004h;
      CDERR_LOADSTRFAILURE   = 0005h;
      CDERR_FINDRESFAILURE   = 0006h;
      CDERR_LOADRESFAILURE   = 0007h;
      CDERR_LOCKRESFAILURE   = 0008h;
      CDERR_MEMALLOCFAILURE  = 0009h;
      CDERR_MEMLOCKFAILURE   = 000Ah;
      CDERR_NOHOOK           = 000Bh;
      CDERR_REGISTERMSGFAIL  = 000Ch;

      PDERR_PRINTERCODES     = 1000h;
      PDERR_SETUPFAILURE     = 1001h;
      PDERR_PARSEFAILURE     = 1002h;
      PDERR_RETDEFFAILURE    = 1003h;
      PDERR_LOADDRVFAILURE   = 1004h;
      PDERR_GETDEVMODEFAIL   = 1005h;
      PDERR_INITFAILURE      = 1006h;
      PDERR_NODEVICES        = 1007h;
      PDERR_NODEFAULTPRN     = 1008h;
      PDERR_DNDMMISMATCH     = 1009h;
      PDERR_CREATEICFAILURE  = 100Ah;
      PDERR_PRINTERNOTFOUND  = 100Bh;
      PDERR_DEFAULTDIFFERENT = 100Ch;

      CFERR_CHOOSEFONTCODES  = 2000h;
      CFERR_NOFONTS          = 2001h;
      CFERR_MAXLESSTHANMIN   = 2002h;

      FNERR_FILENAMECODES    = 3000h;
      FNERR_SUBCLASSFAILURE  = 3001h;
      FNERR_INVALIDFILENAME  = 3002h;
      FNERR_BUFFERTOOSMALL   = 3003h;

      FRERR_FINDREPLACECODES = 4000h;
      FRERR_BUFFERLENGTHZERO = 4001h;

      CCERR_CHOOSECOLORCODES = 5000h;


(******************************************************************************
*                                                                             *
* DDE.def - Dynamic Data Exchange structures and definitions                  *
*                                                                             *
******************************************************************************)



(* DDE window messages *)

CONST WM_DDE_FIRST      = 03E0h;
      WM_DDE_INITIATE   = WM_DDE_FIRST;
      WM_DDE_TERMINATE  = WM_DDE_FIRST+1;
      WM_DDE_ADVISE     = WM_DDE_FIRST+2;
      WM_DDE_UNADVISE   = WM_DDE_FIRST+3;
      WM_DDE_ACK        = WM_DDE_FIRST+4;
      WM_DDE_DATA       = WM_DDE_FIRST+5;
      WM_DDE_REQUEST    = WM_DDE_FIRST+6;
      WM_DDE_POKE       = WM_DDE_FIRST+7;
      WM_DDE_EXECUTE    = WM_DDE_FIRST+8;
      WM_DDE_LAST       = WM_DDE_FIRST+8;


(* Following are constants for "flag" field in the structures *)

CONST fAckReq   = VAL (WORD, 8000h);
      fDeferUpd = VAL (WORD, 4000h);
      fBusy     = VAL (WORD, 4000h);
      fRelease  = VAL (WORD, 2000h);
      fResponse = VAL (WORD, 1000h);

(*----------------------------------------------------------------------------
|       DDEACK structure
|
|        Structure of wStatus (LOWORD(lParam)) in WM_DDE_ACK message
|       sent in response to a WM_DDE_DATA, WM_DDE_REQUEST, WM_DDE_POKE,
|       WM_DDE_ADVISE, or WM_DDE_UNADVISE message.
|
----------------------------------------------------------------------------*)

TYPE DDEACK = WORD;
 (* bit  8000h  = fBusy;
         4000h  = fAck;
    bits 0..FFh = bAppReturnCode;

 *)

(*----------------------------------------------------------------------------
|       DDEADVISE structure
|
|        WM_DDE_ADVISE parameter structure for hOptions (LOWORD(lParam))
|
----------------------------------------------------------------------------*)


TYPE DDEADVISE = RECORD
                        flags    : WORD;
                        cfFormat : SHORT;
                 END;

(* fDeferUpd and fAckReq allowed in flags *)

(*----------------------------------------------------------------------------
|       DDEDATA structure
|
|       WM_DDE_DATA parameter structure for hData (LOWORD(lParam)).
|       The actual size of this structure depends on the size of
|       the Value array.
|
----------------------------------------------------------------------------*)

TYPE DDEDATA = RECORD
                      flags    : WORD;
                      cfFormat : SHORT;
                      Value    : ARRAY [0..0] OF BYTE;
               END;

(* flag field constants *)

(* fResponse, fRelease, fAckReq allowed in flags *)


(*----------------------------------------------------------------------------
|        DDEPOKE structure
|
|        WM_DDE_POKE parameter structure for hData (LOWORD(lParam)).
|       The actual size of this structure depends on the size of
|       the Value array.
|
----------------------------------------------------------------------------*)

TYPE DDEPOKE = RECORD
                      flags    : WORD;
                      cfFormat : SHORT;
                      Value    : ARRAY [0..0] OF BYTE;
               END;

(* the only flag allowed uf fRelease *)


(*----------------------------------------------------------------------------
The following types were used in previous versions of the Windows SDK.
They are still valid.  The above typedef's define exactly the same structures
as those below.  The above typedef names are recommended, however, as they
are more meaningful.
----------------------------------------------------------------------------*)

TYPE DDELN = RECORD
                    flags : WORD;
                    cfFormat : SHORT;
             END;

(*  fRelease, fDeferUpd, fAckReq allowed in flags *)

TYPE DDEUP = RECORD
                    flags    : WORD;
                    cfFormat : SHORT;
                    rgb      : ARRAY [0..0] OF BYTE;
             END;

(* fAck, fRelease, fReserved, fAckReq allowed *)


(*
 * DDE SECURITY
 *)

<* IF BACKEND # "C" THEN *>
PROCEDURE DdeSetQualityOfService
             (hwndClient       : HWND;
              osNew            : SECURITY_QUALITY_OF_SERVICE;  (*!*)
              VAR [NIL] osPrev : SECURITY_QUALITY_OF_SERVICE) : BOOL;
<* ELSE *>
PROCEDURE DdeSetQualityOfService
             (hwndClient       : HWND;
              osNew            : PSECURITY_QUALITY_OF_SERVICE;  (*!*)
              VAR [NIL] osPrev : SECURITY_QUALITY_OF_SERVICE) : BOOL;
<* END *>

PROCEDURE ImpersonateDdeClientWindow (hWndClient : HWND;
                                      hWndServer : HWND) : BOOL;



(*
 * DDE message packing APIs
 *)
PROCEDURE PackDDElParam   (msg : UINT; uiLo, uiHi : UINT) : LONG;
PROCEDURE UnpackDDElParam (msg : UINT; lParam : LONG; VAR uiLo, uiHi : UINT) : BOOL;
PROCEDURE FreeDDElParam   (msg : UINT; lParam : LONG) : BOOL;
PROCEDURE ReuseDDElParam  (lParam : LONG; msgIn, msgOut, uiLo, uiHi : UINT) : LONG;





(******************************************************************************
*                                                                             *
*  DDEML.def - DDEML API definition file                                      *
*                                                                             *
******************************************************************************)


(******** public types ********)

TYPE HCONVLIST = POINTER TO RECORD END;
     HCONV     = POINTER TO RECORD END;
     HSZ       = POINTER TO RECORD END;
     HDDEDATA  = POINTER TO RECORD END;


(* the following structure is for use with XTYP_WILDCONNECT processing. *)

TYPE HSZPAIR = RECORD
                      hszSvc   : HSZ;
                      hszTopic : HSZ;
               END;
    PHSZPAIR = POINTER TO HSZPAIR;

(* The following structure is used by DdeConnect() and DdeConnectList() and
   by XTYP_CONNECT and XTYP_WILDCONNECT callbacks. *)

TYPE CONVCONTEXT =
     RECORD
            cb         : UINT;      (* set to sizeof(CONVCONTEXT) *)
            wFlags     : UINT;      (* none currently defined. *)
            wCountryID : UINT;      (* country code for topic/item strings used. *)
            iCodePage  : INTEGER;   (* codepage used for topic/item strings. *)
            dwLangID   : DWORD;     (* language ID for topic/item strings. *)
            dwSecurity : DWORD;     (* Private security code. *)
            qos        : SECURITY_QUALITY_OF_SERVICE;  (* client side's quality of service *)
     END;
    PCONVCONTEXT = POINTER TO CONVCONTEXT;

(***** conversation states (usState) *****)

TYPE XST_ENUM = (XST_NULL,            (*  0 - quiescent states *)
                 XST_INCOMPLETE,      (*  1 *)
                 XST_CONNECTED,       (*  2 *)
                 XST_INIT1,           (*  3 - mid-initiation states *)
                 XST_INIT2,           (*  4 *)
                 XST_REQSENT,         (*  5 - active conversation states *)
                 XST_DATARCVD,        (*  6 *)
                 XST_POKESENT,        (*  7 *)
                 XST_POKEACKRCVD,     (*  8 *)
                 XST_EXECSENT,        (*  9 *)
                 XST_EXECACKRCVD,     (* 10 *)
                 XST_ADVSENT,         (* 11 *)
                 XST_UNADVSENT,       (* 12 *)
                 XST_ADVACKRCVD,      (* 13 *)
                 XST_UNADVACKRCVD,    (* 14 *)
                 XST_ADVDATASENT,     (* 15 *)
                 XST_ADVDATAACKRCVD); (* 16 *)

(***** conversation status bits (fsStatus) *****)

TYPE ST_ENUM = (ST__CONNECTED,   (* 0 *)
                ST__ADVISE,      (* 1 *)
                ST__ISLOCAL,     (* 2 *)
                ST__BLOCKED,     (* 3 *)
                ST__CLIENT,      (* 4 *)
                ST__TERMINATED,  (* 5 *)
                ST__INLIST,      (* 6 *)
                ST__BLOCKNEXT,   (* 7 *)
                ST__ISSELF);     (* 8 *)

      ST_SET = SET OF ST_ENUM;

CONST ST_CONNECTED  = ST_SET {ST__CONNECTED }; (* 0x0001 *)
      ST_ADVISE     = ST_SET {ST__ADVISE    }; (* 0x0002 *)
      ST_ISLOCAL    = ST_SET {ST__ISLOCAL   }; (* 0x0004 *)
      ST_BLOCKED    = ST_SET {ST__BLOCKED   }; (* 0x0008 *)
      ST_CLIENT     = ST_SET {ST__CLIENT    }; (* 0x0010 *)
      ST_TERMINATED = ST_SET {ST__TERMINATED}; (* 0x0020 *)
      ST_INLIST     = ST_SET {ST__INLIST    }; (* 0x0040 *)
      ST_BLOCKNEXT  = ST_SET {ST__BLOCKNEXT }; (* 0x0080 *)
      ST_ISSELF     = ST_SET {ST__ISSELF    }; (* 0x0100 *)

(***** transaction types *****)

TYPE XTYP = DWORD;

CONST XTYPF_NOBLOCK         = 0002h;  (* CBR_BLOCK will not work *)
      XTYPF_NODATA          = 0004h;  (* DDE_FDEFERUPD *)
      XTYPF_ACKREQ          = 0008h;  (* DDE_FACKREQ *)

CONST XCLASS_MASK           = 0FC00h;
      XCLASS_BOOL           =  1000h;
      XCLASS_DATA           =  2000h;
      XCLASS_FLAGS          =  4000h;
      XCLASS_NOTIFICATION   =  8000h;

      XTYP_ERROR            = 0000h + XCLASS_NOTIFICATION  + XTYPF_NOBLOCK;
      XTYP_ADVDATA          = 0010h + XCLASS_FLAGS;
      XTYP_ADVREQ           = 0020h + XCLASS_DATA          + XTYPF_NOBLOCK;
      XTYP_ADVSTART         = 0030h + XCLASS_BOOL;
      XTYP_ADVSTOP          = 0040h + XCLASS_NOTIFICATION;
      XTYP_EXECUTE          = 0050h + XCLASS_FLAGS;
      XTYP_CONNECT          = 0060h + XCLASS_BOOL          + XTYPF_NOBLOCK;
      XTYP_CONNECT_CONFIRM  = 0070h + XCLASS_NOTIFICATION  + XTYPF_NOBLOCK;
      XTYP_XACT_COMPLETE    = 0080h + XCLASS_NOTIFICATION;
      XTYP_POKE             = 0090h + XCLASS_FLAGS;
      XTYP_REGISTER         = 00A0h + XCLASS_NOTIFICATION  + XTYPF_NOBLOCK;
      XTYP_REQUEST          = 00B0h + XCLASS_DATA;
      XTYP_DISCONNECT       = 00C0h + XCLASS_NOTIFICATION  + XTYPF_NOBLOCK;
      XTYP_UNREGISTER       = 00D0h + XCLASS_NOTIFICATION  + XTYPF_NOBLOCK;
      XTYP_WILDCONNECT      = 00E0h + XCLASS_DATA          + XTYPF_NOBLOCK;
      XTYP_MONITOR          = 00F0h + XCLASS_NOTIFICATION  + XTYPF_NOBLOCK;

      XTYP_MASK             = 00F0h;
      XTYP_SHIFT            = 4;  (* shift to turn XTYP_ into an index *)

(* The following structure is used by DdeQueryConvInfo(): *)

TYPE CONVINFO =
     RECORD
            cb            : DWORD;       (* SIZE (CONVINFO)  *)
            hUser         : DWORD;       (* user specified field  *)
            hConvPartner  : HCONV;       (* hConv on other end or 0 if non-ddemgr partner  *)
            hszSvcPartner : HSZ;         (* app name of partner if obtainable  *)
            hszServiceReq : HSZ;         (* AppName requested for connection  *)
            hszTopic      : HSZ;         (* Topic name for conversation  *)
            hszItem       : HSZ;         (* transaction item name or NULL if quiescent  *)
            wFmt          : UINT;        (* transaction format or NULL if quiescent  *)
            wType         : XTYP;        (* XTYP_ for current transaction  *)
            wStatus       : ST_SET;      (* ST_ constant for current conversation  *)
            wConvst       : XST_ENUM;    (* XST_ constant for current transaction  *)
            wLastError    : UINT;        (* last transaction error.  *)
            hConvList     : HCONVLIST;   (* parent hConvList if this conversation is in a list *)
            ConvCtxt      : CONVCONTEXT; (* conversation context *)
            hwnd          : HWND;        (* window handle for this conversation *)
            hwndPartner   : HWND;        (* partner window handle for this conversation *)
     END;
     PCONVINFO = POINTER TO CONVINFO;

(* used in LOWORD(dwData1) of XTYP_ADVREQ callbacks... *)

CONST CADV_LATEACK = 0FFFFh;

(* DDE constants for wStatus field *)

TYPE DDE_ENUM = (DDE__0, DDE__1, DDE__2, DDE__3,
                 DDE__4, DDE__5, DDE__6, DDE__7,
                 DDE__8, DDE__9, DDE_10, DDE_11,
                 DDE__FREQUESTED,                (* 12 *)
                 DDE__FRELEASE,                  (* 13 *)
                 DDE__FBUSY,                     (* 14 *)
                 DDE__FACK);                     (* 15 *)

     DDE_SET = SET OF DDE_ENUM;

CONST DDE_FACK          = DDE_SET {DDE__FACK};       (* 0x8000 *)
      DDE_FBUSY         = DDE_SET {DDE__FBUSY};      (* 0x4000 *)
      DDE_FRELEASE      = DDE_SET {DDE__FRELEASE};   (* 0x2000 *)
      DDE_FREQUESTED    = DDE_SET {DDE__FREQUESTED}; (* 0x1000 *)
      DDE_FAPPSTATUS    = DDE_SET {DDE__0..DDE__7};  (* 0x00ff *)
      DDE_FNOTPROCESSED = DDE_SET {};                (* 0x0000 *)

      DDE_FACKREQ       = DDE_FACK;  (* 0x8000 *)
      DDE_FDEFERUPD     = DDE_FBUSY; (* 0x4000 *)

      DDE_FACKRESERVED  = -(DDE_FACK + DDE_FBUSY + DDE_FAPPSTATUS);
      DDE_FADVRESERVED  = -(DDE_FACKREQ + DDE_FDEFERUPD);
      DDE_FDATRESERVED  = -(DDE_FACKREQ + DDE_FRELEASE + DDE_FREQUESTED);
      DDE_FPOKRESERVED  = -DDE_FRELEASE;


(***** message filter hook types *****)

CONST  MSGF_DDEMGR = 8001h;

(***** codepage constants ****)

CONST CP_WINANSI    = 1004;  (* default codepage for windows & old DDE convs. *)
      CP_WINUNICODE = 1200;

<* IF DEFINED (UNICODE) THEN *>
      CONST CP_WINNEUTRAL = CP_WINUNICODE;
<* ELSE *>
      CONST CP_WINNEUTRAL = CP_WINANSI;
<* END *>

(***** Timeout constants *****)

CONST TIMEOUT_ASYNC = 0FFFFFFFFh;

(***** Transaction ID constants *****)

CONST QID_SYNC = 0FFFFFFFFh;

(****** public strings used in DDE ******)

TYPE WCHARARRAY5  = ARRAY [0..4] OF WCHAR;
     WCHARARRAY7  = ARRAY [0..6] OF WCHAR;
     WCHARARRAY8  = ARRAY [0..7] OF WCHAR;
     WCHARARRAY9  = ARRAY [0..8] OF WCHAR;
     WCHARARRAY14 = ARRAY [0..13] OF WCHAR;

<* IF DEFINED (UNICODE) THEN *>


CONST SZDDESYS_TOPIC =
               WCHARARRAY7 {ORD ('S'), ORD ('y'), ORD ('s'), ORD ('t'),
                            ORD ('e'), ORD ('m'), 0};

      SZDDESYS_ITEM_TOPICS   =
               WCHARARRAY7 {ORD ('T'), ORD ('o'), ORD ('p'), ORD ('i'),
                            ORD ('c'), ORD ('s'), 0};

      SZDDESYS_ITEM_SYSITEMS =
               WCHARARRAY9 {ORD ('S'), ORD ('y'), ORD ('s'),
                            ORD ('I'), ORD ('t'), ORD ('e'),
                            ORD ('m'), ORD ('s'), 0};

      SZDDESYS_ITEM_RTNMSG   =
               WCHARARRAY14 {ORD ('R'), ORD ('e'), ORD ('t'), ORD ('u'),
                             ORD ('r'), ORD ('n'), ORD ('M'), ORD ('e'),
                             ORD ('s'), ORD ('s'), ORD ('a'), ORD ('g'),
                             ORD ('e'), 0};

      SZDDESYS_ITEM_STATUS   =
               WCHARARRAY7 {ORD ('S'), ORD ('t'), ORD ('a'), ORD ('t'),
                            ORD ('u'), ORD ('s'), 0};

      SZDDESYS_ITEM_FORMATS  =
               WCHARARRAY8 {ORD ('F'), ORD ('o'), ORD ('r'), ORD ('m'),
                            ORD ('a'), ORD ('t'), ORD ('s'), 0};

      SZDDESYS_ITEM_HELP     =
               WCHARARRAY5 {ORD ('H'), ORD ('e'), ORD ('l'), ORD ('p'), 0};

      SZDDE_ITEM_ITEMLIST    =
               WCHARARRAY14 {ORD ('T'), ORD ('o'), ORD ('p'), ORD ('i'),
                             ORD ('c'), ORD ('I'), ORD ('t'), ORD ('e'),
                             ORD ('m'), ORD ('L'), ORD ('i'), ORD ('s'),
                             ORD ('t'), 0};

<* ELSE *>

CONST SZDDESYS_TOPIC         = "System";
      SZDDESYS_ITEM_TOPICS   = "Topics";
      SZDDESYS_ITEM_SYSITEMS = "SysItems";
      SZDDESYS_ITEM_RTNMSG   = "ReturnMessage";
      SZDDESYS_ITEM_STATUS   = "Status";
      SZDDESYS_ITEM_FORMATS  = "Formats";
      SZDDESYS_ITEM_HELP     = "Help";
      SZDDE_ITEM_ITEMLIST    = "TopicItemList";

<* END *>


(****** API entry points ******)

TYPE FNCALLBACK = PROCEDURE ((* wType   : *) UINT,
                             (* wFmt    : *) UINT,
                             (* hConv   : *) HCONV,
                             (* hsz1    : *) HSZ,
                             (* hsz2    : *) HSZ,
                             (* hData   : *) HDDEDATA,
                             (* dwData1 : *) DWORD,
                             (* dwData2 : *) DWORD) : HDDEDATA;


CONST CBR_BLOCK = SYSTEM.CAST (HDDEDATA, VAL (UINT, 0ffffffffh));

(*
 * Flags to use in DdeInitialize
 *)

TYPE DDEFLAGS_ENUM = (APPCLASS__MONITOR,            (* 0 *)
                      APPCLASS__1, APPCLASS__2,
                      APPCLASS__3,

                      APPCMD__CLIENTONLY,           (* 4 *)
                      APPCMD__FILTERINITS,          (* 5 *)
                      APPCMD__6, APPCMD__7,
                      APPCMD__8, APPCMD__9,
                      APPCMD__10, APPCMD__11,

                      CBF__FAIL_SELFCONNECTIONS,    (* 12 *)
                      CBF__FAIL_CONNECTIONS,        (* 13 *)
                      CBF__FAIL_ADVISES,            (* 14 *)
                      CBF__FAIL_EXECUTES,           (* 15 *)
                      CBF__FAIL_POKES,              (* 16 *)
                      CBF__FAIL_REQUESTS,           (* 17 *)

                      CBF__SKIP_CONNECT_CONFIRMS,   (* 18 *)
                      CBF__SKIP_REGISTRATIONS,      (* 19 *)
                      CBF__SKIP_UNREGISTRATIONS,    (* 20 *)
                      CBF__SKIP_DISCONNECTS);       (* 21 *)

     DDEFLAGS_SET = SET OF DDEFLAGS_ENUM;


(*
 * Callback filter flags for use with standard apps.
 *)

CONST CBF_FAIL_SELFCONNECTIONS     = DDEFLAGS_SET {CBF__FAIL_SELFCONNECTIONS};   (* 0x00001000 *)
      CBF_FAIL_CONNECTIONS         = DDEFLAGS_SET {CBF__FAIL_CONNECTIONS};       (* 0x00002000 *)
      CBF_FAIL_ADVISES             = DDEFLAGS_SET {CBF__FAIL_ADVISES};           (* 0x00004000 *)
      CBF_FAIL_EXECUTES            = DDEFLAGS_SET {CBF__FAIL_EXECUTES};          (* 0x00008000 *)
      CBF_FAIL_POKES               = DDEFLAGS_SET {CBF__FAIL_POKES};             (* 0x00010000 *)
      CBF_FAIL_REQUESTS            = DDEFLAGS_SET {CBF__FAIL_REQUESTS};          (* 0x00020000 *)

      CBF_FAIL_ALLSVRXACTIONS      = DDEFLAGS_SET {CBF__FAIL_SELFCONNECTIONS ..
                                                   CBF__FAIL_REQUESTS};          (* 0x0003f000 *)

      CBF_SKIP_CONNECT_CONFIRMS    = DDEFLAGS_SET {CBF__SKIP_CONNECT_CONFIRMS};  (* 0x00040000 *)
      CBF_SKIP_REGISTRATIONS       = DDEFLAGS_SET {CBF__SKIP_REGISTRATIONS};     (* 0x00080000 *)
      CBF_SKIP_UNREGISTRATIONS     = DDEFLAGS_SET {CBF__SKIP_UNREGISTRATIONS};   (* 0x00100000 *)
      CBF_SKIP_DISCONNECTS         = DDEFLAGS_SET {CBF__SKIP_DISCONNECTS};       (* 0x00200000 *)

      CBF_SKIP_ALLNOTIFICATIONS    = DDEFLAGS_SET {CBF__SKIP_CONNECT_CONFIRMS ..
                                                   CBF__SKIP_DISCONNECTS};       (* 0x003c0000 *)

(*
* Application command flags
*)
      APPCMD_CLIENTONLY            = DDEFLAGS_SET {APPCMD__CLIENTONLY};          (* 0x00000010L*)
      APPCMD_FILTERINITS           = DDEFLAGS_SET {APPCMD__FILTERINITS};         (* 0x00000020L*)
      APPCMD_MASK                  = DDEFLAGS_SET {APPCMD__CLIENTONLY ..
                                                   APPCMD__11};                  (* 0x00000FF0L*)

(*
* Application classification flags
*)

      APPCLASS_STANDARD            = DDEFLAGS_SET {};                               (* 0x00000000L*)
      APPCLASS_MONITOR             = DDEFLAGS_SET {APPCLASS__MONITOR};              (* 0x00000001L *)

      APPCLASS_MASK                = DDEFLAGS_SET {APPCLASS__MONITOR..APPCLASS__3}; (* 0x0000000FL*)


(* DLL registration functions *)

PROCEDURE DdeInitializeA (VAR Inst   : DWORD;
                          fnCallback : FNCALLBACK;
                          afCmd      : DDEFLAGS_SET;
                          ulRes      : DWORD
                         ) : UINT;

PROCEDURE DdeInitializeW (VAR Inst   : DWORD;
                          fnCallback : FNCALLBACK;
                          afCmd      : DDEFLAGS_SET;
                          ulRes      : DWORD
                         ) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST DdeInitialize = DdeInitializeW;
<* ELSE *>
      CONST DdeInitialize = DdeInitializeA;
<* END *>

PROCEDURE DdeUninitialize (idInst : DWORD) : BOOL;

(*
 * conversation enumeration functions
 *)

PROCEDURE DdeConnectList (idInst       : DWORD;
                          hszService   : HSZ;
                          hszTopic     : HSZ;
                          hConvList    : HCONVLIST;
                          VAR [NIL] CC : CONVCONTEXT) : HCONVLIST;

PROCEDURE DdeQueryNextServer (hConvList :  HCONVLIST;
                              hConvPrev :  HCONV) : HCONV;

PROCEDURE DdeDisconnectList (hConvList : HCONVLIST) : BOOL;

(*
 * conversation control functions
 *)

PROCEDURE DdeConnect (idInst       : DWORD;
                      hszService   : HSZ;
                      hszTopic     : HSZ;
                      VAR [NIL] CC : CONVCONTEXT) : HCONV;
PROCEDURE DdeDisconnect (hConv : HCONV) : BOOL;
PROCEDURE DdeReconnect  (hConv : HCONV) : HCONV;
PROCEDURE DdeQueryConvInfo (hConv : HCONV;
                            idTransaction : DWORD;
                            VAR  ConvInfo : CONVINFO) : UINT;

PROCEDURE DdeSetUserHandle (hConv : HCONV;
                            id    : DWORD;
                            hUser : DWORD) : BOOL;

PROCEDURE DdeAbandonTransaction (idInst : DWORD;
                                 hConv  : HCONV;
                                 idTransaction : DWORD) : BOOL;

(*
 * app server interface functions
 *)

PROCEDURE DdePostAdvise (idInst   : DWORD;
                         hszTopic : HSZ;
                         hszItem  : HSZ) : BOOL;

TYPE EC_ENUM = ST_ENUM;

CONST EC_ENABLEALL    = VAL (EC_ENUM, 0);
      EC_ENABLEONE    = ST_BLOCKNEXT;
      EC_DISABLE      = ST_BLOCKED;
      EC_QUERYWAITING = VAL (EC_ENUM, 2);

PROCEDURE DdeEnableCallback (idInst : DWORD; hConv : HCONV; wCmd : EC_ENUM) : BOOL;

PROCEDURE DdeImpersonateClient (hConv : HCONV) : BOOL;

TYPE DNS_ENUM = (DNS__REGISTER,    (* 0 *)
                 DNS__UNREGISTER,  (* 1 *)
                 DNS__FILTERON,    (* 2 *)
                 DNS__FILTEROFF);  (* 3 *)

     DNS_SET = SET OF DNS_ENUM;

CONST DNS_REGISTER   = DNS_SET {DNS__REGISTER  }; (* 0x0001 *)
      DNS_UNREGISTER = DNS_SET {DNS__UNREGISTER}; (* 0x0002 *)
      DNS_FILTERON   = DNS_SET {DNS__FILTERON  }; (* 0x0004 *)
      DNS_FILTEROFF  = DNS_SET {DNS__FILTEROFF }; (* 0x0008 *)

PROCEDURE DdeNameService (idInst : DWORD;
                          hsz1   : HSZ;
                          hsz2   : HSZ;
                          afCmd  : DNS_SET) : HDDEDATA;

(*
 * app client interface functions
 *)

PROCEDURE DdeClientTransaction (pData      : PBYTE;
                                cbData     : DWORD;
                                hConv      : HCONV;
                                hszItem    : HSZ;
                                wFmt       : CF_TYPE;
                                wType      : XTYP;
                                dwTimeout  : DWORD;
                                VAR Result : DWORD) : HDDEDATA;

(*
 *data transfer functions
 *)

CONST HDATA_APPOWNED = 1;

PROCEDURE DdeCreateDataHandle (idInst  : DWORD;
                               pSrc    : PBYTE;
                               cb      : DWORD;
                               cbOff   : DWORD;
                               hszItem : HSZ;
                               wFmt    : CF_TYPE;
                               afCmd   : UINT) : HDDEDATA;

PROCEDURE DdeAddData (hData : HDDEDATA;
                      pSrc  : PBYTE;
                      cb    : DWORD;
                      cbOff : DWORD) : HDDEDATA;

PROCEDURE DdeGetData (hData : HDDEDATA;
                      pDst  : PBYTE;
                      cbMax : DWORD;
                      cbOff : DWORD) : DWORD;

PROCEDURE DdeAccessData (hData        : HDDEDATA;
                         VAR DataSize : DWORD) : PBYTE;

PROCEDURE DdeUnaccessData   (hData : HDDEDATA) : BOOL;
PROCEDURE DdeFreeDataHandle (hData : HDDEDATA) : BOOL;

PROCEDURE DdeGetLastError (idInst : DWORD) : UINT;


CONST     DMLERR_NO_ERROR            = 0;

          DMLERR_FIRST               = 4000h;

          DMLERR_ADVACKTIMEOUT       = 4000h;
          DMLERR_BUSY                = 4001h;
          DMLERR_DATAACKTIMEOUT      = 4002h;
          DMLERR_DLL_NOT_INITIALIZED = 4003h;
          DMLERR_DLL_USAGE           = 4004h;
          DMLERR_EXECACKTIMEOUT      = 4005h;
          DMLERR_INVALIDPARAMETER    = 4006h;
          DMLERR_LOW_MEMORY          = 4007h;
          DMLERR_MEMORY_ERROR        = 4008h;
          DMLERR_NOTPROCESSED        = 4009h;
          DMLERR_NO_CONV_ESTABLISHED = 400ah;
          DMLERR_POKEACKTIMEOUT      = 400bh;
          DMLERR_POSTMSG_FAILED      = 400ch;
          DMLERR_REENTRANCY          = 400dh;
          DMLERR_SERVER_DIED         = 400eh;
          DMLERR_SYS_ERROR           = 400fh;
          DMLERR_UNADVACKTIMEOUT     = 4010h;
          DMLERR_UNFOUND_QUEUE_ID    = 4011h;

          DMLERR_LAST                = 4011h;


PROCEDURE DdeCreateStringHandleA (idInst   : DWORD;
                                  psz      : ARRAY OF CHAR;
                                  CodePage : INTEGER) : HSZ;

PROCEDURE DdeCreateStringHandleW (idInst   : DWORD;
                                  psz      : ARRAY OF WCHAR;
                                  CodePage : INTEGER) : HSZ;

<* IF DEFINED (UNICODE) THEN *>
      CONST DdeCreateStringHandle = DdeCreateStringHandleW;
<* ELSE *>
      CONST DdeCreateStringHandle = DdeCreateStringHandleA;
<* END *>

PROCEDURE DdeQueryStringA (idInst       : DWORD;
                           hsz          : HSZ;
                           VAR [NIL] sz : ARRAY OF CHAR;
                           cchMax       : DWORD;
                           iCodePage    : INTEGER) : DWORD;

PROCEDURE DdeQueryStringW (idInst       : DWORD;
                           hsz          : HSZ;
                           VAR [NIL] sz : ARRAY OF WCHAR;
                           cchMax       : DWORD;
                           iCodePage    : INTEGER) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST DdeQueryString = DdeQueryStringW;
<* ELSE *>
      CONST DdeQueryString = DdeQueryStringA;
<* END *>

PROCEDURE DdeFreeStringHandle (idInst : DWORD; hsz : HSZ) : BOOL;
PROCEDURE DdeKeepStringHandle (idInst : DWORD; hsz : HSZ) : BOOL;
PROCEDURE DdeCmpStringHandles (hsz1, hsz2 : HSZ) : INTEGER;

<* IF NOT DEFINED (NODDEMLSPY) THEN *>

(*
 * DDEML public debugging header file info
 *)

TYPE DDEML_MSG_HOOK_DATA =
     RECORD                              (* new for NT *)
        uiLo   : UINT;                   (* unpacked lo and hi parts of lParam *)
        uiHi   : UINT;
        cbData : DWORD;                  (* amount of data in message, if any. May be > than 32 bytes. *)
        Data   : ARRAY [0..7] OF DWORD;  (* data peeking by DDESPY is limited to 32 bytes. *)
     END;
     PDDEML_MSG_HOOK_DATA = POINTER TO DDEML_MSG_HOOK_DATA;

TYPE MONMSGSTRUCT = RECORD
                           cb     : UINT;
                           hwndTo : HWND;
                           dwTime : DWORD;
                           hTask  : HANDLE;
                           wMsg   : UINT;
                           wParam : WPARAM;
                           lParam : LPARAM;
                           dmhd   : DDEML_MSG_HOOK_DATA; (* new for NT *)
                    END;
    PMONMSGSTRUCT = POINTER TO MONMSGSTRUCT;

TYPE MONCBSTRUCT = RECORD
                          cb      : UINT;
                          dwTime  : DWORD;
                          hTask   : HANDLE;
                          dwRet   : DWORD;
                          wType   : XTYP;
                          wFmt    : CF_TYPE;
                          hConv   : HCONV;
                          hsz1    : HSZ;
                          hsz2    : HSZ;
                          hData   : HDDEDATA;
                          dwData1 : DWORD;
                          dwData2 : DWORD;
                          cc      : CONVCONTEXT; (* new for NT for XTYP_CONNECT callbacks *)
                          cbData  : DWORD;       (* new for NT for data peeking *)
                          Data    : ARRAY [0..7] OF DWORD; (* new for NT for data peeking *)
                   END;
    PMONCBSTRUCT = POINTER TO MONCBSTRUCT;

TYPE MH_ENUM = (MH_0,
                MH_CREATE,   (* 1 *)
                MH_KEEP,     (* 2 *)
                MH_DELETE,   (* 3 *)
                MH_CLEANUP); (* 4 *)

TYPE MONHSZSTRUCTA = RECORD
                            cb       : UINT;
                            fsAction : MH_ENUM;  (* MH_ value *)
                            dwTime   : DWORD;
                            hsz      : HSZ;
                            hTask    : HANDLE;
                            str      : ARRAY [0..0] OF CHAR;
                     END;
   PMONHSZSTRUCTA = POINTER TO MONHSZSTRUCTA;

TYPE MONHSZSTRUCTW = RECORD
                            cb       : UINT;
                            fsAction : MH_ENUM;  (* MH_ value *)
                            dwTime   : DWORD;
                            hsz      : HSZ;
                            hTask    : HANDLE;
                            str      : ARRAY [0..0] OF WCHAR;
                     END;
   PMONHSZSTRUCTW = POINTER TO MONHSZSTRUCTW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  MONHSZSTRUCT =  MONHSZSTRUCTW;
      TYPE PMONHSZSTRUCT = PMONHSZSTRUCTW;
<* ELSE *>
      TYPE  MONHSZSTRUCT =  MONHSZSTRUCTA;
      TYPE PMONHSZSTRUCT = PMONHSZSTRUCTA;
<* END *>

TYPE MONERRSTRUCT = RECORD
                           cb         : UINT;
                           wLastError : UINT;
                           dwTime     : DWORD;
                           hTask      : HANDLE;
                    END;
    PMONERRSTRUCT = POINTER TO MONERRSTRUCT;

TYPE MONLINKSTRUCT = RECORD
                            cb           : UINT;
                            dwTime       : DWORD;
                            hTask        : HANDLE;
                            fEstablished : BOOL;
                            fNoData      : BOOL;
                            hszSvc       : HSZ;
                            hszTopic     : HSZ;
                            hszItem      : HSZ;
                            wFmt         : CF_TYPE;
                            fServer      : BOOL;
                            hConvServer  : HCONV;
                            hConvClient  : HCONV;
                     END;
    PMONLINKSTRUCT = POINTER TO MONLINKSTRUCT;


TYPE MONCONVSTRUCT = RECORD
                            cb          : UINT;
                            fConnect    : BOOL;
                            dwTime      : DWORD;
                            hTask       : HANDLE;
                            hszSvc      : HSZ;
                            hszTopic    : HSZ;
                            hConvClient : HCONV; (* Globally unique value != apps local hConv *)
                            hConvServer : HCONV; (* Globally unique value != apps local hConv *)
                     END;
    PMONCONVSTRUCT = POINTER TO MONCONVSTRUCT;

CONST  MAX_MONITORS = 4;

(*
 * Callback filter flags for use with MONITOR apps - 0 implies no monitor
 * callbacks.
 *)

CONST MF_HSZ_INFO   = {24};     (* 0x01000000 *)
      MF_SENDMSGS   = {25};     (* 0x02000000 *)
      MF_POSTMSGS   = {26};     (* 0x04000000 *)
      MF_CALLBACKS  = {27};     (* 0x08000000 *)
      MF_ERRORS     = {28};     (* 0x10000000 *)
      MF_LINKS      = {29};     (* 0x20000000 *)
      MF_CONV       = {30};     (* 0x40000000 *)

      MF_MASK       = {24..31}; (* 0xFF000000 *)

<* END *> (* NODDEMLSPY *)




(*---------------------------------------------------------------------------*)
(* Dlgs.def : UI dialog header                                               *)
(*---------------------------------------------------------------------------*)

(*----Constants--------------------------------------------------------------*)

CONST ctlFirst    = 0400h;
      ctlLast     = 04ffh;

    (* Push buttons *)

      psh1        = 0400h;
      psh2        = 0401h;
      psh3        = 0402h;
      psh4        = 0403h;
      psh5        = 0404h;
      psh6        = 0405h;
      psh7        = 0406h;
      psh8        = 0407h;
      psh9        = 0408h;
      psh10       = 0409h;
      psh11       = 040ah;
      psh12       = 040bh;
      psh13       = 040ch;
      psh14       = 040dh;
      psh15       = 040eh;
      pshHelp     = psh15;
      psh16       = 040fh;

    (* Checkboxes *)

      chx1        = 0410h;
      chx2        = 0411h;
      chx3        = 0412h;
      chx4        = 0413h;
      chx5        = 0414h;
      chx6        = 0415h;
      chx7        = 0416h;
      chx8        = 0417h;
      chx9        = 0418h;
      chx10       = 0419h;
      chx11       = 041ah;
      chx12       = 041bh;
      chx13       = 041ch;
      chx14       = 041dh;
      chx15       = 041eh;
      chx16       = 041fh;

    (* Radio buttons *)

      rad1        = 0420h;
      rad2        = 0421h;
      rad3        = 0422h;
      rad4        = 0423h;
      rad5        = 0424h;
      rad6        = 0425h;
      rad7        = 0426h;
      rad8        = 0427h;
      rad9        = 0428h;
      rad10       = 0429h;
      rad11       = 042ah;
      rad12       = 042bh;
      rad13       = 042ch;
      rad14       = 042dh;
      rad15       = 042eh;
      rad16       = 042fh;

    (* Groups, frames, rectangles, and icons *)

      grp1        = 0430h;
      grp2        = 0431h;
      grp3        = 0432h;
      grp4        = 0433h;
      frm1        = 0434h;
      frm2        = 0435h;
      frm3        = 0436h;
      frm4        = 0437h;
      rct1        = 0438h;
      rct2        = 0439h;
      rct3        = 043ah;
      rct4        = 043bh;
      ico1        = 043ch;
      ico2        = 043dh;
      ico3        = 043eh;
      ico4        = 043fh;

    (* Static text *)

      stc1        = 0440h;
      stc2        = 0441h;
      stc3        = 0442h;
      stc4        = 0443h;
      stc5        = 0444h;
      stc6        = 0445h;
      stc7        = 0446h;
      stc8        = 0447h;
      stc9        = 0448h;
      stc10       = 0449h;
      stc11       = 044ah;
      stc12       = 044bh;
      stc13       = 044ch;
      stc14       = 044dh;
      stc15       = 044eh;
      stc16       = 044fh;
      stc17       = 0450h;
      stc18       = 0451h;
      stc19       = 0452h;
      stc20       = 0453h;
      stc21       = 0454h;
      stc22       = 0455h;
      stc23       = 0456h;
      stc24       = 0457h;
      stc25       = 0458h;
      stc26       = 0459h;
      stc27       = 045ah;
      stc28       = 045bh;
      stc29       = 045ch;
      stc30       = 045dh;
      stc31       = 045eh;
      stc32       = 045fh;

    (* Listboxes *)

      lst1        = 0460h;
      lst2        = 0461h;
      lst3        = 0462h;
      lst4        = 0463h;
      lst5        = 0464h;
      lst6        = 0465h;
      lst7        = 0466h;
      lst8        = 0467h;
      lst9        = 0468h;
      lst10       = 0469h;
      lst11       = 046ah;
      lst12       = 046bh;
      lst13       = 046ch;
      lst14       = 046dh;
      lst15       = 046eh;
      lst16       = 046fh;

    (* Combo boxes *)

      cmb1        = 0470h;
      cmb2        = 0471h;
      cmb3        = 0472h;
      cmb4        = 0473h;
      cmb5        = 0474h;
      cmb6        = 0475h;
      cmb7        = 0476h;
      cmb8        = 0477h;
      cmb9        = 0478h;
      cmb10       = 0479h;
      cmb11       = 047ah;
      cmb12       = 047bh;
      cmb13       = 047ch;
      cmb14       = 047dh;
      cmb15       = 047eh;
      cmb16       = 047fh;

    (* Edit controls *)

      edt1        = 0480h;
      edt2        = 0481h;
      edt3        = 0482h;
      edt4        = 0483h;
      edt5        = 0484h;
      edt6        = 0485h;
      edt7        = 0486h;
      edt8        = 0487h;
      edt9        = 0488h;
      edt10       = 0489h;
      edt11       = 048ah;
      edt12       = 048bh;
      edt13       = 048ch;
      edt14       = 048dh;
      edt15       = 048eh;
      edt16       = 048fh;

    (* Scroll bars *)

      scr1        = 0490h;
      scr2        = 0491h;
      scr3        = 0492h;
      scr4        = 0493h;
      scr5        = 0494h;
      scr6        = 0495h;
      scr7        = 0496h;
      scr8        = 0497h;

(* These dialog resource ordinals really start at 0x0600, but the
 * RC Compiler can't handle hex for resource IDs, hence the decimal.
 *)
      FILEOPENORD      = 1536;
      MULTIFILEOPENORD = 1537;
      PRINTDLGORD      = 1538;
      PRNSETUPDLGORD   = 1539;
      FINDDLGORD       = 1540;
      REPLACEDLGORD    = 1541;
      FONTDLGORD       = 1542;
      FORMATDLGORD31   = 1543;
      FORMATDLGORD30   = 1544;
      PAGESETUPDLGORD  = 1546;


(*----Types------------------------------------------------------------------*)

TYPE CRGB = RECORD
                   bRed   : BYTE;
                   bGreen : BYTE;
                   bBlue  : BYTE;
                   bExtra : BYTE;
            END;



(*
** LZExpand.def - Public interface to LZEXP?.LIB.
*)


(*
** Error Return Codes
*)

CONST LZERROR_BADINHANDLE    = -1;  (* invalid input handle *)
      LZERROR_BADOUTHANDLE   = -2;  (* invalid output handle *)
      LZERROR_READ           = -3;  (* corrupt compressed file format *)
      LZERROR_WRITE          = -4;  (* out of space for output file *)
      LZERROR_GLOBALLOC      = -5;  (* insufficient memory for LZFile struct *)
      LZERROR_GLOBLOCK       = -6;  (* bad global handle *)
      LZERROR_BADVALUE       = -7;  (* input parameter out of acceptable range*)
      LZERROR_UNKNOWNALG     = -8;  (* compression algorithm not recognized *)

(*
** Prototypes
*)

PROCEDURE LZStart () : INTEGER;
PROCEDURE LZDone;
PROCEDURE CopyLZFile (Source, Dest : HFILE) : LONG;
PROCEDURE LZCopy (hfSource, hfDest : INTEGER) : LONG;
PROCEDURE LZInit (hfSource : INTEGER) : INTEGER;
PROCEDURE GetExpandedNameA (Source : ARRAY OF  CHAR; VAR Buffer : ARRAY OF  CHAR) : INTEGER;
PROCEDURE GetExpandedNameW (Source : ARRAY OF WCHAR; VAR Buffer : ARRAY OF WCHAR) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetExpandedName = GetExpandedNameW;
<* ELSE *>
      CONST GetExpandedName = GetExpandedNameA;
<* END *>

PROCEDURE LZOpenFileA (filename      : ARRAY OF CHAR;
                       VAR ReOpenBuf : OFSTRUCT;
                       wStyle        : OF_FLAGS) : INTEGER;

PROCEDURE LZOpenFileW (filename      : ARRAY OF WCHAR;
                       VAR ReOpenBuf : OFSTRUCT;
                       wStyle        : OF_FLAGS) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST LZOpenFile = LZOpenFileW;
<* ELSE *>
      CONST LZOpenFile = LZOpenFileA;
<* END *>

PROCEDURE LZSeek (hFile  : INTEGER;
                  Offset : LONG;
                  Origin : INTEGER) : LONG;

PROCEDURE LZRead (hFile  : INTEGER;
                  Buffer : PBYTE;
                  cbRead : INTEGER) : INTEGER;

PROCEDURE LZClose (hFile : INTEGER);


(*==========================================================================
 *
 *  MMSystem.def -- Import file for Multimedia API's
 *
 *  Version 4.00
 *
 *--------------------------------------------------------------------------
 *
 *  Define:         Prevent inclusion of:
 *  --------------  --------------------------------------------------------
 *  MMNODRV         Installable driver support
 *  MMNOSOUND       Sound support
 *  MMNOWAVE        Waveform support
 *  MMNOMIDI        MIDI support
 *  MMNOAUX         Auxiliary audio support
 *  MMNOMIXER       Mixer support
 *  MMNOTIMER       Timer support
 *  MMNOJOY         Joystick support
 *  MMNOMCI         MCI support
 *  MMNOMMIO        Multimedia file I/O support
 *  MMNOMMSYSTEM    General MMSYSTEM functions
 *
 *==========================================================================
 *)


<* PUSH *> <* ALIGNMENT = "1" *>

(****************************************************************************

                    General constants and data types

****************************************************************************)

(* general constants *)
CONST MAXPNAMELEN     = 32;     (* max product name length (including NULL) *)
      MAXERRORLENGTH  = 256;    (* max error text length (including NULL) *)
      MAX_JOYSTICKOEMVXDNAME = 260; (* max oem vxd name length (including NULL) *)

TYPE PNAMESTR  = ARRAY [0..MAXPNAMELEN-1] OF CHAR; (* product name (NULL terminated string) *)
     PNAMESTRW = ARRAY [0..MAXPNAMELEN-1] OF WCHAR;

(* general data types *)

TYPE MMVERSION = UINT;  (* major (high byte), minor (low byte) *)
TYPE MMRESULT  = UINT;  (* error return code, 0 means no error *)
                        (* call as if(err=xxxx(...)) Error(err); else *)


(* types for wType field in MMTIME struct *)

CONST TIME_MS      = 0001h;  (* time in milliseconds *)
      TIME_SAMPLES = 0002h;  (* number of wave samples *)
      TIME_BYTES   = 0004h;  (* current byte offset *)
      TIME_SMPTE   = 0008h;  (* SMPTE time *)
      TIME_MIDI    = 0010h;  (* MIDI time *)
      TIME_TICKS   = 0020h;  (* Ticks within MIDI stream *)


(* MMTIME data structure *)

TYPE MMTIME =
     RECORD
        CASE wType : UINT OF      (* indicates the contents of the union *)
        | TIME_MS     : ms : DWORD;         (* milliseconds *)
        | TIME_SAMPLES: sample : DWORD;     (* samples *)
        | TIME_BYTES  : cb     : DWORD;     (* byte count *)
        | TIME_TICKS  : ticks  : DWORD;     (* ticks in MIDI stream *)
        | TIME_SMPTE  : hour   : BYTE;      (* hours *)
                        min    : BYTE;      (* minutes *)
                        sec    : BYTE;      (* seconds *)
                        frame  : BYTE;      (* frames  *)
                        fps    : BYTE;      (* frames per second *)
                        dummy  : BYTE;      (* pad *)
                        pad    : ARRAY [0..1] OF BYTE;
        | TIME_MIDI   : songptrpos : DWORD; (* song pointer position *)
        END;
     END;
     PMMTIME = POINTER TO MMTIME;

(* MAKEFOURCC was defined as macro, now in RTL *)

PROCEDURE MAKEFOURCC (ch0, ch1, ch2, ch3 : BYTE) : DWORD;

(****************************************************************************

                    Multimedia Extensions Window Messages

****************************************************************************)

CONST MM_JOY1MOVE        = 3A0h;           (* joystick *)
      MM_JOY2MOVE        = 3A1h;
      MM_JOY1ZMOVE       = 3A2h;
      MM_JOY2ZMOVE       = 3A3h;
      MM_JOY1BUTTONDOWN  = 3B5h;
      MM_JOY2BUTTONDOWN  = 3B6h;
      MM_JOY1BUTTONUP    = 3B7h;
      MM_JOY2BUTTONUP    = 3B8h;

      MM_MCINOTIFY       = 3B9h;           (* MCI *)

      MM_WOM_OPEN        = 3BBh;           (* waveform output *)
      MM_WOM_CLOSE       = 3BCh;
      MM_WOM_DONE        = 3BDh;

      MM_WIM_OPEN        = 3BEh;           (* waveform input *)
      MM_WIM_CLOSE       = 3BFh;
      MM_WIM_DATA        = 3C0h;

      MM_MIM_OPEN        = 3C1h;           (* MIDI input *)
      MM_MIM_CLOSE       = 3C2h;
      MM_MIM_DATA        = 3C3h;
      MM_MIM_LONGDATA    = 3C4h;
      MM_MIM_ERROR       = 3C5h;
      MM_MIM_LONGERROR   = 3C6h;

      MM_MOM_OPEN        = 3C7h;           (* MIDI output *)
      MM_MOM_CLOSE       = 3C8h;
      MM_MOM_DONE        = 3C9h;

      MM_DRVM_OPEN       = 3D0h;           (* installable drivers *)
      MM_DRVM_CLOSE      = 3D1h;
      MM_DRVM_DATA       = 3D2h;
      MM_DRVM_ERROR      = 3D3h;

      MM_STREAM_OPEN     = 3D4h;
      MM_STREAM_CLOSE    = 3D5h;
      MM_STREAM_DONE     = 3D6h;
      MM_STREAM_ERROR    = 3D7h;

      MM_MOM_POSITIONCB  = 3CAh;           (* Callback for MEVT_POSITIONCB *)
      MM_MCISIGNAL       = 3CBh;

      MM_MIM_MOREDATA    = 3CCh;          (* MIM_DONE w/ pending events *)

      MM_MIXM_LINE_CHANGE    = 3D0h;       (* mixer line change notify *)
      MM_MIXM_CONTROL_CHANGE = 3D1h;       (* mixer control change notify *)

(****************************************************************************

                String resource number bases (internal use)

****************************************************************************)

CONST MMSYSERR_BASE        = 0;
      WAVERR_BASE          = 32;
      MIDIERR_BASE         = 64;
      TIMERR_BASE          = 96;
      JOYERR_BASE          = 160;
      MCIERR_BASE          = 256;
      MIXERR_BASE          = 1024;

      MCI_STRING_OFFSET    = 512;
      MCI_VD_OFFSET        = 1024;
      MCI_CD_OFFSET        = 1088;
      MCI_WAVE_OFFSET      = 1152;
      MCI_SEQ_OFFSET       = 1216;

(****************************************************************************

                        General error return values

****************************************************************************)

(* general error return values *)

CONST MMSYSERR_NOERROR      = 0;                  (* no error *)
      MMSYSERR_ERROR        = MMSYSERR_BASE + 1;  (* unspecified error *)
      MMSYSERR_BADDEVICEID  = MMSYSERR_BASE + 2;  (* device ID out of range *)
      MMSYSERR_NOTENABLED   = MMSYSERR_BASE + 3;  (* driver failed enable *)
      MMSYSERR_ALLOCATED    = MMSYSERR_BASE + 4;  (* device already allocated *)
      MMSYSERR_INVALHANDLE  = MMSYSERR_BASE + 5;  (* device handle is invalid *)
      MMSYSERR_NODRIVER     = MMSYSERR_BASE + 6;  (* no device driver present *)
      MMSYSERR_NOMEM        = MMSYSERR_BASE + 7;  (* memory allocation error *)
      MMSYSERR_NOTSUPPORTED = MMSYSERR_BASE + 8;  (* function isn't supported *)
      MMSYSERR_BADERRNUM    = MMSYSERR_BASE + 9;  (* error value out of range *)
      MMSYSERR_INVALFLAG    = MMSYSERR_BASE + 10; (* invalid flag passed *)
      MMSYSERR_INVALPARAM   = MMSYSERR_BASE + 11; (* invalid parameter passed *)
      MMSYSERR_HANDLEBUSY   = MMSYSERR_BASE + 12; (* handle being used *)
                                                  (* simultaneously on another *)
                                                  (* thread (eg callback; *)
      MMSYSERR_INVALIDALIAS = MMSYSERR_BASE + 13; (* specified alias not found *)
      MMSYSERR_BADDB        = MMSYSERR_BASE + 14; (* bad registry database *)
      MMSYSERR_KEYNOTFOUND  = MMSYSERR_BASE + 15; (* registry key not found *)
      MMSYSERR_READERROR    = MMSYSERR_BASE + 16; (* registry read error *)
      MMSYSERR_WRITEERROR   = MMSYSERR_BASE + 17; (* registry write error *)
      MMSYSERR_DELETEERROR  = MMSYSERR_BASE + 18; (* registry delete error *)
      MMSYSERR_VALNOTFOUND  = MMSYSERR_BASE + 19; (* registry value not found *)
      MMSYSERR_NODRIVERCB   = MMSYSERR_BASE + 20; (* driver does not call DriverCallback *)
      MMSYSERR_LASTERROR    = MMSYSERR_BASE + 20; (* last error in range *)


TYPE HDRVR = POINTER TO RECORD END;

<* IF NOT DEFINED (MMNODRV) THEN *>

(****************************************************************************

                        Installable driver support

****************************************************************************)

TYPE DRVCONFIGINFOEX = RECORD
                              dwDCISize          : DWORD;
                              lpszDCISectionName : PCWSTR;
                              lpszDCIAliasName   : PCWSTR;
                              dnDevNode          : DWORD;
                       END;
    PDRVCONFIGINFOEX = POINTER TO DRVCONFIGINFOEX;


(* Driver messages *)

CONST DRV_LOAD             = 0001h;
      DRV_ENABLE           = 0002h;
      DRV_OPEN             = 0003h;
      DRV_CLOSE            = 0004h;
      DRV_DISABLE          = 0005h;
      DRV_FREE             = 0006h;
      DRV_CONFIGURE        = 0007h;
      DRV_QUERYCONFIGURE   = 0008h;
      DRV_INSTALL          = 0009h;
      DRV_REMOVE           = 000Ah;
      DRV_EXITSESSION      = 000Bh;
      DRV_POWER            = 000Fh;
      DRV_RESERVED         = 0800h;
      DRV_USER             = 4000h;

(* LPARAM of DRV_CONFIGURE message *)

TYPE DRVCONFIGINFO = RECORD
                            dwDCISize          : DWORD;
                            lpszDCISectionName : PCWSTR;
                            lpszDCIAliasName   : PCWSTR;
                     END;
    PDRVCONFIGINFO = POINTER TO DRVCONFIGINFO;


(* Supported return values for DRV_CONFIGURE message *)

CONST DRVCNF_CANCEL  = 0000h;
      DRVCNF_OK      = 0001h;
      DRVCNF_RESTART = 0002h;

<* IF NOT DEFINED (_WIN32_VXD) THEN *>

TYPE DRIVERPROC = PROCEDURE (DWORD, HDRVR, UINT, LPARAM, LPARAM) : LRESULT;

PROCEDURE CloseDriver (hDriver : HDRVR; lParam1, lParam2 : LONG) : LRESULT;
PROCEDURE OpenDriver  (szDriverName, szSectionName : PCWSTR; lParam2 : LONG) : HDRVR;
PROCEDURE SendDriverMessage  (hDriver : HDRVR; message : UINT; lParam1, lParam2 : LONG) : LRESULT;
PROCEDURE DrvGetModuleHandle (hDriver : HDRVR) : HMODULE;
PROCEDURE GetDriverModuleHandle (hDriver : HDRVR) : HMODULE;
PROCEDURE DefDriverProc (dwDriverIdentifier : DWORD; hdrvr : HDRVR; uMsg : UINT; lParam1, lParam2 : LPARAM) : LRESULT;

<* END *>

(* return values from DriverProc() function *)

CONST DRV_CANCEL  = DRVCNF_CANCEL;
      DRV_OK      = DRVCNF_OK;
      DRV_RESTART = DRVCNF_RESTART;

CONST DRV_MCI_FIRST = DRV_RESERVED;
      DRV_MCI_LAST  = DRV_RESERVED + 0FFFh;

<* END *>  (* NOT DEFINED (MMNODRV) *)

(****************************************************************************

                          Driver callback support

****************************************************************************)

(* flags used with waveOutOpen(), waveInOpen(), midiInOpen(), and *)
(* midiOutOpen() to specify the type of the dwCallback parameter. *)

CONST CALLBACK_TYPEMASK = 00070000h;    (* callback type mask *)
      CALLBACK_NULL     = 00000000h;    (* no callback *)
      CALLBACK_WINDOW   = 00010000h;    (* dwCallback is a HWND *)
      CALLBACK_TASK     = 00020000h;    (* dwCallback is a HTASK *)
      CALLBACK_FUNCTION = 00030000h;    (* dwCallback is a FARPROC *)
      CALLBACK_THREAD   = CALLBACK_TASK; (* thread ID replaces 16 bit task *)
      CALLBACK_EVENT    = 00050000h;    (* dwCallback is an EVENT Handle *)


<* IF NOT DEFINED (_WIN32_VXD) THEN *>

TYPE DRVCALLBACK = PROCEDURE (HDRVR, UINT, DWORD, DWORD, DWORD);

<* END *>   (* NOT DEFINED (_WIN32_VXD) *)

<* IF NOT DEFINED (MMNOMMSYSTEM) THEN *>
<* IF NOT DEFINED (_WIN32_VXD) THEN *>

(****************************************************************************

                    General MMSYSTEM support

****************************************************************************)

CONST OutputDebugStr = OutputDebugString;

<* END *>  (* NOT DEFINED (_WIN32_VXD)   *)
<* END *>  (* NOT DEFINED (MMNOMMSYSTEM) *)

<* IF NOT DEFINED (MMNOSOUND) THEN *>
<* IF NOT DEFINED (_WIN32_VXD) THEN *>

(****************************************************************************

                            Sound support

****************************************************************************)

PROCEDURE sndPlaySoundA (pszSound : PCSTR;  fuSound : UINT) : BOOL;
PROCEDURE sndPlaySoundW (pszSound : PCWSTR; fuSound : UINT) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST sndPlaySound = sndPlaySoundW;
<* ELSE *>
      CONST sndPlaySound = sndPlaySoundA;
<* END *>

(*
 *  flag values for fuSound and fdwSound arguments on [snd]PlaySound
 *)

CONST SND_SYNC          = 0000h;  (* play synchronously (default) *)
      SND_ASYNC         = 0001h;  (* play asynchronously *)
      SND_NODEFAULT     = 0002h;  (* silence (!default) if sound not found *)
      SND_MEMORY        = 0004h;  (* pszSound points to a memory file *)
      SND_LOOP          = 0008h;  (* loop the sound until next sndPlaySound *)
      SND_NOSTOP        = 0010h;  (* don't stop any currently playing sound *)

      SND_NOWAIT     = 00002000h; (* don't wait if the driver is busy *)
      SND_ALIAS      = 00010000h; (* name is a registry alias *)
      SND_ALIAS_ID   = 00110000h; (* alias is a predefined ID *)
      SND_FILENAME   = 00020000h; (* name is file name *)
      SND_RESOURCE   = 00040004h; (* name is resource name or atom *)

      SND_PURGE          = 0040h; (* purge non-static events for task *)
      SND_APPLICATION    = 0080h; (* look for application specific association *)

      SND_ALIAS_START = 0;        (* alias base *)

      SND_ALIAS_SYSTEMASTERISK      = SND_ALIAS_START + ORD ('S') + ORD ('*') * 256;
      SND_ALIAS_SYSTEMQUESTION      = SND_ALIAS_START + ORD ('S') + ORD ('?') * 256;
      SND_ALIAS_SYSTEMHAND          = SND_ALIAS_START + ORD ('S') + ORD ('H') * 256;
      SND_ALIAS_SYSTEMEXIT          = SND_ALIAS_START + ORD ('S') + ORD ('E') * 256;
      SND_ALIAS_SYSTEMSTART         = SND_ALIAS_START + ORD ('S') + ORD ('S') * 256;
      SND_ALIAS_SYSTEMWELCOME       = SND_ALIAS_START + ORD ('S') + ORD ('W') * 256;
      SND_ALIAS_SYSTEMEXCLAMATION   = SND_ALIAS_START + ORD ('S') + ORD ('!') * 256;
      SND_ALIAS_SYSTEMDEFAULT       = SND_ALIAS_START + ORD ('S') + ORD ('D') * 256;

PROCEDURE PlaySoundA (pszSound : PCSTR;  hmod : HMODULE; fdwSound : DWORD) : BOOL;
PROCEDURE PlaySoundW (pszSound : PCWSTR; hmod : HMODULE; fdwSound : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST PlaySound = PlaySoundW;
<* ELSE *>
      CONST PlaySound = PlaySoundA;
<* END *>

<* END *>  (* NOT DEFINED (_WIN32_VXD) *)
<* END *>  (* NOT DEFINED (MMNOSOUND) *)

<* IF NOT DEFINED (MMNOWAVE) THEN *>
(****************************************************************************

                        Waveform audio support

****************************************************************************)

(* waveform audio error return values *)

CONST WAVERR_BADFORMAT     = WAVERR_BASE + 0;    (* unsupported wave format *)
      WAVERR_STILLPLAYING  = WAVERR_BASE + 1;    (* still something playing *)
      WAVERR_UNPREPARED    = WAVERR_BASE + 2;    (* header not prepared *)
      WAVERR_SYNC          = WAVERR_BASE + 3;    (* device is synchronous *)
      WAVERR_LASTERROR     = WAVERR_BASE + 3;    (* last error in range *)

(* waveform audio data types *)

TYPE HWAVE    = POINTER TO RECORD END;
     HWAVEIN  = POINTER TO RECORD END;
     HWAVEOUT = POINTER TO RECORD END;

TYPE PHWAVEIN     = HWAVEIN;
TYPE PHWAVEOUT    = HWAVEOUT;
TYPE WAVECALLBACK = DRVCALLBACK;

(* wave callback messages *)

CONST WOM_OPEN      = MM_WOM_OPEN;
      WOM_CLOSE     = MM_WOM_CLOSE;
      WOM_DONE      = MM_WOM_DONE;
      WIM_OPEN      = MM_WIM_OPEN;
      WIM_CLOSE     = MM_WIM_CLOSE;
      WIM_DATA      = MM_WIM_DATA;

(* device ID for wave device mapper *)

CONST WAVE_MAPPER   = SYSTEM.CAST (UINT, VAL (INTEGER, -1));

(* flags for dwFlags parameter in waveOutOpen() and waveInOpen() *)

CONST WAVE_FORMAT_QUERY         = 0001h;
      WAVE_ALLOWSYNC            = 0002h;
      WAVE_MAPPED               = 0004h;
      WAVE_FORMAT_DIRECT        = 0008h;
      WAVE_FORMAT_DIRECT_QUERY  = WAVE_FORMAT_QUERY + WAVE_FORMAT_DIRECT;

(* wave data block header *)

TYPE PWAVEHDR = POINTER TO WAVEHDR;
      WAVEHDR = RECORD
                lpData          : PBYTE;    (* pointer to locked data buffer *)
                dwBufferLength  : DWORD;    (* length of data buffer *)
                dwBytesRecorded : DWORD;    (* used for input only *)
                dwUser          : DWORD;    (* for client's use *)
                dwFlags         : DWORD;    (* assorted flags (see defines) *)
                dwLoops         : DWORD;    (* loop control counter *)
                lpNext          : PWAVEHDR; (* reserved for driver *)
                reserved        : DWORD;    (* reserved for driver *)
      END;

(* flags for dwFlags field of WAVEHDR *)

CONST WHDR_DONE      = 00000001h; (* done bit *)
      WHDR_PREPARED  = 00000002h; (* set if this header has been prepared *)
      WHDR_BEGINLOOP = 00000004h; (* loop start block *)
      WHDR_ENDLOOP   = 00000008h; (* loop end block *)
      WHDR_INQUEUE   = 00000010h; (* reserved for driver *)

(* waveform output device capabilities structure *)

TYPE WAVEOUTCAPSA =
     RECORD
       wMid           : WORD;        (* manufacturer ID *)
       wPid           : WORD;        (* product ID *)
       vDriverVersion : MMVERSION;   (* version of the driver *)
       szPname        : PNAMESTR;    (* product name (NULL terminated string) *)
       dwFormats      : DWORD;       (* formats supported *)
       wChannels      : WORD;        (* number of sources supported *)
       wReserved1     : WORD;        (* packing *)
       dwSupport      : DWORD;       (* functionality supported by driver *)
     END;
     PWAVEOUTCAPSA = POINTER TO WAVEOUTCAPSA;

TYPE WAVEOUTCAPSW =
     RECORD
       wMid           : WORD;        (* manufacturer ID *)
       wPid           : WORD;        (* product ID *)
       vDriverVersion : MMVERSION;   (* version of the driver *)
       szPname        : PNAMESTRW;   (* product name (NULL terminated string) *)
       dwFormats      : DWORD;       (* formats supported *)
       wChannels      : WORD;        (* number of sources supported *)
       wReserved1     : WORD;        (* packing *)
       dwSupport      : DWORD;       (* functionality supported by driver *)
     END;
     PWAVEOUTCAPSW = POINTER TO WAVEOUTCAPSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  WAVEOUTCAPS =  WAVEOUTCAPSW;
      TYPE PWAVEOUTCAPS = PWAVEOUTCAPSW;
<* ELSE *>
      TYPE  WAVEOUTCAPS =  WAVEOUTCAPSA;
      TYPE PWAVEOUTCAPS = PWAVEOUTCAPSA;
<* END *>

(* flags for dwSupport field of WAVEOUTCAPS *)

CONST WAVECAPS_PITCH          = 0001h; (* supports pitch control *)
      WAVECAPS_PLAYBACKRATE   = 0002h; (* supports playback rate control *)
      WAVECAPS_VOLUME         = 0004h; (* supports volume control *)
      WAVECAPS_LRVOLUME       = 0008h; (* separate left-right volume control *)
      WAVECAPS_SYNC           = 0010h;
      WAVECAPS_SAMPLEACCURATE = 0020h;
      WAVECAPS_DIRECTSOUND    = 0040h;

(* waveform input device capabilities structure *)

TYPE WAVEINCAPSA =
     RECORD
       wMid           : WORD;          (* manufacturer ID *)
       wPid           : WORD;          (* product ID *)
       vDriverVersion : MMVERSION;     (* version of the driver *)
       szPname        : PNAMESTR;      (* product name (NULL terminated string) *)
       dwFormats      : DWORD;         (* formats supported *)
       wChannels      : WORD;          (* number of channels supported *)
       wReserved1     : WORD;          (* structure packing *)
     END;
     PWAVEINCAPSA = POINTER TO WAVEINCAPSA;

TYPE WAVEINCAPSW =
     RECORD
       wMid           : WORD;          (* manufacturer ID *)
       wPid           : WORD;          (* product ID *)
       vDriverVersion : MMVERSION;     (* version of the driver *)
       szPname        : PNAMESTRW;     (* product name (NULL terminated string) *)
       dwFormats      : DWORD;         (* formats supported *)
       wChannels      : WORD;          (* number of channels supported *)
       wReserved1     : WORD;          (* structure packing *)
     END;
     PWAVEINCAPSW = POINTER TO WAVEINCAPSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  WAVEINCAPS =  WAVEINCAPSW;
      TYPE PWAVEINCAPS = PWAVEINCAPSW;
<* ELSE *>
      TYPE  WAVEINCAPS =  WAVEINCAPSA;
      TYPE PWAVEINCAPS = PWAVEINCAPSA;
<* END *>

(* defines for dwFormat field of WAVEINCAPS and WAVEOUTCAPS *)

CONST WAVE_INVALIDFORMAT     = 00000000h;  (* invalid format *)
      WAVE_FORMAT_1M08       = 00000001h;  (* 11.025 kHz, Mono,   8-bit  *)
      WAVE_FORMAT_1S08       = 00000002h;  (* 11.025 kHz, Stereo, 8-bit  *)
      WAVE_FORMAT_1M16       = 00000004h;  (* 11.025 kHz, Mono,   16-bit *)
      WAVE_FORMAT_1S16       = 00000008h;  (* 11.025 kHz, Stereo, 16-bit *)
      WAVE_FORMAT_2M08       = 00000010h;  (* 22.05  kHz, Mono,   8-bit  *)
      WAVE_FORMAT_2S08       = 00000020h;  (* 22.05  kHz, Stereo, 8-bit  *)
      WAVE_FORMAT_2M16       = 00000040h;  (* 22.05  kHz, Mono,   16-bit *)
      WAVE_FORMAT_2S16       = 00000080h;  (* 22.05  kHz, Stereo, 16-bit *)
      WAVE_FORMAT_4M08       = 00000100h;  (* 44.1   kHz, Mono,   8-bit  *)
      WAVE_FORMAT_4S08       = 00000200h;  (* 44.1   kHz, Stereo, 8-bit  *)
      WAVE_FORMAT_4M16       = 00000400h;  (* 44.1   kHz, Mono,   16-bit *)
      WAVE_FORMAT_4S16       = 00000800h;  (* 44.1   kHz, Stereo, 16-bit *)

(* OLD general waveform format structure (information common to all formats) *)

TYPE WAVEFORMAT =
     RECORD
        wFormatTag      : WORD;   (* format type *)
        nChannels       : WORD;   (* number of channels (i.e. mono, stereo, etc.) *)
        nSamplesPerSec  : DWORD;  (* sample rate *)
        nAvgBytesPerSec : DWORD;  (* for buffer estimation *)
        nBlockAlign     : WORD;   (* block size of data *)
     END;
     PWAVEFORMAT = POINTER TO WAVEFORMAT;

(* flags for wFormatTag field of WAVEFORMAT *)

CONST WAVE_FORMAT_PCM = 1;

(* specific waveform format structure for PCM data *)
TYPE PCMWAVEFORMAT = RECORD
                            wf             : WAVEFORMAT;
                            wBitsPerSample : WORD;
                     END;
    PPCMWAVEFORMAT = POINTER TO PCMWAVEFORMAT;


(*
 *  extended waveform format structure used for all non-PCM formats. this
 *  structure is common to all non-PCM formats.
 *)

TYPE WAVEFORMATEX =
     RECORD
        wFormatTag      : WORD;  (* format type *)
        nChannels       : WORD;  (* number of channels (i.e. mono, stereo...) *)
        nSamplesPerSec  : DWORD; (* sample rate *)
        nAvgBytesPerSec : DWORD; (* for buffer estimation *)
        nBlockAlign     : WORD;  (* block size of data *)
        wBitsPerSample  : WORD;  (* number of bits per sample of mono data *)
        cbSize          : WORD;  (* the count in bytes of the size of *)
     END;                        (* extra information (after cbSize) *)
    PWAVEFORMATEX = POINTER TO WAVEFORMATEX;
   PCWAVEFORMATEX = POINTER TO WAVEFORMATEX;

<* IF NOT DEFINED (_WIN32_VXD) THEN *>
(* waveform audio function prototypes *)

PROCEDURE waveOutGetNumDevs () : UINT;

PROCEDURE waveOutGetDevCapsA (uDeviceID : UINT; VAR woc : WAVEOUTCAPSA; cbwoc : UINT) : MMRESULT;
PROCEDURE waveOutGetDevCapsW (uDeviceID : UINT; VAR woc : WAVEOUTCAPSW; cbwoc : UINT) : MMRESULT;

<* IF DEFINED (UNICODE) THEN *>
      CONST waveOutGetDevCaps = waveOutGetDevCapsW;
<* ELSE *>
      CONST waveOutGetDevCaps = waveOutGetDevCapsA;
<* END *>

PROCEDURE waveOutGetVolume (hwo : HWAVEOUT; VAR dwVolume : DWORD) : MMRESULT;
PROCEDURE waveOutSetVolume (hwo : HWAVEOUT;     dwVolume : DWORD) : MMRESULT;

PROCEDURE waveOutGetErrorTextA (mmrError : MMRESULT; pszText : PSTR;  cchText : UINT) : MMRESULT;
PROCEDURE waveOutGetErrorTextW (mmrError : MMRESULT; pszText : PWSTR; cchText : UINT) : MMRESULT;

<* IF DEFINED (UNICODE) THEN *>
      CONST waveOutGetErrorText = waveOutGetErrorTextW;
<* ELSE *>
      CONST waveOutGetErrorText = waveOutGetErrorTextA;
<* END *>


PROCEDURE waveOutOpen (VAR hwo : HWAVEOUT; uDeviceID : UINT;
                       VAR wfx : WAVEFORMATEX; dwCallback : DWORD;
                       dwInstance : DWORD; fdwOpen : DWORD) : MMRESULT;

PROCEDURE waveOutClose           (hwo : HWAVEOUT) : MMRESULT;
PROCEDURE waveOutPrepareHeader   (hwo : HWAVEOUT; VAR pwh : WAVEHDR; cbwh : UINT) : MMRESULT;
PROCEDURE waveOutUnprepareHeader (hwo : HWAVEOUT; VAR pwh : WAVEHDR; cbwh : UINT) : MMRESULT;
PROCEDURE waveOutWrite           (hwo : HWAVEOUT; VAR pwh : WAVEHDR; cbwh : UINT) : MMRESULT;
PROCEDURE waveOutPause           (hwo : HWAVEOUT) : MMRESULT;
PROCEDURE waveOutRestart         (hwo : HWAVEOUT) : MMRESULT;
PROCEDURE waveOutReset           (hwo : HWAVEOUT) : MMRESULT;
PROCEDURE waveOutBreakLoop       (hwo : HWAVEOUT) : MMRESULT;
PROCEDURE waveOutGetPosition     (hwo : HWAVEOUT; VAR mmt : MMTIME; cbmmt : UINT) : MMRESULT;
PROCEDURE waveOutGetPitch        (hwo : HWAVEOUT; VAR Pitch : DWORD) : MMRESULT;
PROCEDURE waveOutSetPitch        (hwo : HWAVEOUT;     Pitch : DWORD) : MMRESULT;
PROCEDURE waveOutGetPlaybackRate (hwo : HWAVEOUT; VAR Rate  : DWORD) : MMRESULT;
PROCEDURE waveOutSetPlaybackRate (hwo : HWAVEOUT;     Rate  : DWORD) : MMRESULT;
PROCEDURE waveOutGetID           (hwo : HWAVEOUT; VAR DeviceID : UINT) : MMRESULT;

PROCEDURE waveOutMessage (hwo : HWAVEOUT; uMsg : UINT; dw1, dw2 : DWORD) : MMRESULT;

PROCEDURE waveInGetNumDevs () : UINT;

PROCEDURE waveInGetDevCapsA (uDeviceID : UINT; VAR wic : WAVEINCAPSA; cbwic : UINT) : MMRESULT;
PROCEDURE waveInGetDevCapsW (uDeviceID : UINT; VAR wic : WAVEINCAPSW; cbwic : UINT) : MMRESULT;

<* IF DEFINED (UNICODE) THEN *>
      CONST waveInGetDevCaps = waveInGetDevCapsW;
<* ELSE *>
      CONST waveInGetDevCaps = waveInGetDevCapsA;
<* END *>

PROCEDURE waveInGetErrorTextA (mmrError : MMRESULT; pszText : PSTR;  cchText : UINT) : MMRESULT;
PROCEDURE waveInGetErrorTextW (mmrError : MMRESULT; pszText : PWSTR; cchText : UINT) : MMRESULT;

<* IF DEFINED (UNICODE) THEN *>
      CONST waveInGetErrorText = waveInGetErrorTextW;
<* ELSE *>
      CONST waveInGetErrorText = waveInGetErrorTextA;
<* END *>

PROCEDURE waveIntOpen (VAR hwi : HWAVEIN; uDeviceID : UINT;
                       VAR wfx : WAVEFORMATEX; dwCallback : DWORD;
                       dwInstance : DWORD; fdwOpen : DWORD) : MMRESULT;

PROCEDURE waveInClose           (hwi : HWAVEIN) : MMRESULT;
PROCEDURE waveInPrepareHeader   (hwi : HWAVEIN; VAR wh : WAVEHDR; cbwh : UINT) : MMRESULT;
PROCEDURE waveInUnprepareHeader (hwi : HWAVEIN; VAR wh : WAVEHDR; cbwh : UINT) : MMRESULT;
PROCEDURE waveInAddBuffer       (hwi : HWAVEIN; VAR wh : WAVEHDR; cbwh : UINT) : MMRESULT;
PROCEDURE waveInStart           (hwi : HWAVEIN) : MMRESULT;
PROCEDURE waveInStop            (hwi : HWAVEIN) : MMRESULT;
PROCEDURE waveInReset           (hwi : HWAVEIN) : MMRESULT;
PROCEDURE waveInGetPosition     (hwi : HWAVEIN; VAR mmt : MMTIME; cbmmt : UINT) : MMRESULT;
PROCEDURE waveInGetID           (hwi : HWAVEIN; VAR DeviceID : UINT) : MMRESULT;

PROCEDURE waveInMessage (hwo : HWAVEIN; uMsg : UINT; dw1, dw2 : DWORD) : MMRESULT;

<* END *>  (* NOT DEFINED (_WIN32_VXD) *)

<* END *>  (* NOT DEFINED (MMNOWAVE) *)

<* IF NOT DEFINED (MMNOMIDI) THEN *>
(****************************************************************************

                            MIDI audio support

****************************************************************************)

(* MIDI error return values *)

CONST MIDIERR_UNPREPARED    = MIDIERR_BASE + 0;   (* header not prepared *)
      MIDIERR_STILLPLAYING  = MIDIERR_BASE + 1;   (* still something playing *)
      MIDIERR_NOMAP         = MIDIERR_BASE + 2;   (* no configured instruments *)
      MIDIERR_NOTREADY      = MIDIERR_BASE + 3;   (* hardware is still busy *)
      MIDIERR_NODEVICE      = MIDIERR_BASE + 4;   (* port no longer connected *)
      MIDIERR_INVALIDSETUP  = MIDIERR_BASE + 5;   (* invalid MIF *)
      MIDIERR_BADOPENMODE   = MIDIERR_BASE + 6;   (* operation unsupported w/ open mode *)
      MIDIERR_DONT_CONTINUE = MIDIERR_BASE + 7;   (* thru device 'eating' a message *)
      MIDIERR_LASTERROR     = MIDIERR_BASE + 7;   (* last error in range *)


(* MIDI audio data types *)

TYPE HMIDI = POINTER TO RECORD END;
TYPE HMIDIIN = POINTER TO RECORD END;
TYPE HMIDIOUT = POINTER TO RECORD END;
TYPE HMIDISTRM = POINTER TO RECORD END;

TYPE PHMIDI = POINTER TO HMIDI;
TYPE PHMIDIIN = POINTER TO HMIDIIN;
TYPE PHMIDIOUT = POINTER TO HMIDIOUT;
TYPE PHMIDISTRM = POINTER TO HMIDISTRM;
TYPE MIDICALLBACK = DRVCALLBACK;

CONST MIDIPATCHSIZE = 128;

TYPE PATCHARRAY = ARRAY [0..MIDIPATCHSIZE-1] OF WORD;
TYPE KEYARRAY   = ARRAY [0..MIDIPATCHSIZE-1] OF WORD;

(* MIDI callback messages *)

CONST MIM_OPEN       = MM_MIM_OPEN;
      MIM_CLOSE      = MM_MIM_CLOSE;
      MIM_DATA       = MM_MIM_DATA;
      MIM_LONGDATA   = MM_MIM_LONGDATA;
      MIM_ERROR      = MM_MIM_ERROR;
      MIM_LONGERROR  = MM_MIM_LONGERROR;
      MOM_OPEN       = MM_MOM_OPEN;
      MOM_CLOSE      = MM_MOM_CLOSE;
      MOM_DONE       = MM_MOM_DONE;
      MIM_MOREDATA   = MM_MIM_MOREDATA;
      MOM_POSITIONCB = MM_MOM_POSITIONCB;

      MIDIMAPPER     = SYSTEM.CAST (UINT, VAL (INTEGER, -1));
      MIDI_MAPPER    = SYSTEM.CAST (UINT, VAL (INTEGER, -1));

(* flags for dwFlags parm of midiInOpen() *)

CONST MIDI_IO_STATUS = 00000020h;

(* flags for wFlags parm of midiOutCachePatches(), midiOutCacheDrumPatches() *)

CONST MIDI_CACHE_ALL     = 1;
      MIDI_CACHE_BESTFIT = 2;
      MIDI_CACHE_QUERY   = 3;
      MIDI_UNCACHE       = 4;


(* MIDI output device capabilities structure *)

TYPE MIDIOUTCAPSA =
     RECORD
        wMid           : WORD;          (* manufacturer ID *)
        wPid           : WORD;          (* product ID *)
        vDriverVersion : MMVERSION;     (* version of the driver *)
        szPname        : PNAMESTR;      (* product name (NULL terminated string) *)
        wTechnology    : WORD;          (* type of device *)
        wVoices        : WORD;          (* # of voices (internal synth only) *)
        wNotes         : WORD;          (* max # of notes (internal synth only) *)
        wChannelMask   : WORD;          (* channels used (internal synth only) *)
        dwSupport      : DWORD;         (* functionality supported by driver *)
     END;
     PMIDIOUTCAPSA = POINTER TO MIDIOUTCAPSA;

TYPE MIDIOUTCAPSW =
     RECORD
        wMid           : WORD;          (* manufacturer ID *)
        wPid           : WORD;          (* product ID *)
        vDriverVersion : MMVERSION;     (* version of the driver *)
        szPname        : PNAMESTRW;     (* product name (NULL terminated string) *)
        wTechnology    : WORD;          (* type of device *)
        wVoices        : WORD;          (* # of voices (internal synth only) *)
        wNotes         : WORD;          (* max # of notes (internal synth only) *)
        wChannelMask   : WORD;          (* channels used (internal synth only) *)
        dwSupport      : DWORD;         (* functionality supported by driver *)
     END;
     PMIDIOUTCAPSW = POINTER TO MIDIOUTCAPSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  MIDIOUTCAPS =  MIDIOUTCAPSW;
      TYPE PMIDIOUTCAPS = PMIDIOUTCAPSW;
<* ELSE *>
      TYPE  MIDIOUTCAPS =  MIDIOUTCAPSA;
      TYPE PMIDIOUTCAPS = PMIDIOUTCAPSA;
<* END *>

(* flags for wTechnology field of MIDIOUTCAPS structure *)

CONST MOD_MIDIPORT   = 1; (* output port *)
      MOD_SYNTH      = 2; (* generic internal synth *)
      MOD_SQSYNTH    = 3; (* square wave internal synth *)
      MOD_FMSYNTH    = 4; (* FM internal synth *)
      MOD_MAPPER     = 5; (* MIDI mapper *)

(* flags for dwSupport field of MIDIOUTCAPS structure *)

CONST MIDICAPS_VOLUME   = 0001h; (* supports volume control *)
      MIDICAPS_LRVOLUME = 0002h; (* separate left-right volume control *)
      MIDICAPS_CACHE    = 0004h;
      MIDICAPS_STREAM   = 0008h; (* driver supports midiStreamOut directly *)

(* MIDI input device capabilities structure *)

TYPE MIDIINCAPSA =
     RECORD
        wMid           : WORD;          (* manufacturer ID *)
        wPid           : WORD;          (* product ID *)
        vDriverVersion : MMVERSION;     (* version of the driver *)
        szPname        : PNAMESTR;      (* product name (NULL terminated string) *)
        dwSupport      : DWORD;         (* functionality supported by driver *)
     END;
    PMIDIINCAPSA = POINTER TO MIDIINCAPSA;

TYPE MIDIINCAPSW =
     RECORD
        wMid           : WORD;          (* manufacturer ID *)
        wPid           : WORD;          (* product ID *)
        vDriverVersion : MMVERSION;     (* version of the driver *)
        szPname        : PNAMESTRW;     (* product name (NULL terminated string) *)
        dwSupport      : DWORD;         (* functionality supported by driver *)
     END;
    PMIDIINCAPSW = POINTER TO MIDIINCAPSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  MIDIINCAPS =  MIDIINCAPSW;
      TYPE PMIDIINCAPS = PMIDIINCAPSW;
<* ELSE *>
      TYPE  MIDIINCAPS =  MIDIINCAPSA;
      TYPE PMIDIINCAPS = PMIDIINCAPSA;
<* END *>

(* MIDI data block header *)
TYPE PMIDIHDR = POINTER TO MIDIHDR;
     MIDIHDR =
     RECORD
        lpData          : PSTR;       (* pointer to locked data block *)
        dwBufferLength  : DWORD;      (* length of data in data block *)
        dwBytesRecorded : DWORD;      (* used for input only *)
        dwUser          : DWORD;      (* for client's use *)
        dwFlags         : DWORD;      (* assorted flags (see defines) *)
        lpNext          : PMIDIHDR;   (* reserved for driver *)
        reserved        : DWORD;      (* reserved for driver *)
        dwOffset        : DWORD;      (* Callback offset into buffer *)
        dwReserved      : ARRAY [0..7] OF DWORD;  (* Reserved for MMSYSTEM *)
     END;

TYPE MIDIEVENT =
     RECORD
        dwDeltaTime : DWORD;      (* Ticks since last event *)
        dwStreamID  : DWORD;      (* Reserved; must be zero *)
        dwEvent     : DWORD;      (* Event type and parameters *)
        dwParms     : ARRAY [0..0] OF DWORD;  (* Parameters if this is a long event *)
     END;

TYPE MIDISTRMBUFFVER =
     RECORD
        dwVersion    : DWORD;     (* Stream buffer format version *)
        dwMid        : DWORD;     (* Manufacturer ID as defined in MMREG.H *)
        dwOEMVersion : DWORD;     (* Manufacturer version for custom ext *)
     END;

(* flags for dwFlags field of MIDIHDR structure *)

CONST MHDR_DONE      = 00000001h;       (* done bit *)
      MHDR_PREPARED  = 00000002h;       (* set if header prepared *)
      MHDR_INQUEUE   = 00000004h;       (* reserved for driver *)
      MHDR_ISSTRM    = 00000008h;       (* Buffer is stream buffer *)

(* *)
(* Type codes which go in the high byte of the event DWORD of a stream buffer *)
(* *)
(* Type codes 00-7F contain parameters within the low 24 bits *)
(* Type codes 80-FF contain a length of their parameter in the low 24 *)
(* bits, followed by their parameter data in the buffer. The event *)
(* DWORD contains the exact byte length; the parm data itself must be *)
(* padded to be an even multiple of 4 bytes long. *)
(* *)

CONST MEVT_F_SHORT      = 00000000h;
      MEVT_F_LONG       = 80000000h;
      MEVT_F_CALLBACK   = 40000000h;

PROCEDURE MEVT_EVENTTYPE (x : DWORD) : BYTE;
PROCEDURE MEVT_EVENTPARM (x : DWORD) : DWORD;

CONST MEVT_SHORTMSG     = VAL (BYTE, 0);    (* parm = shortmsg for midiOutShortMsg *)
      MEVT_TEMPO        = VAL (BYTE, 1);    (* parm = new tempo in microsec/qn     *)
      MEVT_NOP          = VAL (BYTE, 2);    (* parm = unused; does nothing         *)

(* 0x04-0x7F reserved *)

CONST MEVT_LONGMSG      = VAL (BYTE, 80h);  (* parm = bytes to send verbatim       *)
      MEVT_COMMENT      = VAL (BYTE, 82h);  (* parm = comment data                 *)
      MEVT_VERSION      = VAL (BYTE, 84h);  (* parm = MIDISTRMBUFFVER struct       *)

(* 0x81-0xFF reserved *)

CONST MIDISTRM_ERROR    = -2;

(* *)
(* Structures and defines for midiStreamProperty *)
(* *)

CONST MIDIPROP_SET      = 80000000h;
      MIDIPROP_GET      = 40000000h;

(* These are intentionally both non-zero so the app cannot accidentally *)
(* leave the operation off and happen to appear to work due to default *)
(* action. *)

CONST MIDIPROP_TIMEDIV  = 00000001h;
      MIDIPROP_TEMPO    = 00000002h;

TYPE MIDIPROPTIMEDIV = RECORD
                              cbStruct  : DWORD;
                              dwTimeDiv : DWORD;
                       END;
    PMIDIPROPTIMEDIV = POINTER TO MIDIPROPTIMEDIV;

TYPE MIDIPROPTEMPO = RECORD
                            cbStruct : DWORD;
                            dwTempo  : DWORD;
                     END;
    PMIDIPROPTEMPO = POINTER TO MIDIPROPTEMPO;

<* IF NOT DEFINED (_WIN32_VXD) THEN *>

PROCEDURE midiOutGetNumDevs () : UINT;

PROCEDURE midiStreamOpen  (VAR hms : HMIDISTRM; VAR DeviceID : UINT;
                           cMidi : DWORD; dwCallback : DWORD;
                           dwInstance : DWORD; fdwOpen : DWORD) : MMRESULT;

PROCEDURE midiStreamClose (hms : HMIDISTRM) : MMRESULT;

PROCEDURE midiStreamProperty (hms : HMIDISTRM; lppropdata : PBYTE; dwProperty : DWORD) : MMRESULT;
PROCEDURE midiStreamPosition (hms : HMIDISTRM; VAR mmt : MMTIME; cbmmt : UINT) : MMRESULT;

PROCEDURE midiStreamOut     (hms : HMIDISTRM; VAR mh : MIDIHDR; cbmh : UINT) : MMRESULT;
PROCEDURE midiStreamPause   (hms : HMIDISTRM) : MMRESULT;
PROCEDURE midiStreamRestart (hms : HMIDISTRM) : MMRESULT;
PROCEDURE midiStreamStop    (hms : HMIDISTRM) : MMRESULT;

PROCEDURE midiConnect    (hmi : HMIDI; hmo : HMIDIOUT; pReserved : PVOID) : MMRESULT;
PROCEDURE midiDisconnect (hmi : HMIDI; hmo : HMIDIOUT; pReserved : PVOID) : MMRESULT;

PROCEDURE midiOutGetDevCapsA (uDeviceID : UINT; VAR mod : MIDIOUTCAPSA; cbmoc : UINT) : MMRESULT;
PROCEDURE midiOutGetDevCapsW (uDeviceID : UINT; VAR mod : MIDIOUTCAPSW; cbmoc : UINT) : MMRESULT;

<* IF DEFINED (UNICODE) THEN *>
      CONST midiOutGetDevCaps = midiOutGetDevCapsW;
<* ELSE *>
      CONST midiOutGetDevCaps = midiOutGetDevCapsA;
<* END *>


PROCEDURE midiOutGetVolume (hmo : HMIDIOUT; VAR Volume : DWORD) : MMRESULT;
PROCEDURE midiOutSetVolume (hmo : HMIDIOUT;     Volume : DWORD) : MMRESULT;

PROCEDURE midiOutGetErrorTextA (mmrError : MMRESULT; Text : PSTR;  cchText : UINT) : MMRESULT;
PROCEDURE midiOutGetErrorTextW (mmrError : MMRESULT; Text : PWSTR; cchText : UINT) : MMRESULT;

<* IF DEFINED (UNICODE) THEN *>
      CONST midiOutGetErrorText = midiOutGetErrorTextW;
<* ELSE *>
      CONST midiOutGetErrorText = midiOutGetErrorTextA;
<* END *>

PROCEDURE midiOutOpen (VAR hmo : HMIDIOUT; uDeviceID : UINT;
                       dwCallback : DWORD; dwInstance : DWORD;
                       fdwOpen : DWORD) : MMRESULT;
PROCEDURE midiOutClose            (hmo : HMIDIOUT) : MMRESULT;
PROCEDURE midiOutPrepareHeader    (hmo : HMIDIOUT; VAR mh : MIDIHDR; cbmh : UINT) : MMRESULT;
PROCEDURE midiOutUnprepareHeader  (hmo : HMIDIOUT; VAR mh : MIDIHDR; cbmh : UINT) : MMRESULT;
PROCEDURE midiOutShortMsg         (hmo : HMIDIOUT; dwMsg : DWORD) : MMRESULT;
PROCEDURE midiOutLongMsg          (hmo : HMIDIOUT; VAR mh : MIDIHDR; cbmh : UINT) : MMRESULT;
PROCEDURE midiOutReset            (hmo : HMIDIOUT) : MMRESULT;
PROCEDURE midiOutCachePatches     (hmo : HMIDIOUT; uBank  : UINT; VAR pa : PATCHARRAY; fuCache : UINT) : MMRESULT;
PROCEDURE midiOutCacheDrumPatches (hmo : HMIDIOUT; uPatch : UINT; VAR pa : PATCHARRAY; fuCache : UINT) : MMRESULT;
PROCEDURE midiOutGetID            (hmo : HMIDIOUT; VAR DeviceID : UINT) : MMRESULT;

PROCEDURE midiOutMessage (hmo : HMIDIOUT; uMsg : UINT; dw1, dw2 : DWORD) : MMRESULT;

PROCEDURE midiInGetNumDevs () : UINT;

PROCEDURE midiInGetDevCapsA (uDeviceID : UINT; VAR mic : MIDIINCAPSA; cbmic : UINT) : MMRESULT;
PROCEDURE midiInGetDevCapsW (uDeviceID : UINT; VAR mic : MIDIINCAPSW; cbmic : UINT) : MMRESULT;

<* IF DEFINED (UNICODE) THEN *>
      CONST midiInGetDevCaps = midiInGetDevCapsW;
<* ELSE *>
      CONST midiInGetDevCaps = midiInGetDevCapsA;
<* END *>

PROCEDURE midiInGetErrorTextA (mmrError : MMRESULT; pszText : PSTR;  cchText : UINT) : MMRESULT;
PROCEDURE midiInGetErrorTextW (mmrError : MMRESULT; pszText : PWSTR; cchText : UINT) : MMRESULT;

<* IF DEFINED (UNICODE) THEN *>
      CONST midiInGetErrorText = midiInGetErrorTextW;
<* ELSE *>
      CONST midiInGetErrorText = midiInGetErrorTextA;
<* END *>

PROCEDURE midiInOpen (VAR hmi : HMIDIIN; uDeviceID : UINT;
                      dwCallback : DWORD; dwInstance : DWORD;
                      fdwOpen : DWORD) : MMRESULT;
PROCEDURE midiInClose           (hmi : HMIDIIN) : MMRESULT;
PROCEDURE midiInPrepareHeader   (hmi : HMIDIIN; VAR mh : MIDIHDR; cbmh : UINT) : MMRESULT;
PROCEDURE midiInUnprepareHeader (hmi : HMIDIIN; VAR mh : MIDIHDR; cbmh : UINT) : MMRESULT;
PROCEDURE midiInAddBuffer       (hmi : HMIDIIN; VAR mh : MIDIHDR; cbmh : UINT) : MMRESULT;
PROCEDURE midiInStart           (hmi : HMIDIIN) : MMRESULT;
PROCEDURE midiInStop            (hmi : HMIDIIN) : MMRESULT;
PROCEDURE midiInReset           (hmi : HMIDIIN) : MMRESULT;
PROCEDURE midiInGetID           (hmi : HMIDIIN; VAR DeviceID : UINT) : MMRESULT;

PROCEDURE midiInMessage (hmi : HMIDIIN; uMsg : UINT; dw1, dw2 : DWORD) : MMRESULT;

<* END *>  (* NOT DEFINED (_WIN32_VXD) *)

<* END *>  (* NOT DEFINED (MMNOMIDI) *)

<* IF NOT DEFINED (MMNOAUX) THEN *>
(****************************************************************************

                        Auxiliary audio support

****************************************************************************)

(* device ID for aux device mapper *)

CONST AUX_MAPPER = SYSTEM.CAST (UINT, VAL (INTEGER, -1));

(* Auxiliary audio device capabilities structure *)

TYPE AUXCAPSA =
     RECORD
            wMid           : WORD;         (* manufacturer ID *)
            wPid           : WORD;         (* product ID *)
            vDriverVersion : MMVERSION;    (* version of the driver *)
            szPname        : PNAMESTR;     (* product name (NULL terminated string) *)
            wTechnology    : WORD;         (* type of device *)
            wReserved1     : WORD;         (* padding *)
            dwSupport      : DWORD;        (* functionality supported by driver *)
     END;
     PAUXCAPSA = POINTER TO AUXCAPSA;

TYPE AUXCAPSW =
     RECORD
            wMid           : WORD;         (* manufacturer ID *)
            wPid           : WORD;         (* product ID *)
            vDriverVersion : MMVERSION;    (* version of the driver *)
            szPname        : PNAMESTRW;    (* product name (NULL terminated string) *)
            wTechnology    : WORD;         (* type of device *)
            wReserved1     : WORD;         (* padding *)
            dwSupport      : DWORD;        (* functionality supported by driver *)
     END;
     PAUXCAPSW = POINTER TO AUXCAPSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  AUXCAPS =  AUXCAPSW;
      TYPE PAUXCAPS = PAUXCAPSW;
<* ELSE *>
      TYPE  AUXCAPS =  AUXCAPSA;
      TYPE PAUXCAPS = PAUXCAPSA;
<* END *>

(* flags for wTechnology field in AUXCAPS structure *)

CONST AUXCAPS_CDAUDIO   = 1;       (* audio from internal CD-ROM drive *)
      AUXCAPS_AUXIN     = 2;       (* audio from auxiliary input jacks *)

(* flags for dwSupport field in AUXCAPS structure *)

CONST AUXCAPS_VOLUME    = 0001h;   (* supports volume control *)
      AUXCAPS_LRVOLUME  = 0002h;   (* separate left-right volume control *)

<* IF NOT DEFINED (_WIN32_VXD) THEN *>

(* auxiliary audio function prototypes *)

PROCEDURE auxGetNumDevs () : UINT;

PROCEDURE auxGetDevCapsA (uDeviceID : UINT; VAR pac : AUXCAPSA; cbac : UINT) : MMRESULT;
PROCEDURE auxGetDevCapsW (uDeviceID : UINT; VAR pac : AUXCAPSW; cbac : UINT) : MMRESULT;

<* IF DEFINED (UNICODE) THEN *>
      CONST auxGetDevCaps = auxGetDevCapsW;
<* ELSE *>
      CONST auxGetDevCaps = auxGetDevCapsA;
<* END *>

PROCEDURE auxSetVolume (uDeviceID : UINT; VAR Volume : DWORD) : MMRESULT;
PROCEDURE auxGetVolume (uDeviceID : UINT; VAR Volume : DWORD) : MMRESULT;

PROCEDURE auxOutMessage (uDeviceID : UINT; uMsg : UINT; dw1, dw2 : DWORD) : MMRESULT;

<* END *> (* NOT DEFINED (_WIN32_VXD) *)

<* END *>  (* NOT DEFINED (MMNOAUX) *)

<* IF NOT DEFINED (MMNOMIXER) THEN *>
<* IF NOT DEFINED (_WIN32_VXD) THEN *>
(****************************************************************************

                            Mixer Support

****************************************************************************)

TYPE  HMIXEROBJ = POINTER TO RECORD END;
     PHMIXEROBJ = POINTER TO HMIXEROBJ;

TYPE HMIXER  = POINTER TO RECORD END;
     PHMIXER = POINTER TO HMIXER;

CONST MIXER_SHORT_NAME_CHARS = 16;
      MIXER_LONG_NAME_CHARS  = 64;

(* *)
(*  MMRESULT error return values specific to the mixer API *)
(* *)
(* *)

CONST MIXERR_INVALLINE           = MIXERR_BASE + 0;
      MIXERR_INVALCONTROL        = MIXERR_BASE + 1;
      MIXERR_INVALVALUE          = MIXERR_BASE + 2;
      MIXERR_LASTERROR           = MIXERR_BASE + 2;

CONST MIXER_OBJECTF_HANDLE    = 80000000h;
      MIXER_OBJECTF_MIXER     = 00000000h;
      MIXER_OBJECTF_HMIXER    = MIXER_OBJECTF_HANDLE + MIXER_OBJECTF_MIXER;

      MIXER_OBJECTF_WAVEOUT   = 1000000h;
      MIXER_OBJECTF_HWAVEOUT  = MIXER_OBJECTF_HANDLE + MIXER_OBJECTF_WAVEOUT;

      MIXER_OBJECTF_WAVEIN    = 20000000h;
      MIXER_OBJECTF_HWAVEIN   = MIXER_OBJECTF_HANDLE + MIXER_OBJECTF_WAVEIN;

      MIXER_OBJECTF_MIDIOUT   = 30000000h;
      MIXER_OBJECTF_HMIDIOUT  = MIXER_OBJECTF_HANDLE + MIXER_OBJECTF_MIDIOUT;

      MIXER_OBJECTF_MIDIIN    = 40000000h;
      MIXER_OBJECTF_HMIDIIN   = MIXER_OBJECTF_HANDLE + MIXER_OBJECTF_MIDIIN;

      MIXER_OBJECTF_AUX       = 50000000h;

PROCEDURE mixerGetNumDevs () : UINT;

TYPE MIXERCAPSA =
     RECORD
            wMid           : WORD;        (* manufacturer id *)
            wPid           : WORD;        (* product id *)
            vDriverVersion : MMVERSION;   (* version of the driver *)
            szPname        : PNAMESTR;    (* product name *)
            fdwSupport     : DWORD;       (* misc. support bits *)
            cDestinations  : DWORD;       (* count of destinations *)
     END;
     PMIXERCAPSA = POINTER TO MIXERCAPSA;

TYPE MIXERCAPSW =
     RECORD
            wMid           : WORD;        (* manufacturer id *)
            wPid           : WORD;        (* product id *)
            vDriverVersion : MMVERSION;   (* version of the driver *)
            szPname        : PNAMESTRW;   (* product name *)
            fdwSupport     : DWORD;       (* misc. support bits *)
            cDestinations  : DWORD;       (* count of destinations *)
     END;
     PMIXERCAPSW = POINTER TO MIXERCAPSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  MIXERCAPS = MIXERCAPSW;
      TYPE PMIXERCAPS = PMIXERCAPSW;
<* ELSE *>
      TYPE  MIXERCAPS = MIXERCAPSA;
      TYPE PMIXERCAPS = PMIXERCAPSA;
<* END *>


PROCEDURE mixerGetDevCapsA (uMxId : UINT; VAR mxcaps : MIXERCAPSA; cbmxcaps : UINT) : MMRESULT;
PROCEDURE mixerGetDevCapsW (uMxId : UINT; VAR mxcaps : MIXERCAPSW; cbmxcaps : UINT) : MMRESULT;

<* IF DEFINED (UNICODE) THEN *>
      CONST mixerGetDevCaps = mixerGetDevCapsW;
<* ELSE *>
      CONST mixerGetDevCaps = mixerGetDevCapsA;
<* END *>


PROCEDURE mixerOpen (VAR hmx : HMIXER; uMxId : UINT; dwCallback : DWORD;
                     dwInstance : DWORD; fdwOpen : DWORD) : MMRESULT;

PROCEDURE mixerClose (hmx : HMIXER) : MMRESULT;

PROCEDURE mixerMessage (hmx : HMIXER; uMsg : UINT; dwParam1, dwParam2 : DWORD) : DWORD;

TYPE MIXERLINEA =
     RECORD
            cbStruct        : DWORD;           (* size of MIXERLINE structure *)
            dwDestination   : DWORD;           (* zero based destination index *)
            dwSource        : DWORD;           (* zero based source index (if source) *)
            dwLineID        : DWORD;           (* unique line id for mixer device *)
            fdwLine         : DWORD;           (* state/information about line *)
            dwUser          : DWORD;           (* driver specific information *)
            dwComponentType : DWORD;           (* component type line connects to *)
            cChannels       : DWORD;           (* number of channels line supports *)
            cConnections    : DWORD;           (* number of connections [possible] *)
            cControls       : DWORD;           (* number of controls at this line *)
            szShortName     : ARRAY [0..MIXER_SHORT_NAME_CHARS-1] OF CHAR;
            szName          : ARRAY [0..MIXER_LONG_NAME_CHARS -1] OF CHAR;
            Target : RECORD
                      dwType         : DWORD;     (* MIXERLINE_TARGETTYPE_xxxx *)
                      dwDeviceID     : DWORD;     (* target device ID of device type *)
                      wMid           : WORD;      (* of target device *)
                      wPid           : WORD;      (*      " *)
                      vDriverVersion : MMVERSION; (*      " *)
                      szPname        : PNAMESTR;  (*      " *)
                     END;
     END;
     PMIXERLINEA = POINTER TO MIXERLINEA;

TYPE MIXERLINEW =
     RECORD
            cbStruct        : DWORD;           (* size of MIXERLINE structure *)
            dwDestination   : DWORD;           (* zero based destination index *)
            dwSource        : DWORD;           (* zero based source index (if source) *)
            dwLineID        : DWORD;           (* unique line id for mixer device *)
            fdwLine         : DWORD;           (* state/information about line *)
            dwUser          : DWORD;           (* driver specific information *)
            dwComponentType : DWORD;           (* component type line connects to *)
            cChannels       : DWORD;           (* number of channels line supports *)
            cConnections    : DWORD;           (* number of connections [possible] *)
            cControls       : DWORD;           (* number of controls at this line *)
            szShortName     : ARRAY [0..MIXER_SHORT_NAME_CHARS-1] OF WCHAR;
            szName          : ARRAY [0..MIXER_LONG_NAME_CHARS -1] OF WCHAR;
            Target : RECORD
                      dwType         : DWORD;     (* MIXERLINE_TARGETTYPE_xxxx *)
                      dwDeviceID     : DWORD;     (* target device ID of device type *)
                      wMid           : WORD;      (* of target device *)
                      wPid           : WORD;      (*      " *)
                      vDriverVersion : MMVERSION; (*      " *)
                      szPname        : PNAMESTRW; (*      " *)
                     END;
     END;
     PMIXERLINEW = POINTER TO MIXERLINEW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  MIXERLINE =  MIXERLINEW;
           PMIXERLINE = PMIXERLINEW;
<* ELSE *>
      TYPE  MIXERLINE =  MIXERLINEA;
           PMIXERLINE = PMIXERLINEA;
<* END *>

(* *)
(*  MIXERLINE.fdwLine *)
(* *)
(* *)

CONST MIXERLINE_LINEF_ACTIVE              = 00000001h;
      MIXERLINE_LINEF_DISCONNECTED        = 00008000h;
      MIXERLINE_LINEF_SOURCE              = 80000000h;

(* *)
(*  MIXERLINE.dwComponentType *)
(* *)
(*  component types for destinations and sources *)
(* *)
(* *)
CONST MIXERLINE_COMPONENTTYPE_DST_FIRST       = 00000000h;
      MIXERLINE_COMPONENTTYPE_DST_UNDEFINED   = MIXERLINE_COMPONENTTYPE_DST_FIRST + 0;
      MIXERLINE_COMPONENTTYPE_DST_DIGITAL     = MIXERLINE_COMPONENTTYPE_DST_FIRST + 1;
      MIXERLINE_COMPONENTTYPE_DST_LINE        = MIXERLINE_COMPONENTTYPE_DST_FIRST + 2;
      MIXERLINE_COMPONENTTYPE_DST_MONITOR     = MIXERLINE_COMPONENTTYPE_DST_FIRST + 3;
      MIXERLINE_COMPONENTTYPE_DST_SPEAKERS    = MIXERLINE_COMPONENTTYPE_DST_FIRST + 4;
      MIXERLINE_COMPONENTTYPE_DST_HEADPHONES  = MIXERLINE_COMPONENTTYPE_DST_FIRST + 5;
      MIXERLINE_COMPONENTTYPE_DST_TELEPHONE   = MIXERLINE_COMPONENTTYPE_DST_FIRST + 6;
      MIXERLINE_COMPONENTTYPE_DST_WAVEIN      = MIXERLINE_COMPONENTTYPE_DST_FIRST + 7;
      MIXERLINE_COMPONENTTYPE_DST_VOICEIN     = MIXERLINE_COMPONENTTYPE_DST_FIRST + 8;
      MIXERLINE_COMPONENTTYPE_DST_LAST        = MIXERLINE_COMPONENTTYPE_DST_FIRST + 8;

      MIXERLINE_COMPONENTTYPE_SRC_FIRST       = 00001000h;
      MIXERLINE_COMPONENTTYPE_SRC_UNDEFINED   = MIXERLINE_COMPONENTTYPE_SRC_FIRST + 0;
      MIXERLINE_COMPONENTTYPE_SRC_DIGITAL     = MIXERLINE_COMPONENTTYPE_SRC_FIRST + 1;
      MIXERLINE_COMPONENTTYPE_SRC_LINE        = MIXERLINE_COMPONENTTYPE_SRC_FIRST + 2;
      MIXERLINE_COMPONENTTYPE_SRC_MICROPHONE  = MIXERLINE_COMPONENTTYPE_SRC_FIRST + 3;
      MIXERLINE_COMPONENTTYPE_SRC_SYNTHESIZER = MIXERLINE_COMPONENTTYPE_SRC_FIRST + 4;
      MIXERLINE_COMPONENTTYPE_SRC_COMPACTDISC = MIXERLINE_COMPONENTTYPE_SRC_FIRST + 5;
      MIXERLINE_COMPONENTTYPE_SRC_TELEPHONE   = MIXERLINE_COMPONENTTYPE_SRC_FIRST + 6;
      MIXERLINE_COMPONENTTYPE_SRC_PCSPEAKER   = MIXERLINE_COMPONENTTYPE_SRC_FIRST + 7;
      MIXERLINE_COMPONENTTYPE_SRC_WAVEOUT     = MIXERLINE_COMPONENTTYPE_SRC_FIRST + 8;
      MIXERLINE_COMPONENTTYPE_SRC_AUXILIARY   = MIXERLINE_COMPONENTTYPE_SRC_FIRST + 9;
      MIXERLINE_COMPONENTTYPE_SRC_ANALOG      = MIXERLINE_COMPONENTTYPE_SRC_FIRST + 10;
      MIXERLINE_COMPONENTTYPE_SRC_LAST        = MIXERLINE_COMPONENTTYPE_SRC_FIRST + 10;

(* *)
(*  MIXERLINE.Target.dwType *)
(* *)
(* *)

CONST MIXERLINE_TARGETTYPE_UNDEFINED     = 0;
      MIXERLINE_TARGETTYPE_WAVEOUT       = 1;
      MIXERLINE_TARGETTYPE_WAVEIN        = 2;
      MIXERLINE_TARGETTYPE_MIDIOUT       = 3;
      MIXERLINE_TARGETTYPE_MIDIIN        = 4;
      MIXERLINE_TARGETTYPE_AUX           = 5;

PROCEDURE mixerGetLineInfoA (hmxobj : HMIXEROBJ; VAR mxl : MIXERLINEA; fdwInfo : DWORD) : MMRESULT;
PROCEDURE mixerGetLineInfoW (hmxobj : HMIXEROBJ; VAR mxl : MIXERLINEW; fdwInfo : DWORD) : MMRESULT;

<* IF DEFINED (UNICODE) THEN *>
      CONST mixerGetLineInfo = mixerGetLineInfoW;
<* ELSE *>
      CONST mixerGetLineInfo = mixerGetLineInfoA;
<* END *>

CONST MIXER_GETLINEINFOF_DESTINATION      = 00000000h;
      MIXER_GETLINEINFOF_SOURCE           = 00000001h;
      MIXER_GETLINEINFOF_LINEID           = 00000002h;
      MIXER_GETLINEINFOF_COMPONENTTYPE    = 00000003h;
      MIXER_GETLINEINFOF_TARGETTYPE       = 00000004h;

      MIXER_GETLINEINFOF_QUERYMASK        = 0000000Fh;

PROCEDURE mixerGetID (hmxobj : HMIXEROBJ; VAR MxId : UINT; fdwId : DWORD) : MMRESULT;

(* *)
(*  MIXERCONTROL *)
(* *)
(* *)

TYPE MIXERCONTROLA =
     RECORD
            cbStruct       : DWORD;         (* size in bytes of MIXERCONTROL *)
            dwControlID    : DWORD;         (* unique control id for mixer device *)
            dwControlType  : DWORD;         (* MIXERCONTROL_CONTROLTYPE_xxx *)
            fdwControl     : DWORD;         (* MIXERCONTROL_CONTROLF_xxx *)
            cMultipleItems : DWORD;         (* if MIXERCONTROL_CONTROLF_MULTIPLE set *)
            szShortName    : ARRAY [0..MIXER_SHORT_NAME_CHARS-1] OF CHAR;
            szName         : ARRAY [0..MIXER_LONG_NAME_CHARS-1] OF CHAR;
            Bounds  : RECORD
                        CASE : BOOLEAN OF
                        | TRUE  : lMinimum  : LONG;   (* signed minimum for this control *)
                                  lMaximum  : LONG;   (* signed maximum for this control *)
                        | FALSE : dwMinimum : DWORD;  (* unsigned minimum for this control *)
                                  dwMaximum : DWORD;  (* unsigned maximum for this control *)
                        ELSE
                                  dwReserved : ARRAY [0..5] OF DWORD;
                        END;
                      END;
            Metrics : RECORD
                        CASE : BOOLEAN OF
                        | TRUE  : cSteps       : DWORD;  (* # of steps between min & max *)
                        | FALSE : cbCustomData : DWORD;  (* size in bytes of custom data *)
                        ELSE
                                  dwReserved : ARRAY [0..5] OF DWORD;  (* !!! needed? we have cbStruct.... *)
                        END;
                      END;
     END;
     PMIXERCONTROLA = POINTER TO MIXERCONTROLA;

TYPE MIXERCONTROLW =
     RECORD
            cbStruct       : DWORD;         (* size in bytes of MIXERCONTROL *)
            dwControlID    : DWORD;         (* unique control id for mixer device *)
            dwControlType  : DWORD;         (* MIXERCONTROL_CONTROLTYPE_xxx *)
            fdwControl     : DWORD;         (* MIXERCONTROL_CONTROLF_xxx *)
            cMultipleItems : DWORD;         (* if MIXERCONTROL_CONTROLF_MULTIPLE set *)
            szShortName    : ARRAY [0..MIXER_SHORT_NAME_CHARS-1] OF WCHAR;
            szName         : ARRAY [0..MIXER_LONG_NAME_CHARS-1] OF WCHAR;
            Bounds  : RECORD
                        CASE : BOOLEAN OF
                        | TRUE  : lMinimum  : LONG;   (* signed minimum for this control *)
                                  lMaximum  : LONG;   (* signed maximum for this control *)
                        | FALSE : dwMinimum : DWORD;  (* unsigned minimum for this control *)
                                  dwMaximum : DWORD;  (* unsigned maximum for this control *)
                        ELSE
                                  dwReserved : ARRAY [0..5] OF DWORD;
                        END;
                      END;
            Metrics : RECORD
                        CASE : BOOLEAN OF
                        | TRUE  : cSteps       : DWORD;  (* # of steps between min & max *)
                        | FALSE : cbCustomData : DWORD;  (* size in bytes of custom data *)
                        ELSE
                                  dwReserved : ARRAY [0..5] OF DWORD;  (* !!! needed? we have cbStruct.... *)
                        END;
                      END;
     END;
     PMIXERCONTROLW = POINTER TO MIXERCONTROLW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  MIXERCONTROL =  MIXERCONTROLW;
      TYPE PMIXERCONTROL = PMIXERCONTROLW;
<* ELSE *>
      TYPE  MIXERCONTROL =  MIXERCONTROLA;
      TYPE PMIXERCONTROL = PMIXERCONTROLA;
<* END *>

(* *)
(*  MIXERCONTROL.fdwControl *)
(* *)
(* *)

CONST MIXERCONTROL_CONTROLF_UNIFORM   = 00000001h;
      MIXERCONTROL_CONTROLF_MULTIPLE  = 00000002h;
      MIXERCONTROL_CONTROLF_DISABLED  = 80000000h;

(* *)
(*  MIXERCONTROL_CONTROLTYPE_xxx building block defines *)
(* *)
(* *)

CONST MIXERCONTROL_CT_CLASS_MASK          = 0F0000000h;
      MIXERCONTROL_CT_CLASS_CUSTOM        = 000000000h;
      MIXERCONTROL_CT_CLASS_METER         = 010000000h;
      MIXERCONTROL_CT_CLASS_SWITCH        = 020000000h;
      MIXERCONTROL_CT_CLASS_NUMBER        = 030000000h;
      MIXERCONTROL_CT_CLASS_SLIDER        = 040000000h;
      MIXERCONTROL_CT_CLASS_FADER         = 050000000h;
      MIXERCONTROL_CT_CLASS_TIME          = 060000000h;
      MIXERCONTROL_CT_CLASS_LIST          = 070000000h;

      MIXERCONTROL_CT_SUBCLASS_MASK       = 00F000000h;

      MIXERCONTROL_CT_SC_SWITCH_BOOLEAN   = 000000000h;
      MIXERCONTROL_CT_SC_SWITCH_BUTTON    = 001000000h;

      MIXERCONTROL_CT_SC_METER_POLLED     = 000000000h;

      MIXERCONTROL_CT_SC_TIME_MICROSECS   = 000000000h;
      MIXERCONTROL_CT_SC_TIME_MILLISECS   = 001000000h;

      MIXERCONTROL_CT_SC_LIST_SINGLE      = 000000000h;
      MIXERCONTROL_CT_SC_LIST_MULTIPLE    = 001000000h;

      MIXERCONTROL_CT_UNITS_MASK          = 000FF0000h;
      MIXERCONTROL_CT_UNITS_CUSTOM        = 000000000h;
      MIXERCONTROL_CT_UNITS_BOOLEAN       = 000010000h;
      MIXERCONTROL_CT_UNITS_SIGNED        = 000020000h;
      MIXERCONTROL_CT_UNITS_UNSIGNED      = 000030000h;
      MIXERCONTROL_CT_UNITS_DECIBELS      = 000040000h; (* in 10ths *)
      MIXERCONTROL_CT_UNITS_PERCENT       = 000050000h; (* in 10ths *)

(* *)
(*  Commonly used control types for specifying MIXERCONTROL.dwControlType *)
(* *)

CONST MIXERCONTROL_CONTROLTYPE_CUSTOM         = MIXERCONTROL_CT_CLASS_CUSTOM + MIXERCONTROL_CT_UNITS_CUSTOM;
      MIXERCONTROL_CONTROLTYPE_BOOLEANMETER   = MIXERCONTROL_CT_CLASS_METER + MIXERCONTROL_CT_SC_METER_POLLED + MIXERCONTROL_CT_UNITS_BOOLEAN;
      MIXERCONTROL_CONTROLTYPE_SIGNEDMETER    = MIXERCONTROL_CT_CLASS_METER + MIXERCONTROL_CT_SC_METER_POLLED + MIXERCONTROL_CT_UNITS_SIGNED;
      MIXERCONTROL_CONTROLTYPE_PEAKMETER      = MIXERCONTROL_CONTROLTYPE_SIGNEDMETER + 1;
      MIXERCONTROL_CONTROLTYPE_UNSIGNEDMETER  = MIXERCONTROL_CT_CLASS_METER + MIXERCONTROL_CT_SC_METER_POLLED + MIXERCONTROL_CT_UNITS_UNSIGNED;
      MIXERCONTROL_CONTROLTYPE_BOOLEAN        = MIXERCONTROL_CT_CLASS_SWITCH + MIXERCONTROL_CT_SC_SWITCH_BOOLEAN + MIXERCONTROL_CT_UNITS_BOOLEAN;
      MIXERCONTROL_CONTROLTYPE_ONOFF          = MIXERCONTROL_CONTROLTYPE_BOOLEAN + 1;
      MIXERCONTROL_CONTROLTYPE_MUTE           = MIXERCONTROL_CONTROLTYPE_BOOLEAN + 2;
      MIXERCONTROL_CONTROLTYPE_MONO           = MIXERCONTROL_CONTROLTYPE_BOOLEAN + 3;
      MIXERCONTROL_CONTROLTYPE_LOUDNESS       = MIXERCONTROL_CONTROLTYPE_BOOLEAN + 4;
      MIXERCONTROL_CONTROLTYPE_STEREOENH      = MIXERCONTROL_CONTROLTYPE_BOOLEAN + 5;
      MIXERCONTROL_CONTROLTYPE_BUTTON         = MIXERCONTROL_CT_CLASS_SWITCH + MIXERCONTROL_CT_SC_SWITCH_BUTTON + MIXERCONTROL_CT_UNITS_BOOLEAN;
      MIXERCONTROL_CONTROLTYPE_DECIBELS       = MIXERCONTROL_CT_CLASS_NUMBER + MIXERCONTROL_CT_UNITS_DECIBELS;
      MIXERCONTROL_CONTROLTYPE_SIGNED         = MIXERCONTROL_CT_CLASS_NUMBER + MIXERCONTROL_CT_UNITS_SIGNED;
      MIXERCONTROL_CONTROLTYPE_UNSIGNED       = MIXERCONTROL_CT_CLASS_NUMBER + MIXERCONTROL_CT_UNITS_UNSIGNED;
      MIXERCONTROL_CONTROLTYPE_PERCENT        = MIXERCONTROL_CT_CLASS_NUMBER + MIXERCONTROL_CT_UNITS_PERCENT;
      MIXERCONTROL_CONTROLTYPE_SLIDER         = MIXERCONTROL_CT_CLASS_SLIDER + MIXERCONTROL_CT_UNITS_SIGNED;
      MIXERCONTROL_CONTROLTYPE_PAN            = MIXERCONTROL_CONTROLTYPE_SLIDER + 1;
      MIXERCONTROL_CONTROLTYPE_QSOUNDPAN      = MIXERCONTROL_CONTROLTYPE_SLIDER + 2;
      MIXERCONTROL_CONTROLTYPE_FADER          = MIXERCONTROL_CT_CLASS_FADER + MIXERCONTROL_CT_UNITS_UNSIGNED;
      MIXERCONTROL_CONTROLTYPE_VOLUME         = MIXERCONTROL_CONTROLTYPE_FADER + 1;
      MIXERCONTROL_CONTROLTYPE_BASS           = MIXERCONTROL_CONTROLTYPE_FADER + 2;
      MIXERCONTROL_CONTROLTYPE_TREBLE         = MIXERCONTROL_CONTROLTYPE_FADER + 3;
      MIXERCONTROL_CONTROLTYPE_EQUALIZER      = MIXERCONTROL_CONTROLTYPE_FADER + 4;
      MIXERCONTROL_CONTROLTYPE_SINGLESELECT   = MIXERCONTROL_CT_CLASS_LIST + MIXERCONTROL_CT_SC_LIST_SINGLE + MIXERCONTROL_CT_UNITS_BOOLEAN;
      MIXERCONTROL_CONTROLTYPE_MUX            = MIXERCONTROL_CONTROLTYPE_SINGLESELECT + 1;
      MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT = MIXERCONTROL_CT_CLASS_LIST + MIXERCONTROL_CT_SC_LIST_MULTIPLE + MIXERCONTROL_CT_UNITS_BOOLEAN;
      MIXERCONTROL_CONTROLTYPE_MIXER          = MIXERCONTROL_CONTROLTYPE_MULTIPLESELECT + 1;
      MIXERCONTROL_CONTROLTYPE_MICROTIME      = MIXERCONTROL_CT_CLASS_TIME + MIXERCONTROL_CT_SC_TIME_MICROSECS + MIXERCONTROL_CT_UNITS_UNSIGNED;
      MIXERCONTROL_CONTROLTYPE_MILLITIME      = MIXERCONTROL_CT_CLASS_TIME + MIXERCONTROL_CT_SC_TIME_MILLISECS + MIXERCONTROL_CT_UNITS_UNSIGNED;

(* *)
(*  MIXERLINECONTROLS *)
(* *)

TYPE MIXERLINECONTROLSA =
     RECORD
            cbStruct : DWORD;       (* size in bytes of MIXERLINECONTROLS *)
            dwLineID : DWORD;       (* line id (from MIXERLINE.dwLineID) *)
            CASE : BOOLEAN OF
            | TRUE  : dwControlID   : DWORD;  (* MIXER_GETLINECONTROLSF_ONEBYID *)
            | FALSE : dwControlType : DWORD;  (* MIXER_GETLINECONTROLSF_ONEBYTYPE *)
            END;
            cControls : DWORD;           (* count of controls pmxctrl points to *)
            cbmxctrl  : DWORD;           (* size in bytes of _one_ MIXERCONTROL *)
            pamxctrl  : PMIXERCONTROLA;  (* pointer to first MIXERCONTROL array *)
     END;
     PMIXERLINECONTROLSA = POINTER TO MIXERLINECONTROLSA;

TYPE MIXERLINECONTROLSW =
     RECORD
            cbStruct : DWORD;       (* size in bytes of MIXERLINECONTROLS *)
            dwLineID : DWORD;       (* line id (from MIXERLINE.dwLineID) *)
            CASE : BOOLEAN OF
            | TRUE  : dwControlID   : DWORD;  (* MIXER_GETLINECONTROLSF_ONEBYID *)
            | FALSE : dwControlType : DWORD;  (* MIXER_GETLINECONTROLSF_ONEBYTYPE *)
            END;
            cControls : DWORD;           (* count of controls pmxctrl points to *)
            cbmxctrl  : DWORD;           (* size in bytes of _one_ MIXERCONTROL *)
            pamxctrl  : PMIXERCONTROLW;  (* pointer to first MIXERCONTROL array *)
     END;
     PMIXERLINECONTROLSW = POINTER TO MIXERLINECONTROLSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  MIXERLINECONTROLS =  MIXERLINECONTROLSW;
           PMIXERLINECONTROLS = PMIXERLINECONTROLSW;
<* ELSE *>
      TYPE  MIXERLINECONTROLS =  MIXERLINECONTROLSA;
           PMIXERLINECONTROLS = PMIXERLINECONTROLSA;
<* END *>


(* *)
(* *)
(* *)

PROCEDURE mixerGetLineControlsA (hmxobj : HMIXEROBJ; VAR mxlc : MIXERLINECONTROLSA; fdwControls : DWORD) : MMRESULT;
PROCEDURE mixerGetLineControlsW (hmxobj : HMIXEROBJ; VAR mxlc : MIXERLINECONTROLSW; fdwControls : DWORD) : MMRESULT;

<* IF DEFINED (UNICODE) THEN *>
      CONST mixerGetLineControls = mixerGetLineControlsW;
<* ELSE *>
      CONST mixerGetLineControls = mixerGetLineControlsA;
<* END *>

CONST MIXER_GETLINECONTROLSF_ALL          = 00000000h;
      MIXER_GETLINECONTROLSF_ONEBYID      = 00000001h;
      MIXER_GETLINECONTROLSF_ONEBYTYPE    = 00000002h;

      MIXER_GETLINECONTROLSF_QUERYMASK    = 0000000Fh;

TYPE MIXERCONTROLDETAILS =
     RECORD
            cbStruct : DWORD;       (* size in bytes of MIXERCONTROLDETAILS *)
            dwControlID : DWORD;    (* control id to get/set details on *)
            cChannels : DWORD;      (* number of channels in paDetails array *)
            CASE : BOOLEAN OF
            | TRUE  : hwndOwner      : HWND;    (* for MIXER_SETCONTROLDETAILSF_CUSTOM *)
            | FALSE : cMultipleItems : DWORD;   (* if _MULTIPLE, the number of items per channel *)
            END;
            cbDetails : DWORD;      (* size of _one_ details_XX struct *)
            paDetails : PVOID;      (* pointer to array of details_XX structs *)
     END;
     PMIXERCONTROLDETAILS = POINTER TO MIXERCONTROLDETAILS;

(* *)
(*  MIXER_GETCONTROLDETAILSF_LISTTEXT *)
(* *)
(* *)

TYPE MIXERCONTROLDETAILS_LISTTEXTA =
     RECORD
            dwParam1 : DWORD;
            dwParam2 : DWORD;
            szName   : ARRAY [0..MIXER_LONG_NAME_CHARS-1] OF CHAR;
     END;
     PMIXERCONTROLDETAILS_LISTTEXTA = POINTER TO MIXERCONTROLDETAILS_LISTTEXTA;

TYPE MIXERCONTROLDETAILS_LISTTEXTW =
     RECORD
            dwParam1 : DWORD;
            dwParam2 : DWORD;
            szName   : ARRAY [0..MIXER_LONG_NAME_CHARS-1] OF WCHAR;
     END;
     PMIXERCONTROLDETAILS_LISTTEXTW = POINTER TO MIXERCONTROLDETAILS_LISTTEXTW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  MIXERCONTROLDETAILS_LISTTEXT =  MIXERCONTROLDETAILS_LISTTEXTW;
      TYPE PMIXERCONTROLDETAILS_LISTTEXT = PMIXERCONTROLDETAILS_LISTTEXTW;
<* ELSE *>
      TYPE  MIXERCONTROLDETAILS_LISTTEXT =  MIXERCONTROLDETAILS_LISTTEXTA;
      TYPE PMIXERCONTROLDETAILS_LISTTEXT = PMIXERCONTROLDETAILS_LISTTEXTA;
<* END *>

(* *)
(*  MIXER_GETCONTROLDETAILSF_VALUE *)
(* *)
(* *)

TYPE MIXERCONTROLDETAILS_BOOLEAN = RECORD
                                          fValue : LONG;
                                   END;
    PMIXERCONTROLDETAILS_BOOLEAN = POINTER TO MIXERCONTROLDETAILS_BOOLEAN;

TYPE MIXERCONTROLDETAILS_SIGNED  = RECORD
                                          lValue : LONG;
                                   END;
    PMIXERCONTROLDETAILS_SIGNED  = POINTER TO MIXERCONTROLDETAILS_SIGNED;

TYPE MIXERCONTROLDETAILS_UNSIGNED = RECORD
                                           dwValue : DWORD;
                                    END;
    PMIXERCONTROLDETAILS_UNSIGNED = POINTER TO MIXERCONTROLDETAILS_UNSIGNED;

PROCEDURE mixerGetControlDetailsA (hmxobj : HMIXEROBJ; VAR pmxcd : MIXERCONTROLDETAILS; fdwDetails : DWORD) : MMRESULT;
PROCEDURE mixerGetControlDetailsW (hmxobj : HMIXEROBJ; VAR pmxcd : MIXERCONTROLDETAILS; fdwDetails : DWORD) : MMRESULT;

<* IF DEFINED (UNICODE) THEN *>
      CONST mixerGetControlDetails = mixerGetControlDetailsW;
<* ELSE *>
      CONST mixerGetControlDetails = mixerGetControlDetailsA;
<* END *>

CONST MIXER_GETCONTROLDETAILSF_VALUE      = 00000000h;
      MIXER_GETCONTROLDETAILSF_LISTTEXT   = 00000001h;

      MIXER_GETCONTROLDETAILSF_QUERYMASK  = 0000000Fh;

PROCEDURE mixerSetControlDetails (hmxobj : HMIXEROBJ; VAR mxcd : MIXERCONTROLDETAILS; fdwDetails : DWORD) : MMRESULT;

CONST MIXER_SETCONTROLDETAILSF_VALUE      = 00000000h;
      MIXER_SETCONTROLDETAILSF_CUSTOM     = 00000001h;

      MIXER_SETCONTROLDETAILSF_QUERYMASK  = 0000000Fh;

<* END *> (* NOT DEFINED (_WIN32_VXD) *)
<* END *> (* NOT DEFINED (MMNOMIXER)  *)

<* IF NOT DEFINED (MMNOTIMER) THEN *>
<* IF NOT DEFINED (_WIN32_VXD) THEN *>
(****************************************************************************

                            Timer support

****************************************************************************)

(* timer error return values *)

CONST TIMERR_NOERROR = 0;                  (* no error *)
      TIMERR_NOCANDO = TIMERR_BASE+1;      (* request not completed *)
      TIMERR_STRUCT  = TIMERR_BASE+33;     (* time struct size *)

(* timer data types *)

TYPE TIMECALLBACK = PROCEDURE ((* uTimerID : *) UINT,
                               (* uMsg     : *) UINT,
                               (* dwUser   : *) DWORD,
                               (* dw1      : *) DWORD,
                               (* dw2      : *) DWORD);

(* flags for fuEvent parameter of timeSetEvent() function *)

CONST TIME_ONESHOT  = 0000h;   (* program timer for single event *)
      TIME_PERIODIC = 0001h;   (* program for continuous periodic event *)

      TIME_CALLBACK_FUNCTION    = 0000h;  (* callback is function *)
      TIME_CALLBACK_EVENT_SET   = 0010h;  (* callback is event - use SetEvent *)
      TIME_CALLBACK_EVENT_PULSE = 0020h;  (* callback is event - use PulseEvent *)

(* timer device capabilities data structure *)

TYPE TIMECAPS = RECORD
                       wPeriodMin : UINT;     (* minimum period supported  *)
                       wPeriodMax : UINT;     (* maximum period supported  *)
                END;
    PTIMECAPS = POINTER TO TIMECAPS;

(* timer function prototypes *)

PROCEDURE timeGetSystemTime (VAR mmt : MMTIME; cbmmt : UINT) : MMRESULT;

PROCEDURE timeGetTime () : DWORD;
PROCEDURE timeSetEvent (uDelay : UINT; uResolution : UINT;
                        tc : TIMECALLBACK; dwUser : DWORD; fuEvent : UINT) : MMRESULT;
PROCEDURE timeKillEvent   (uTimerID : UINT) : MMRESULT;
PROCEDURE timeGetDevCaps  (VAR tc : TIMECAPS; cbtc : UINT) : MMRESULT;
PROCEDURE timeBeginPeriod (uPeriod : UINT) : MMRESULT;
PROCEDURE timeEndPeriod   (uPeriod : UINT) : MMRESULT;

<* END *>  (* NOT DEFINED (_WIN32_VXD) *)
<* END *>  (* NOT DEFINED (MMNOTIMER) *)

<* IF NOT DEFINED (MMNOJOY) THEN *>
(****************************************************************************

                            Joystick support

****************************************************************************)

(* joystick error return values *)

CONST JOYERR_NOERROR        = 0;                  (* no error *)
      JOYERR_PARMS          = JOYERR_BASE+5;      (* bad parameters *)
      JOYERR_NOCANDO        = JOYERR_BASE+6;      (* request not completed *)
      JOYERR_UNPLUGGED      = JOYERR_BASE+7;      (* joystick is unplugged *)

(* constants used with JOYINFO and JOYINFOEX structures and MM_JOY* messages *)

CONST JOY_BUTTON1         = 0001h;
      JOY_BUTTON2         = 0002h;
      JOY_BUTTON3         = 0004h;
      JOY_BUTTON4         = 0008h;
      JOY_BUTTON1CHG      = 0100h;
      JOY_BUTTON2CHG      = 0200h;
      JOY_BUTTON3CHG      = 0400h;
      JOY_BUTTON4CHG      = 0800h;

(* constants used with JOYINFOEX *)

CONST JOY_BUTTON5         = 00000010h;
      JOY_BUTTON6         = 00000020h;
      JOY_BUTTON7         = 00000040h;
      JOY_BUTTON8         = 00000080h;
      JOY_BUTTON9         = 00000100h;
      JOY_BUTTON10        = 00000200h;
      JOY_BUTTON11        = 00000400h;
      JOY_BUTTON12        = 00000800h;
      JOY_BUTTON13        = 00001000h;
      JOY_BUTTON14        = 00002000h;
      JOY_BUTTON15        = 00004000h;
      JOY_BUTTON16        = 00008000h;
      JOY_BUTTON17        = 00010000h;
      JOY_BUTTON18        = 00020000h;
      JOY_BUTTON19        = 00040000h;
      JOY_BUTTON20        = 00080000h;
      JOY_BUTTON21        = 00100000h;
      JOY_BUTTON22        = 00200000h;
      JOY_BUTTON23        = 00400000h;
      JOY_BUTTON24        = 00800000h;
      JOY_BUTTON25        = 01000000h;
      JOY_BUTTON26        = 02000000h;
      JOY_BUTTON27        = 04000000h;
      JOY_BUTTON28        = 08000000h;
      JOY_BUTTON29        = 10000000h;
      JOY_BUTTON30        = 20000000h;
      JOY_BUTTON31        = 40000000h;
      JOY_BUTTON32        = 80000000h;

(* constants used with JOYINFOEX structure *)

CONST JOY_POVCENTERED        = MAX (WORD);
      JOY_POVFORWARD         = 0;
      JOY_POVRIGHT           = 9000;
      JOY_POVBACKWARD        = 18000;
      JOY_POVLEFT            = 27000;

      JOY_RETURNX            = 00000001h;
      JOY_RETURNY            = 00000002h;
      JOY_RETURNZ            = 00000004h;
      JOY_RETURNR            = 00000008h;
      JOY_RETURNU            = 00000010h;     (* axis 5 *)
      JOY_RETURNV            = 00000020h;     (* axis 6 *)
      JOY_RETURNPOV          = 00000040h;
      JOY_RETURNBUTTONS      = 00000080h;
      JOY_RETURNRAWDATA      = 00000100h;
      JOY_RETURNPOVCTS       = 00000200h;
      JOY_RETURNCENTERED     = 00000400h;
      JOY_USEDEADZONE        = 00000800h;
      JOY_RETURNALL          = JOY_RETURNX + JOY_RETURNY + JOY_RETURNZ +
                               JOY_RETURNR + JOY_RETURNU + JOY_RETURNV +
                               JOY_RETURNPOV + JOY_RETURNBUTTONS;
      JOY_CAL_READALWAYS     = 00010000h;
      JOY_CAL_READXYONLY     = 00020000h;
      JOY_CAL_READ3          = 00040000h;
      JOY_CAL_READ4          = 00080000h;
      JOY_CAL_READXONLY      = 00100000h;
      JOY_CAL_READYONLY      = 00200000h;
      JOY_CAL_READ5          = 00400000h;
      JOY_CAL_READ6          = 00800000h;
      JOY_CAL_READZONLY      = 01000000h;
      JOY_CAL_READRONLY      = 02000000h;
      JOY_CAL_READUONLY      = 04000000h;
      JOY_CAL_READVONLY      = 08000000h;

(* joystick ID constants *)

CONST JOYSTICKID1            = 0;
      JOYSTICKID2            = 1;

(* joystick driver capabilites *)

CONST JOYCAPS_HASZ           = 0001h;
      JOYCAPS_HASR           = 0002h;
      JOYCAPS_HASU           = 0004h;
      JOYCAPS_HASV           = 0008h;
      JOYCAPS_HASPOV         = 0010h;
      JOYCAPS_POV4DIR        = 0020h;
      JOYCAPS_POVCTS         = 0040h;

(* joystick device capabilities data structure *)

TYPE JOYCAPSA =
     RECORD
       wMid        : WORD;      (* manufacturer ID *)
       wPid        : WORD;      (* product ID *)
       szPname     : PNAMESTR;  (* product name (NULL terminated string) *)
       wXmin       : UINT;      (* minimum x position value *)
       wXmax       : UINT;      (* maximum x position value *)
       wYmin       : UINT;      (* minimum y position value *)
       wYmax       : UINT;      (* maximum y position value *)
       wZmin       : UINT;      (* minimum z position value *)
       wZmax       : UINT;      (* maximum z position value *)
       wNumButtons : UINT;      (* number of buttons *)
       wPeriodMin  : UINT;      (* minimum message period when captured *)
       wPeriodMax  : UINT;      (* maximum message period when captured *)
       wRmin       : UINT;      (* minimum r position value *)
       wRmax       : UINT;      (* maximum r position value *)
       wUmin       : UINT;      (* minimum u (5th axis) position value *)
       wUmax       : UINT;      (* maximum u (5th axis) position value *)
       wVmin       : UINT;      (* minimum v (6th axis) position value *)
       wVmax       : UINT;      (* maximum v (6th axis) position value *)
       wCaps       : UINT;      (* joystick capabilites *)
       wMaxAxes    : UINT;      (* maximum number of axes supported *)
       wNumAxes    : UINT;      (* number of axes in use *)
       wMaxButtons : UINT;      (* maximum number of buttons supported *)
       szRegKey    : PNAMESTR;  (* registry key *)
       szOEMVxD    : ARRAY [0..MAX_JOYSTICKOEMVXDNAME-1] OF CHAR; (* OEM VxD in use *)
     END;
     PJOYCAPSA = POINTER TO JOYCAPSA;

TYPE JOYCAPSW =
     RECORD
       wMid        : WORD;      (* manufacturer ID *)
       wPid        : WORD;      (* product ID *)
       szPname     : PNAMESTRW; (* product name (NULL terminated string) *)
       wXmin       : UINT;      (* minimum x position value *)
       wXmax       : UINT;      (* maximum x position value *)
       wYmin       : UINT;      (* minimum y position value *)
       wYmax       : UINT;      (* maximum y position value *)
       wZmin       : UINT;      (* minimum z position value *)
       wZmax       : UINT;      (* maximum z position value *)
       wNumButtons : UINT;      (* number of buttons *)
       wPeriodMin  : UINT;      (* minimum message period when captured *)
       wPeriodMax  : UINT;      (* maximum message period when captured *)
       wRmin       : UINT;      (* minimum r position value *)
       wRmax       : UINT;      (* maximum r position value *)
       wUmin       : UINT;      (* minimum u (5th axis) position value *)
       wUmax       : UINT;      (* maximum u (5th axis) position value *)
       wVmin       : UINT;      (* minimum v (6th axis) position value *)
       wVmax       : UINT;      (* maximum v (6th axis) position value *)
       wCaps       : UINT;      (* joystick capabilites *)
       wMaxAxes    : UINT;      (* maximum number of axes supported *)
       wNumAxes    : UINT;      (* number of axes in use *)
       wMaxButtons : UINT;      (* maximum number of buttons supported *)
       szRegKey    : PNAMESTRW; (* registry key *)
       szOEMVxD    : ARRAY [0..MAX_JOYSTICKOEMVXDNAME-1] OF WCHAR; (* OEM VxD in use *)
     END;
     PJOYCAPSW = POINTER TO JOYCAPSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  JOYCAPS =  JOYCAPSW;
           PJOYCAPS = PJOYCAPSW;
<* ELSE *>
      TYPE  JOYCAPS =  JOYCAPSA;
           PJOYCAPS = PJOYCAPSA;
<* END *>

(* joystick information data structure *)

TYPE JOYINFO = RECORD
                      wXpos    : UINT;  (* x position *)
                      wYpos    : UINT;  (* y position *)
                      wZpos    : UINT;  (* z position *)
                      wButtons : UINT;  (* button states *)
               END;
    PJOYINFO = POINTER TO JOYINFO;

TYPE JOYINFOEX =
     RECORD
            dwSize         : DWORD;  (* size of structure *)
            dwFlags        : DWORD;  (* flags to indicate what to return *)
            dwXpos         : DWORD;  (* x position *)
            dwYpos         : DWORD;  (* y position *)
            dwZpos         : DWORD;  (* z position *)
            dwRpos         : DWORD;  (* rudder/4th axis position *)
            dwUpos         : DWORD;  (* 5th axis position *)
            dwVpos         : DWORD;  (* 6th axis position *)
            dwButtons      : DWORD;  (* button states *)
            dwButtonNumber : DWORD;  (* current button number pressed *)
            dwPOV          : DWORD;  (* point of view state *)
            dwReserved1    : DWORD;  (* reserved for communication between winmm & driver *)
            dwReserved2    : DWORD;  (* reserved for future expansion *)
     END;
     PJOYINFOEX = POINTER TO JOYINFOEX;

<* IF NOT DEFINED (_WIN32_VXD) THEN *>

(* joystick function prototypes *)

PROCEDURE joyGetNumDevs () : UINT;

PROCEDURE joyGetDevCapsA (uJoyID : UINT; VAR jc : JOYCAPSA; cbjc : UINT) : MMRESULT;
PROCEDURE joyGetDevCapsW (uJoyID : UINT; VAR jc : JOYCAPSW; cbjc : UINT) : MMRESULT;

<* IF DEFINED (UNICODE) THEN *>
      CONST joyGetDevCaps = joyGetDevCapsW;
<* ELSE *>
      CONST joyGetDevCaps = joyGetDevCapsA;
<* END *>

PROCEDURE joyGetPos         (uJoyID : UINT; VAR ji : JOYINFO)   : MMRESULT;
PROCEDURE joyGetPosEx       (uJoyID : UINT; VAR ji : JOYINFOEX) : MMRESULT;
PROCEDURE joyGetThreshold   (uJoyID : UINT; VAR puThreshold : UINT) : MMRESULT;
PROCEDURE joyReleaseCapture (uJoyID : UINT) : MMRESULT;
PROCEDURE joySetCapture     (hwnd : HWND; uJoyID : UINT; uPeriod : UINT;
                             fChanged : BOOL) : MMRESULT;
PROCEDURE joySetThreshold   (uJoyID : UINT; uThreshold : UINT) : MMRESULT;

<* END *>  (* IF NOT DEFINED (_WIN32_VXD) *)

<* END *>  (* IF NOT DEFINED (MMNOJOY) *)


<* IF NOT DEFINED (MMNOMMIO) THEN *>
<* IF NOT DEFINED (_WIN32_VXD) THEN *>
(****************************************************************************

                        Multimedia File I/O support

****************************************************************************)

(* MMIO error return values *)

CONST MMIOERR_BASE                = 256;
      MMIOERR_FILENOTFOUND        = MMIOERR_BASE + 1;  (* file not found *)
      MMIOERR_OUTOFMEMORY         = MMIOERR_BASE + 2;  (* out of memory *)
      MMIOERR_CANNOTOPEN          = MMIOERR_BASE + 3;  (* cannot open *)
      MMIOERR_CANNOTCLOSE         = MMIOERR_BASE + 4;  (* cannot close *)
      MMIOERR_CANNOTREAD          = MMIOERR_BASE + 5;  (* cannot read *)
      MMIOERR_CANNOTWRITE         = MMIOERR_BASE + 6;  (* cannot write *)
      MMIOERR_CANNOTSEEK          = MMIOERR_BASE + 7;  (* cannot seek *)
      MMIOERR_CANNOTEXPAND        = MMIOERR_BASE + 8;  (* cannot expand file *)
      MMIOERR_CHUNKNOTFOUND       = MMIOERR_BASE + 9;  (* chunk not found *)
      MMIOERR_UNBUFFERED          = MMIOERR_BASE + 10; (*  *)
      MMIOERR_PATHNOTFOUND        = MMIOERR_BASE + 11; (* path incorrect *)
      MMIOERR_ACCESSDENIED        = MMIOERR_BASE + 12; (* file was protected *)
      MMIOERR_SHARINGVIOLATION    = MMIOERR_BASE + 13; (* file in use *)
      MMIOERR_NETWORKERROR        = MMIOERR_BASE + 14; (* network not responding *)
      MMIOERR_TOOMANYOPENFILES    = MMIOERR_BASE + 15; (* no more file handles  *)
      MMIOERR_INVALIDFILE         = MMIOERR_BASE + 16; (* default error file error *)

(* MMIO constants *)

CONST CFSEPCHAR = '+';             (* compound file name separator char. *)

(* MMIO data types *)
TYPE FOURCC = DWORD;         (* a four character code *)

TYPE HMMIO = POINTER TO RECORD END;        (* a handle to an open file *)

TYPE MMIOPROC = PROCEDURE ((* lpmmioinfo : *) PSTR,
                           (* uMsg       : *) UINT,
                           (* lParam1    : *) LPARAM,
                           (* lParam2    : *) LPARAM) : LRESULT;

(* general MMIO information data structure *)

TYPE MMIOINFO =
     RECORD

        (* general fields *)

        dwFlags     : DWORD;        (* general status flags *)
        fccIOProc   : FOURCC;       (* pointer to I/O procedure *)
        pIOProc     : MMIOPROC;     (* pointer to I/O procedure *)
        wErrorRet   : UINT;         (* place for error to be returned *)
        htask       : HTASK;        (* alternate local task *)

        (* fields maintained by MMIO functions during buffered I/O *)

        cchBuffer   : LONG;         (* size of I/O buffer (or 0L) *)
        pchBuffer   : PSTR;         (* start of I/O buffer (or NULL) *)
        pchNext     : PSTR;         (* pointer to next byte to read/write *)
        pchEndRead  : PSTR;         (* pointer to last valid byte to read *)
        pchEndWrite : PSTR;         (* pointer to last byte to write *)
        lBufOffset  : LONG;         (* disk offset of start of buffer *)

        (* fields maintained by I/O procedure *)

        lDiskOffset : LONG;                   (* disk offset of next read or write *)
        adwInfo     : ARRAY [0..2] OF DWORD;  (* data specific to type of MMIOPROC *)

        (* other fields maintained by MMIO *)

        dwReserved1 : DWORD;        (* reserved for MMIO use *)
        dwReserved2 : DWORD;        (* reserved for MMIO use *)
        hmmio       : HMMIO;        (* handle to open file *)
     END;
     PMMIOINFO = POINTER TO MMIOINFO;

(* RIFF chunk information data structure *)

TYPE MMCKINFO =
     RECORD
        ckid         : FOURCC;  (* chunk ID *)
        cksize       : DWORD;   (* chunk size *)
        fccType      : FOURCC;  (* form type or list type *)
        dwDataOffset : DWORD;   (* offset of data portion of chunk *)
        dwFlags      : DWORD;   (* flags used by MMIO functions *)
     END;
     PMMCKINFO = POINTER TO MMCKINFO;

(* bit field masks *)

CONST MMIO_RWMODE     = 00000003h;      (* open file for reading/writing/both *)
      MMIO_SHAREMODE  = 00000070h;      (* file sharing mode number *)

(* constants for dwFlags field of MMIOINFO *)

CONST MMIO_CREATE     = 00001000h;      (* create new file (or truncate file) *)
      MMIO_PARSE      = 00000100h;      (* parse new file returning path *)
      MMIO_DELETE     = 00000200h;      (* create new file (or truncate file) *)
      MMIO_EXIST      = 00004000h;      (* checks for existence of file *)
      MMIO_ALLOCBUF   = 00010000h;      (* mmioOpen() should allocate a buffer *)
      MMIO_GETTEMP    = 00020000h;      (* mmioOpen() should retrieve temp name *)

      MMIO_DIRTY      = 10000000h;      (* I/O buffer is dirty *)

(* read/write mode numbers (bit field MMIO_RWMODE) *)

CONST MMIO_READ       = 00000000h;      (* open file for reading only *)
      MMIO_WRITE      = 00000001h;      (* open file for writing only *)
      MMIO_READWRITE  = 00000002h;      (* open file for reading and writing *)

(* share mode numbers (bit field MMIO_SHAREMODE) *)

CONST MMIO_COMPAT     = 00000000h;      (* compatibility mode *)
      MMIO_EXCLUSIVE  = 00000010h;      (* exclusive-access mode *)
      MMIO_DENYWRITE  = 00000020h;      (* deny writing to other processes *)
      MMIO_DENYREAD   = 00000030h;      (* deny reading to other processes *)
      MMIO_DENYNONE   = 00000040h;      (* deny nothing to other processes *)

(* various MMIO flags *)

CONST MMIO_FHOPEN             = 0010h;  (* mmioClose: keep file handle open *)
      MMIO_EMPTYBUF           = 0010h;  (* mmioFlush: empty the I/O buffer *)
      MMIO_TOUPPER            = 0010h;  (* mmioStringToFOURCC: to u-case *)
      MMIO_INSTALLPROC    = 00010000h;  (* mmioInstallIOProc: install MMIOProc *)
      MMIO_GLOBALPROC     = 10000000h;  (* mmioInstallIOProc: install globally *)
      MMIO_REMOVEPROC     = 00020000h;  (* mmioInstallIOProc: remove MMIOProc *)
      MMIO_UNICODEPROC    = 01000000h;  (* mmioInstallIOProc: Unicode MMIOProc *)
      MMIO_FINDPROC       = 00040000h;  (* mmioInstallIOProc: find an MMIOProc *)
      MMIO_FINDCHUNK          = 0010h;  (* mmioDescend: find a chunk by ID *)
      MMIO_FINDRIFF           = 0020h;  (* mmioDescend: find a LIST chunk *)
      MMIO_FINDLIST           = 0040h;  (* mmioDescend: find a RIFF chunk *)
      MMIO_CREATERIFF         = 0020h;  (* mmioCreateChunk: make a LIST chunk *)
      MMIO_CREATELIST         = 0040h;  (* mmioCreateChunk: make a RIFF chunk *)

(* message numbers for MMIOPROC I/O procedure functions *)

CONST MMIOM_READ   =  MMIO_READ;        (* read *)
      MMIOM_WRITE  = MMIO_WRITE;        (* write *)
      MMIOM_SEEK            = 2;        (* seek to a new position in file *)
      MMIOM_OPEN            = 3;        (* open file *)
      MMIOM_CLOSE           = 4;        (* close file *)
      MMIOM_WRITEFLUSH      = 5;        (* write and flush *)
      MMIOM_RENAME          = 6;        (* rename specified file *)
      MMIOM_USER            = 8000h;    (* beginning of user-defined messages *)

(* standard four character codes *)

CONST FOURCC_RIFF     = VAL (DWORD, 'R') +
                        VAL (DWORD, 'I') * 100H +
                        VAL (DWORD, 'F') * 10000H +
                        VAL (DWORD, 'F') * 1000000H;

      FOURCC_LIST     = VAL (DWORD, 'L') +
                        VAL (DWORD, 'I') * 100H +
                        VAL (DWORD, 'S') * 10000H +
                        VAL (DWORD, 'T') * 1000000H;

(* four character codes used to identify standard built-in I/O procedures *)

CONST FOURCC_DOS      = VAL (DWORD, 'D') +
                        VAL (DWORD, 'O') * 100H +
                        VAL (DWORD, 'S') * 10000H +
                        VAL (DWORD, ' ') * 1000000H;

      FOURCC_MEM      = VAL (DWORD, 'M') +
                        VAL (DWORD, 'E') * 100H +
                        VAL (DWORD, 'M') * 10000H +
                        VAL (DWORD, ' ') * 1000000H;

(* flags for mmioSeek() *)

CONST SEEK_SET = 0;               (* seek to an absolute position *)
      SEEK_CUR = 1;               (* seek relative to current position *)
      SEEK_END = 2;               (* seek relative to end of file *)

(* other constants *)

CONST MMIO_DEFAULTBUFFER = 8192;      (* default buffer size *)

CONST mmioFOURCC = MAKEFOURCC;


(* MMIO function prototypes *)

PROCEDURE mmioStringToFOURCCA (sz : PCSTR;  uFlags : UINT) : FOURCC;
PROCEDURE mmioStringToFOURCCW (sz : PCWSTR; uFlags : UINT) : FOURCC;

<* IF DEFINED (UNICODE) THEN *>
      CONST mmioStringToFOURCC = mmioStringToFOURCCW;
<* ELSE *>
      CONST mmioStringToFOURCC = mmioStringToFOURCCA;
<* END *>

PROCEDURE mmioInstallIOProcA (fccIOProc : FOURCC; pIOProc : MMIOPROC; dwFlags : DWORD) : MMIOPROC;
PROCEDURE mmioInstallIOProcW (fccIOProc : FOURCC; pIOProc : MMIOPROC; dwFlags : DWORD) : MMIOPROC;

<* IF DEFINED (UNICODE) THEN *>
      CONST mmioInstallIOProc = mmioInstallIOProcW;
<* ELSE *>
      CONST mmioInstallIOProc = mmioInstallIOProcA;
<* END *>

PROCEDURE mmioOpenA (pszFileName : PSTR;  VAR mmioinfo : MMIOINFO; fdwOpen : DWORD) : HMMIO;
PROCEDURE mmioOpenW (pszFileName : PWSTR; VAR mmioinfo : MMIOINFO; fdwOpen : DWORD) : HMMIO;

<* IF DEFINED (UNICODE) THEN *>
      CONST mmioOpen = mmioOpenW;
<* ELSE *>
      CONST mmioOpen = mmioOpenA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE mmioRenameA (pszFileName : PCSTR;  pszNewFileName : PCSTR;  mmioinfo : MMIOINFO; fdwRename : DWORD) : MMRESULT;
<* ELSE *>
PROCEDURE mmioRenameA (pszFileName : PCSTR;  pszNewFileName : PCSTR;  mmioinfo : PMMIOINFO; fdwRename : DWORD) : MMRESULT;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE mmioRenameW (pszFileName : PCWSTR; pszNewFileName : PCWSTR; mmioinfo : MMIOINFO; fdwRename : DWORD) : MMRESULT;
<* ELSE *>
PROCEDURE mmioRenameW (pszFileName : PCWSTR; pszNewFileName : PCWSTR; mmioinfo : PMMIOINFO; fdwRename : DWORD) : MMRESULT;
<* END *>

<* IF DEFINED (UNICODE) THEN *>
      CONST mmioRename = mmioRenameW;
<* ELSE *>
      CONST mmioRename = mmioRenameA;
<* END *>

PROCEDURE mmioClose       (hmmio : HMMIO; fuClose : UINT) : MMRESULT;
PROCEDURE mmioRead        (hmmio : HMMIO; pch : PBYTE;  cch : LONG) : LONG;
PROCEDURE mmioWrite       (hmmio : HMMIO; pch : PCBYTE; cch : LONG) : LONG;
PROCEDURE mmioSeek        (hmmio : HMMIO; lOffset : LONG; iOrigin : INTEGER) : LONG;
PROCEDURE mmioGetInfo     (hmmio : HMMIO; VAR mmioinfo  : MMIOINFO; fuInfo : UINT) : MMRESULT;
<* IF BACKEND # "C" THEN *>
PROCEDURE mmioSetInfo     (hmmio : HMMIO;     pmmioinfo : MMIOINFO; fuInfo : UINT) : MMRESULT;
<* ELSE *>
PROCEDURE mmioSetInfo     (hmmio : HMMIO;     pmmioinfo : PMMIOINFO; fuInfo : UINT) : MMRESULT;
<* END *>
PROCEDURE mmioSetBuffer   (hmmio : HMMIO; pchBuffer : PBYTE; cchBuffer : LONG;
                           fuBuffer : UINT) : MMRESULT;
PROCEDURE mmioFlush       (hmmio : HMMIO; fuFlush : UINT) : MMRESULT;
PROCEDURE mmioAdvance     (hmmio : HMMIO; VAR mmioinfo : MMIOINFO; fuAdvance : UINT) : MMRESULT;
PROCEDURE mmioSendMessage (hmmio : HMMIO;  uMsg : UINT;
                           lParam1, lParam2 : LPARAM) : LRESULT;
<* IF BACKEND # "C" THEN *>
PROCEDURE mmioDescend     (hmmio : HMMIO; VAR mmcki : MMCKINFO;
                           mmckiParent : MMCKINFO; fuDescend : UINT) : MMRESULT;
<* ELSE *>
PROCEDURE mmioDescend     (hmmio : HMMIO; VAR mmcki : MMCKINFO;
                           mmckiParent : PMMCKINFO; fuDescend : UINT) : MMRESULT;
<* END *>
PROCEDURE mmioAscend      (hmmio : HMMIO; VAR mmcki : MMCKINFO; fuAscend : UINT) : MMRESULT;
PROCEDURE mmioCreateChunk (hmmio : HMMIO; VAR mmcki : MMCKINFO; fuCreate : UINT) : MMRESULT;

<* END *>  (* NOT DEFINED (_WIN32_VXD) *)
<* END *>  (* NOT DEFINED (MMNOMMIO) *)

<* IF NOT DEFINED (MMNOMCI) THEN *>
<* IF NOT DEFINED (_WIN32_VXD) THEN *>
(****************************************************************************

                            MCI support

****************************************************************************)

TYPE MCIERROR    = DWORD;   (* error return code, 0 means no error *)
TYPE MCIDEVICEID = UINT;    (* MCI device ID type *)

TYPE YIELDPROC = PROCEDURE ((* mciId       : *) MCIDEVICEID,
                            (* dwYieldData : *) DWORD) : UINT;

(* MCI function prototypes *)

PROCEDURE mciSendCommandA (mciId : MCIDEVICEID; uMsg : UINT; dwParam1, dwParam2 : DWORD) : MCIERROR;
PROCEDURE mciSendCommandW (mciId : MCIDEVICEID; uMsg : UINT; dwParam1, dwParam2 : DWORD) : MCIERROR;

<* IF DEFINED (UNICODE) THEN *>
      CONST mciSendCommand = mciSendCommandW;
<* ELSE *>
      CONST mciSendCommand = mciSendCommandA;
<* END *>

PROCEDURE mciSendStringA (lpstrCommand : PCSTR; lpstrReturnString : PSTR;
                          uReturnLength : UINT; hwndCallback : HWND) : MCIERROR;
PROCEDURE mciSendStringW (lpstrCommand : PCWSTR; lpstrReturnString : PWSTR;
                          uReturnLength : UINT; hwndCallback : HWND) : MCIERROR;

<* IF DEFINED (UNICODE) THEN *>
      CONST mciSendString = mciSendStringW;
<* ELSE *>
      CONST mciSendString = mciSendStringA;
<* END *>

PROCEDURE mciGetDeviceIDA (pszDevice : PCSTR)  : MCIDEVICEID;
PROCEDURE mciGetDeviceIDW (pszDevice : PCWSTR) : MCIDEVICEID;

<* IF DEFINED (UNICODE) THEN *>
      CONST mciGetDeviceID = mciGetDeviceIDW;
<* ELSE *>
      CONST mciGetDeviceID = mciGetDeviceIDA;
<* END *>

PROCEDURE mciGetDeviceIDFromElementIDA (dwElementID : DWORD; lpstrType : PCSTR) : MCIDEVICEID;
PROCEDURE mciGetDeviceIDFromElementIDW (dwElementID : DWORD; lpstrType : PCWSTR) : MCIDEVICEID;

<* IF DEFINED (UNICODE) THEN *>
      CONST mciGetDeviceIDFromElementID = mciGetDeviceIDFromElementIDW;
<* ELSE *>
      CONST mciGetDeviceIDFromElementID = mciGetDeviceIDFromElementIDA;
<* END *>

PROCEDURE mciGetErrorStringA (mcierr : MCIERROR; pszText : PSTR;  cchText : UINT) : BOOL;
PROCEDURE mciGetErrorStringW (mcierr : MCIERROR; pszText : PWSTR; cchText : UINT) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST mciGetErrorString = mciGetErrorStringW;
<* ELSE *>
      CONST mciGetErrorString = mciGetErrorStringA;
<* END *>

PROCEDURE mciSetYieldProc (mciId : MCIDEVICEID; fpYieldProc : YIELDPROC;
                           dwYieldData : DWORD) : BOOL;

PROCEDURE mciGetCreatorTask (mciId : MCIDEVICEID) : HTASK;
PROCEDURE mciGetYieldProc   (mciId : MCIDEVICEID; VAR dwYieldData : DWORD) : YIELDPROC;


(* MCI error return values *)

CONST MCIERR_INVALID_DEVICE_ID        = MCIERR_BASE + 1;
      MCIERR_UNRECOGNIZED_KEYWORD     = MCIERR_BASE + 3;
      MCIERR_UNRECOGNIZED_COMMAND     = MCIERR_BASE + 5;
      MCIERR_HARDWARE                 = MCIERR_BASE + 6;
      MCIERR_INVALID_DEVICE_NAME      = MCIERR_BASE + 7;
      MCIERR_OUT_OF_MEMORY            = MCIERR_BASE + 8;
      MCIERR_DEVICE_OPEN              = MCIERR_BASE + 9;
      MCIERR_CANNOT_LOAD_DRIVER       = MCIERR_BASE + 10;
      MCIERR_MISSING_COMMAND_STRING   = MCIERR_BASE + 11;
      MCIERR_PARAM_OVERFLOW           = MCIERR_BASE + 12;
      MCIERR_MISSING_STRING_ARGUMENT  = MCIERR_BASE + 13;
      MCIERR_BAD_INTEGER              = MCIERR_BASE + 14;
      MCIERR_PARSER_INTERNAL          = MCIERR_BASE + 15;
      MCIERR_DRIVER_INTERNAL          = MCIERR_BASE + 16;
      MCIERR_MISSING_PARAMETER        = MCIERR_BASE + 17;
      MCIERR_UNSUPPORTED_FUNCTION     = MCIERR_BASE + 18;
      MCIERR_FILE_NOT_FOUND           = MCIERR_BASE + 19;
      MCIERR_DEVICE_NOT_READY         = MCIERR_BASE + 20;
      MCIERR_INTERNAL                 = MCIERR_BASE + 21;
      MCIERR_DRIVER                   = MCIERR_BASE + 22;
      MCIERR_CANNOT_USE_ALL           = MCIERR_BASE + 23;
      MCIERR_MULTIPLE                 = MCIERR_BASE + 24;
      MCIERR_EXTENSION_NOT_FOUND      = MCIERR_BASE + 25;
      MCIERR_OUTOFRANGE               = MCIERR_BASE + 26;
      MCIERR_FLAGS_NOT_COMPATIBLE     = MCIERR_BASE + 28;
      MCIERR_FILE_NOT_SAVED           = MCIERR_BASE + 30;
      MCIERR_DEVICE_TYPE_REQUIRED     = MCIERR_BASE + 31;
      MCIERR_DEVICE_LOCKED            = MCIERR_BASE + 32;
      MCIERR_DUPLICATE_ALIAS          = MCIERR_BASE + 33;
      MCIERR_BAD_CONSTANT             = MCIERR_BASE + 34;
      MCIERR_MUST_USE_SHAREABLE       = MCIERR_BASE + 35;
      MCIERR_MISSING_DEVICE_NAME      = MCIERR_BASE + 36;
      MCIERR_BAD_TIME_FORMAT          = MCIERR_BASE + 37;
      MCIERR_NO_CLOSING_QUOTE         = MCIERR_BASE + 38;
      MCIERR_DUPLICATE_FLAGS          = MCIERR_BASE + 39;
      MCIERR_INVALID_FILE             = MCIERR_BASE + 40;
      MCIERR_NULL_PARAMETER_BLOCK     = MCIERR_BASE + 41;
      MCIERR_UNNAMED_RESOURCE         = MCIERR_BASE + 42;
      MCIERR_NEW_REQUIRES_ALIAS       = MCIERR_BASE + 43;
      MCIERR_NOTIFY_ON_AUTO_OPEN      = MCIERR_BASE + 44;
      MCIERR_NO_ELEMENT_ALLOWED       = MCIERR_BASE + 45;
      MCIERR_NONAPPLICABLE_FUNCTION   = MCIERR_BASE + 46;
      MCIERR_ILLEGAL_FOR_AUTO_OPEN    = MCIERR_BASE + 47;
      MCIERR_FILENAME_REQUIRED        = MCIERR_BASE + 48;
      MCIERR_EXTRA_CHARACTERS         = MCIERR_BASE + 49;
      MCIERR_DEVICE_NOT_INSTALLED     = MCIERR_BASE + 50;
      MCIERR_GET_CD                   = MCIERR_BASE + 51;
      MCIERR_SET_CD                   = MCIERR_BASE + 52;
      MCIERR_SET_DRIVE                = MCIERR_BASE + 53;
      MCIERR_DEVICE_LENGTH            = MCIERR_BASE + 54;
      MCIERR_DEVICE_ORD_LENGTH        = MCIERR_BASE + 55;
      MCIERR_NO_INTEGER               = MCIERR_BASE + 56;

      MCIERR_WAVE_OUTPUTSINUSE        = MCIERR_BASE + 64;
      MCIERR_WAVE_SETOUTPUTINUSE      = MCIERR_BASE + 65;
      MCIERR_WAVE_INPUTSINUSE         = MCIERR_BASE + 66;
      MCIERR_WAVE_SETINPUTINUSE       = MCIERR_BASE + 67;
      MCIERR_WAVE_OUTPUTUNSPECIFIED   = MCIERR_BASE + 68;
      MCIERR_WAVE_INPUTUNSPECIFIED    = MCIERR_BASE + 69;
      MCIERR_WAVE_OUTPUTSUNSUITABLE   = MCIERR_BASE + 70;
      MCIERR_WAVE_SETOUTPUTUNSUITABLE = MCIERR_BASE + 71;
      MCIERR_WAVE_INPUTSUNSUITABLE    = MCIERR_BASE + 72;
      MCIERR_WAVE_SETINPUTUNSUITABLE  = MCIERR_BASE + 73;

      MCIERR_SEQ_DIV_INCOMPATIBLE     = MCIERR_BASE + 80;
      MCIERR_SEQ_PORT_INUSE           = MCIERR_BASE + 81;
      MCIERR_SEQ_PORT_NONEXISTENT     = MCIERR_BASE + 82;
      MCIERR_SEQ_PORT_MAPNODEVICE     = MCIERR_BASE + 83;
      MCIERR_SEQ_PORT_MISCERROR       = MCIERR_BASE + 84;
      MCIERR_SEQ_TIMER                = MCIERR_BASE + 85;
      MCIERR_SEQ_PORTUNSPECIFIED      = MCIERR_BASE + 86;
      MCIERR_SEQ_NOMIDIPRESENT        = MCIERR_BASE + 87;

      MCIERR_NO_WINDOW                = MCIERR_BASE + 90;
      MCIERR_CREATEWINDOW             = MCIERR_BASE + 91;
      MCIERR_FILE_READ                = MCIERR_BASE + 92;
      MCIERR_FILE_WRITE               = MCIERR_BASE + 93;

      MCIERR_NO_IDENTITY              = MCIERR_BASE + 94;

(* all custom device driver errors must be >= than this value *)

CONST MCIERR_CUSTOM_DRIVER_BASE       = MCIERR_BASE + 256;

CONST MCI_FIRST                       = DRV_MCI_FIRST;   (* 0x0800 *)

(* MCI command message identifiers *)

CONST MCI_OPEN                        = 0803h;
      MCI_CLOSE                       = 0804h;
      MCI_ESCAPE                      = 0805h;
      MCI_PLAY                        = 0806h;
      MCI_SEEK                        = 0807h;
      MCI_STOP                        = 0808h;
      MCI_PAUSE                       = 0809h;
      MCI_INFO                        = 080Ah;
      MCI_GETDEVCAPS                  = 080Bh;
      MCI_SPIN                        = 080Ch;
      MCI_SET                         = 080Dh;
      MCI_STEP                        = 080Eh;
      MCI_RECORD                      = 080Fh;
      MCI_SYSINFO                     = 0810h;
      MCI_BREAK                       = 0811h;
      MCI_SAVE                        = 0813h;
      MCI_STATUS                      = 0814h;
      MCI_CUE                         = 0830h;
      MCI_REALIZE                     = 0840h;
      MCI_WINDOW                      = 0841h;
      MCI_PUT                         = 0842h;
      MCI_WHERE                       = 0843h;
      MCI_FREEZE                      = 0844h;
      MCI_UNFREEZE                    = 0845h;
      MCI_LOAD                        = 0850h;
      MCI_CUT                         = 0851h;
      MCI_COPY                        = 0852h;
      MCI_PASTE                       = 0853h;
      MCI_UPDATE                      = 0854h;
      MCI_RESUME                      = 0855h;
      MCI_DELETE                      = 0856h;

(* all custom MCI command messages must be >= than this value *)

CONST MCI_USER_MESSAGES               = DRV_MCI_FIRST + 0400h;
      MCI_LAST                        = 0FFFh;

(* device ID for "all devices" *)

CONST MCI_ALL_DEVICE_ID               = MAX (MCIDEVICEID);

(* constants for predefined MCI device types *)

CONST MCI_DEVTYPE_VCR                 = 513; (* MCI_STRING_OFFSET + 1  *)
      MCI_DEVTYPE_VIDEODISC           = 514; (* MCI_STRING_OFFSET + 2  *)
      MCI_DEVTYPE_OVERLAY             = 515; (* MCI_STRING_OFFSET + 3  *)
      MCI_DEVTYPE_CD_AUDIO            = 516; (* MCI_STRING_OFFSET + 4  *)
      MCI_DEVTYPE_DAT                 = 517; (* MCI_STRING_OFFSET + 5  *)
      MCI_DEVTYPE_SCANNER             = 518; (* MCI_STRING_OFFSET + 6  *)
      MCI_DEVTYPE_ANIMATION           = 519; (* MCI_STRING_OFFSET + 7  *)
      MCI_DEVTYPE_DIGITAL_VIDEO       = 520; (* MCI_STRING_OFFSET + 8  *)
      MCI_DEVTYPE_OTHER               = 521; (* MCI_STRING_OFFSET + 9  *)
      MCI_DEVTYPE_WAVEFORM_AUDIO      = 522; (* MCI_STRING_OFFSET + 10 *)
      MCI_DEVTYPE_SEQUENCER           = 523; (* MCI_STRING_OFFSET + 11 *)

      MCI_DEVTYPE_FIRST               = MCI_DEVTYPE_VCR;
      MCI_DEVTYPE_LAST                = MCI_DEVTYPE_SEQUENCER;

      MCI_DEVTYPE_FIRST_USER          = 1000h;

(* return values for 'status mode' command *)

CONST MCI_MODE_NOT_READY              = MCI_STRING_OFFSET + 12;
      MCI_MODE_STOP                   = MCI_STRING_OFFSET + 13;
      MCI_MODE_PLAY                   = MCI_STRING_OFFSET + 14;
      MCI_MODE_RECORD                 = MCI_STRING_OFFSET + 15;
      MCI_MODE_SEEK                   = MCI_STRING_OFFSET + 16;
      MCI_MODE_PAUSE                  = MCI_STRING_OFFSET + 17;
      MCI_MODE_OPEN                   = MCI_STRING_OFFSET + 18;

(* constants used in 'set time format' and 'status time format' commands *)

CONST MCI_FORMAT_MILLISECONDS         = 0;
      MCI_FORMAT_HMS                  = 1;
      MCI_FORMAT_MSF                  = 2;
      MCI_FORMAT_FRAMES               = 3;
      MCI_FORMAT_SMPTE_24             = 4;
      MCI_FORMAT_SMPTE_25             = 5;
      MCI_FORMAT_SMPTE_30             = 6;
      MCI_FORMAT_SMPTE_30DROP         = 7;
      MCI_FORMAT_BYTES                = 8;
      MCI_FORMAT_SAMPLES              = 9;
      MCI_FORMAT_TMSF                 = 10;


(* MCI time format conversion procedures.
   All of them were macros in original .H file; implemented in RTL *)

PROCEDURE MCI_MSF_MINUTE  (msf : DWORD) : BYTE;
PROCEDURE MCI_MSF_SECOND  (msf : DWORD) : BYTE;
PROCEDURE MCI_MSF_FRAME   (msf : DWORD) : BYTE;
PROCEDURE MCI_MAKE_MSF    (m, s, f : BYTE) : DWORD;
PROCEDURE MCI_TMSF_TRACK  (tmsf : DWORD) : BYTE;
PROCEDURE MCI_TMSF_MINUTE (tmsf : DWORD) : BYTE;
PROCEDURE MCI_TMSF_SECOND (tmsf : DWORD) : BYTE;
PROCEDURE MCI_TMSF_FRAME  (tmsf : DWORD) : BYTE;
PROCEDURE MCI_MAKE_TMSF   (t, m, s, f : BYTE) : DWORD;
PROCEDURE MCI_HMS_HOUR    (hms : DWORD) : BYTE;
PROCEDURE MCI_HMS_MINUTE  (hms : DWORD) : BYTE;
PROCEDURE MCI_HMS_SECOND  (hms : DWORD) : BYTE;
PROCEDURE MCI_MAKE_HMS    (h, m, s : BYTE) : DWORD;

(* flags for wParam of MM_MCINOTIFY message *)

CONST MCI_NOTIFY_SUCCESSFUL           = 0001h;
      MCI_NOTIFY_SUPERSEDED           = 0002h;
      MCI_NOTIFY_ABORTED              = 0004h;
      MCI_NOTIFY_FAILURE              = 0008h;

(* common flags for dwFlags parameter of MCI command messages *)

CONST MCI_NOTIFY                      = 00000001h;
      MCI_WAIT                        = 00000002h;
      MCI_FROM                        = 00000004h;
      MCI_TO                          = 00000008h;
      MCI_TRACK                       = 00000010h;

(* flags for dwFlags parameter of MCI_OPEN command message *)

CONST MCI_OPEN_SHAREABLE              = 00000100h;
      MCI_OPEN_ELEMENT                = 00000200h;
      MCI_OPEN_ALIAS                  = 00000400h;
      MCI_OPEN_ELEMENT_ID             = 00000800h;
      MCI_OPEN_TYPE_ID                = 00001000h;
      MCI_OPEN_TYPE                   = 00002000h;

(* flags for dwFlags parameter of MCI_SEEK command message *)

CONST MCI_SEEK_TO_START               = 00000100h;
      MCI_SEEK_TO_END                 = 00000200h;

(* flags for dwFlags parameter of MCI_STATUS command message *)

CONST MCI_STATUS_ITEM                 = 00000100h;
      MCI_STATUS_START                = 00000200h;

(* flags for dwItem field of the MCI_STATUS_PARMS parameter block *)

CONST MCI_STATUS_LENGTH               = 00000001h;
      MCI_STATUS_POSITION             = 00000002h;
      MCI_STATUS_NUMBER_OF_TRACKS     = 00000003h;
      MCI_STATUS_MODE                 = 00000004h;
      MCI_STATUS_MEDIA_PRESENT        = 00000005h;
      MCI_STATUS_TIME_FORMAT          = 00000006h;
      MCI_STATUS_READY                = 00000007h;
      MCI_STATUS_CURRENT_TRACK        = 00000008h;

(* flags for dwFlags parameter of MCI_INFO command message *)

CONST MCI_INFO_PRODUCT                = 00000100h;
      MCI_INFO_FILE                   = 00000200h;
      MCI_INFO_MEDIA_UPC              = 00000400h;
      MCI_INFO_MEDIA_IDENTITY         = 00000800h;
      MCI_INFO_NAME                   = 00001000h;
      MCI_INFO_COPYRIGHT              = 00002000h;

(* flags for dwFlags parameter of MCI_GETDEVCAPS command message *)

CONST MCI_GETDEVCAPS_ITEM             = 00000100h;

(* flags for dwItem field of the MCI_GETDEVCAPS_PARMS parameter block *)

CONST MCI_GETDEVCAPS_CAN_RECORD       = 00000001h;
      MCI_GETDEVCAPS_HAS_AUDIO        = 00000002h;
      MCI_GETDEVCAPS_HAS_VIDEO        = 00000003h;
      MCI_GETDEVCAPS_DEVICE_TYPE      = 00000004h;
      MCI_GETDEVCAPS_USES_FILES       = 00000005h;
      MCI_GETDEVCAPS_COMPOUND_DEVICE  = 00000006h;
      MCI_GETDEVCAPS_CAN_EJECT        = 00000007h;
      MCI_GETDEVCAPS_CAN_PLAY         = 00000008h;
      MCI_GETDEVCAPS_CAN_SAVE         = 00000009h;

(* flags for dwFlags parameter of MCI_SYSINFO command message *)

CONST MCI_SYSINFO_QUANTITY            = 00000100h;
      MCI_SYSINFO_OPEN                = 00000200h;
      MCI_SYSINFO_NAME                = 00000400h;
      MCI_SYSINFO_INSTALLNAME         = 00000800h;

(* flags for dwFlags parameter of MCI_SET command message *)

CONST MCI_SET_DOOR_OPEN               = 00000100h;
      MCI_SET_DOOR_CLOSED             = 00000200h;
      MCI_SET_TIME_FORMAT             = 00000400h;
      MCI_SET_AUDIO                   = 00000800h;
      MCI_SET_VIDEO                   = 00001000h;
      MCI_SET_ON                      = 00002000h;
      MCI_SET_OFF                     = 00004000h;

(* flags for dwAudio field of MCI_SET_PARMS or MCI_SEQ_SET_PARMS *)

CONST MCI_SET_AUDIO_ALL               = 00000000h;
      MCI_SET_AUDIO_LEFT              = 00000001h;
      MCI_SET_AUDIO_RIGHT             = 00000002h;

(* flags for dwFlags parameter of MCI_BREAK command message *)

CONST MCI_BREAK_KEY                   = 00000100h;
      MCI_BREAK_HWND                  = 00000200h;
      MCI_BREAK_OFF                   = 00000400h;

(* flags for dwFlags parameter of MCI_RECORD command message *)

CONST MCI_RECORD_INSERT               = 00000100h;
      MCI_RECORD_OVERWRITE            = 00000200h;

(* flags for dwFlags parameter of MCI_SAVE command message *)

CONST MCI_SAVE_FILE                   = 00000100h;

(* flags for dwFlags parameter of MCI_LOAD command message *)

CONST MCI_LOAD_FILE                   = 00000100h;

(* generic parameter block for MCI command messages with no special parameters *)

TYPE MCI_GENERIC_PARMS = RECORD
                                dwCallback : DWORD;
     END;
     PMCI_GENERIC_PARMS = POINTER TO MCI_GENERIC_PARMS;

(* parameter block for MCI_OPEN command message *)

TYPE MCI_OPEN_PARMSA = RECORD
                              dwCallback       : DWORD;
                              wDeviceID        : MCIDEVICEID;
                              lpstrDeviceType  : PCSTR;
                              lpstrElementName : PCSTR;
                              lpstrAlias       : PCSTR;
                       END;
    PMCI_OPEN_PARMSA = POINTER TO MCI_OPEN_PARMSA;

TYPE MCI_OPEN_PARMSW = RECORD
                              dwCallback       : DWORD;
                              wDeviceID        : MCIDEVICEID;
                              lpstrDeviceType  : PCWSTR;
                              lpstrElementName : PCWSTR;
                              lpstrAlias       : PCWSTR;
                       END;
    PMCI_OPEN_PARMSW = POINTER TO MCI_OPEN_PARMSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  MCI_OPEN_PARMS =  MCI_OPEN_PARMSW;
           PMCI_OPEN_PARMS = PMCI_OPEN_PARMSW;
<* ELSE *>
      TYPE  MCI_OPEN_PARMS =  MCI_OPEN_PARMSA;
           PMCI_OPEN_PARMS = PMCI_OPEN_PARMSA;
<* END *>

(* parameter block for MCI_PLAY command message *)

TYPE MCI_PLAY_PARMS = RECORD
                             dwCallback : DWORD;
                             dwFrom     : DWORD;
                             dwTo       : DWORD;
                      END;
    PMCI_PLAY_PARMS = POINTER TO MCI_PLAY_PARMS;

(* parameter block for MCI_SEEK command message *)

TYPE MCI_SEEK_PARMS = RECORD
                             dwCallback : DWORD;
                             dwTo       : DWORD;
                      END;
    PMCI_SEEK_PARMS = POINTER TO MCI_SEEK_PARMS;

(* parameter block for MCI_STATUS command message *)

TYPE MCI_STATUS_PARMS = RECORD
                               dwCallback : DWORD;
                               dwReturn   : DWORD;
                               dwItem     : DWORD;
                               dwTrack    : DWORD;
                        END;
    PMCI_STATUS_PARMS = POINTER TO MCI_STATUS_PARMS;

(* parameter block for MCI_INFO command message *)

TYPE MCI_INFO_PARMSA = RECORD
                              dwCallback  : DWORD;
                              lpstrReturn : PSTR;
                              dwRetSize   : DWORD;
                       END;
    PMCI_INFO_PARMSA = POINTER TO MCI_INFO_PARMSA;

TYPE MCI_INFO_PARMSW = RECORD
                              dwCallback  : DWORD;
                              lpstrReturn : PWSTR;
                              dwRetSize   : DWORD;
                       END;
    PMCI_INFO_PARMSW = POINTER TO MCI_INFO_PARMSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  MCI_INFO_PARMS =  MCI_INFO_PARMSW;
           PMCI_INFO_PARMS = PMCI_INFO_PARMSW;
<* ELSE *>
      TYPE  MCI_INFO_PARMS =  MCI_INFO_PARMSA;
           PMCI_INFO_PARMS = PMCI_INFO_PARMSA;
<* END *>

(* parameter block for MCI_GETDEVCAPS command message *)
TYPE MCI_GETDEVCAPS_PARMS = RECORD
                                   dwCallback : DWORD;
                                   dwReturn   : DWORD;
                                   dwItem     : DWORD;
                            END;
    PMCI_GETDEVCAPS_PARMS = POINTER TO MCI_GETDEVCAPS_PARMS;

(* parameter block for MCI_SYSINFO command message *)

TYPE MCI_SYSINFO_PARMSA = RECORD
                                 dwCallback  : DWORD;
                                 lpstrReturn : PSTR;
                                 dwRetSize   : DWORD;
                                 dwNumber    : DWORD;
                                 wDeviceType : UINT;
                          END;
    PMCI_SYSINFO_PARMSA = POINTER TO MCI_SYSINFO_PARMSA;

TYPE MCI_SYSINFO_PARMSW = RECORD
                                 dwCallback  : DWORD;
                                 lpstrReturn : PWSTR;
                                 dwRetSize   : DWORD;
                                 dwNumber    : DWORD;
                                 wDeviceType : UINT;
                          END;
    PMCI_SYSINFO_PARMSW = POINTER TO MCI_SYSINFO_PARMSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  MCI_SYSINFO_PARMS =  MCI_SYSINFO_PARMSW;
           PMCI_SYSINFO_PARMS = PMCI_SYSINFO_PARMSW;
<* ELSE *>
      TYPE  MCI_SYSINFO_PARMS =  MCI_SYSINFO_PARMSA;
           PMCI_SYSINFO_PARMS = PMCI_SYSINFO_PARMSA;
<* END *>

(* parameter block for MCI_SET command message *)

TYPE MCI_SET_PARMS = RECORD
                            dwCallback   : DWORD;
                            dwTimeFormat : DWORD;
                            dwAudio      : DWORD;
                     END;
    PMCI_SET_PARMS = POINTER TO MCI_SET_PARMS;

(* parameter block for MCI_BREAK command message *)

TYPE MCI_BREAK_PARMS = RECORD
                              dwCallback : DWORD;
                              nVirtKey   : INTEGER;
                              hwndBreak  : HWND;
                       END;
    PMCI_BREAK_PARMS = POINTER TO MCI_BREAK_PARMS;

(* parameter block for MCI_SAVE command message *)

TYPE MCI_SAVE_PARMSA = RECORD
                              dwCallback : DWORD;
                              lpfilename : PCSTR;
                       END;
    PMCI_SAVE_PARMSA = POINTER TO MCI_SAVE_PARMSA;

TYPE MCI_SAVE_PARMSW = RECORD
                              dwCallback : DWORD;
                              lpfilename : PCWSTR;
                       END;
    PMCI_SAVE_PARMSW = POINTER TO MCI_SAVE_PARMSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  MCI_SAVE_PARMS =  MCI_SAVE_PARMSW;
           PMCI_SAVE_PARMS = PMCI_SAVE_PARMSW;
<* ELSE *>
      TYPE  MCI_SAVE_PARMS =  MCI_SAVE_PARMSA;
           PMCI_SAVE_PARMS = PMCI_SAVE_PARMSA;
<* END *>

(* parameter block for MCI_LOAD command message *)

TYPE MCI_LOAD_PARMSA = RECORD
                              dwCallback : DWORD;
                              lpfilename : PCSTR;
                       END;
    PMCI_LOAD_PARMSA = POINTER TO MCI_LOAD_PARMSA;

TYPE MCI_LOAD_PARMSW = RECORD
                              dwCallback : DWORD;
                              lpfilename : PCWSTR;
                       END;
    PMCI_LOAD_PARMSW = POINTER TO MCI_LOAD_PARMSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  MCI_LOAD_PARMS =  MCI_LOAD_PARMSW;
           PMCI_LOAD_PARMS = PMCI_LOAD_PARMSW;
<* ELSE *>
      TYPE  MCI_LOAD_PARMS =  MCI_LOAD_PARMSA;
           PMCI_LOAD_PARMS = PMCI_LOAD_PARMSA;
<* END *>

(* parameter block for MCI_RECORD command message *)
TYPE MCI_RECORD_PARMS = RECORD
                               dwCallback : DWORD;
                               dwFrom     : DWORD;
                               dwTo       : DWORD;
                        END;
    PMCI_RECORD_PARMS = POINTER TO MCI_RECORD_PARMS;

(* MCI extensions for videodisc devices *)

(* flag for dwReturn field of MCI_STATUS_PARMS *)
(* MCI_STATUS command, (dwItem == MCI_STATUS_MODE) *)

CONST MCI_VD_MODE_PARK                = MCI_VD_OFFSET + 1;

(* flag for dwReturn field of MCI_STATUS_PARMS *)
(* MCI_STATUS command, (dwItem == MCI_VD_STATUS_MEDIA_TYPE) *)

CONST MCI_VD_MEDIA_CLV                = MCI_VD_OFFSET + 2;
      MCI_VD_MEDIA_CAV                = MCI_VD_OFFSET + 3;
      MCI_VD_MEDIA_OTHER              = MCI_VD_OFFSET + 4;

      MCI_VD_FORMAT_TRACK             = 4001h;

(* flags for dwFlags parameter of MCI_PLAY command message *)

CONST MCI_VD_PLAY_REVERSE             = 00010000h;
      MCI_VD_PLAY_FAST                = 00020000h;
      MCI_VD_PLAY_SPEED               = 00040000h;
      MCI_VD_PLAY_SCAN                = 00080000h;
      MCI_VD_PLAY_SLOW                = 00100000h;

(* flag for dwFlags parameter of MCI_SEEK command message *)

CONST MCI_VD_SEEK_REVERSE             = 00010000h;

(* flags for dwItem field of MCI_STATUS_PARMS parameter block *)

CONST MCI_VD_STATUS_SPEED             = 00004002h;
      MCI_VD_STATUS_FORWARD           = 00004003h;
      MCI_VD_STATUS_MEDIA_TYPE        = 00004004h;
      MCI_VD_STATUS_SIDE              = 00004005h;
      MCI_VD_STATUS_DISC_SIZE         = 00004006h;

(* flags for dwFlags parameter of MCI_GETDEVCAPS command message *)

CONST MCI_VD_GETDEVCAPS_CLV           = 00010000h;
      MCI_VD_GETDEVCAPS_CAV           = 00020000h;

      MCI_VD_SPIN_UP                  = 00010000h;
      MCI_VD_SPIN_DOWN                = 00020000h;

(* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block *)

CONST MCI_VD_GETDEVCAPS_CAN_REVERSE   = 00004002h;
      MCI_VD_GETDEVCAPS_FAST_RATE     = 00004003h;
      MCI_VD_GETDEVCAPS_SLOW_RATE     = 00004004h;
      MCI_VD_GETDEVCAPS_NORMAL_RATE   = 00004005h;

(* flags for the dwFlags parameter of MCI_STEP command message *)

CONST MCI_VD_STEP_FRAMES              = 00010000h;
      MCI_VD_STEP_REVERSE             = 00020000h;

(* flag for the MCI_ESCAPE command message *)

CONST MCI_VD_ESCAPE_STRING            = 00000100h;

(* parameter block for MCI_PLAY command message *)

TYPE MCI_VD_PLAY_PARMS = RECORD
                                dwCallback : DWORD;
                                dwFrom     : DWORD;
                                dwTo       : DWORD;
                                dwSpeed    : DWORD;
                         END;
    PMCI_VD_PLAY_PARMS = POINTER TO MCI_VD_PLAY_PARMS;

(* parameter block for MCI_STEP command message *)

TYPE MCI_VD_STEP_PARMS = RECORD
                                dwCallback : DWORD;
                                dwFrames   : DWORD;
                         END;
    PMCI_VD_STEP_PARMS = POINTER TO MCI_VD_STEP_PARMS;

(* parameter block for MCI_ESCAPE command message *)

TYPE MCI_VD_ESCAPE_PARMSA = RECORD
                                   dwCallback   : DWORD;
                                   lpstrCommand : PCSTR;
                            END;
    PMCI_VD_ESCAPE_PARMSA = POINTER TO MCI_VD_ESCAPE_PARMSA;

TYPE MCI_VD_ESCAPE_PARMSW = RECORD
                                   dwCallback   : DWORD;
                                   lpstrCommand : PCSTR;
                            END;
    PMCI_VD_ESCAPE_PARMSW = POINTER TO MCI_VD_ESCAPE_PARMSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  MCI_VD_ESCAPE_PARMS =  MCI_VD_ESCAPE_PARMSW;
      TYPE PMCI_VD_ESCAPE_PARMS = PMCI_VD_ESCAPE_PARMSW;
<* ELSE *>
      TYPE  MCI_VD_ESCAPE_PARMS =  MCI_VD_ESCAPE_PARMSA;
      TYPE PMCI_VD_ESCAPE_PARMS = PMCI_VD_ESCAPE_PARMSA;
<* END *>

(* MCI extensions for CD audio devices *)

(* flags for the dwItem field of the MCI_STATUS_PARMS parameter block *)

CONST MCI_CDA_STATUS_TYPE_TRACK       = 00004001h;

(* flags for the dwReturn field of MCI_STATUS_PARMS parameter block *)
(* MCI_STATUS command, (dwItem == MCI_CDA_STATUS_TYPE_TRACK) *)

CONST MCI_CDA_TRACK_AUDIO             = MCI_CD_OFFSET + 0;
      MCI_CDA_TRACK_OTHER             = MCI_CD_OFFSET + 1;

(* MCI extensions for waveform audio devices *)

CONST MCI_WAVE_PCM                    = MCI_WAVE_OFFSET + 0;
      MCI_WAVE_MAPPER                 = MCI_WAVE_OFFSET + 1;

(* flags for the dwFlags parameter of MCI_OPEN command message *)

CONST MCI_WAVE_OPEN_BUFFER            = 00010000h;

(* flags for the dwFlags parameter of MCI_SET command message *)

CONST MCI_WAVE_SET_FORMATTAG          = 00010000h;
      MCI_WAVE_SET_CHANNELS           = 00020000h;
      MCI_WAVE_SET_SAMPLESPERSEC      = 00040000h;
      MCI_WAVE_SET_AVGBYTESPERSEC     = 00080000h;
      MCI_WAVE_SET_BLOCKALIGN         = 00100000h;
      MCI_WAVE_SET_BITSPERSAMPLE      = 00200000h;

(* flags for the dwFlags parameter of MCI_STATUS, MCI_SET command messages *)

CONST MCI_WAVE_INPUT                  = 00400000h;
      MCI_WAVE_OUTPUT                 = 00800000h;

(* flags for the dwItem field of MCI_STATUS_PARMS parameter block *)

CONST MCI_WAVE_STATUS_FORMATTAG       = 00004001h;
      MCI_WAVE_STATUS_CHANNELS        = 00004002h;
      MCI_WAVE_STATUS_SAMPLESPERSEC   = 00004003h;
      MCI_WAVE_STATUS_AVGBYTESPERSEC  = 00004004h;
      MCI_WAVE_STATUS_BLOCKALIGN      = 00004005h;
      MCI_WAVE_STATUS_BITSPERSAMPLE   = 00004006h;
      MCI_WAVE_STATUS_LEVEL           = 00004007h;

(* flags for the dwFlags parameter of MCI_SET command message *)

CONST MCI_WAVE_SET_ANYINPUT           = 04000000h;
      MCI_WAVE_SET_ANYOUTPUT          = 08000000h;

(* flags for the dwFlags parameter of MCI_GETDEVCAPS command message *)

CONST MCI_WAVE_GETDEVCAPS_INPUTS      = 00004001h;
      MCI_WAVE_GETDEVCAPS_OUTPUTS     = 00004002h;

(* parameter block for MCI_OPEN command message *)

TYPE MCI_WAVE_OPEN_PARMSA = RECORD
                                   dwCallback       : DWORD;
                                   wDeviceID        : MCIDEVICEID;
                                   lpstrDeviceType  : PCSTR;
                                   lpstrElementName : PCSTR;
                                   lpstrAlias       : PCSTR;
                                   dwBufferSeconds  : DWORD;
                            END;
    PMCI_WAVE_OPEN_PARMSA = POINTER TO MCI_WAVE_OPEN_PARMSA;

TYPE MCI_WAVE_OPEN_PARMSW = RECORD
                                   dwCallback       : DWORD;
                                   wDeviceID        : MCIDEVICEID;
                                   lpstrDeviceType  : PCWSTR;
                                   lpstrElementName : PCWSTR;
                                   lpstrAlias       : PCWSTR;
                                   dwBufferSeconds  : DWORD;
                            END;
    PMCI_WAVE_OPEN_PARMSW = POINTER TO MCI_WAVE_OPEN_PARMSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  MCI_WAVE_OPEN_PARMS =  MCI_WAVE_OPEN_PARMSW;
           PMCI_WAVE_OPEN_PARMS = PMCI_WAVE_OPEN_PARMSW;
<* ELSE *>
      TYPE  MCI_WAVE_OPEN_PARMS =  MCI_WAVE_OPEN_PARMSA;
           PMCI_WAVE_OPEN_PARMS = PMCI_WAVE_OPEN_PARMSA;
<* END *>

(* parameter block for MCI_DELETE command message *)
TYPE MCI_WAVE_DELETE_PARMS = RECORD
                                    dwCallback : DWORD;
                                    dwFrom     : DWORD;
                                    dwTo       : DWORD;
                             END;
    PMCI_WAVE_DELETE_PARMS = POINTER TO MCI_WAVE_DELETE_PARMS;

(* parameter block for MCI_SET command message *)

TYPE MCI_WAVE_SET_PARMS = RECORD
                                 dwCallback      : DWORD;
                                 dwTimeFormat    : DWORD;
                                 dwAudio         : DWORD;
                                 wInput          : UINT;
                                 wOutput         : UINT;
                                 wFormatTag      : WORD;
                                 wReserved2      : WORD;
                                 nChannels       : WORD;
                                 wReserved3      : WORD;
                                 nSamplesPerSec  : DWORD;
                                 nAvgBytesPerSec : DWORD;
                                 nBlockAlign     : WORD;
                                 wReserved4      : WORD;
                                 wBitsPerSample  : WORD;
                                 wReserved5      : WORD;
                          END;
    PMCI_WAVE_SET_PARMS = POINTER TO MCI_WAVE_SET_PARMS;

(* MCI extensions for MIDI sequencer devices *)

(* flags for the dwReturn field of MCI_STATUS_PARMS parameter block *)
(* MCI_STATUS command, (dwItem == MCI_SEQ_STATUS_DIVTYPE) *)

CONST     MCI_SEQ_DIV_PPQN            = 0 + MCI_SEQ_OFFSET;
          MCI_SEQ_DIV_SMPTE_24        = 1 + MCI_SEQ_OFFSET;
          MCI_SEQ_DIV_SMPTE_25        = 2 + MCI_SEQ_OFFSET;
          MCI_SEQ_DIV_SMPTE_30DROP    = 3 + MCI_SEQ_OFFSET;
          MCI_SEQ_DIV_SMPTE_30        = 4 + MCI_SEQ_OFFSET;

(* flags for the dwMaster field of MCI_SEQ_SET_PARMS parameter block *)
(* MCI_SET command, (dwFlags == MCI_SEQ_SET_MASTER) *)

CONST     MCI_SEQ_FORMAT_SONGPTR      = 4001h;
          MCI_SEQ_FILE                = 4002h;
          MCI_SEQ_MIDI                = 4003h;
          MCI_SEQ_SMPTE               = 4004h;
          MCI_SEQ_NONE                = 65533;
          MCI_SEQ_MAPPER              = 65535;

(* flags for the dwItem field of MCI_STATUS_PARMS parameter block *)

CONST MCI_SEQ_STATUS_TEMPO            = 00004002h;
      MCI_SEQ_STATUS_PORT             = 00004003h;
      MCI_SEQ_STATUS_SLAVE            = 00004007h;
      MCI_SEQ_STATUS_MASTER           = 00004008h;
      MCI_SEQ_STATUS_OFFSET           = 00004009h;
      MCI_SEQ_STATUS_DIVTYPE          = 0000400Ah;
      MCI_SEQ_STATUS_NAME             = 0000400Bh;
      MCI_SEQ_STATUS_COPYRIGHT        = 0000400Ch;

(* flags for the dwFlags parameter of MCI_SET command message *)

CONST MCI_SEQ_SET_TEMPO               = 00010000h;
      MCI_SEQ_SET_PORT                = 00020000h;
      MCI_SEQ_SET_SLAVE               = 00040000h;
      MCI_SEQ_SET_MASTER              = 00080000h;
      MCI_SEQ_SET_OFFSET              = 01000000h;

(* parameter block for MCI_SET command message *)
TYPE MCI_SEQ_SET_PARMS = RECORD
                                dwCallback   : DWORD;
                                dwTimeFormat : DWORD;
                                dwAudio      : DWORD;
                                dwTempo      : DWORD;
                                dwPort       : DWORD;
                                dwSlave      : DWORD;
                                dwMaster     : DWORD;
                                dwOffset     : DWORD;
                         END;
    PMCI_SEQ_SET_PARMS = POINTER TO MCI_SEQ_SET_PARMS;

(* MCI extensions for animation devices *)

(* flags for dwFlags parameter of MCI_OPEN command message *)

CONST MCI_ANIM_OPEN_WS                = 00010000h;
      MCI_ANIM_OPEN_PARENT            = 00020000h;
      MCI_ANIM_OPEN_NOSTATIC          = 00040000h;

(* flags for dwFlags parameter of MCI_PLAY command message *)

CONST MCI_ANIM_PLAY_SPEED             = 00010000h;
      MCI_ANIM_PLAY_REVERSE           = 00020000h;
      MCI_ANIM_PLAY_FAST              = 00040000h;
      MCI_ANIM_PLAY_SLOW              = 00080000h;
      MCI_ANIM_PLAY_SCAN              = 00100000h;

(* flags for dwFlags parameter of MCI_STEP command message *)

CONST MCI_ANIM_STEP_REVERSE           = 00010000h;
      MCI_ANIM_STEP_FRAMES            = 00020000h;

(* flags for dwItem field of MCI_STATUS_PARMS parameter block *)

CONST MCI_ANIM_STATUS_SPEED           = 00004001h;
      MCI_ANIM_STATUS_FORWARD         = 00004002h;
      MCI_ANIM_STATUS_HWND            = 00004003h;
      MCI_ANIM_STATUS_HPAL            = 00004004h;
      MCI_ANIM_STATUS_STRETCH         = 00004005h;

(* flags for the dwFlags parameter of MCI_INFO command message *)

CONST MCI_ANIM_INFO_TEXT              = 00010000h;

(* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block *)

CONST MCI_ANIM_GETDEVCAPS_CAN_REVERSE = 00004001h;
      MCI_ANIM_GETDEVCAPS_FAST_RATE   = 00004002h;
      MCI_ANIM_GETDEVCAPS_SLOW_RATE   = 00004003h;
      MCI_ANIM_GETDEVCAPS_NORMAL_RATE = 00004004h;
      MCI_ANIM_GETDEVCAPS_PALETTES    = 00004006h;
      MCI_ANIM_GETDEVCAPS_CAN_STRETCH = 00004007h;
      MCI_ANIM_GETDEVCAPS_MAX_WINDOWS = 00004008h;

(* flags for the MCI_REALIZE command message *)

CONST MCI_ANIM_REALIZE_NORM           = 00010000h;
      MCI_ANIM_REALIZE_BKGD           = 00020000h;

(* flags for dwFlags parameter of MCI_WINDOW command message *)

CONST MCI_ANIM_WINDOW_HWND            = 00010000h;
      MCI_ANIM_WINDOW_STATE           = 00040000h;
      MCI_ANIM_WINDOW_TEXT            = 00080000h;
      MCI_ANIM_WINDOW_ENABLE_STRETCH  = 00100000h;
      MCI_ANIM_WINDOW_DISABLE_STRETCH = 00200000h;

(* flags for hWnd field of MCI_ANIM_WINDOW_PARMS parameter block *)
(* MCI_WINDOW command message, (dwFlags == MCI_ANIM_WINDOW_HWND) *)

CONST MCI_ANIM_WINDOW_DEFAULT         = 00000000h;

(* flags for dwFlags parameter of MCI_PUT command message *)

CONST MCI_ANIM_RECT                   = 00010000h;
      MCI_ANIM_PUT_SOURCE             = 00020000h;
      MCI_ANIM_PUT_DESTINATION        = 00040000h;

(* flags for dwFlags parameter of MCI_WHERE command message *)

CONST MCI_ANIM_WHERE_SOURCE           = 00020000h;
      MCI_ANIM_WHERE_DESTINATION      = 00040000h;

(* flags for dwFlags parameter of MCI_UPDATE command message *)

CONST MCI_ANIM_UPDATE_HDC             = 00020000h;

(* parameter block for MCI_OPEN command message *)

TYPE MCI_ANIM_OPEN_PARMSA = RECORD
                                   dwCallback       : DWORD;
                                   wDeviceID        : MCIDEVICEID;
                                   lpstrDeviceType  : PCSTR;
                                   lpstrElementName : PCSTR;
                                   lpstrAlias       : PCSTR;
                                   dwStyle          : DWORD;
                                   hWndParent       : HWND;
                            END;
    PMCI_ANIM_OPEN_PARMSA = POINTER TO MCI_ANIM_OPEN_PARMSA;

TYPE MCI_ANIM_OPEN_PARMSW = RECORD
                                   dwCallback       : DWORD;
                                   wDeviceID        : MCIDEVICEID;
                                   lpstrDeviceType  : PCWSTR;
                                   lpstrElementName : PCWSTR;
                                   lpstrAlias       : PCWSTR;
                                   dwStyle          : DWORD;
                                   hWndParent       : HWND;
                            END;
    PMCI_ANIM_OPEN_PARMSW = POINTER TO MCI_ANIM_OPEN_PARMSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  MCI_ANIM_OPEN_PARMS =  MCI_ANIM_OPEN_PARMSW;
           PMCI_ANIM_OPEN_PARMS = PMCI_ANIM_OPEN_PARMSW;
<* ELSE *>
      TYPE  MCI_ANIM_OPEN_PARMS =  MCI_ANIM_OPEN_PARMSA;
           PMCI_ANIM_OPEN_PARMS = PMCI_ANIM_OPEN_PARMSA;
<* END *>

(* parameter block for MCI_PLAY command message *)

TYPE MCI_ANIM_PLAY_PARMS = RECORD
                                  dwCallback : DWORD;
                                  dwFrom     : DWORD;
                                  dwTo       : DWORD;
                                  dwSpeed    : DWORD;
                           END;
    PMCI_ANIM_PLAY_PARMS = POINTER TO MCI_ANIM_PLAY_PARMS;

(* parameter block for MCI_STEP command message *)

TYPE MCI_ANIM_STEP_PARMS = RECORD
                                  dwCallback : DWORD;
                                  dwFrames   : DWORD;
                           END;
    PMCI_ANIM_STEP_PARMS = POINTER TO MCI_ANIM_STEP_PARMS;

(* parameter block for MCI_WINDOW command message *)

TYPE MCI_ANIM_WINDOW_PARMSA = RECORD
                                     dwCallback : DWORD;
                                     hWnd       : HWND;
                                     nCmdShow   : UINT;
                                     lpstrText  : PCSTR;
                              END;
    PMCI_ANIM_WINDOW_PARMSA = POINTER TO MCI_ANIM_WINDOW_PARMSA;

TYPE MCI_ANIM_WINDOW_PARMSW = RECORD
                                     dwCallback : DWORD;
                                     hWnd       : HWND;
                                     nCmdShow   : UINT;
                                     lpstrText  : PCWSTR;
                              END;
    PMCI_ANIM_WINDOW_PARMSW = POINTER TO MCI_ANIM_WINDOW_PARMSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  MCI_ANIM_WINDOW_PARMS =  MCI_ANIM_WINDOW_PARMSW;
           PMCI_ANIM_WINDOW_PARMS = PMCI_ANIM_WINDOW_PARMSW;
<* ELSE *>
      TYPE  MCI_ANIM_WINDOW_PARMS =  MCI_ANIM_WINDOW_PARMSA;
           PMCI_ANIM_WINDOW_PARMS = PMCI_ANIM_WINDOW_PARMSA;
<* END *>


(* parameter block for MCI_PUT, MCI_UPDATE, MCI_WHERE command messages *)

TYPE MCI_ANIM_RECT_PARMS = RECORD
                                  dwCallback : DWORD;
                                  CASE : BOOLEAN OF
                                  | TRUE  : ptOffset : POINT;
                                            ptExtent : POINT;
                                  | FALSE : rc : RECT;
                                  END;
                           END;

    PMCI_ANIM_RECT_PARMS = POINTER TO MCI_ANIM_RECT_PARMS;

(* parameter block for MCI_UPDATE PARMS *)

TYPE MCI_ANIM_UPDATE_PARMS = RECORD
                                    dwCallback : DWORD;
                                    rc         : RECT;
                                    hDC        : HDC;
                             END;
    PMCI_ANIM_UPDATE_PARMS = POINTER TO MCI_ANIM_UPDATE_PARMS;

(* MCI extensions for video overlay devices *)

(* flags for dwFlags parameter of MCI_OPEN command message *)

CONST MCI_OVLY_OPEN_WS                = 00010000h;
      MCI_OVLY_OPEN_PARENT            = 00020000h;

(* flags for dwFlags parameter of MCI_STATUS command message *)

CONST MCI_OVLY_STATUS_HWND            = 00004001h;
      MCI_OVLY_STATUS_STRETCH         = 00004002h;

(* flags for dwFlags parameter of MCI_INFO command message *)

CONST MCI_OVLY_INFO_TEXT              = 00010000h;

(* flags for dwItem field of MCI_GETDEVCAPS_PARMS parameter block *)

CONST MCI_OVLY_GETDEVCAPS_CAN_STRETCH = 00004001h;
      MCI_OVLY_GETDEVCAPS_CAN_FREEZE  = 00004002h;
      MCI_OVLY_GETDEVCAPS_MAX_WINDOWS = 00004003h;

(* flags for dwFlags parameter of MCI_WINDOW command message *)

CONST MCI_OVLY_WINDOW_HWND            = 00010000h;
      MCI_OVLY_WINDOW_STATE           = 00040000h;
      MCI_OVLY_WINDOW_TEXT            = 00080000h;
      MCI_OVLY_WINDOW_ENABLE_STRETCH  = 00100000h;
      MCI_OVLY_WINDOW_DISABLE_STRETCH = 00200000h;

(* flags for hWnd parameter of MCI_OVLY_WINDOW_PARMS parameter block *)

CONST MCI_OVLY_WINDOW_DEFAULT         = 00000000h;

(* flags for dwFlags parameter of MCI_PUT command message *)

CONST MCI_OVLY_RECT                   = 00010000h;
      MCI_OVLY_PUT_SOURCE             = 00020000h;
      MCI_OVLY_PUT_DESTINATION        = 00040000h;
      MCI_OVLY_PUT_FRAME              = 00080000h;
      MCI_OVLY_PUT_VIDEO              = 00100000h;

(* flags for dwFlags parameter of MCI_WHERE command message *)

CONST MCI_OVLY_WHERE_SOURCE           = 00020000h;
      MCI_OVLY_WHERE_DESTINATION      = 00040000h;
      MCI_OVLY_WHERE_FRAME            = 00080000h;
      MCI_OVLY_WHERE_VIDEO            = 00100000h;

(* parameter block for MCI_OPEN command message *)

TYPE MCI_OVLY_OPEN_PARMSA = RECORD
                                   dwCallback       : DWORD;
                                   wDeviceID        : MCIDEVICEID;
                                   lpstrDeviceType  : PCSTR;
                                   lpstrElementName : PCSTR;
                                   lpstrAlias       : PCSTR;
                                   dwStyle          : DWORD;
                                   hWndParent       : HWND;
                            END;
    PMCI_OVLY_OPEN_PARMSA = POINTER TO MCI_OVLY_OPEN_PARMSA;

TYPE MCI_OVLY_OPEN_PARMSW = RECORD
                                   dwCallback       : DWORD;
                                   wDeviceID        : MCIDEVICEID;
                                   lpstrDeviceType  : PCWSTR;
                                   lpstrElementName : PCWSTR;
                                   lpstrAlias       : PCWSTR;
                                   dwStyle          : DWORD;
                                   hWndParent       : HWND;
                            END;
    PMCI_OVLY_OPEN_PARMSW = POINTER TO MCI_OVLY_OPEN_PARMSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  MCI_OVLY_OPEN_PARMS =  MCI_OVLY_OPEN_PARMSW;
           PMCI_OVLY_OPEN_PARMS = PMCI_OVLY_OPEN_PARMSW;
<* ELSE *>
      TYPE  MCI_OVLY_OPEN_PARMS =  MCI_OVLY_OPEN_PARMSA;
           PMCI_OVLY_OPEN_PARMS = PMCI_OVLY_OPEN_PARMSA;
<* END *>


(* parameter block for MCI_WINDOW command message *)

TYPE MCI_OVLY_WINDOW_PARMSA = RECORD
                                     dwCallback : DWORD;
                                     hWnd       : HWND;
                                     nCmdShow   : UINT;
                                     lpstrText  : PCSTR;
                              END;
    PMCI_OVLY_WINDOW_PARMSA = POINTER TO MCI_OVLY_WINDOW_PARMSA;

TYPE MCI_OVLY_WINDOW_PARMSW = RECORD
                                     dwCallback : DWORD;
                                     hWnd       : HWND;
                                     nCmdShow   : UINT;
                                     lpstrText  : PCWSTR;
                              END;
    PMCI_OVLY_WINDOW_PARMSW = POINTER TO MCI_OVLY_WINDOW_PARMSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  MCI_OVLY_WINDOW_PARMS =  MCI_OVLY_WINDOW_PARMSW;
           PMCI_OVLY_WINDOW_PARMS = PMCI_OVLY_WINDOW_PARMSW;
<* ELSE *>
      TYPE  MCI_OVLY_WINDOW_PARMS =  MCI_OVLY_WINDOW_PARMSA;
           PMCI_OVLY_WINDOW_PARMS = PMCI_OVLY_WINDOW_PARMSA;
<* END *>

(* parameter block for MCI_PUT, MCI_UPDATE, and MCI_WHERE command messages *)

TYPE MCI_OVLY_RECT_PARMS = RECORD
                                  dwCallback : DWORD;
                                  CASE : BOOLEAN OF
                                  | TRUE  : ptOffset : POINT;
                                            ptExtent : POINT;
                                  | FALSE : rc : RECT;
                                  END;
                           END;
    PMCI_OVLY_RECT_PARMS = POINTER TO MCI_OVLY_RECT_PARMS;

(* parameter block for MCI_SAVE command message *)

TYPE MCI_OVLY_SAVE_PARMSA = RECORD
                                   dwCallback : DWORD;
                                   lpfilename : PCSTR;
                                   rc         : RECT;
                            END;
    PMCI_OVLY_SAVE_PARMSA = POINTER TO MCI_OVLY_SAVE_PARMSA;

TYPE MCI_OVLY_SAVE_PARMSW = RECORD
                                   dwCallback : DWORD;
                                   lpfilename : PCWSTR;
                                   rc         : RECT;
                            END;
    PMCI_OVLY_SAVE_PARMSW = POINTER TO MCI_OVLY_SAVE_PARMSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  MCI_OVLY_SAVE_PARMS =  MCI_OVLY_SAVE_PARMSW;
           PMCI_OVLY_SAVE_PARMS = PMCI_OVLY_SAVE_PARMSW;
<* ELSE *>
      TYPE  MCI_OVLY_SAVE_PARMS =  MCI_OVLY_SAVE_PARMSA;
           PMCI_OVLY_SAVE_PARMS = PMCI_OVLY_SAVE_PARMSA;
<* END *>

(* parameter block for MCI_LOAD command message *)

TYPE MCI_OVLY_LOAD_PARMSA = RECORD
                                   dwCallback : DWORD;
                                   lpfilename : PCSTR;
                                   rc         : RECT;
                            END;
    PMCI_OVLY_LOAD_PARMSA = POINTER TO MCI_OVLY_LOAD_PARMSA;

TYPE MCI_OVLY_LOAD_PARMSW = RECORD
                                   dwCallback : DWORD;
                                   lpfilename : PCWSTR;
                                   rc         : RECT;
                            END;
    PMCI_OVLY_LOAD_PARMSW = POINTER TO MCI_OVLY_LOAD_PARMSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  MCI_OVLY_LOAD_PARMS =  MCI_OVLY_LOAD_PARMSW;
           PMCI_OVLY_LOAD_PARMS = PMCI_OVLY_LOAD_PARMSW;
<* ELSE *>
      TYPE  MCI_OVLY_LOAD_PARMS =  MCI_OVLY_LOAD_PARMSA;
           PMCI_OVLY_LOAD_PARMS = PMCI_OVLY_LOAD_PARMSA;
<* END *>

<* END *>  (* NOT DEFINED (_WIN32_VXD) *)
<* END *>  (* NOT DEFINED (MMNOMCI) *)

(****************************************************************************

                        DISPLAY Driver extensions

****************************************************************************)

CONST  NEWTRANSPARENT  = 3;           (* use with SetBkMode() *)

       QUERYROPSUPPORT = 40;          (* use to determine ROP support *)

(****************************************************************************

                        DIB Driver extensions

****************************************************************************)

CONST SELECTDIB        = 41;          (* DIB.DRV select dib escape *)

PROCEDURE DIBINDEX (n : WORD) : DWORD;

(* DIBINDEX was a macro: #define DIBINDEX(n)  MAKELONG((n),0x10FF)
   now it is in RTL
*)

<* POP *> (* back to alignment=8 *)



(* NB30.def

   This module contains the definitions for portable NetBIOS 3.0
   support.

*)



(****************************************************************
 *                                                              *
 *              Data structure templates                        *
 *                                                              *
 ****************************************************************)

CONST NCBNAMSZ =  16; (* absolute length of a net name           *)
      MAX_LANA = 254; (* lana's in range 0 to MAX_LANA inclusive *)

(*
 * Network Control Block
 *)

TYPE PNCB = POINTER TO NCB;
     NCB =
     RECORD
         ncb_command  : UCHAR;                          (* command code                   *)
         ncb_retcode  : UCHAR;                          (* return code                    *)
         ncb_lsn      : UCHAR;                          (* local session number           *)
         ncb_num      : UCHAR;                          (* number of our network name     *)
         ncb_buffer   : PUCHAR;                         (* address of message buffer      *)
         ncb_length   : WORD;                           (* size of message buffer         *)
         ncb_callname : ARRAY [0..NCBNAMSZ-1] OF UCHAR; (* blank-padded name of remote    *)
         ncb_name     : ARRAY [0..NCBNAMSZ-1] OF UCHAR; (* our blank-padded netname       *)
         ncb_rto      : UCHAR;                          (* rcv timeout/retry count        *)
         ncb_sto      : UCHAR;                          (* send timeout/sys timeout       *)
         ncb_post     : PROCEDURE (PNCB);               (* POST routine address           *)
         ncb_lana_num : UCHAR;                          (* lana (adapter) number          *)
         ncb_cmd_cplt : UCHAR;                          (* 0xff => commmand pending       *)
         ncb_reserve  : ARRAY [0..9] OF UCHAR;          (* reserved, used by BIOS         *)
         ncb_event    : HANDLE;                         (* HANDLE to Win32 event which    *)
                                                        (* will be set to the signalled   *)
                                                        (* state when an ASYNCH command   *)
                                                        (* completes                      *)
     END;

(*
 *  Structure returned to the NCB command NCBASTAT is ADAPTER_STATUS followed
 *  by an array of NAME_BUFFER structures.
 *)

TYPE ADAPTER_STATUS = RECORD
                             adapter_address : ARRAY [0..5] OF UCHAR;
                             rev_major       : UCHAR;
                             reserved0       : UCHAR;
                             adapter_type    : UCHAR;
                             rev_minor       : UCHAR;
                             duration        : WORD;
                             frmr_recv       : WORD;
                             frmr_xmit       : WORD;

                             iframe_recv_err : WORD;

                             xmit_aborts     : WORD;
                             xmit_success    : DWORD;
                             recv_success    : DWORD;

                             iframe_xmit_err : WORD;

                             recv_buff_unavail : WORD;
                             t1_timeouts       : WORD;
                             ti_timeouts       : WORD;
                             reserved1         : DWORD;
                             free_ncbs         : WORD;
                             max_cfg_ncbs      : WORD;
                             max_ncbs          : WORD;
                             xmit_buf_unavail  : WORD;
                             max_dgram_size    : WORD;
                             pending_sess      : WORD;
                             max_cfg_sess      : WORD;
                             max_sess          : WORD;
                             max_sess_pkt_size : WORD;
                             name_count        : WORD;
                      END;
    PADAPTER_STATUS = POINTER TO ADAPTER_STATUS;

TYPE NAME_BUFFER = RECORD
                          name : ARRAY [0..NCBNAMSZ-1] OF UCHAR;
                          name_num : UCHAR;
                          name_flags : UCHAR;
                   END;
    PNAME_BUFFER = POINTER TO NAME_BUFFER;

(*  values for name_flags bits. *)

CONST NAME_FLAGS_MASK = VAL (UCHAR, 87h);

      GROUP_NAME      = VAL (UCHAR, 80h);
      UNIQUE_NAME     = VAL (UCHAR, 00h);

      REGISTERING     = VAL (UCHAR, 00h);
      REGISTERED      = VAL (UCHAR, 04h);
      DEREGISTERED    = VAL (UCHAR, 05h);
      DUPLICATE       = VAL (UCHAR, 06h);
      DUPLICATE_DEREG = VAL (UCHAR, 07h);

(*
 *  Structure returned to the NCB command NCBSSTAT is SESSION_HEADER followed
 *  by an array of SESSION_BUFFER structures. If the NCB_NAME starts with an
 *  asterisk then an array of these structures is returned containing the
 *  status for all names.
 *)

TYPE SESSION_HEADER = RECORD
                             sess_name           : UCHAR;
                             num_sess            : UCHAR;
                             rcv_dg_outstanding  : UCHAR;
                             rcv_any_outstanding : UCHAR;
                      END;
    PSESSION_HEADER = POINTER TO SESSION_HEADER;

(*  Values for state *)

<* PUSH *> <* ENUMSIZE = "1" *>

TYPE STATE_ENUM = (STATE_0,
                   LISTEN_OUTSTANDING,  (* 1 *)
                   CALL_PENDING,        (* 2 *)
                   SESSION_ESTABLISHED, (* 3 *)
                   HANGUP_PENDING,      (* 4 *)
                   HANGUP_COMPLETE,     (* 5 *)
                   SESSION_ABORTED);    (* 6 *)

<* POP *>

TYPE SESSION_BUFFER = RECORD
                             lsn                   : UCHAR;
                             state                 : STATE_ENUM;
                             local_name  : ARRAY [0..NCBNAMSZ-1] OF UCHAR;
                             remote_name : ARRAY [0..NCBNAMSZ-1] OF UCHAR;
                             rcvs_outstanding      : UCHAR;
                             sends_outstanding     : UCHAR;
                      END;
    PSESSION_BUFFER = POINTER TO SESSION_BUFFER;

(*
 *  Structure returned to the NCB command NCBENUM.
 *
 *  On a system containing lana's 0, 2 and 3, a structure with
 *  length =3, lana[0]=0, lana[1]=2 and lana[2]=3 will be returned.
 *)

TYPE LANA_ENUM = RECORD
                        length : UCHAR;  (* Number of valid entries in lana[] *)
                        lana   : ARRAY [0..MAX_LANA] OF UCHAR;
                 END;
    PLANA_ENUM = POINTER TO LANA_ENUM;

(*
 *  Structure returned to the NCB command NCBFINDNAME is FIND_NAME_HEADER followed
 *  by an array of FIND_NAME_BUFFER structures.
 *)

TYPE FIND_NAME_HEADER = RECORD
                               node_count   : WORD;
                               reserved     : UCHAR;
                               unique_group : UCHAR;
                        END;
    PFIND_NAME_HEADER = POINTER TO FIND_NAME_HEADER;

TYPE FIND_NAME_BUFFER = RECORD
                               length           : UCHAR;
                               access_control   : UCHAR;
                               frame_control    : UCHAR;
                               destination_addr : ARRAY [0..5]  OF UCHAR;
                               source_addr      : ARRAY [0..5]  OF UCHAR;
                               routing_info     : ARRAY [0..17] OF UCHAR;
                        END;
    PFIND_NAME_BUFFER = POINTER TO FIND_NAME_BUFFER;

(*
 *  Structure provided with NCBACTION. The purpose of NCBACTION is to provide
 *  transport specific extensions to netbios.
 *)

TYPE ACTION_HEADER = RECORD
                            transport_id : ULONG;
                            action_code  : USHORT;
                            reserved     : USHORT;
                     END;
    PACTION_HEADER = POINTER TO ACTION_HEADER;

(*  Values for transport_id *)

CONST ALL_TRANSPORTS = ORD ('M');                     (* M\0\0\0 *)
      MS_NBF         = ORD ('M') +
                       ORD ('N') * 100H +
                       ORD ('B') * 10000H +
                       ORD ('F') * 1000000H;          (* "MNBF" *)


(****************************************************************
 *                                                              *
 *              Special values and constants                    *
 *                                                              *
 ****************************************************************)

(*
 *      NCB Command codes
 *)

CONST NCBCALL         = 10h;            (* NCB CALL                           *)
      NCBLISTEN       = 11h;            (* NCB LISTEN                         *)
      NCBHANGUP       = 12h;            (* NCB HANG UP                        *)
      NCBSEND         = 14h;            (* NCB SEND                           *)
      NCBRECV         = 15h;            (* NCB RECEIVE                        *)
      NCBRECVANY      = 16h;            (* NCB RECEIVE ANY                    *)
      NCBCHAINSEND    = 17h;            (* NCB CHAIN SEND                     *)
      NCBDGSEND       = 20h;            (* NCB SEND DATAGRAM                  *)
      NCBDGRECV       = 21h;            (* NCB RECEIVE DATAGRAM               *)
      NCBDGSENDBC     = 22h;            (* NCB SEND BROADCAST DATAGRAM        *)
      NCBDGRECVBC     = 23h;            (* NCB RECEIVE BROADCAST DATAGRAM     *)
      NCBADDNAME      = 30h;            (* NCB ADD NAME                       *)
      NCBDELNAME      = 31h;            (* NCB DELETE NAME                    *)
      NCBRESET        = 32h;            (* NCB RESET                          *)
      NCBASTAT        = 33h;            (* NCB ADAPTER STATUS                 *)
      NCBSSTAT        = 34h;            (* NCB SESSION STATUS                 *)
      NCBCANCEL       = 35h;            (* NCB CANCEL                         *)
      NCBADDGRNAME    = 36h;            (* NCB ADD GROUP NAME                 *)
      NCBENUM         = 37h;            (* NCB ENUMERATE LANA NUMBERS         *)
      NCBUNLINK       = 70h;            (* NCB UNLINK                         *)
      NCBSENDNA       = 71h;            (* NCB SEND NO ACK                    *)
      NCBCHAINSENDNA  = 72h;            (* NCB CHAIN SEND NO ACK              *)
      NCBLANSTALERT   = 73h;            (* NCB LAN STATUS ALERT               *)
      NCBACTION       = 77h;            (* NCB ACTION                         *)
      NCBFINDNAME     = 78h;            (* NCB FIND NAME                      *)
      NCBTRACE        = 79h;            (* NCB TRACE                          *)


      ASYNCH          = 80h;            (* high bit set == asynchronous       *)

(*
 *      NCB Return codes
 *)

      NRC_GOODRET     = 00h;    (* good return                                *)
                                (* also returned when ASYNCH request accepted *)
      NRC_BUFLEN      = 01h;    (* illegal buffer length                      *)
      NRC_ILLCMD      = 03h;    (* illegal command                            *)
      NRC_CMDTMO      = 05h;    (* command timed out                          *)
      NRC_INCOMP      = 06h;    (* message incomplete, issue another command  *)
      NRC_BADDR       = 07h;    (* illegal buffer address                     *)
      NRC_SNUMOUT     = 08h;    (* session number out of range                *)
      NRC_NORES       = 09h;    (* no resource available                      *)
      NRC_SCLOSED     = 0ah;    (* session closed                             *)
      NRC_CMDCAN      = 0bh;    (* command cancelled                          *)
      NRC_DUPNAME     = 0dh;    (* duplicate name                             *)
      NRC_NAMTFUL     = 0eh;    (* name table full                            *)
      NRC_ACTSES      = 0fh;    (* no deletions, name has active sessions     *)
      NRC_LOCTFUL     = 11h;    (* local session table full                   *)
      NRC_REMTFUL     = 12h;    (* remote session table full                  *)
      NRC_ILLNN       = 13h;    (* illegal name number                        *)
      NRC_NOCALL      = 14h;    (* no callname                                *)
      NRC_NOWILD      = 15h;    (* cannot put * in NCB_NAME                   *)
      NRC_INUSE       = 16h;    (* name in use on remote adapter              *)
      NRC_NAMERR      = 17h;    (* name deleted                               *)
      NRC_SABORT      = 18h;    (* session ended abnormally                   *)
      NRC_NAMCONF     = 19h;    (* name conflict detected                     *)
      NRC_IFBUSY      = 21h;    (* interface busy, IRET before retrying       *)
      NRC_TOOMANY     = 22h;    (* too many commands outstanding, retry later *)
      NRC_BRIDGE      = 23h;    (* ncb_lana_num field invalid                 *)
      NRC_CANOCCR     = 24h;    (* command completed while cancel occurring   *)
      NRC_CANCEL      = 26h;    (* command not valid to cancel                *)
      NRC_DUPENV      = 30h;    (* name defined by anther local process       *)
      NRC_ENVNOTDEF   = 34h;    (* environment undefined. RESET required      *)
      NRC_OSRESNOTAV  = 35h;    (* required OS resources exhausted            *)
      NRC_MAXAPPS     = 36h;    (* max number of applications exceeded        *)
      NRC_NOSAPS      = 37h;    (* no saps available for netbios              *)
      NRC_NORESOURCES = 38h;    (* requested resources are not available      *)
      NRC_INVADDRESS  = 39h;    (* invalid ncb address or length > segment    *)
      NRC_INVDDID     = 3Bh;    (* invalid NCB DDID                           *)
      NRC_LOCKFAIL    = 3Ch;    (* lock of user area failed                   *)
      NRC_OPENERR     = 3fh;    (* NETBIOS not loaded                         *)
      NRC_SYSTEM      = 40h;    (* system error                               *)

      NRC_PENDING     = 0ffh;   (* asynchronous command is not yet finished   *)


(****************************************************************
 *                                                              *
 *              main user entry point for NetBIOS 3.0           *
 *                                                              *
 * Usage: result = Netbios( pncb );                             *
 ****************************************************************)

PROCEDURE Netbios (VAR pnc : NCB) : UCHAR;


(******************************************************************************
*                                                                             *
* ShellAPI.def -  SHELL.DLL functions, types, and definitions                 *
*                                                                             *
******************************************************************************)


<* PUSH *> <* ALIGNMENT = "1" *>

TYPE HDROP = POINTER TO RECORD END;

PROCEDURE DragQueryFileA (hDrop    : HDROP;
                          iFile    : UINT;
                          FileName : PSTR;
                          bufsize  : UINT) : UINT;

PROCEDURE DragQueryFileW (hDrop    : HDROP;
                          iFile    : UINT;
                          FileName : PWSTR;
                          bufsize  : UINT) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST DragQueryFile = DragQueryFileW;
<* ELSE *>
      CONST DragQueryFile = DragQueryFileA;
<* END *>

PROCEDURE DragQueryPoint  (hDrop : HDROP; VAR point : POINT) : BOOL;
PROCEDURE DragFinish      (hDrop : HDROP);
PROCEDURE DragAcceptFiles (hWnd : HWND; fAccept : BOOL);

PROCEDURE ShellExecuteA (hwnd         : HWND;
                         lpOperation  : PCSTR;
                         lpFile       : PCSTR;
                         lpParameters : PCSTR;
                         lpDirectory  : PCSTR;
                         nShowCmd     : SW_ENUM) : HINSTANCE;

PROCEDURE ShellExecuteW (hwnd         : HWND;
                         lpOperation  : PCWSTR;
                         lpFile       : PCWSTR;
                         lpParameters : PCWSTR;
                         lpDirectory  : PCWSTR;
                         nShowCmd     : SW_ENUM) : HINSTANCE;


<* IF DEFINED (UNICODE) THEN *>
      CONST ShellExecute = ShellExecuteW;
<* ELSE *>
      CONST ShellExecute = ShellExecuteA;
<* END *>

PROCEDURE FindExecutableA (lpFile : PCSTR;  lpDirector : PCSTR;  lpResult : PSTR)  : HINSTANCE;
PROCEDURE FindExecutableW (lpFile : PCWSTR; lpDirector : PCWSTR; lpResult : PWSTR) : HINSTANCE;

<* IF DEFINED (UNICODE) THEN *>
      CONST FindExecutable = FindExecutableW;
<* ELSE *>
      CONST FindExecutable = FindExecutableA;
<* END *>

PROCEDURE CommandLineToArgvW (lpCmdLine   : PCSTR;
                              VAR NumArgs : INTEGER) : PPWSTR;

PROCEDURE ShellAboutA (hWnd : HWND; szApp : PCSTR;  szOtherStuff : PCSTR;  hIcon : HICON) : INTEGER;
PROCEDURE ShellAboutW (hWnd : HWND; szApp : PCWSTR; szOtherStuff : PCWSTR; hIcon : HICON) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST ShellAbout = ShellAboutW;
<* ELSE *>
      CONST ShellAbout = ShellAboutA;
<* END *>

PROCEDURE ExtractAssociatedIconA (hInst : HINSTANCE; lpIconPath : PSTR;  VAR iIcon : WORD) : HICON;
PROCEDURE ExtractAssociatedIconW (hInst : HINSTANCE; lpIconPath : PWSTR; VAR iIcon : WORD) : HICON;

<* IF DEFINED (UNICODE) THEN *>
      CONST ExtractAssociatedIcon = ExtractAssociatedIconW;
<* ELSE *>
      CONST ExtractAssociatedIcon = ExtractAssociatedIconA;
<* END *>

PROCEDURE ExtractIconA (hInst : HINSTANCE; lpszExeFileName : PCSTR;  nIconIndex : UINT) : HICON;
PROCEDURE ExtractIconW (hInst : HINSTANCE; lpszExeFileName : PCWSTR; nIconIndex : UINT) : HICON;

<* IF DEFINED (UNICODE) THEN *>
      CONST ExtractIcon = ExtractIconW;
<* ELSE *>
      CONST ExtractIcon = ExtractIconA;
<* END *>

(***
**** AppBar stuff
***)

TYPE ABM_ENUM = (ABM_NEW,               (* 0x00000000 *)
                 ABM_REMOVE,            (* 0x00000001 *)
                 ABM_QUERYPOS,          (* 0x00000002 *)
                 ABM_SETPOS,            (* 0x00000003 *)
                 ABM_GETSTATE,          (* 0x00000004 *)
                 ABM_GETTASKBARPOS,     (* 0x00000005 *)
                 ABM_ACTIVATE,          (* 0x00000006 *) (* lParam == TRUE/FALSE means activate/deactivate *)
                 ABM_GETAUTOHIDEBAR,    (* 0x00000007 *)
                 ABM_SETAUTOHIDEBAR,    (* 0x00000008 *) (* this can fail at any time.  MUST check the result *)
                                                         (* lParam = TRUE/FALSE  Set/Unset *)
                                                         (* uEdge = what edge *)
                 ABM_WINDOWPOSCHANGED); (* 0x00000009 *)

(* these are put in the wparam of callback messages *)

TYPE ABN_ENUM = (ABN_STATECHANGE,    (* 0x00000000 *)
                 ABN_POSCHANGED,     (* 0x00000001 *)
                 ABN_FULLSCREENAPP,  (* 0x00000002 *)
                 ABN_WINDOWARRANGE); (* 0x00000003 *) (* lParam == TRUE means hide *)

(* flags for get state *)


TYPE ABS_ENUM = (ABS__AUTOHIDE,     (* 0 *)
                 ABS__ALWAYSONTOP); (* 1 *)

     ABS_SET = SET OF ABS_ENUM;

CONST ABS_AUTOHIDE    = ABS_SET {ABS__AUTOHIDE};    (* 0x0000001 *)
      ABS_ALWAYSONTOP = ABS_SET {ABS__ALWAYSONTOP}; (* 0x0000002 *)

TYPE ABE_ENUM = (ABE_LEFT,    (* 0 *)
                 ABE_TOP,     (* 1 *)
                 ABE_RIGHT,   (* 2 *)
                 ABE_BOTTOM); (* 3 *)

TYPE APPBARDATA = RECORD
                         cbSize           : DWORD;
                         hWnd             : HWND;
                         uCallbackMessage : UINT;
                         uEdge            : UINT;
                         rc               : RECT;
                         lParam           : LPARAM; (* message specific *)
                  END;
    PAPPBARDATA = POINTER TO APPBARDATA;

<* IF BACKEND # "C" THEN *>
PROCEDURE SHAppBarMessage (dwMessage : ABM_ENUM;
                           Data      : APPBARDATA) : UINT;
<* ELSE *>
PROCEDURE SHAppBarMessage (dwMessage : ABM_ENUM;
                           Data      : PAPPBARDATA) : UINT;
<* END *>

(***
****  EndAppBar
***)

PROCEDURE ExtractIconExA (szFile         : PCSTR;
                          nIconIndex     : INTEGER;
                          VAR hiconLarge : ARRAY OF HICON;
                          VAR hiconSmall : ARRAY OF HICON;
                          nIcons         : UINT) : UINT;

PROCEDURE ExtractIconExW (szFile         : PCWSTR;
                          nIconIndex     : INTEGER;
                          VAR hiconLarge : ARRAY OF HICON;
                          VAR hiconSmall : ARRAY OF HICON;
                          nIcons         : UINT) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST ExtractIconEx = ExtractIconExW;
<* ELSE *>
      CONST ExtractIconEx = ExtractIconExA;
<* END *>


(***
**** Shell File Operations
***)

TYPE FO_ENUM = (FO_0,
                FO_MOVE,    (* 0x0001 *)
                FO_COPY,    (* 0x0002 *)
                FO_DELETE,  (* 0x0003 *)
                FO_RENAME); (* 0x0004 *)

TYPE FILEOP_FLAGS = WORD;

(* following bits are not defined as set elements due to size (2 bytes) *)

CONST FOF_MULTIDESTFILES        = 0001h;
      FOF_CONFIRMMOUSE          = 0002h;
      FOF_SILENT                = 0004h; (* don't create progress/report *)
      FOF_RENAMEONCOLLISION     = 0008h;
      FOF_NOCONFIRMATION        = 0010h; (* Don't prompt the user. *)
      FOF_WANTMAPPINGHANDLE     = 0020h; (* Fill in SHFILEOPSTRUCT.hNameMappings *)
                                         (* Must be freed using SHFreeNameMappings *)
      FOF_ALLOWUNDO             = 0040h;
      FOF_FILESONLY             = 0080h; (* on *.*, do only files *)
      FOF_SIMPLEPROGRESS        = 0100h; (* means don't show names of files *)
      FOF_NOCONFIRMMKDIR        = 0200h; (* don't confirm making any needed dirs *)
      FOF_NOERRORUI             = 0400h; (* don't put up error UI *)

CONST PO_DELETE      = 0013h;  (* printer is being deleted *)
      PO_RENAME      = 0014h;  (* printer is being renamed *)
      PO_PORTCHANGE  = 0020h;  (* port this printer connected to is being changed *)
                               (* if this id is set, the strings received by *)
                               (* the copyhook are a doubly-null terminated *)
                               (* list of strings.  The first is the printer *)
                               (* name and the second is the printer port. *)
      PO_REN_PORT    = 0034h;  (* PO_RENAME and PO_PORTCHANGE at same time. *)

(* no POF_ flags currently defined *)

TYPE PRINTEROP_FLAGS = WORD;


(* implicit parameters are: *)
(*      if pFrom or pTo are unqualified names the current directories are *)
(*      taken from the global current drive/directory settings managed *)
(*      by Get/SetCurrentDrive/Directory *)
(* *)
(*      the global confirmation settings *)

TYPE SHFILEOPSTRUCTA = RECORD
                              hwnd                  : HWND;
                              wFunc                 : FO_ENUM;
                              pFrom                 : PCSTR;
                              pTo                   : PCSTR;
                              fFlags                : FILEOP_FLAGS;
                              fAnyOperationsAborted : BOOL;
                              hNameMappings         : PVOID;
                              lpszProgressTitle     : PCSTR; (* only used if FOF_SIMPLEPROGRESS *)
                       END;
    PSHFILEOPSTRUCTA = POINTER TO SHFILEOPSTRUCTA;

TYPE SHFILEOPSTRUCTW = RECORD
                              hwnd                  : HWND;
                              wFunc                 : FO_ENUM;
                              pFrom                 : PCWSTR;
                              pTo                   : PCWSTR;
                              fFlags                : FILEOP_FLAGS;
                              fAnyOperationsAborted : BOOL;
                              hNameMappings         : PVOID;
                              lpszProgressTitle     : PCWSTR; (* only used if FOF_SIMPLEPROGRESS *)
                       END;
    PSHFILEOPSTRUCTW = POINTER TO SHFILEOPSTRUCTW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  SHFILEOPSTRUCT =  SHFILEOPSTRUCTW;
      TYPE PSHFILEOPSTRUCT = PSHFILEOPSTRUCTW;
<* ELSE *>
      TYPE  SHFILEOPSTRUCT =  SHFILEOPSTRUCTA;
      TYPE PSHFILEOPSTRUCT = PSHFILEOPSTRUCTA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE SHFileOperationA (FileOp : SHFILEOPSTRUCTA) : INTEGER;
<* ELSE *>
PROCEDURE SHFileOperationA (FileOp : PSHFILEOPSTRUCTA) : INTEGER;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE SHFileOperationW (FileOp : SHFILEOPSTRUCTW) : INTEGER;
<* ELSE *>
PROCEDURE SHFileOperationW (FileOp : PSHFILEOPSTRUCTW) : INTEGER;
<* END *>

<* IF DEFINED (UNICODE) THEN *>
      CONST SHFileOperation = SHFileOperationW;
<* ELSE *>
      CONST SHFileOperation = SHFileOperationA;
<* END *>

PROCEDURE SHFreeNameMappings (hNameMappings : HANDLE);

TYPE SHNAMEMAPPINGA = RECORD
                             pszOldPath : PSTR;
                             pszNewPath : PSTR;
                             cchOldPath : INTEGER;
                             cchNewPath : INTEGER;
                      END;
    PSHNAMEMAPPINGA = POINTER TO SHNAMEMAPPINGA;

TYPE SHNAMEMAPPINGW = RECORD
                             pszOldPath : PWSTR;
                             pszNewPath : PWSTR;
                             cchOldPath : INTEGER;
                             cchNewPath : INTEGER;
                      END;
    PSHNAMEMAPPINGW = POINTER TO SHNAMEMAPPINGW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  SHNAMEMAPPING =  SHNAMEMAPPINGW;
      TYPE PSHNAMEMAPPING = PSHNAMEMAPPINGW;
<* ELSE *>
      TYPE  SHNAMEMAPPING =  SHNAMEMAPPINGA;
      TYPE PSHNAMEMAPPING = PSHNAMEMAPPINGA;
<* END *>


(***
**** End Shell File Operations
***)

(***
****  Begin ShellExecuteEx and family
***)

(* ShellExecute() and ShellExecuteEx() error codes *)

(* regular WinExec() codes *)

CONST SE_ERR_FNF             = 2;       (* file not found *)
      SE_ERR_PNF             = 3;       (* path not found *)
      SE_ERR_ACCESSDENIED    = 5;       (* access denied *)
      SE_ERR_OOM             = 8;       (* out of memory *)
      SE_ERR_DLLNOTFOUND     = 32;

(* error values for ShellExecute() beyond the regular WinExec() codes *)

CONST SE_ERR_SHARE           = 26;
      SE_ERR_ASSOCINCOMPLETE = 27;
      SE_ERR_DDETIMEOUT      = 28;
      SE_ERR_DDEFAIL         = 29;
      SE_ERR_DDEBUSY         = 30;
      SE_ERR_NOASSOC         = 31;

TYPE SEE_MASK_ENUM = (SEE_MASK__CLASSNAME,     (* 0 *)
                      SEE_MASK__CLASSKEY,      (* 1 *)
                      SEE_MASK__IDLIST,        (* 2 *)
                      SEE_MASK__INVOKEIDLIST,  (* 3 *)
                      SEE_MASK__ICON,          (* 4 *)
                      SEE_MASK__HOTKEY,        (* 5 *)
                      SEE_MASK__NOCLOSEPROCESS,(* 6 *)
                      SEE_MASK__CONNECTNETDRV, (* 7 *)
                      SEE_MASK__FLAG_DDEWAIT,  (* 8 *)
                      SEE_MASK__DOENVSUBST,    (* 9 *)
                      SEE_MASK__FLAG_NO_UI,    (* 10 *)
                      SEE_MASK__11,
                      SEE_MASK__12,
                      SEE_MASK__13,
                      SEE_MASK__UNICODE,       (* 14 *)
                      SEE_MASK__NO_CONSOLE,    (* 15 *)
                      SEE_MASK__16,
                      SEE_MASK__17,
                      SEE_MASK__18,
                      SEE_MASK__19,
                      SEE_MASK__ASYNCOK);      (* 20 *)

      SEE_MASK_SET = SET OF SEE_MASK_ENUM;

(* Note CLASSKEY overrides CLASSNAME *)

CONST SEE_MASK_CLASSNAME     = SEE_MASK_SET {SEE_MASK__CLASSNAME     }; (* 0x00000001 *)
      SEE_MASK_CLASSKEY      = SEE_MASK_SET {SEE_MASK__CLASSNAME,
                                             SEE_MASK__CLASSKEY      }; (* 0x00000003 *)

(* Note INVOKEIDLIST overrides IDLIST *)
      SEE_MASK_IDLIST        = SEE_MASK_SET {SEE_MASK__IDLIST        }; (* 0x00000004 *)
      SEE_MASK_INVOKEIDLIST  = SEE_MASK_SET {SEE_MASK__IDLIST,
                                             SEE_MASK__INVOKEIDLIST  }; (* 0x0000000c *)
      SEE_MASK_ICON          = SEE_MASK_SET {SEE_MASK__ICON          }; (* 0x00000010 *)
      SEE_MASK_HOTKEY        = SEE_MASK_SET {SEE_MASK__HOTKEY        }; (* 0x00000020 *)
      SEE_MASK_NOCLOSEPROCESS= SEE_MASK_SET {SEE_MASK__NOCLOSEPROCESS}; (* 0x00000040 *)
      SEE_MASK_CONNECTNETDRV = SEE_MASK_SET {SEE_MASK__CONNECTNETDRV }; (* 0x00000080 *)
      SEE_MASK_FLAG_DDEWAIT  = SEE_MASK_SET {SEE_MASK__FLAG_DDEWAIT  }; (* 0x00000100 *)
      SEE_MASK_DOENVSUBST    = SEE_MASK_SET {SEE_MASK__DOENVSUBST    }; (* 0x00000200 *)
      SEE_MASK_FLAG_NO_UI    = SEE_MASK_SET {SEE_MASK__FLAG_NO_UI    }; (* 0x00000400 *)
      SEE_MASK_UNICODE       = SEE_MASK_SET {SEE_MASK__UNICODE       }; (* 0x00004000 *)
      SEE_MASK_NO_CONSOLE    = SEE_MASK_SET {SEE_MASK__NO_CONSOLE    }; (* 0x00008000 *)
      SEE_MASK_ASYNCOK       = SEE_MASK_SET {SEE_MASK__ASYNCOK       }; (* 0x00100000 *)


TYPE SHELLEXECUTEINFOA = RECORD
                                cbSize       : DWORD;
                                fMask        : SEE_MASK_SET;
                                hwnd         : HWND;
                                lpVerb       : PCSTR;
                                lpFile       : PCSTR;
                                lpParameters : PCSTR;
                                lpDirectory  : PCSTR;
                                nShow        : SW_ENUM;
                                hInstApp     : HINSTANCE;
                         (* Optional fields *)
                                lpIDList     : PVOID;
                                lpClass      : PCSTR;
                                hkeyClass    : HKEY;
                                dwHotKey     : DWORD;
                                hIcon        : HANDLE;
                                hProcess     : HANDLE;
                         END;
    PSHELLEXECUTEINFOA = POINTER TO SHELLEXECUTEINFOA;

TYPE SHELLEXECUTEINFOW = RECORD
                                cbSize       : DWORD;
                                fMask        : SEE_MASK_SET;
                                hwnd         : HWND;
                                lpVerb       : PCWSTR;
                                lpFile       : PCWSTR;
                                lpParameters : PCWSTR;
                                lpDirectory  : PCWSTR;
                                nShow        : SW_ENUM;
                                hInstApp     : HINSTANCE;
                         (* Optional fields *)
                                lpIDList     : PVOID;
                                lpClass      : PCWSTR;
                                hkeyClass    : HKEY;
                                dwHotKey     : DWORD;
                                hIcon        : HANDLE;
                                hProcess     : HANDLE;
                         END;
    PSHELLEXECUTEINFOW = POINTER TO SHELLEXECUTEINFOW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  SHELLEXECUTEINFO =  SHELLEXECUTEINFOW;
      TYPE PSHELLEXECUTEINFO = PSHELLEXECUTEINFOW;
<* ELSE *>
      TYPE  SHELLEXECUTEINFO =  SHELLEXECUTEINFOA;
      TYPE PSHELLEXECUTEINFO = PSHELLEXECUTEINFOA;
<* END *>

PROCEDURE ShellExecuteExA (VAR ExecInfo : SHELLEXECUTEINFOA) : BOOL;
PROCEDURE ShellExecuteExW (VAR ExecInfo : SHELLEXECUTEINFOW) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ShellExecuteEx = ShellExecuteExW;
<* ELSE *>
      CONST ShellExecuteEx = ShellExecuteExA;
<* END *>

(***
****  End ShellExecuteEx and family
***)


(***
**** Tray notification definitions
***)


TYPE NIF_ENUM = (NIF__MESSAGE, (* 0 *)
                 NIF__ICON,    (* 1 *)
                 NIF__TIP);    (* 2 *)

     NIF_SET = SET OF NIF_ENUM;

CONST NIF_MESSAGE = NIF_SET {NIF__MESSAGE}; (* 0x00000001 *)
      NIF_ICON    = NIF_SET {NIF__ICON};    (* 0x00000002 *)
      NIF_TIP     = NIF_SET {NIF__TIP};     (* 0x00000004 *)

TYPE NOTIFYICONDATAA  = RECORD
                               cbSize           : DWORD;
                               hWnd             : HWND;
                               uID              : UINT;
                               uFlags           : NIF_SET;
                               uCallbackMessage : UINT;
                               hIcon            : HICON;
                               szTip            : ARRAY [0..63] OF CHAR;
                        END;
     PNOTIFYICONDATAA = POINTER TO NOTIFYICONDATAA;

TYPE NOTIFYICONDATAW  = RECORD
                               cbSize           : DWORD;
                               hWnd             : HWND;
                               uID              : UINT;
                               uFlags           : NIF_SET;
                               uCallbackMessage : UINT;
                               hIcon            : HICON;
                               szTip            : ARRAY [0..63] OF WCHAR;
                        END;
     PNOTIFYICONDATAW = POINTER TO NOTIFYICONDATAW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  NOTIFYICONDATA =  NOTIFYICONDATAW;
      TYPE PNOTIFYICONDATA = PNOTIFYICONDATAW;
<* ELSE *>
      TYPE  NOTIFYICONDATA =  NOTIFYICONDATAA;
      TYPE PNOTIFYICONDATA = PNOTIFYICONDATAA;
<* END *>

TYPE NIM_ENUM = (NIM_ADD,     (* 0x00000000 *)
                 NIM_MODIFY,  (* 0x00000001 *)
                 NIM_DELETE); (* 0x00000002 *)

PROCEDURE Shell_NotifyIconA (dwMessage : NIM_ENUM; VAR Data : NOTIFYICONDATAA) : BOOL;
PROCEDURE Shell_NotifyIconW (dwMessage : NIM_ENUM; VAR Data : NOTIFYICONDATAW) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST Shell_NotifyIcon = Shell_NotifyIconW;
<* ELSE *>
      CONST Shell_NotifyIcon = Shell_NotifyIconA;
<* END *>

(***
**** End Tray Notification Icons
***)


(***
**** Begin SHGetFileInfo
***)

(*
 * The SHGetFileInfo API provides an easy way to get attributes
 * for a file given a pathname.
 *
 *   PARAMETERS
 *
 *     pszPath              file name to get info about
 *     dwFileAttributes     file attribs, only used with SHGFI_USEFILEATTRIBUTES
 *     psfi                 place to return file info
 *     cbFileInfo           size of structure
 *     uFlags               flags
 *
 *   RETURN
 *     TRUE if things worked
 *)

TYPE SHFILEINFOA = RECORD
                          hIcon         : HICON;                         (* out: icon *)
                          iIcon         : INTEGER;                       (* out: icon index *)
                          dwAttributes  : DWORD;                         (* out: SFGAO_ flags *)
                          szDisplayName : ARRAY [0..MAX_PATH-1] OF CHAR; (* out: display name (or path) *)
                          szTypeName    : ARRAY [0..79] OF CHAR;         (* out: type name *)
                   END;

TYPE SHFILEINFOW = RECORD
                          hIcon         : HICON;                          (* out: icon *)
                          iIcon         : INTEGER;                        (* out: icon index *)
                          dwAttributes  : DWORD;                          (* out: SFGAO_ flags *)
                          szDisplayName : ARRAY [0..MAX_PATH-1] OF WCHAR; (* out: display name (or path) *)
                          szTypeName    : ARRAY [0..79] OF WCHAR;         (* out: type name *)
                   END;

<* IF DEFINED (UNICODE) THEN *>
      TYPE SHFILEINFO = SHFILEINFOW;
<* ELSE *>
      TYPE SHFILEINFO = SHFILEINFOA;
<* END *>

TYPE SHGFI_ENUM = (SHGFI__SMALLICON,         (*  0 - get small icon *)
                   SHGFI__OPENICON,          (*  1 - get open icon *)
                   SHGFI__SHELLICONSIZE,     (*  2 - get shell size icon *)
                   SHGFI__PIDL,              (*  3 - pszPath is a pidl *)
                   SHGFI__USEFILEATTRIBUTES, (*  4 - use passed dwFileAttribute *)
                   SHGFI__5,
                   SHGFI__6,
                   SHGFI__7,
                   SHGFI__ICON,              (*  8 - get icon *)
                   SHGFI__DISPLAYNAME,       (*  9 - get display name *)
                   SHGFI__TYPENAME,          (* 10 - get type name *)
                   SHGFI__ATTRIBUTES,        (* 11 - get attributes *)
                   SHGFI__ICONLOCATION,      (* 12 - get icon location *)
                   SHGFI__EXETYPE,           (* 13 - return exe type *)
                   SHGFI__SYSICONINDEX,      (* 14 - get system icon index *)
                   SHGFI__LINKOVERLAY,       (* 15 - put a link overlay on icon *)
                   SHGFI__SELECTED );        (* 16 - show icon in selected state *)
      SHGFI_SET = SET OF SHGFI_ENUM;

CONST SHGFI_ICON             = SHGFI_SET {SHGFI__ICON             }; (* 0x000000100 *)
      SHGFI_DISPLAYNAME      = SHGFI_SET {SHGFI__DISPLAYNAME      }; (* 0x000000200 *)
      SHGFI_TYPENAME         = SHGFI_SET {SHGFI__TYPENAME         }; (* 0x000000400 *)
      SHGFI_ATTRIBUTES       = SHGFI_SET {SHGFI__ATTRIBUTES       }; (* 0x000000800 *)
      SHGFI_ICONLOCATION     = SHGFI_SET {SHGFI__ICONLOCATION     }; (* 0x000001000 *)
      SHGFI_EXETYPE          = SHGFI_SET {SHGFI__EXETYPE          }; (* 0x000002000 *)
      SHGFI_SYSICONINDEX     = SHGFI_SET {SHGFI__SYSICONINDEX     }; (* 0x000004000 *)
      SHGFI_LINKOVERLAY      = SHGFI_SET {SHGFI__LINKOVERLAY      }; (* 0x000008000 *)
      SHGFI_SELECTED         = SHGFI_SET {SHGFI__SELECTED         }; (* 0x000010000 *)
      SHGFI_LARGEICON        = SHGFI_SET {};                      (* 0x000000000 *)
      SHGFI_SMALLICON        = SHGFI_SET {SHGFI__SMALLICON        }; (* 0x000000001 *)
      SHGFI_OPENICON         = SHGFI_SET {SHGFI__OPENICON         }; (* 0x000000002 *)
      SHGFI_SHELLICONSIZE    = SHGFI_SET {SHGFI__SHELLICONSIZE    }; (* 0x000000004 *)
      SHGFI_PIDL             = SHGFI_SET {SHGFI__PIDL             }; (* 0x000000008 *)
      SHGFI_USEFILEATTRIBUTES= SHGFI_SET {SHGFI__USEFILEATTRIBUTES}; (* 0x000000010 *)

PROCEDURE SHGetFileInfoA (pszPath          : PCSTR;
                          dwFileAttributes : FILE_ATTRIBUTE_SET;
                          VAR fi           : SHFILEINFO;
                          cbFileInfo       : UINT;
                          uFlags           : SHGFI_SET) : DWORD;

PROCEDURE SHGetFileInfoW (pszPath          : PCWSTR;
                          dwFileAttributes : FILE_ATTRIBUTE_SET;
                          VAR fi           : SHFILEINFO;
                          cbFileInfo       : UINT;
                          uFlags           : SHGFI_SET) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST SHGetFileInfo = SHGetFileInfoW;
<* ELSE *>
      CONST SHGetFileInfo = SHGetFileInfoA;
<* END *>

TYPE SHGNLI_ENUM = (SHGNLI__PIDL,        (* 0 - pszLinkTo is a pidl *)
                    SHGNLI__PREFIXNAME); (* 1 - Make name "Shortcut to xxx" *)

     SHGNLI_SET = SET OF SHGNLI_ENUM;

CONST SHGNLI_PIDL       = SHGNLI_SET {SHGNLI__PIDL};       (* 0x000000001 *)
      SHGNLI_PREFIXNAME = SHGNLI_SET {SHGNLI__PREFIXNAME}; (* 0x000000002 *)

PROCEDURE SHGetNewLinkInfoA (pszLinkTo    : PCSTR;
                             pszDir       : PCSTR;
                             pszName      : PSTR;
                             VAR MustCopy : BOOL;
                             uFlags       : SHGNLI_SET) : BOOL;

PROCEDURE SHGetNewLinkInfoW (pszLinkTo    : PCWSTR;
                             pszDir       : PCWSTR;
                             pszName      : PWSTR;
                             VAR MustCopy : BOOL;
                             uFlags       : SHGNLI_SET) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST SHGetNewLinkInfo = SHGetNewLinkInfoW;
<* ELSE *>
      CONST SHGetNewLinkInfo = SHGetNewLinkInfoA;
<* END *>

(***
**** End SHGetFileInfo
***)

<* POP *> (* back to alignment = 8 *)


(*  WinPerf.def

    Definition file for the Performance Monitor data.

    This file contains the definitions of the data structures returned
    by the Configuration Registry in response to a request for
    performance data.  This file is used by both the Configuration
    Registry and the Performance Monitor to define their interface.
    The complete interface is described here, except for the name
    of the node to query in the registry.  It is

                   HKEY_PERFORMANCE_DATA.

    By querying that node with a subkey of "Global" the caller will
    retrieve the structures described here.

    There is no need to RegOpenKey() the reserved handle HKEY_PERFORMANCE_DATA,
    but the caller should RegCloseKey() the handle so that network transports
    and drivers can be removed or installed (which cannot happen while
    they are open for monitoring.)  Remote requests must first
    RegConnectRegistry().

*)


(*  Data structure definitions.

**  In order for data to be returned through the Configuration Registry
**  in a system-independent fashion, it must be self-describing.

**  In the following, all offsets are in bytes.

**
**  Data is returned through the Configuration Registry in a
**  a data block which begins with a _PERF_DATA_BLOCK structure.
*)


CONST PERF_DATA_VERSION  = 1;
      PERF_DATA_REVISION = 1;

TYPE PERF_DATA_BLOCK =
     RECORD
            Signature        : ARRAY [0..3] OF WCHAR; (* Signature: Unicode "PERF" *)
            LittleEndian     : BOOL;                  (* 0 = Big Endian, 1 = Little Endian *)
            Version          : DWORD;                 (* Version of these data structures *)
                                                      (* starting at 1 *)
            Revision         : DWORD;                 (* Revision of these data structures *)
                                                      (* starting at 0 for each Version *)
            TotalByteLength  : DWORD;                 (* Total length of data block *)
            HeaderLength     : DWORD;                 (* Length of this structure *)
            NumObjectTypes   : DWORD;                 (* Number of types of objects *)
                                                      (* being reported *)
            DefaultObject    : LONG;                  (* Object Title Index of default *)
                                                      (* object to display when data from *)
                                                      (* this system is retrieved (-1 = *)
                                                      (* none, but this is not expected to *)
                                                      (* be used) *)
            SystemTime       : SYSTEMTIME;            (* Time at the system under *)
                                                      (* measurement *)
            PerfTime         : LARGE_INTEGER;         (* Performance counter value *)
                                                      (* at the system under measurement *)
            PerfFreq         : LARGE_INTEGER;         (* Performance counter frequency *)
                                                      (* at the system under measurement *)
            PerfTime100nSec  : LARGE_INTEGER;         (* Performance counter time in 100 nsec *)
                                                      (* units at the system under measurement *)
            SystemNameLength : DWORD;                 (* Length of the system name *)
            SystemNameOffset : DWORD;                 (* Offset, from beginning of this *)
                                                      (* structure, to name of system *)
                                                      (* being measured *)
    END;
    PPERF_DATA_BLOCK = POINTER TO PERF_DATA_BLOCK;

(*
**  The PERF_DATA_BLOCK structure is followed by NumObjectTypes of
**  data sections, one for each type of object measured.  Each object
**  type section begins with a PERF_OBJECT_TYPE structure.
*)


(*
**  The following are used to determine the level of detail associated
**  with the counter.  The user will be setting the level of detail
**  that should be displayed at any given time.
*)

TYPE PERF_DETAIL_TYPE = DWORD;

CONST PERF_DETAIL_NOVICE   = VAL (PERF_DETAIL_TYPE, 100); (* The uninformed can understand it *)
      PERF_DETAIL_ADVANCED = VAL (PERF_DETAIL_TYPE, 200); (* For the advanced user *)
      PERF_DETAIL_EXPERT   = VAL (PERF_DETAIL_TYPE, 300); (* For the expert user *)
      PERF_DETAIL_WIZARD   = VAL (PERF_DETAIL_TYPE, 400); (* For the system designer *)


TYPE PERF_OBJECT_TYPE =
     RECORD
            TotalByteLength      : DWORD;            (* Length of this object definition *)
                                                     (* including this structure, the *)
                                                     (* counter definitions, and the *)
                                                     (* instance definitions and the *)
                                                     (* counter blocks for each instance: *)
                                                     (* This is the offset from this *)
                                                     (* structure to the next object, if *)
                                                     (* any *)
            DefinitionLength     : DWORD;            (* Length of object definition, *)
                                                     (* which includes this structure *)
                                                     (* and the counter definition *)
                                                     (* structures for this object: this *)
                                                     (* is the offset of the first *)
                                                     (* instance or of the counters *)
                                                     (* for this object if there is *)
                                                     (* no instance *)
            HeaderLength         : DWORD;            (* Length of this structure: this *)
                                                     (* is the offset to the first *)
                                                     (* counter definition for this *)
                                                     (* object *)
            ObjectNameTitleIndex : DWORD;            (* Index to name in Title Database *)
            ObjectNameTitle      : PWSTR;            (* Initially NULL, for use by *)
                                                     (* analysis program to point to *)
                                                     (* retrieved title string *)
            ObjectHelpTitleIndex : DWORD;            (* Index to Help in Title Database *)
            ObjectHelpTitle      : PWSTR;            (* Initially NULL, for use by *)
                                                     (* analysis program to point to *)
                                                     (* retrieved title string *)
            DetailLevel          : PERF_DETAIL_TYPE; (* Object level of detail (for *)
                                                     (* controlling display complexity); *)
                                                     (* will be min of detail levels *)
                                                     (* for all this object's counters *)
            NumCounters          : DWORD;            (* Number of counters in each *)
                                                     (* counter block (one counter *)
                                                     (* block per instance) *)
            DefaultCounter       : LONG;             (* Default counter to display when *)
                                                     (* this object is selected, index *)
                                                     (* starting at 0 (-1 = none, but *)
                                                     (* this is not expected to be used) *)
            NumInstances         : LONG;             (* Number of object instances *)
                                                     (* for which counters are being *)
                                                     (* returned from the system under *)
                                                     (* measurement. If the object defined *)
                                                     (* will never have any instance data *)
                                                     (* structures (PERF_INSTANCE_DEFINITION) *)
                                                     (* then this value should be -1, if the *)
                                                     (* object can have 0 or more instances, *)
                                                     (* but has none present, then this *)
                                                     (* should be 0, otherwise this field *)
                                                     (* contains the number of instances of *)
                                                     (* this counter. *)
            CodePage             : DWORD;            (* 0 if instance strings are in *)
                                                     (* UNICODE, else the Code Page of *)
                                                     (* the instance names *)
            PerfTime             : LARGE_INTEGER;    (* Sample Time in "Object" units *)
            PerfFreq             : LARGE_INTEGER;    (* Frequency of "Object" units in *)
                                                     (* counts per second. *)
     END;
     PPERF_OBJECT_TYPE = POINTER TO PERF_OBJECT_TYPE;

CONST PERF_NO_INSTANCES  = -1;  (* no instances (see NumInstances above) *)

(*
** - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
**
**  PERF_COUNTER_DEFINITION.CounterType field values
**
**
**        Counter ID Field Definition:
**
**   3      2        2    2    2        1        1    1
**   1      8        4    2    0        6        2    0    8                0
**  +--------+--------+----+----+--------+--------+----+----+----------------+
**  |Display |Calculation  |Time|Counter |        |Ctr |Size|                |
**  |Flags   |Modifiers    |Base|SubType |Reserved|Type|Fld |   Reserved     |
**  +--------+--------+----+----+--------+--------+----+----+----------------+
**
**
**  The counter type is the "or" of the following values as described below
**
**  select one of the following to indicate the counter's data size
*)

CONST PERF_SIZE_DWORD         = 00000000h;
      PERF_SIZE_LARGE         = 00000100h;
      PERF_SIZE_ZERO          = 00000200h;  (* for Zero Length fields *)
      PERF_SIZE_VARIABLE_LEN  = 00000300h;  (* length is in CounterLength field *)
                                            (*  of Counter Definition struct *)
(*
**  select one of the following values to indicate the counter field usage
*)
      PERF_TYPE_NUMBER        = 00000000h;  (* a number (not a counter) *)
      PERF_TYPE_COUNTER       = 00000400h;  (* an increasing numeric value *)
      PERF_TYPE_TEXT          = 00000800h;  (* a text field *)
      PERF_TYPE_ZERO          = 00000C00h;  (* displays a zero *)
(*
**  If the PERF_TYPE_NUMBER field was selected, then select one of the
**  following to describe the Number
*)
      PERF_NUMBER_HEX         = 00000000h;  (* display as HEX value *)
      PERF_NUMBER_DECIMAL     = 00010000h;  (* display as a decimal integer *)
      PERF_NUMBER_DEC_1000    = 00020000h;  (* display as a decimal/1000 *)
(*
**  If the PERF_TYPE_COUNTER value was selected then select one of the
**  following to indicate the type of counter
*)
      PERF_COUNTER_VALUE      = 00000000h;  (* display counter value *)
      PERF_COUNTER_RATE       = 00010000h;  (* divide ctr / delta time *)
      PERF_COUNTER_FRACTION   = 00020000h;  (* divide ctr / base *)
      PERF_COUNTER_BASE       = 00030000h;  (* base value used in fractions *)
      PERF_COUNTER_ELAPSED    = 00040000h;  (* subtract counter from current time *)
      PERF_COUNTER_QUEUELEN   = 00050000h;  (* Use Queuelen processing func. *)
      PERF_COUNTER_HISTOGRAM  = 00060000h;  (* Counter begins or ends a histogram *)
(*
**  If the PERF_TYPE_TEXT value was selected, then select one of the
**  following to indicate the type of TEXT data.
*)
      PERF_TEXT_UNICODE       = 00000000h;  (* type of text in text field *)
      PERF_TEXT_ASCII         = 00010000h;  (* ASCII using the CodePage field *)
(*
**  Timer SubTypes
*)
      PERF_TIMER_TICK         = 00000000h;  (* use system perf. freq for base *)
      PERF_TIMER_100NS        = 00100000h;  (* use 100 NS timer time base units *)
      PERF_OBJECT_TIMER       = 00200000h;  (* use the object timer freq *)
(*
**  Any types that have calculations performed can use one or more of
**  the following calculation modification flags listed here
*)
      PERF_DELTA_COUNTER      = 00400000h;  (* compute difference first *)
      PERF_DELTA_BASE         = 00800000h;  (* compute base diff as well *)
      PERF_INVERSE_COUNTER    = 01000000h;  (* show as 1.00-value (assumes: *)
      PERF_MULTI_COUNTER      = 02000000h;  (* sum of multiple instances *)
(*
**  Select one of the following values to indicate the display suffix (if any)
*)
      PERF_DISPLAY_NO_SUFFIX  = 00000000h;  (* no suffix *)
      PERF_DISPLAY_PER_SEC    = 10000000h;  (* "/sec" *)
      PERF_DISPLAY_PERCENT    = 20000000h;  (* "%" *)
      PERF_DISPLAY_SECONDS    = 30000000h;  (* "secs" *)
      PERF_DISPLAY_NOSHOW     = 40000000h;  (* value is not displayed *)
(*
**  Predefined counter types
*)

CONST

(* 32-bit Counter.  Divide delta by delta time.  Display suffix: "/sec" *)
      PERF_COUNTER_COUNTER =
            PERF_SIZE_DWORD + PERF_TYPE_COUNTER + PERF_COUNTER_RATE +
            PERF_TIMER_TICK + PERF_DELTA_COUNTER + PERF_DISPLAY_PER_SEC;


(* 64-bit Timer.  Divide delta by delta time.  Display suffix: "%" *)
      PERF_COUNTER_TIMER =
            PERF_SIZE_LARGE + PERF_TYPE_COUNTER + PERF_COUNTER_RATE +
            PERF_TIMER_TICK + PERF_DELTA_COUNTER + PERF_DISPLAY_PERCENT;

(* Queue Length Space-Time Product. Divide delta by delta time. No Display Suffix. *)
      PERF_COUNTER_QUEUELEN_TYPE =
            PERF_SIZE_DWORD + PERF_TYPE_COUNTER + PERF_COUNTER_QUEUELEN +
            PERF_TIMER_TICK + PERF_DELTA_COUNTER + PERF_DISPLAY_NO_SUFFIX;

(* 64-bit Counter.  Divide delta by delta time. Display Suffix: "/sec" *)
      PERF_COUNTER_BULK_COUNT =
            PERF_SIZE_LARGE + PERF_TYPE_COUNTER + PERF_COUNTER_RATE +
            PERF_TIMER_TICK + PERF_DELTA_COUNTER + PERF_DISPLAY_PER_SEC;

(* Indicates the counter is not a  counter but rather Unicode text Display as text. *)
      PERF_COUNTER_TEXT =
            PERF_SIZE_VARIABLE_LEN + PERF_TYPE_TEXT + PERF_TEXT_UNICODE +
            PERF_DISPLAY_NO_SUFFIX;

(* Indicates the data is a counter  which should not be
** time averaged on display such as an error counter on a serial line;
** Display as is.  No Display Suffix.
*)
      PERF_COUNTER_RAWCOUNT =
            PERF_SIZE_DWORD + PERF_TYPE_NUMBER + PERF_NUMBER_DECIMAL +
            PERF_DISPLAY_NO_SUFFIX;

(* Same as PERF_COUNTER_RAWCOUNT except its size is a large integer *)
      PERF_COUNTER_LARGE_RAWCOUNT =
            PERF_SIZE_LARGE + PERF_TYPE_NUMBER + PERF_NUMBER_DECIMAL +
            PERF_DISPLAY_NO_SUFFIX;

(* Special case for RAWCOUNT that want to be displayed in hex
** Indicates the data is a counter  which should not be
** time averaged on display such as an error counter on a serial line;
** Display as is.  No Display Suffix.
*)
      PERF_COUNTER_RAWCOUNT_HEX =
            PERF_SIZE_DWORD + PERF_TYPE_NUMBER + PERF_NUMBER_HEX +
            PERF_DISPLAY_NO_SUFFIX;

(* Same as PERF_COUNTER_RAWCOUNT_HEX except its size is a large integer *)
      PERF_COUNTER_LARGE_RAWCOUNT_HEX =
            PERF_SIZE_LARGE + PERF_TYPE_NUMBER + PERF_NUMBER_HEX +
            PERF_DISPLAY_NO_SUFFIX;


(* A count which is either 1 or 0 on each sampling interrupt % busy;
** Divide delta by delta base. Display Suffix: "%"
*)
      PERF_SAMPLE_FRACTION =
            PERF_SIZE_DWORD + PERF_TYPE_COUNTER + PERF_COUNTER_FRACTION +
            PERF_DELTA_COUNTER + PERF_DELTA_BASE + PERF_DISPLAY_PERCENT;

(* A count which is sampled on each sampling interrupt queue length;
** Divide delta by delta time. No Display Suffix.
*)
      PERF_SAMPLE_COUNTER =
            PERF_SIZE_DWORD + PERF_TYPE_COUNTER + PERF_COUNTER_RATE +
            PERF_TIMER_TICK + PERF_DELTA_COUNTER + PERF_DISPLAY_NO_SUFFIX;

(* A label: no data is associated with this counter it has 0 length;
** Do not display.
*)
      PERF_COUNTER_NODATA =
            PERF_SIZE_ZERO + PERF_DISPLAY_NOSHOW;

(* 64-bit Timer inverse e.g., idle is measured, but display busy %;
** Display 100 - delta divided by delta time.  Display suffix: "%"
*)
      PERF_COUNTER_TIMER_INV =
            PERF_SIZE_LARGE + PERF_TYPE_COUNTER + PERF_COUNTER_RATE +
            PERF_TIMER_TICK + PERF_DELTA_COUNTER + PERF_INVERSE_COUNTER +
            PERF_DISPLAY_PERCENT;

(* The divisor for a sample, used with the previous counter to form a
** sampled %.  You must check for >0 before dividing by this!  This
** counter will directly follow the  numerator counter.  It should not
** be displayed to the user.
*)
      PERF_SAMPLE_BASE =
            PERF_SIZE_DWORD + PERF_TYPE_COUNTER + PERF_COUNTER_BASE +
            PERF_DISPLAY_NOSHOW +
            1;           (* for compatibility with pre-beta versions *)

(* A timer which, when divided by an average base, produces a time
** in seconds which is the average time of some operation.  This
** timer times total operations, and  the base is the number of opera-
** tions.  Display Suffix: "sec"
*)
      PERF_AVERAGE_TIMER =
            PERF_SIZE_DWORD + PERF_TYPE_COUNTER + PERF_COUNTER_FRACTION +
            PERF_DISPLAY_SECONDS;

(* Used as the denominator in the computation of time or count
** averages.  Must directly follow the numerator counter.  Not dis-
** played to the user.
*)
      PERF_AVERAGE_BASE =
            PERF_SIZE_DWORD + PERF_TYPE_COUNTER + PERF_COUNTER_BASE +
            PERF_DISPLAY_NOSHOW +
            00000002h;  (* for compatibility with pre-beta versions *)


(* A bulk count which, when divided typically; by the number of
** operations, gives typically; the number of bytes per operation.
** No Display Suffix.
*)
      PERF_AVERAGE_BULK =
            PERF_SIZE_LARGE + PERF_TYPE_COUNTER + PERF_COUNTER_FRACTION  +
            PERF_DISPLAY_NOSHOW;

(* 64-bit Timer in 100 nsec units. Display delta divided by
** delta time.  Display suffix: "%"
*)
      PERF_100NSEC_TIMER =
            PERF_SIZE_LARGE + PERF_TYPE_COUNTER + PERF_COUNTER_RATE +
            PERF_TIMER_100NS + PERF_DELTA_COUNTER + PERF_DISPLAY_PERCENT;

(* 64-bit Timer inverse e.g., idle is measured, but display busy %;
** Display 100 - delta divided by delta time.  Display suffix: "%"
*)
      PERF_100NSEC_TIMER_INV =
            PERF_SIZE_LARGE + PERF_TYPE_COUNTER + PERF_COUNTER_RATE +
            PERF_TIMER_100NS + PERF_DELTA_COUNTER + PERF_INVERSE_COUNTER  +
            PERF_DISPLAY_PERCENT;

(* 64-bit Timer.  Divide delta by delta time.  Display suffix: "%"
** Timer for multiple instances, so result can exceed 100%.
*)
      PERF_COUNTER_MULTI_TIMER =
            PERF_SIZE_LARGE + PERF_TYPE_COUNTER + PERF_COUNTER_RATE +
            PERF_DELTA_COUNTER + PERF_TIMER_TICK + PERF_MULTI_COUNTER +
            PERF_DISPLAY_PERCENT;

(* 64-bit Timer inverse e.g., idle is measured, but display busy %;
** Display 100 * _MULTI_BASE - delta divided by delta time.
** Display suffix: "%" Timer for multiple instances, so result
** can exceed 100%.  Followed by a counter of type _MULTI_BASE.
*)
      PERF_COUNTER_MULTI_TIMER_INV =
            PERF_SIZE_LARGE + PERF_TYPE_COUNTER + PERF_COUNTER_RATE +
            PERF_DELTA_COUNTER + PERF_MULTI_COUNTER + PERF_TIMER_TICK +
            PERF_INVERSE_COUNTER + PERF_DISPLAY_PERCENT;

(* Number of instances to which the preceding _MULTI_..._INV counter
** applies.  Used as a factor to get the percentage.
*)
      PERF_COUNTER_MULTI_BASE =
            PERF_SIZE_LARGE + PERF_TYPE_COUNTER + PERF_COUNTER_BASE +
            PERF_MULTI_COUNTER + PERF_DISPLAY_NOSHOW;

(* 64-bit Timer in 100 nsec units. Display delta divided by delta time.
** Display suffix: "%" Timer for multiple instances, so result can exceed 100%.
*)
      PERF_100NSEC_MULTI_TIMER =
            PERF_SIZE_LARGE + PERF_TYPE_COUNTER + PERF_DELTA_COUNTER  +
            PERF_COUNTER_RATE + PERF_TIMER_100NS + PERF_MULTI_COUNTER +
            PERF_DISPLAY_PERCENT;

(* 64-bit Timer inverse e.g., idle is measured, but display busy %;
** Display 100 * _MULTI_BASE - delta divided by delta time.
** Display suffix: "%" Timer for multiple instances, so result
** can exceed 100%.  Followed by a counter of type _MULTI_BASE.
*)
      PERF_100NSEC_MULTI_TIMER_INV =
            PERF_SIZE_LARGE + PERF_TYPE_COUNTER + PERF_DELTA_COUNTER  +
            PERF_COUNTER_RATE + PERF_TIMER_100NS + PERF_MULTI_COUNTER +
            PERF_INVERSE_COUNTER + PERF_DISPLAY_PERCENT;

(* Indicates the data is a fraction of the following counter  which
** should not be time averaged on display such as free space over
** total space.; Display as is.  Display the quotient as "%".
*)
      PERF_RAW_FRACTION =
            PERF_SIZE_DWORD + PERF_TYPE_COUNTER + PERF_COUNTER_FRACTION +
            PERF_DISPLAY_PERCENT;

(* Indicates the data is a base for the preceding counter which should
** not be time averaged on display such as free space over total space.;
*)
      PERF_RAW_BASE =
            PERF_SIZE_DWORD + PERF_TYPE_COUNTER + PERF_COUNTER_BASE +
            PERF_DISPLAY_NOSHOW +
            3;  (* for compatibility with pre-beta versions *)

(* The data collected in this counter is actually the start time of the
** item being measured. For display, this data is subtracted from the
** sample time to yield the elapsed time as the difference between the two.
** In the definition below, the PerfTime field of the Object contains
** the sample time as indicated by the PERF_OBJECT_TIMER bit and the
** difference is scaled by the PerfFreq of the Object to convert the time
** units into seconds.
*)
      PERF_ELAPSED_TIME =
            PERF_SIZE_LARGE + PERF_TYPE_COUNTER + PERF_COUNTER_ELAPSED +
            PERF_OBJECT_TIMER + PERF_DISPLAY_SECONDS;
(*
**  The following counter type can be used with the preceding types to
**  define a range of values to be displayed in a histogram.
*)

      PERF_COUNTER_HISTOGRAM_TYPE = 80000000h; (* Counter begins or ends a histogram *)
(*
**  This counter is used to display the difference from one sample
**  to the next. The counter value is a constantly increasing number
**  and the value displayed is the difference between the current
**  value and the previous value. Negative numbers are not allowed
**  which shouldn't be a problem as long as the counter value is
**  increasing or unchanged.
*)

      PERF_COUNTER_DELTA =
            PERF_SIZE_DWORD + PERF_TYPE_COUNTER + PERF_COUNTER_VALUE +
            PERF_DELTA_COUNTER + PERF_DISPLAY_NO_SUFFIX;

      PERF_COUNTER_LARGE_DELTA =
            PERF_SIZE_LARGE + PERF_TYPE_COUNTER + PERF_COUNTER_VALUE +
            PERF_DELTA_COUNTER + PERF_DISPLAY_NO_SUFFIX;

(*
**  There is one of the following for each of the
**  PERF_OBJECT_TYPE.NumCounters.  The Unicode names in this structure MUST
**  come from a message file.
*)

TYPE PERF_COUNTER_DEFINITION =
     RECORD
            ByteLength            : DWORD; (* Length in bytes of this structure *)
            CounterNameTitleIndex : DWORD; (* Index of Counter name into *)
                                           (* Title Database *)
            CounterNameTitle      : PWSTR; (* Initially NULL, for use by *)
                                           (* analysis program to point to *)
                                           (* retrieved title string *)
            CounterHelpTitleIndex : DWORD; (* Index of Counter Help into *)
                                           (* Title Database *)
            CounterHelpTitle      : PWSTR; (* Initially NULL, for use by *)
                                           (* analysis program to point to *)
                                           (* retrieved title string *)
            DefaultScale          : LONG;  (* Power of 10 by which to scale *)
                                           (* chart line if vertical axis is 100 *)
                                           (* 0 ==> 1, 1 ==> 10, -1 ==>1/10, etc. *)
            DetailLevel           : DWORD; (* Counter level of detail (for *)
                                           (* controlling display complexity) *)
            CounterType           : DWORD; (* Type of counter *)
            CounterSize           : DWORD; (* Size of counter in bytes *)
            CounterOffset         : DWORD; (* Offset from the start of the *)
                                           (* PERF_COUNTER_BLOCK to the first *)
                                           (* byte of this counter *)
     END;
     PPERF_COUNTER_DEFINITION = POINTER TO PERF_COUNTER_DEFINITION;

(*
**  If (PERF_DATA_BLOCK.NumInstances >= 0) then there will be
**  PERF_DATA_BLOCK.NumInstances of a (PERF_INSTANCE_DEFINITION
**  followed by a PERF_COUNTER_BLOCK followed by the counter data fields)
**  for each instance.
**
**  If (PERF_DATA_BLOCK.NumInstances < 0) then the counter definition
**  strucutre above will be followed by only a PERF_COUNTER_BLOCK and the
**  counter data for that COUNTER.
*)

CONST PERF_NO_UNIQUE_ID = -1;

TYPE PERF_INSTANCE_DEFINITION =
     RECORD
            ByteLength             : DWORD; (* Length in bytes of this structure, *)
                                            (* including the subsequent name *)
            ParentObjectTitleIndex : DWORD;
                                            (* Title Index to name of "parent" *)
                                            (* object (e.g., if thread, then *)
                                            (* process is parent object type); *)
                                            (* if logical drive, the physical *)
                                            (* drive is parent object type *)
            ParentObjectInstance   : DWORD;
                                            (* Index to instance of parent object *)
                                            (* type which is the parent of this *)
                                            (* instance. *)
            UniqueID               : LONG;
                                            (* A unique ID used instead of *)
                                            (* matching the name to identify *)
                                            (* this instance, -1 = none *)
            NameOffset             : DWORD;
                                            (* Offset from beginning of *)
                                            (* this struct to the Unicode name *)
                                            (* of this instance *)
            NameLength             : DWORD;
                                            (* Length in bytes of name; 0 = none *)

     END;
     PPERF_INSTANCE_DEFINITION = POINTER TO PERF_INSTANCE_DEFINITION;

(*
**  If .ParentObjectName is 0, there
**  is no parent-child hierarchy for this object type.  Otherwise,
**   the .ParentObjectInstance is an index, starting at 0, into the
**  instances reported for the parent object type.  It is only
**  meaningful if .ParentObjectName is not 0.  The purpose of all this
**  is to permit reporting/summation of object instances like threads
**  within processes, and logical drives within physical drives.
**
**
**  The PERF_INSTANCE_DEFINITION will be followed by a PERF_COUNTER_BLOCK.
*)

TYPE PERF_COUNTER_BLOCK =
     RECORD
            ByteLength : DWORD; (* Length in bytes of this structure, *)
                                (* including the following counters *)
     END;
     PPERF_COUNTER_BLOCK = PERF_COUNTER_BLOCK;

(*
**  The PERF_COUNTER_BLOCK is followed by PERF_OBJECT_TYPE.NumCounters
**  number of counters.
*)

(*
**  function typedefs for extensible counter function prototypes
*)

TYPE PM_OPEN_PROC    = PROCEDURE (PWSTR) : DWORD;
TYPE PM_COLLECT_PROC = PROCEDURE (PWSTR, VAR [NIL] PVOID,
                                         VAR [NIL] DWORD,
                                         VAR [NIL] DWORD) : DWORD;
TYPE PM_CLOSE_PROC   = PROCEDURE () : DWORD;


(* WinSock.def--definitions to be used with the WINSOCK.DLL
 *
 * This definition module corresponds to version 1.1 of the
 * Windows Sockets specification.
 *
 * This file includes parts which are Copyright (c) 1982-1986 Regents
 * of the University of California.  All rights reserved.  The
 * Berkeley Software License Agreement specifies the terms and
 * conditions for redistribution.
 *
 *)



(*
 * Basic system type definitions, taken from the BSD file sys/types.h.
 *)

TYPE u_char   = UCHAR;
TYPE u_short  = USHORT;
TYPE u_int    = UINT;
TYPE u_long   = ULONG;
     p_u_long = POINTER TO u_long;

(*
 * The new type to be used in all
 * instances which refer to sockets.
 *)
TYPE SOCKET = u_int;


(*
 * Select uses arrays of SOCKETs.  These macros manipulate such
 * arrays.  FD_SETSIZE may be defined by the user before including
 * this file, but the default here should be >= 64.
 *
 * CAVEAT IMPLEMENTOR and USER: THESE MACROS AND TYPES MUST BE
 * INCLUDED IN WINSOCK.H EXACTLY AS SHOWN HERE.
 *)

CONST FD_SETSIZE = 64;

TYPE fd_set = RECORD
                   fd_count : u_int;                             (* how many are SET? *)
                   fd_array : ARRAY [0..FD_SETSIZE-1] OF SOCKET; (* an array of SOCKETs *)
              END;
     Pfd_set = POINTER TO fd_set;

<* IF BACKEND # "C" THEN *>
PROCEDURE __WSAFDIsSet (fd : SOCKET; set : fd_set) : INTEGER;
<* ELSE *>
PROCEDURE __WSAFDIsSet (fd : SOCKET; set : Pfd_set) : INTEGER;
<* END *>

(* FD_CLR, FD_SET, FD_ZERO were defined as macroes; now they're in RTL *)

PROCEDURE FD_CLR (fd : SOCKET; VAR set : fd_set);
PROCEDURE FD_SET (fd : SOCKET; VAR set : fd_set);
PROCEDURE FD_ZERO (VAR set : fd_set);
CONST FD_ISSET = __WSAFDIsSet;

(*
 * Structure used in select() call, taken from the BSD file sys/time.h.
 *)

<* IF BACKEND = "C" THEN *> <* PUSH *> <* GENTYPEDEF- *> <* END *>
TYPE timeval = RECORD
                      tv_sec  : LONG;         (* seconds *)
                      tv_usec : LONG;        (* and microseconds *)
               END;
     Ptimeval = POINTER TO timeval;
<* IF BACKEND = "C" THEN *> <* POP *> <* END *>

(*
 * Operations on timevals.
 *
 * They all were macroes. General macro timercmp was replaced with
 * three different procedures: timergt, timerlt and timerequ.
 *)

PROCEDURE timerisset (VAR tvp : timeval) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE timergt    (tvp, uvp : timeval) : BOOL;
<* ELSE *>
PROCEDURE timergt    (tvp, uvp : Ptimeval) : BOOL;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE timerlt    (tvp, uvp : timeval) : BOOL;
<* ELSE *>
PROCEDURE timerlt    (tvp, uvp : Ptimeval) : BOOL;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE timerequ   (tvp, uvp : timeval) : BOOL;
<* ELSE *>
PROCEDURE timerequ   (tvp, uvp : Ptimeval) : BOOL;
<* END *>
PROCEDURE timerclear (VAR tvp : timeval);

(*
 * Commands for ioctlsocket(),  taken from the BSD file fcntl.h.
 *
 *
 * Ioctl's have the command encoded in the lower word,
 * and the size of any in or out parameters in the upper
 * word.  The high 2 bits of the upper word are used
 * to encode the in/out status of the parameter; for now
 * we restrict parameters to at most 128 bytes.
 *)

CONST IOCPARM_MASK = 07fh;           (* parameters must be < 128 bytes *)
      IOC_VOID     = 20000000h;      (* no parameters *)
      IOC_OUT      = 40000000h;      (* copy out parameters *)
      IOC_IN       = 80000000h;      (* copy in parameters *)
      IOC_INOUT    = IOC_IN+IOC_OUT;
                                        (* 0x20000000 distinguishes new &
                                           old ioctl's *)

      FIONREAD   = IOC_OUT + 4 * 65536 + ORD ('f') * 256 + 127; (* get # bytes to read *)
      FIONBIO    = IOC_IN  + 4 * 65536 + ORD ('f') * 256 + 126; (* set/clear non-blocking i/o *)
      FIOASYNC   = IOC_IN  + 4 * 65536 + ORD ('f') * 256 + 125; (* set/clear async i/o *)

(* Socket I/O Controls *)

      SIOCSHIWAT = IOC_IN  + 4 * 65536 + ORD ('s') * 256 + 0; (* set high watermark *)
      SIOCGHIWAT = IOC_OUT + 4 * 65536 + ORD ('s') * 256 + 1; (* get high watermark *)
      SIOCSLOWAT = IOC_IN  + 4 * 65536 + ORD ('s') * 256 + 2; (* set low watermark *)
      SIOCGLOWAT = IOC_OUT + 4 * 65536 + ORD ('s') * 256 + 3; (* get low watermark *)
      SIOCATMARK = IOC_OUT + 4 * 65536 + ORD ('s') * 256 + 7; (* at oob mark? *)

(*
 * Structures returned by network data base library, taken from the
 * BSD file netdb.h.  All addresses are supplied in host order, and
 * returned in network order (suitable for use in system calls).
 *)

TYPE hostent = RECORD
                      h_name      : PSTR;  (* official name of host *)
                      h_aliases   : PPSTR; (* alias list *)
                      h_addrtype  : SHORT; (* host address type *)
                      h_length    : SHORT; (* length of address *)
                      h_addr_list : PPSTR; (* list of addresses *)
               END;
   p_hostent = POINTER TO hostent;

(*
 * It is assumed here that a network number
 * fits in 32 bits.
 *)
TYPE netent = RECORD
                   n_name     : PSTR;   (* official name of net *)
                   n_aliases  : PPSTR;  (* alias list *)
                   n_addrtype : SHORT;  (* net address type *)
                   n_net      : u_long; (* network # *)
              END;

TYPE servent = RECORD
                    s_name    : PSTR;   (* official service name *)
                    s_aliases : PPSTR;  (* alias list *)
                    s_port    : SHORT;  (* port # *)
                    s_proto   : PSTR;   (* protocol to use *)
               END;
   p_servent = POINTER TO servent;

TYPE protoent = RECORD
                     p_name    : PSTR;  (* official protocol name *)
                     p_aliases : PPSTR; (* alias list *)
                     p_proto   : SHORT; (* protocol # *)
                END;
   p_protoent = POINTER TO protoent;

(*
 * Constants and structures defined by the internet system,
 * Per RFC 790, September 1981, taken from the BSD file netinet/in.h.
 *)

(*
 * Protocols
 *)

CONST IPPROTO_IP            = 0;              (* dummy for IP *)
      IPPROTO_ICMP          = 1;              (* control message protocol *)
      IPPROTO_IGMP          = 2;              (* group management protocol *)
      IPPROTO_GGP           = 3;              (* gateway^2 (deprecated) *)
      IPPROTO_TCP           = 6;              (* tcp *)
      IPPROTO_PUP           = 12;             (* pup *)
      IPPROTO_UDP           = 17;             (* user datagram protocol *)
      IPPROTO_IDP           = 22;             (* xns idp *)
      IPPROTO_ND            = 77;             (* UNOFFICIAL net disk proto *)

      IPPROTO_RAW           = 255;            (* raw IP packet *)
      IPPROTO_MAX           = 256;

(*
 * Port/socket numbers: network standard functions
 *)
      IPPORT_ECHO           = 7;
      IPPORT_DISCARD        = 9;
      IPPORT_SYSTAT         = 11;
      IPPORT_DAYTIME        = 13;
      IPPORT_NETSTAT        = 15;
      IPPORT_FTP            = 21;
      IPPORT_TELNET         = 23;
      IPPORT_SMTP           = 25;
      IPPORT_TIMESERVER     = 37;
      IPPORT_NAMESERVER     = 42;
      IPPORT_WHOIS          = 43;
      IPPORT_MTP            = 57;

(*
 * Port/socket numbers: host specific functions
 *)
      IPPORT_TFTP           = 69;
      IPPORT_RJE            = 77;
      IPPORT_FINGER         = 79;
      IPPORT_TTYLINK        = 87;
      IPPORT_SUPDUP         = 95;

(*
 * UNIX TCP sockets
 *)
      IPPORT_EXECSERVER     = 512;
      IPPORT_LOGINSERVER    = 513;
      IPPORT_CMDSERVER      = 514;
      IPPORT_EFSSERVER      = 520;

(*
 * UNIX UDP sockets
 *)
      IPPORT_BIFFUDP        = 512;
      IPPORT_WHOSERVER      = 513;
      IPPORT_ROUTESERVER    = 520;
                                        (* 520+1 also used *)

(*
 * Ports < IPPORT_RESERVED are reserved for
 * privileged processes (e.g. root).
 *)
      IPPORT_RESERVED       = 1024;

(*
 * Link numbers
 *)
      IMPLINK_IP            = 155;
      IMPLINK_LOWEXPER      = 156;
      IMPLINK_HIGHEXPER     = 158;

(*
 * Internet address (old style... should be updated)
 *)

TYPE in_addr = RECORD
                    CASE : INTEGER OF
                    | 0 : s_b1, s_b2, s_b3, s_b4 : u_char;
                    | 1 : s_w1, s_w2 : u_short;
                    | 2 : S_addr : u_long;
                    | 3 : s_addr : u_long;
                                            (* can be used for most tcp & ip code *)
                    | 4 : s_net,            (* netword *)
                          s_host,           (* host on imp *)
                          s_lh,             (* logical host *)
                          s_impno : u_char; (* imp # *)
                    | 5 : s_dummy,
                          s_imp : u_short;  (* imp *)
                    END;
               END;


(*
 * Definitions of bits in internet address integers.
 * On subnets, the decomposition of addresses to host and net parts
 * is done according to subnet mask, not the masks here.
 *)

(* IN_CLASSA, IN_CLASSB, IN_CLASSC implemented in RTL *)

PROCEDURE IN_CLASSA (i : ULONG) : BOOL;

CONST IN_CLASSA_NET         = 0ff000000h;
      IN_CLASSA_NSHIFT      = 24;
      IN_CLASSA_HOST        = 000ffffffh;
      IN_CLASSA_MAX         = 128;

PROCEDURE IN_CLASSB (i : ULONG) : BOOL;

CONST IN_CLASSB_NET         = 0ffff0000h;
      IN_CLASSB_NSHIFT      = 16;
      IN_CLASSB_HOST        = 00000ffffh;
      IN_CLASSB_MAX         = 65536;

PROCEDURE IN_CLASSC (i : ULONG) : BOOL;

CONST IN_CLASSC_NET         = 0ffffff00h;
      IN_CLASSC_NSHIFT      = 8;
      IN_CLASSC_HOST        = 0000000ffh;

      INADDR_ANY            = 000000000h;
      INADDR_LOOPBACK       = 07f000001h;
      INADDR_BROADCAST      = 0ffffffffh;
      INADDR_NONE           = 0ffffffffh;

(*
 * Socket address, internet style.
 *)

TYPE sockaddr_in = RECORD
                        sin_family : SHORT;
                        sin_port   : u_short;
                        sin_addr   : in_addr;
                        sin_zero   : ARRAY [0..7] OF CHAR;
                   END;


CONST WSADESCRIPTION_LEN = 256;
      WSASYS_STATUS_LEN  = 128;

TYPE WSADATA = RECORD
                    wVersion       : WORD;
                    wHighVersion   : WORD;
                    szDescription  : ARRAY [0..WSADESCRIPTION_LEN] OF CHAR;
                    szSystemStatus : ARRAY [0..WSASYS_STATUS_LEN]  OF CHAR;
                    iMaxSockets    : USHORT;
                    iMaxUdpDg      : USHORT;
                    lpVendorInfo   : PSTR;
               END;

       PWSADATA = POINTER TO WSADATA;

(*
 * Options for use with [gs]etsockopt at the IP level.
 *)

CONST IP_OPTIONS          = 1;           (* set/get IP per-packet options    *)
      IP_MULTICAST_IF     = 2;           (* set/get IP multicast interface   *)
      IP_MULTICAST_TTL    = 3;           (* set/get IP multicast timetolive  *)
      IP_MULTICAST_LOOP   = 4;           (* set/get IP multicast loopback    *)
      IP_ADD_MEMBERSHIP   = 5;           (* add  an IP group membership      *)
      IP_DROP_MEMBERSHIP  = 6;           (* drop an IP group membership      *)

      IP_DEFAULT_MULTICAST_TTL  = 1;    (* normally limit m'casts to 1 hop  *)
      IP_DEFAULT_MULTICAST_LOOP = 1;    (* normally hear sends if a member  *)
      IP_MAX_MEMBERSHIPS        = 20;   (* per socket; must fit in one mbuf *)

(*
 * Argument structure for IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP.
 *)

TYPE ip_mreq = RECORD
                  imr_multiaddr : in_addr;  (* IP multicast address of group *)
                  imr_interface : in_addr;  (* local IP address of interface *)
               END;

(*
 * Definitions related to sockets: types, address families, options,
 * taken from the BSD file sys/socket.h.
 *)

(*
 * This is used instead of -1, since the
 * SOCKET type is unsigned.
 *)

CONST INVALID_SOCKET = VAL (SOCKET, 0FFFFFFFFh);
      SOCKET_ERROR   = -1;

(*
 * Types
 *)

CONST SOCK_STREAM     = 1;               (* stream socket *)
      SOCK_DGRAM      = 2;               (* datagram socket *)
      SOCK_RAW        = 3;               (* raw-protocol interface *)
      SOCK_RDM        = 4;               (* reliably-delivered message *)
      SOCK_SEQPACKET  = 5;               (* sequenced packet stream *)

(*
 * Option flags per-socket.
 *)

CONST SO_DEBUG        = 0001h;          (* turn on debugging info recording *)
      SO_ACCEPTCONN   = 0002h;          (* socket has had listen() *)
      SO_REUSEADDR    = 0004h;          (* allow local address reuse *)
      SO_KEEPALIVE    = 0008h;          (* keep connections alive *)
      SO_DONTROUTE    = 0010h;          (* just use interface addresses *)
      SO_BROADCAST    = 0020h;          (* permit sending of broadcast msgs *)
      SO_USELOOPBACK  = 0040h;          (* bypass hardware when possible *)
      SO_LINGER       = 0080h;          (* linger on close if data present *)
      SO_OOBINLINE    = 0100h;          (* leave received OOB data in line *)

      SO_DONTLINGER   = 0FFFFFF7Fh; (* (u_int)(~SO_LINGER) *)

(*
 * Additional options.
 *)

CONST SO_SNDBUF       = 1001h;          (* send buffer size *)
      SO_RCVBUF       = 1002h;          (* receive buffer size *)
      SO_SNDLOWAT     = 1003h;          (* send low-water mark *)
      SO_RCVLOWAT     = 1004h;          (* receive low-water mark *)
      SO_SNDTIMEO     = 1005h;          (* send timeout *)
      SO_RCVTIMEO     = 1006h;          (* receive timeout *)
      SO_ERROR        = 1007h;          (* get error status and clear *)
      SO_TYPE         = 1008h;          (* get socket type *)

(*
 * Options for connect and disconnect data and options.  Used only by
 * non-TCP/IP transports such as DECNet, OSI TP4, etc.
 *)

CONST SO_CONNDATA     = 7000h;
      SO_CONNOPT      = 7001h;
      SO_DISCDATA     = 7002h;
      SO_DISCOPT      = 7003h;
      SO_CONNDATALEN  = 7004h;
      SO_CONNOPTLEN   = 7005h;
      SO_DISCDATALEN  = 7006h;
      SO_DISCOPTLEN   = 7007h;

(*
 * Option for opening sockets for synchronous access.
 *)

CONST SO_OPENTYPE     = 7008h;

CONST SO_SYNCHRONOUS_ALERT    = 10h;
      SO_SYNCHRONOUS_NONALERT = 20h;

(*
 * Other NT-specific options.
 *)

CONST SO_MAXDG        = 7009h;
      SO_MAXPATHDG    = 700Ah;

(*
 * TCP options.
 *)

CONST TCP_NODELAY     = 0001h;
      TCP_BSDURGENT   = 7000h;

(*
 * Address families.
 *)

CONST AF_UNSPEC       = 0;              (* unspecified *)
      AF_UNIX         = 1;              (* local to host (pipes, portals) *)
      AF_INET         = 2;              (* internetwork: UDP, TCP, etc. *)
      AF_IMPLINK      = 3;              (* arpanet imp addresses *)
      AF_PUP          = 4;              (* pup protocols: e.g. BSP *)
      AF_CHAOS        = 5;              (* mit CHAOS protocols *)
      AF_IPX          = 6;              (* IPX and SPX *)
      AF_NS           = 6;              (* XEROX NS protocols *)
      AF_ISO          = 7;              (* ISO protocols *)
      AF_OSI          = AF_ISO;         (* OSI is ISO *)
      AF_ECMA         = 8;              (* european computer manufacturers *)
      AF_DATAKIT      = 9;              (* datakit protocols *)
      AF_CCITT        = 10;             (* CCITT protocols, X.25 etc *)
      AF_SNA          = 11;             (* IBM SNA *)
      AF_DECnet       = 12;             (* DECnet *)
      AF_DLI          = 13;             (* Direct data link interface *)
      AF_LAT          = 14;             (* LAT *)
      AF_HYLINK       = 15;             (* NSC Hyperchannel *)
      AF_APPLETALK    = 16;             (* AppleTalk *)
      AF_NETBIOS      = 17;             (* NetBios-style addresses *)
      AF_VOICEVIEW    = 18;             (* VoiceView *)

      AF_MAX          = 19;

(*
 * Structure used by kernel to store most
 * addresses.
 *)

TYPE sockaddr = RECORD
                  sa_family : u_short;               (* address family *)
                  sa_data   : ARRAY [0..13] OF CHAR; (* up to 14 bytes of direct address *)
                END;
     Psockaddr = POINTER TO sockaddr;

(*
 * Structure used by kernel to pass protocol
 * information in raw sockets.
 *)

TYPE sockproto = RECORD
                   sp_family   : u_short; (* address family *)
                   sp_protocol : u_short; (* protocol *)
                 END;

(*
 * Protocol families, same as address families for now.
 *)

CONST PF_UNSPEC      = AF_UNSPEC;
      PF_UNIX        = AF_UNIX;
      PF_INET        = AF_INET;
      PF_IMPLINK     = AF_IMPLINK;
      PF_PUP         = AF_PUP;
      PF_CHAOS       = AF_CHAOS;
      PF_NS          = AF_NS;
      PF_IPX         = AF_IPX;
      PF_ISO         = AF_ISO;
      PF_OSI         = AF_OSI;
      PF_ECMA        = AF_ECMA;
      PF_DATAKIT     = AF_DATAKIT;
      PF_CCITT       = AF_CCITT;
      PF_SNA         = AF_SNA;
      PF_DECnet      = AF_DECnet;
      PF_DLI         = AF_DLI;
      PF_LAT         = AF_LAT;
      PF_HYLINK      = AF_HYLINK;
      PF_APPLETALK   = AF_APPLETALK;
      PF_VOICEVIEW   = AF_VOICEVIEW;

      PF_MAX         = AF_MAX;

(*
 * Structure used for manipulating linger option.
 *)

TYPE linger = RECORD
                l_onoff  : u_short;               (* option on/off *)
                l_linger : u_short;               (* linger time *)
              END;

(*
 * Level number for (get/set)sockopt() to apply to socket itself.
 *)

CONST SOL_SOCKET =  0ffffh;          (* options for socket level *)

(*
 * Maximum queue length specifiable by listen.
 *)

CONST SOMAXCONN = 5;

CONST MSG_OOB       = 1;             (* process out-of-band data *)
      MSG_PEEK      = 2;             (* peek at incoming message *)
      MSG_DONTROUTE = 4;             (* send without using routing tables *)

      MSG_MAXIOVLEN = 16;

      MSG_PARTIAL   = 8000h;         (* partial send or recv for message xport *)

(*
 * Define constant based on rfc883, used by gethostbyxxxx() calls.
 *)

CONST MAXGETHOSTSTRUCT = 1024;

(*
 * Define flags to be used with the WSAAsyncSelect() call.
 *)

TYPE FD_ENUM = (FD__READ,     (* 0 *)
                FD__WRITE,    (* 1 *)
                FD__OOB,      (* 2 *)
                FD__ACCEPT,   (* 3 *)
                FD__CONNECT,  (* 4 *)
                FD__CLOSE);   (* 5 *)
 
     FD_FLAGS = SET OF FD_ENUM;

CONST FD_READ     = FD_FLAGS {FD__READ};    (* 0x01 *)
      FD_WRITE    = FD_FLAGS {FD__WRITE};   (* 0x02 *)
      FD_OOB      = FD_FLAGS {FD__OOB};     (* 0x04 *)
      FD_ACCEPT   = FD_FLAGS {FD__ACCEPT};  (* 0x08 *)
      FD_CONNECT  = FD_FLAGS {FD__CONNECT}; (* 0x10 *)
      FD_CLOSE    = FD_FLAGS {FD__CLOSE};   (* 0x20 *)

(*
 * All Windows Sockets error constants are biased by = WSABASEERR from
 * the "normal"
 *)

CONST WSABASEERR = 10000;

(*
 * Windows Sockets definitions of regular Microsoft C error constants
 *)

CONST WSAEINTR                = WSABASEERR+4;
      WSAEBADF                = WSABASEERR+9;
      WSAEACCES               = WSABASEERR+13;
      WSAEFAULT               = WSABASEERR+14;
      WSAEINVAL               = WSABASEERR+22;
      WSAEMFILE               = WSABASEERR+24;

(*
 * Windows Sockets definitions of regular Berkeley error constants
 *)

CONST WSAEWOULDBLOCK          = WSABASEERR+35;
      WSAEINPROGRESS          = WSABASEERR+36;
      WSAEALREADY             = WSABASEERR+37;
      WSAENOTSOCK             = WSABASEERR+38;
      WSAEDESTADDRREQ         = WSABASEERR+39;
      WSAEMSGSIZE             = WSABASEERR+40;
      WSAEPROTOTYPE           = WSABASEERR+41;
      WSAENOPROTOOPT          = WSABASEERR+42;
      WSAEPROTONOSUPPORT      = WSABASEERR+43;
      WSAESOCKTNOSUPPORT      = WSABASEERR+44;
      WSAEOPNOTSUPP           = WSABASEERR+45;
      WSAEPFNOSUPPORT         = WSABASEERR+46;
      WSAEAFNOSUPPORT         = WSABASEERR+47;
      WSAEADDRINUSE           = WSABASEERR+48;
      WSAEADDRNOTAVAIL        = WSABASEERR+49;
      WSAENETDOWN             = WSABASEERR+50;
      WSAENETUNREACH          = WSABASEERR+51;
      WSAENETRESET            = WSABASEERR+52;
      WSAECONNABORTED         = WSABASEERR+53;
      WSAECONNRESET           = WSABASEERR+54;
      WSAENOBUFS              = WSABASEERR+55;
      WSAEISCONN              = WSABASEERR+56;
      WSAENOTCONN             = WSABASEERR+57;
      WSAESHUTDOWN            = WSABASEERR+58;
      WSAETOOMANYREFS         = WSABASEERR+59;
      WSAETIMEDOUT            = WSABASEERR+60;
      WSAECONNREFUSED         = WSABASEERR+61;
      WSAELOOP                = WSABASEERR+62;
      WSAENAMETOOLONG         = WSABASEERR+63;
      WSAEHOSTDOWN            = WSABASEERR+64;
      WSAEHOSTUNREACH         = WSABASEERR+65;
      WSAENOTEMPTY            = WSABASEERR+66;
      WSAEPROCLIM             = WSABASEERR+67;
      WSAEUSERS               = WSABASEERR+68;
      WSAEDQUOT               = WSABASEERR+69;
      WSAESTALE               = WSABASEERR+70;
      WSAEREMOTE              = WSABASEERR+71;

      WSAEDISCON              = WSABASEERR+101;

(*
 * Extended Windows Sockets error constant definitions
 *)

CONST WSASYSNOTREADY          = WSABASEERR+91;
      WSAVERNOTSUPPORTED      = WSABASEERR+92;
      WSANOTINITIALISED       = WSABASEERR+93;

(*
 * Error return codes from gethostbyname() and gethostbyaddr()
 * (when using the resolver). Note that these errors are
 * retrieved via WSAGetLastError() and must therefore follow
 * the rules for avoiding clashes with error numbers from
 * specific implementations or language run-time systems.
 * For this reason the codes are based at WSABASEERR+1001.
 * Note also that [WSA]NO_ADDRESS is defined only for
 * compatibility purposes.
 *)

(* Authoritative Answer: Host not found *)

CONST WSAHOST_NOT_FOUND     = WSABASEERR+1001;
      HOST_NOT_FOUND        = WSAHOST_NOT_FOUND;

(* Non-Authoritative: Host not found, or SERVERFAIL *)

CONST WSATRY_AGAIN          = WSABASEERR+1002;
      TRY_AGAIN             = WSATRY_AGAIN;

(* Non recoverable errors, FORMERR, REFUSED, NOTIMP *)

CONST WSANO_RECOVERY        = WSABASEERR+1003;
      NO_RECOVERY           = WSANO_RECOVERY;

(* Valid name, no data record of requested type *)

CONST WSANO_DATA            = WSABASEERR+1004;
      NO_DATA               = WSANO_DATA;

(* no address, look for MX record *)

CONST WSANO_ADDRESS         = WSANO_DATA;
      NO_ADDRESS            = WSANO_ADDRESS;

(*
 * Windows Sockets errors redefined as regular Berkeley error constants.
 * These were commented out in Windows NT to avoid conflicts with errno.h.
 * However, we can define it in DEF-file (unlike C, import in Modula-2
 * is qualified)
 *)

CONST EWOULDBLOCK           = WSAEWOULDBLOCK;
      EINPROGRESS           = WSAEINPROGRESS;
      EALREADY              = WSAEALREADY;
      ENOTSOCK              = WSAENOTSOCK;
      EDESTADDRREQ          = WSAEDESTADDRREQ;
      EMSGSIZE              = WSAEMSGSIZE;
      EPROTOTYPE            = WSAEPROTOTYPE;
      ENOPROTOOPT           = WSAENOPROTOOPT;
      EPROTONOSUPPORT       = WSAEPROTONOSUPPORT;
      ESOCKTNOSUPPORT       = WSAESOCKTNOSUPPORT;
      EOPNOTSUPP            = WSAEOPNOTSUPP;
      EPFNOSUPPORT          = WSAEPFNOSUPPORT;
      EAFNOSUPPORT          = WSAEAFNOSUPPORT;
      EADDRINUSE            = WSAEADDRINUSE;
      EADDRNOTAVAIL         = WSAEADDRNOTAVAIL;
      ENETDOWN              = WSAENETDOWN;
      ENETUNREACH           = WSAENETUNREACH;
      ENETRESET             = WSAENETRESET;
      ECONNABORTED          = WSAECONNABORTED;
      ECONNRESET            = WSAECONNRESET;
      ENOBUFS               = WSAENOBUFS;
      EISCONN               = WSAEISCONN;
      ENOTCONN              = WSAENOTCONN;
      ESHUTDOWN             = WSAESHUTDOWN;
      ETOOMANYREFS          = WSAETOOMANYREFS;
      ETIMEDOUT             = WSAETIMEDOUT;
      ECONNREFUSED          = WSAECONNREFUSED;
      ELOOP                 = WSAELOOP;
      ENAMETOOLONG          = WSAENAMETOOLONG;
      EHOSTDOWN             = WSAEHOSTDOWN;
      EHOSTUNREACH          = WSAEHOSTUNREACH;
      ENOTEMPTY             = WSAENOTEMPTY;
      EPROCLIM              = WSAEPROCLIM;
      EUSERS                = WSAEUSERS;
      EDQUOT                = WSAEDQUOT;
      ESTALE                = WSAESTALE;
      EREMOTE               = WSAEREMOTE;

(* Socket function prototypes *)

PROCEDURE accept (s : SOCKET; VAR addr : sockaddr; VAR [NIL] addrlen : INTEGER) : SOCKET;

<* IF BACKEND # "C" THEN *>
PROCEDURE bind (s : SOCKET; addr : sockaddr; namelen : INTEGER) : INTEGER;
<* ELSE *>
PROCEDURE bind (s : SOCKET; addr : Psockaddr; namelen : INTEGER) : INTEGER;
<* END *>

PROCEDURE closesocket (s : SOCKET) : INTEGER;

<* IF BACKEND # "C" THEN *>
PROCEDURE connect (s : SOCKET; name : sockaddr; namelen : INTEGER) : INTEGER;
<* ELSE *>
PROCEDURE connect (s : SOCKET; name : Psockaddr; namelen : INTEGER) : INTEGER;
<* END *>

PROCEDURE ioctlsocket (s : SOCKET; cmd : LONG; argp : p_u_long) : INTEGER;

PROCEDURE getpeername (s : SOCKET; VAR name : sockaddr; VAR [NIL] namelen : INTEGER) : INTEGER;

PROCEDURE getsockname (s : SOCKET; VAR name : sockaddr; VAR [NIL] namelen : INTEGER) : INTEGER;

PROCEDURE getsockopt (s : SOCKET; level : INTEGER; optname : INTEGER;
                      optval : PBYTE; VAR optlen : INTEGER) : INTEGER;

PROCEDURE htonl (hostlong : u_long) : u_long;

PROCEDURE htons (hostshort : u_short) : u_short;

PROCEDURE inet_addr (cp : ARRAY OF CHAR) : u_long;

(* inet_ntoa required structure passing by value; implemented in RTL *)

<* IF BACKEND # "C" THEN *>
PROCEDURE rtl_inet_ntoa (in : in_addr) : PSTR;
CONST inet_ntoa = rtl_inet_ntoa;
<* ELSE *>
PROCEDURE inet_ntoa (in : in_addr) : PSTR;
<* END *>

PROCEDURE listen (s : SOCKET; backlog : INTEGER) : INTEGER;

PROCEDURE ntohl (netlong : u_long) : u_long;

PROCEDURE ntohs (netshort : u_short) : u_short;

PROCEDURE recv (s : SOCKET; buf : PBYTE; len : INTEGER; flags : INTEGER) : INTEGER;

PROCEDURE recvfrom (s : SOCKET; buf : PBYTE; len : INTEGER; flags : INTEGER;
                    VAR [NIL] from : sockaddr; VAR [NIL] fromlen : INTEGER) : INTEGER;

<* IF BACKEND # "C" THEN *>
PROCEDURE select (nfds : INTEGER;
                  VAR readfds, writefds, exceptfds : FD_FLAGS;
                  timeout : timeval) : INTEGER;
<* ELSE *>
PROCEDURE select (nfds : INTEGER;
                  VAR readfds, writefds, exceptfds : FD_FLAGS;
                  timeout : Ptimeval) : INTEGER;
<* END *>

PROCEDURE send (s : SOCKET; buf : PCBYTE; len : INTEGER; flags : INTEGER) : INTEGER;

PROCEDURE sendto (s : SOCKET; buf : PCBYTE; len : INTEGER; flags : INTEGER;
                  VAR [NIL] to : sockaddr; tolen : INTEGER) : INTEGER;

PROCEDURE setsockopt (s : SOCKET; level : INTEGER; optname : INTEGER;
                      optval : PCBYTE; optlen : INTEGER) : INTEGER;

PROCEDURE shutdown (s : SOCKET; how : INTEGER) : INTEGER;

PROCEDURE socket (af : INTEGER; type : INTEGER; protocol : INTEGER) : SOCKET;

(* Database function prototypes *)

PROCEDURE gethostbyaddr (addr : PCBYTE; len : INTEGER; type : INTEGER) : p_hostent;

PROCEDURE gethostbyname (name : ARRAY OF CHAR) : p_hostent;

PROCEDURE gethostname (name : PSTR; namelen : INTEGER) : INTEGER;

PROCEDURE getservbyport (port : INTEGER; proto : PCSTR) : p_servent;

PROCEDURE getservbyname (name : ARRAY OF CHAR; proto : PCSTR) : p_servent;

PROCEDURE getprotobynumber (proto : INTEGER) : p_protoent;

PROCEDURE getprotobyname (name : ARRAY OF CHAR) : p_protoent;

(* Microsoft Windows Extension function prototypes *)

PROCEDURE WSAStartup (wVersionRequired : WORD; VAR WSAData : WSADATA) : INTEGER;

PROCEDURE WSACleanup () : INTEGER;

PROCEDURE WSASetLastError (iError : INTEGER);

PROCEDURE WSAGetLastError () : INTEGER;

PROCEDURE WSAIsBlocking () : BOOL;

PROCEDURE WSAUnhookBlockingHook () : INTEGER;

PROCEDURE WSASetBlockingHook (BlockFunc : FARPROC) : FARPROC;

PROCEDURE WSACancelBlockingCall () : INTEGER;

PROCEDURE WSAAsyncGetServByName (hwnd   : HWND;
                                 wMsg   : u_int;
                                 name   : ARRAY OF CHAR;
                                 proto  : PCSTR;
                                 buf    : PBYTE;
                                 buflen : INTEGER) : HANDLE;

PROCEDURE WSAAsyncGetServByPort (hwnd   : HWND;
                                 wMsg   : u_int;
                                 port   : INTEGER;
                                 proto  : PCSTR;
                                 buf    : PBYTE;
                                 buflen : INTEGER) : HANDLE;

PROCEDURE WSAAsyncGetProtoByName (hwnd   : HWND;
                                  wMsg   : u_int;
                                  name   : ARRAY OF CHAR;
                                  buf    : PBYTE;
                                  buflen : INTEGER) : HANDLE;

PROCEDURE WSAAsyncGetProtoByNumber (hwnd   : HWND;
                                    wMsg   : u_int;
                                    number : INTEGER;
                                    buf    : PBYTE;
                                    buflen : INTEGER) : HANDLE;

PROCEDURE WSAAsyncGetHostByName (hwnd   : HWND;
                                 wMsg   : u_int;
                                 name   : ARRAY OF CHAR;
                                 buf    : PBYTE;
                                 buflen : INTEGER) : HANDLE;

PROCEDURE WSAAsyncGetHostByAddr (hwnd   : HWND;
                                 wMsg   : u_int;
                                 addr   : ARRAY OF CHAR;
                                 len    : INTEGER;
                                 type   : INTEGER;
                                 buf    : PBYTE;
                                 buflen : INTEGER) : HANDLE;

PROCEDURE WSACancelAsyncRequest (hAsyncTaskHandle : HANDLE) : INTEGER;

PROCEDURE WSAAsyncSelect (s      : SOCKET;
                          hwnd   : HWND;
                          wMsg   : u_int;
                          lEvent : LONG) : INTEGER;

PROCEDURE WSARecvEx (s : SOCKET;
                     buf : PBYTE;
                     len : INTEGER;
                     VAR [NIL] flags : INTEGER) : INTEGER;

TYPE TRANSMIT_FILE_BUFFERS = RECORD
                                    Head       : PVOID;
                                    HeadLength : DWORD;
                                    Tail       : PVOID;
                                    TailLength : DWORD;
                             END;

    PTRANSMIT_FILE_BUFFERS = POINTER TO TRANSMIT_FILE_BUFFERS;

PROCEDURE TransmitFile (hSocket                   : SOCKET;
                        hFile                     : HANDLE;
                        nNumberOfBytesToWrite     : DWORD;
                        nNumberOfBytesPerSend     : DWORD;
                        VAR [NIL] Overlapped      : OVERLAPPED;
                        VAR [NIL] TransmitBuffers : TRANSMIT_FILE_BUFFERS;
                        dwReserved                : DWORD
                       ) : BOOL;



(* Microsoft Windows Extended data types *)

TYPE  SOCKADDR = sockaddr;
TYPE PSOCKADDR = POINTER TO SOCKADDR;

TYPE  SOCKADDR_IN = sockaddr_in;
TYPE PSOCKADDR_IN = POINTER TO SOCKADDR_IN;

TYPE  LINGER = linger;
TYPE PLINGER = POINTER TO LINGER;

TYPE  IN_ADDR = in_addr;
TYPE PIN_ADDR = POINTER TO IN_ADDR;

(* Original windock.h defined FD_SET = fd_set;
   We do not because there's function (former macro) FD_SET *)

TYPE  HOSTENT = hostent;
TYPE PHOSTENT = POINTER TO HOSTENT;

TYPE  SERVENT = servent;
TYPE PSERVENT = POINTER TO SERVENT;

TYPE  PROTOENT = protoent;
TYPE PPROTOENT = POINTER TO PROTOENT;

TYPE TIMEVAL  = timeval;
TYPE PTIMEVAL = POINTER TO TIMEVAL;

(*
 * Windows message parameter composition and decomposition
 * macros.
 *
 * WSAMAKEASYNCREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to a WSAAsyncGetXByY() routine.
 *)

 (* WSAMAKEASYNCREPLY (buflen,error) *)

CONST WSAMAKEASYNCREPLY = MAKELONG;

(*
 * WSAMAKESELECTREPLY is intended for use by the Windows Sockets implementation
 * when constructing the response to WSAAsyncSelect().
 *)

 (* WSAMAKESELECTREPLY (event,error) *)

CONST WSAMAKESELECTREPLY = MAKELONG;

(*
 * WSAGETASYNCBUFLEN is intended for use by the Windows Sockets application
 * to extract the buffer length from the lParam in the response
 * to a WSAGetXByY().
 *)

  (* WSAGETASYNCBUFLEN (lParam) *)

CONST WSAGETASYNCBUFLEN = LOWORD;

(*
 * WSAGETASYNCERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAGetXByY().
 *)

 (* WSAGETASYNCERROR (lParam) *)

CONST WSAGETASYNCERROR = HIWORD;

(*
 * WSAGETSELECTEVENT is intended for use by the Windows Sockets application
 * to extract the event code from the lParam in the response
 * to a WSAAsyncSelect().
 *)

 (* WSAGETSELECTEVENT (lParam) *)

CONST WSAGETSELECTEVENT = LOWORD;

(*
 * WSAGETSELECTERROR is intended for use by the Windows Sockets application
 * to extract the error code from the lParam in the response
 * to a WSAAsyncSelect().
 *)

 (* WSAGETSELECTERROR (lParam) *)

CONST WSAGETSELECTERROR = HIWORD;



(************************************************************************
*                                                                       *
*   Commdlg.def -- This module defines the 32-Bit Common Dialog APIs    *
*                                                                       *
************************************************************************)


<* PUSH *> <* ALIGNMENT = "1" *>


(* ----------------- Open / Save As Dialog Box --------------------------- *)

TYPE OFN_ENUM = (OFN__READONLY,              (*  0 *)
                 OFN__OVERWRITEPROMPT,       (*  1 *)
                 OFN__HIDEREADONLY,          (*  2 *)
                 OFN__NOCHANGEDIR,           (*  3 *)
                 OFN__SHOWHELP,              (*  4 *)
                 OFN__ENABLEHOOK,            (*  5 *)
                 OFN__ENABLETEMPLATE,        (*  6 *)
                 OFN__ENABLETEMPLATEHANDLE,  (*  7 *)
                 OFN__NOVALIDATE,            (*  8 *)
                 OFN__ALLOWMULTISELECT,      (*  9 *)
                 OFN__EXTENSIONDIFFERENT,    (* 10 *)
                 OFN__PATHMUSTEXIST,         (* 11 *)
                 OFN__FILEMUSTEXIST,         (* 12 *)
                 OFN__CREATEPROMPT,          (* 13 *)
                 OFN__SHAREAWARE,            (* 14 *)
                 OFN__NOREADONLYRETURN,      (* 15 *)
                 OFN__NOTESTFILECREATE,      (* 16 *)
                 OFN__NONETWORKBUTTON,       (* 17 *)
                 OFN__NOLONGNAMES,           (* 18 *)
                 OFN__EXPLORER,              (* 19 *)   (* new look commdlg *)
                 OFN__NODEREFERENCELINKS,    (* 20 *)
                 OFN__LONGNAMES              (* 21 *)   (* force long names for 3.x modules *)
      );
      OFN_SET = SET OF OFN_ENUM;

CONST OFN_READONLY             = OFN_SET {OFN__READONLY             }; (* 0x00000001 *)
      OFN_OVERWRITEPROMPT      = OFN_SET {OFN__OVERWRITEPROMPT      }; (* 0x00000002 *)
      OFN_HIDEREADONLY         = OFN_SET {OFN__HIDEREADONLY         }; (* 0x00000004 *)
      OFN_NOCHANGEDIR          = OFN_SET {OFN__NOCHANGEDIR          }; (* 0x00000008 *)
      OFN_SHOWHELP             = OFN_SET {OFN__SHOWHELP             }; (* 0x00000010 *)
      OFN_ENABLEHOOK           = OFN_SET {OFN__ENABLEHOOK           }; (* 0x00000020 *)
      OFN_ENABLETEMPLATE       = OFN_SET {OFN__ENABLETEMPLATE       }; (* 0x00000040 *)
      OFN_ENABLETEMPLATEHANDLE = OFN_SET {OFN__ENABLETEMPLATEHANDLE }; (* 0x00000080 *)
      OFN_NOVALIDATE           = OFN_SET {OFN__NOVALIDATE           }; (* 0x00000100 *)
      OFN_ALLOWMULTISELECT     = OFN_SET {OFN__ALLOWMULTISELECT     }; (* 0x00000200 *)
      OFN_EXTENSIONDIFFERENT   = OFN_SET {OFN__EXTENSIONDIFFERENT   }; (* 0x00000400 *)
      OFN_PATHMUSTEXIST        = OFN_SET {OFN__PATHMUSTEXIST        }; (* 0x00000800 *)
      OFN_FILEMUSTEXIST        = OFN_SET {OFN__FILEMUSTEXIST        }; (* 0x00001000 *)
      OFN_CREATEPROMPT         = OFN_SET {OFN__CREATEPROMPT         }; (* 0x00002000 *)
      OFN_SHAREAWARE           = OFN_SET {OFN__SHAREAWARE           }; (* 0x00004000 *)
      OFN_NOREADONLYRETURN     = OFN_SET {OFN__NOREADONLYRETURN     }; (* 0x00008000 *)
      OFN_NOTESTFILECREATE     = OFN_SET {OFN__NOTESTFILECREATE     }; (* 0x00010000 *)
      OFN_NONETWORKBUTTON      = OFN_SET {OFN__NONETWORKBUTTON      }; (* 0x00020000 *)
      OFN_NOLONGNAMES          = OFN_SET {OFN__NOLONGNAMES          }; (* 0x00040000 *)
      OFN_EXPLORER             = OFN_SET {OFN__EXPLORER             }; (* 0x00080000 *)
      OFN_NODEREFERENCELINKS   = OFN_SET {OFN__NODEREFERENCELINKS   }; (* 0x00100000 *)
      OFN_LONGNAMES            = OFN_SET {OFN__LONGNAMES            }; (* 0x00200000 *)

(* Return values for the registered message sent to the hook function
** when a sharing violation occurs.  OFN_SHAREFALLTHROUGH allows the
** filename to be accepted, OFN_SHARENOWARN rejects the name but puts
** up no warning (returned when the app has already put up a warning
** message), and OFN_SHAREWARN puts up the default warning message
** for sharing violations.
**
** Note:  Undefined return values map to OFN_SHAREWARN, but are
**        reserved for future use.
*)

CONST OFN_SHAREFALLTHROUGH = 2;
      OFN_SHARENOWARN      = 1;
      OFN_SHAREWARN        = 0;

TYPE OFNHOOKPROC = PROCEDURE (HWND, UINT, WPARAM, LPARAM) : UINT;

TYPE OPENFILENAMEA = RECORD
                            lStructSize       : DWORD;
                            hwndOwner         : HWND;
                            hInstance         : HINSTANCE;
                            lpstrFilter       : PCSTR;
                            lpstrCustomFilter : PSTR;
                            nMaxCustFilter    : DWORD;
                            nFilterIndex      : DWORD;
                            lpstrFile         : PSTR;
                            nMaxFile          : DWORD;
                            lpstrFileTitle    : PSTR;
                            nMaxFileTitle     : DWORD;
                            lpstrInitialDir   : PCSTR;
                            lpstrTitle        : PCSTR;
                            Flags             : OFN_SET;
                            nFileOffset       : WORD;
                            nFileExtension    : WORD;
                            lpstrDefExt       : PCSTR;
                            lCustData         : LPARAM;
                            lpfnHook          : OFNHOOKPROC;
                            lpTemplateName    : PCSTR;
                     END;
    POPENFILENAMEA = POINTER TO OPENFILENAMEA;

TYPE OPENFILENAMEW = RECORD
                            lStructSize       : DWORD;
                            hwndOwner         : HWND;
                            hInstance         : HINSTANCE;
                            lpstrFilter       : PCWSTR;
                            lpstrCustomFilter : PWSTR;
                            nMaxCustFilter    : DWORD;
                            nFilterIndex      : DWORD;
                            lpstrFile         : PWSTR;
                            nMaxFile          : DWORD;
                            lpstrFileTitle    : PWSTR;
                            nMaxFileTitle     : DWORD;
                            lpstrInitialDir   : PCWSTR;
                            lpstrTitle        : PCWSTR;
                            Flags             : OFN_SET;
                            nFileOffset       : WORD;
                            nFileExtension    : WORD;
                            lpstrDefExt       : PCWSTR;
                            lCustData         : LPARAM;
                            lpfnHook          : OFNHOOKPROC;
                            lpTemplateName    : PCWSTR;
                     END;
     POPENFILENAMEW = POINTER TO OPENFILENAMEW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  OPENFILENAME =  OPENFILENAMEW;
      TYPE POPENFILENAME = POPENFILENAMEW;
<* ELSE *>
      TYPE  OPENFILENAME =  OPENFILENAMEA;
      TYPE POPENFILENAME = POPENFILENAMEA;
<* END *>

PROCEDURE GetOpenFileNameA (VAR ofn : OPENFILENAMEA) : BOOL;
PROCEDURE GetOpenFileNameW (VAR ofn : OPENFILENAMEW) : BOOL;

PROCEDURE GetSaveFileNameA (VAR ofn : OPENFILENAMEA) : BOOL;
PROCEDURE GetSaveFileNameW (VAR ofn : OPENFILENAMEW) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetOpenFileName = GetOpenFileNameW;
            GetSaveFileName = GetSaveFileNameW;
<* ELSE *>
      CONST GetOpenFileName = GetOpenFileNameA;
            GetSaveFileName = GetSaveFileNameA;
<* END *>

PROCEDURE GetFileTitleA (File : STRING; Title : PSTR;
                         BufLen : WORD) : SHORT;

PROCEDURE GetFileTitleW (File : WSTRING; Title : PWSTR;
                         BufLen : WORD) : SHORT;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetFileTitle = GetFileTitleW;
<* ELSE *>
      CONST GetFileTitle = GetFileTitleA;
<* END *>


(* Structure used for all OpenFileName notifications *)

TYPE OFNOTIFYA = RECORD
                        hdr     : NMHDR;
                        lpOFN   : POPENFILENAMEA;
                        pszFile : PSTR;           (* May be NULL *)
                 END;
    POFNOTIFYA = POINTER TO OFNOTIFYA;

TYPE OFNOTIFYW = RECORD
                        hdr     : NMHDR;
                        lpOFN   : POPENFILENAMEW;
                        pszFile : PWSTR;          (* May be NULL *)
                 END;
    POFNOTIFYW = POINTER TO OFNOTIFYW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  OFNOTIFY =  OFNOTIFYW;
      TYPE POFNOTIFY = POFNOTIFYW;
<* ELSE *>
      TYPE  OFNOTIFY =  OFNOTIFYA;
      TYPE POFNOTIFY = POFNOTIFYA;
<* END *>


CONST CDN_FIRST = SYSTEM.CAST (ULONG, 0 - VAL (LONG, 601));
      CDN_LAST  = SYSTEM.CAST (ULONG, 0 - VAL (LONG, 699));

(* Notifications when Open or Save dialog status changes *)

CONST CDN_INITDONE       = CDN_FIRST - 0;
      CDN_SELCHANGE      = CDN_FIRST - 1;
      CDN_FOLDERCHANGE   = CDN_FIRST - 2;
      CDN_SHAREVIOLATION = CDN_FIRST - 3;
      CDN_HELP           = CDN_FIRST - 4;
      CDN_FILEOK         = CDN_FIRST - 5;
      CDN_TYPECHANGE     = CDN_FIRST - 6;

CONST CDM_FIRST          = WM_USER + 100;
      CDM_LAST           = WM_USER + 200;

(* Messages to query information from the Open or Save dialogs *)

(* lParam = pointer to text buffer that gets filled in
** wParam = max number of characters of the text buffer (including NULL)
** return = < 0 if error; number of characters needed (including NULL)
*)

CONST CDM_GETSPEC = CDM_FIRST + 0;

PROCEDURE CommDlg_OpenSave_GetSpecA (hdlg : HWND; psz : PSTR;   cbmax : INTEGER) : INTEGER;
PROCEDURE CommDlg_OpenSave_GetSpecW (hdlg : HWND; psz : PWSTR;  cbmax : INTEGER) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST CommDlg_OpenSave_GetSpec = CommDlg_OpenSave_GetSpecW;
<* ELSE *>
      CONST CommDlg_OpenSave_GetSpec = CommDlg_OpenSave_GetSpecA;
<* END *>


(* lParam = pointer to text buffer that gets filled in
** wParam = max number of characters of the text buffer (including NULL)
** return = < 0 if error; number of characters needed (including NULL)
*)

CONST CDM_GETFILEPATH = CDM_FIRST + 1;

PROCEDURE CommDlg_OpenSave_GetFilePathA (hdlg : HWND; psz : PSTR;   cbmax : INTEGER) : INTEGER;
PROCEDURE CommDlg_OpenSave_GetFilePathW (hdlg : HWND; psz : PWSTR;  cbmax : INTEGER) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST CommDlg_OpenSave_GetFilePath = CommDlg_OpenSave_GetFilePathW;
<* ELSE *>
      CONST CommDlg_OpenSave_GetFilePath = CommDlg_OpenSave_GetFilePathA;
<* END *>

(* lParam = pointer to text buffer that gets filled in
** wParam = max number of characters of the text buffer (including NULL)
** return = < 0 if error; number of characters needed (including NULL)
*)

CONST CDM_GETFOLDERPATH = CDM_FIRST + 2;

PROCEDURE CommDlg_OpenSave_GetFolderPathA (hdlg : HWND; psz : PSTR;  cbmax : INTEGER) : INTEGER;
PROCEDURE CommDlg_OpenSave_GetFolderPathW (hdlg : HWND; psz : PWSTR; cbmax : INTEGER) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      CONST CommDlg_OpenSave_GetFolderPath = CommDlg_OpenSave_GetFolderPathW;
<* ELSE *>
      CONST CommDlg_OpenSave_GetFolderPath = CommDlg_OpenSave_GetFolderPathA;
<* END *>


(* lParam = pointer to ITEMIDLIST buffer that gets filled in
** wParam = size of the ITEMIDLIST buffer
** return = < 0 if error; length of buffer needed
*)

CONST CDM_GETFOLDERIDLIST = CDM_FIRST + 3;

PROCEDURE CommDlg_OpenSave_GetFolderIDList (hdlg : HWND; pidl : PVOID; cbmax : INTEGER) : INTEGER;

(* lParam = pointer to a string
** wParam = ID of control to change
** return = not used
*)

CONST CDM_SETCONTROLTEXT = CDM_FIRST + 4;

PROCEDURE CommDlg_OpenSave_SetControlText  (hdlg : HWND; id : INTEGER; text : PSTR) : INTEGER;

(* lParam = not used
** wParam = ID of control to change
** return = not used
*)

CONST CDM_HIDECONTROL = CDM_FIRST + 5;

PROCEDURE CommDlg_OpenSave_HideControl (hdlg : HWND; id : INTEGER);

(* lParam = pointer to default extension (no dot)
** wParam = not used
** return = not used
*)

CONST CDM_SETDEFEXT = CDM_FIRST + 6;

PROCEDURE CommDlg_OpenSave_SetDefExt (hdlg : HWND; ext : PSTR);

(* ----------------- Choose color dialog box ----------------------------- *)

TYPE CCHOOKPROC = PROCEDURE (HWND, UINT, WPARAM, LPARAM) : UINT;

TYPE CCDLG_ENUM = (CC__RGBINIT,             (* 0 *)
                   CC__FULLOPEN,            (* 1 *)
                   CC__PREVENTFULLOPEN,     (* 2 *)
                   CC__SHOWHELP,            (* 3 *)
                   CC__ENABLEHOOK,          (* 4 *)
                   CC__ENABLETEMPLATE,      (* 5 *)
                   CC__ENABLETEMPLATEHANDLE,(* 6 *)
                   CC__SOLIDCOLOR,          (* 7 *)
                   CC__ANYCOLOR             (* 8 *)
                  );
     CCDLG_SET = SET OF CCDLG_ENUM;

CONST CCDLG_RGBINIT              = CCDLG_SET {CC__RGBINIT             }; (* 0x00000001 *)
      CCDLG_FULLOPEN             = CCDLG_SET {CC__FULLOPEN            }; (* 0x00000002 *)
      CCDLG_PREVENTFULLOPEN      = CCDLG_SET {CC__PREVENTFULLOPEN     }; (* 0x00000004 *)
      CCDLG_SHOWHELP             = CCDLG_SET {CC__SHOWHELP            }; (* 0x00000008 *)
      CCDLG_ENABLEHOOK           = CCDLG_SET {CC__ENABLEHOOK          }; (* 0x00000010 *)
      CCDLG_ENABLETEMPLATE       = CCDLG_SET {CC__ENABLETEMPLATE      }; (* 0x00000020 *)
      CCDLG_ENABLETEMPLATEHANDLE = CCDLG_SET {CC__ENABLETEMPLATEHANDLE}; (* 0x00000040 *)
      CCDLG_SOLODCOLOR           = CCDLG_SET {CC__SOLIDCOLOR          }; (* 0x00000080 *)
      CCDLG_ANYCOLOR             = CCDLG_SET {CC__ANYCOLOR            }; (* 0x00000100 *)

TYPE CUSTCOLORS  = ARRAY [0..15] OF COLORREF;
     PCUSTCOLORS = POINTER TO CUSTCOLORS;

TYPE CHOOSECOLORA = RECORD
                           lStructSize    : DWORD;
                           hwndOwner      : HWND;
                           hInstance      : HWND;
                           rgbResult      : COLORREF;
                           lpCustColors   : PCUSTCOLORS;
                           Flags          : CCDLG_SET;
                           lCustData      : LPARAM;
                           lpfnHook       : CCHOOKPROC;
                           lpTemplateName : RESOURCESTRA;
                    END;
    PCHOOSECOLORA = POINTER TO CHOOSECOLORA;

TYPE CHOOSECOLORW = RECORD
                           lStructSize    : DWORD;
                           hwndOwner      : HWND;
                           hInstance      : HWND;
                           rgbResult      : COLORREF;
                           lpCustColors   : PCUSTCOLORS;
                           Flags          : CCDLG_SET;
                           lCustData      : LPARAM;
                           lpfnHook       : CCHOOKPROC;
                           lpTemplateName : RESOURCESTRW;
                    END;
    PCHOOSECOLORW = POINTER TO CHOOSECOLORW;

<* IF DEFINED (UNICODE) THEN *>
TYPE  CHOOSECOLOR =  CHOOSECOLORW;
TYPE PCHOOSECOLOR = PCHOOSECOLORW;
<* ELSE *>
TYPE  CHOOSECOLOR =  CHOOSECOLORA;
TYPE PCHOOSECOLOR = PCHOOSECOLORA;
<* END *>

PROCEDURE ChooseColorA (VAR ChooseColorStruct : CHOOSECOLORA) : BOOL;
PROCEDURE ChooseColorW (VAR ChooseColorStruct : CHOOSECOLORW) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ChooseColor = ChooseColorW;
<* ELSE *>
      CONST ChooseColor = ChooseColorA;
<* END *>

(* ----------------- Find and Replace dialog box ------------------------- *)

TYPE FRHOOKPROC = PROCEDURE (HWND, UINT, WPARAM, LPARAM) : UINT;

TYPE FR_ENUM = (FR__DOWN,                 (*  0 *)
                FR__WHOLEWORD,            (*  1 *)
                FR__MATCHCASE,            (*  2 *)
                FR__FINDNEXT,             (*  3 *)
                FR__REPLACE,              (*  4 *)
                FR__REPLACEALL,           (*  5 *)
                FR__DIALOGTERM,           (*  6 *)
                FR__SHOWHELP,             (*  7 *)
                FR__ENABLEHOOK,           (*  8 *)
                FR__ENABLETEMPLATE,       (*  9 *)
                FR__NOUPDOWN,             (* 10 *)
                FR__NOMATCHCASE,          (* 11 *)
                FR__NOWHOLEWORD,          (* 12 *)
                FR__ENABLETEMPLATEHANDLE, (* 13 *)
                FR__HIDEUPDOWN,           (* 14 *)
                FR__HIDEMATCHCASE,        (* 15 *)
                FR__HIDEWHOLEWORD);       (* 16 *)
     FR_SET = SET OF FR_ENUM;

CONST
   FR_DOWN                 = FR_SET {FR__DOWN                }; (* 0x00000001 *)
   FR_WHOLEWORD            = FR_SET {FR__WHOLEWORD           }; (* 0x00000002 *)
   FR_MATCHCASE            = FR_SET {FR__MATCHCASE           }; (* 0x00000004 *)
   FR_FINDNEXT             = FR_SET {FR__FINDNEXT            }; (* 0x00000008 *)
   FR_REPLACE              = FR_SET {FR__REPLACE             }; (* 0x00000010 *)
   FR_REPLACEALL           = FR_SET {FR__REPLACEALL          }; (* 0x00000020 *)
   FR_DIALOGTERM           = FR_SET {FR__DIALOGTERM          }; (* 0x00000040 *)
   FR_SHOWHELP             = FR_SET {FR__SHOWHELP            }; (* 0x00000080 *)
   FR_ENABLEHOOK           = FR_SET {FR__ENABLEHOOK          }; (* 0x00000100 *)
   FR_ENABLETEMPLATE       = FR_SET {FR__ENABLETEMPLATE      }; (* 0x00000200 *)
   FR_NOUPDOWN             = FR_SET {FR__NOUPDOWN            }; (* 0x00000400 *)
   FR_NOMATCHCASE          = FR_SET {FR__NOMATCHCASE         }; (* 0x00000800 *)
   FR_NOWHOLEWORD          = FR_SET {FR__NOWHOLEWORD         }; (* 0x00001000 *)
   FR_ENABLETEMPLATEHANDLE = FR_SET {FR__ENABLETEMPLATEHANDLE}; (* 0x00002000 *)
   FR_HIDEUPDOWN           = FR_SET {FR__HIDEUPDOWN          }; (* 0x00004000 *)
   FR_HIDEMATCHCASE        = FR_SET {FR__HIDEMATCHCASE       }; (* 0x00008000 *)
   FR_HIDEWHOLEWORD        = FR_SET {FR__HIDEWHOLEWORD       }; (* 0x00010000 *)

TYPE FINDREPLACEA =
     RECORD
           lStructSize      : DWORD;        (* size of this struct 0x20     *)
           hwndOwner        : HWND;         (* handle to owner's window     *)
           hInstance        : HINSTANCE;    (* instance handle of.EXE that
                                               contains cust. dlg. template *)
           Flags            : FR_SET;       (* one or more of the FR_??     *)
           lpstrFindWhat    : PSTR;         (* ptr. to search string        *)
           lpstrReplaceWith : PSTR;         (* ptr. to replace string       *)
           wFindWhatLen     : WORD;         (* size of find buffer          *)
           wReplaceWithLen  : WORD;         (* size of replace buffer       *)
           lCustData        : LPARAM;       (* data passed to hook fn.      *)
           lpfnHook         : FRHOOKPROC;   (* ptr. to hook fn. or NULL     *)
           lpTemplateName   : RESOURCESTRA; (* custom template name         *)
     END;
     PFINDREPLACEA = POINTER TO FINDREPLACEA;

TYPE FINDREPLACEW =
     RECORD
           lStructSize      : DWORD;        (* size of this struct 0x20     *)
           hwndOwner        : HWND;         (* handle to owner's window     *)
           hInstance        : HINSTANCE;    (* instance handle of.EXE that
                                               contains cust. dlg. template *)
           Flags            : FR_SET;       (* one or more of the FR_??     *)
           lpstrFindWhat    : PWSTR;        (* ptr. to search string        *)
           lpstrReplaceWith : PWSTR;        (* ptr. to replace string       *)
           wFindWhatLen     : WORD;         (* size of find buffer          *)
           wReplaceWithLen  : WORD;         (* size of replace buffer       *)
           lCustData        : LPARAM;       (* data passed to hook fn.      *)
           lpfnHook         : FRHOOKPROC;   (* ptr. to hook fn. or NULL     *)
           lpTemplateName   : RESOURCESTRW; (* custom template name         *)
     END;
     PFINDREPLACEW = POINTER TO FINDREPLACEW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  FINDREPLACE =  FINDREPLACEW;
      TYPE PFINDREPLACE = PFINDREPLACEW;
<* ELSE *>
      TYPE  FINDREPLACE =  FINDREPLACEA;
      TYPE PFINDREPLACE = PFINDREPLACEA;
<* END *>


PROCEDURE FindTextA (VAR FindStruct : FINDREPLACEA) : HWND;
PROCEDURE FindTextW (VAR FindStruct : FINDREPLACEW) : HWND;

PROCEDURE ReplaceTextA (VAR FindStruct : FINDREPLACEA) : HWND;
PROCEDURE ReplaceTextW (VAR FindStruct : FINDREPLACEA) : HWND;

<* IF DEFINED (UNICODE) THEN *>
      CONST FindText = FindTextW;
            ReplaceText = ReplaceTextW;
<* ELSE *>
      CONST FindText = FindTextA;
            ReplaceText = ReplaceTextA;
<* END *>

(* ----------------- Choose Font dialog box ------------------------------ *)

TYPE CFHOOKPROC = PROCEDURE (HWND, UINT, WPARAM, LPARAM) : UINT;

TYPE CF_ENUM = (CF__SCREENFONTS,           (*  0 *)
                CF__PRINTERFONTS,          (*  1 *)
                CF__SHOWHELP,              (*  2 *)
                CF__ENABLEHOOK,            (*  3 *)
                CF__ENABLETEMPLATE,        (*  4 *)
                CF__ENABLETEMPLATEHANDLE,  (*  5 *)
                CF__INITTOLOGFONTSTRUCT,   (*  6 *)
                CF__USESTYLE,              (*  7 *)
                CF__EFFECTS,               (*  8 *)
                CF__APPLY,                 (*  9 *)
                CF__ANSIONLY,              (* 10 *)
                CF__NOVECTORFONTS,         (* 11 *)
                CF__NOSIMULATIONS,         (* 12 *)
                CF__LIMITSIZE,             (* 13 *)
                CF__FIXEDPITCHONLY,        (* 14 *)
                CF__WYSIWYG,               (* 15 *)
                CF__FORCEFONTEXIST,        (* 16 *)
                CF__SCALABLEONLY,          (* 17 *)
                CF__TTONLY,                (* 18 *)
                CF__NOFACESEL,             (* 19 *)
                CF__NOSTYLESEL,            (* 20 *)
                CF__NOSIZESEL,             (* 21 *)
                CF__SELECTSCRIPT,          (* 22 *)
                CF__NOSCRIPTSEL,           (* 23 *)
                CF__NOVERTFONTS);          (* 24 *)

     CF_SET = SET OF CF_ENUM;

CONST CF_SCREENFONTS          = CF_SET {CF__SCREENFONTS         }; (* 0x00000001L *)
      CF_PRINTERFONTS         = CF_SET {CF__PRINTERFONTS        }; (* 0x00000002L *)
      CF_BOTH                 = CF_SCREENFONTS + CF_PRINTERFONTS;
      CF_SHOWHELP             = CF_SET {CF__SHOWHELP            }; (* 0x00000004L *)
      CF_ENABLEHOOK           = CF_SET {CF__ENABLEHOOK          }; (* 0x00000008L *)
      CF_ENABLETEMPLATE       = CF_SET {CF__ENABLETEMPLATE      }; (* 0x00000010L *)
      CF_ENABLETEMPLATEHANDLE = CF_SET {CF__ENABLETEMPLATEHANDLE}; (* 0x00000020L *)
      CF_INITTOLOGFONTSTRUCT  = CF_SET {CF__INITTOLOGFONTSTRUCT }; (* 0x00000040L *)
      CF_USESTYLE             = CF_SET {CF__USESTYLE            }; (* 0x00000080L *)
      CF_EFFECTS              = CF_SET {CF__EFFECTS             }; (* 0x00000100L *)
      CF_APPLY                = CF_SET {CF__APPLY               }; (* 0x00000200L *)
      CF_ANSIONLY             = CF_SET {CF__ANSIONLY            }; (* 0x00000400L *)
      CF_SCRIPTSONLY          = CF_ANSIONLY;
      CF_NOVECTORFONTS        = CF_SET {CF__NOVECTORFONTS       }; (* 0x00000800L *)
      CF_NOOEMFONTS           = CF_NOVECTORFONTS;
      CF_NOSIMULATIONS        = CF_SET {CF__NOSIMULATIONS       }; (* 0x00001000L *)
      CF_LIMITSIZE            = CF_SET {CF__LIMITSIZE           }; (* 0x00002000L *)
      CF_FIXEDPITCHONLY       = CF_SET {CF__FIXEDPITCHONLY      }; (* 0x00004000L *)
      CF_WYSIWYG              = CF_SET {CF__WYSIWYG             }; (* 0x00008000L // must also have CF__SCREENFONTS & CF__PRINTERFONTS *)
      CF_FORCEFONTEXIST       = CF_SET {CF__FORCEFONTEXIST      }; (* 0x00010000L *)
      CF_SCALABLEONLY         = CF_SET {CF__SCALABLEONLY        }; (* 0x00020000L *)
      CF_TTONLY               = CF_SET {CF__TTONLY              }; (* 0x00040000L *)
      CF_NOFACESEL            = CF_SET {CF__NOFACESEL           }; (* 0x00080000L *)
      CF_NOSTYLESEL           = CF_SET {CF__NOSTYLESEL          }; (* 0x00100000L *)
      CF_NOSIZESEL            = CF_SET {CF__NOSIZESEL           }; (* 0x00200000L *)
      CF_SELECTSCRIPT         = CF_SET {CF__SELECTSCRIPT        }; (* 0x00400000L *)
      CF_NOSCRIPTSEL          = CF_SET {CF__NOSCRIPTSEL         }; (* 0x00800000L *)
      CF_NOVERTFONTS          = CF_SET {CF__NOVERTFONTS         }; (* 0x01000000L *)


TYPE CHOOSEFONTA =
RECORD
   lStructSize    : DWORD;
   hwndOwner      : HWND;          (* caller's window handle               *)
   hDC            : HDC;           (* printer DC/IC or NULL                *)
   lpLogFont      : PLOGFONTA;     (* ptr. to a LOGFONT struct             *)
   iPointSize     : INTEGER;       (* 10 * size in points of selected font *)
   Flags          : CF_SET;        (* enum. type flags                     *)
   rgbColors      : COLORREF;      (* returned text color                  *)
   lCustData      : LPARAM;        (* data passed to hook fn.              *)
   lpfnHook       : CFHOOKPROC;    (* ptr. to hook function                *)
   lpTemplateName : RESOURCESTRA;  (* custom template name                 *)
   hInstance      : HINSTANCE;     (* instance handle of.EXE that
                                      contains cust. dlg. template         *)
   lpszStyle      : PSTR;          (* return the style field here
                                      must be LF_FACESIZE or bigger        *)
   nFontType      : WORD;          (* same value reported to the EnumFonts
                                        call back with the extra FONTTYPE_
                                        bits added                         *)
   ___MISSING_ALIGNMENT__ : WORD;
   nSizeMin       : INTEGER;       (* minimum pt size allowed &            *)
   nSizeMax       : INTEGER;       (* max pt size allowed if
                                      CF_LIMITSIZE is used                 *)
END;

TYPE CHOOSEFONTW =
RECORD
   lStructSize    : DWORD;
   hwndOwner      : HWND;          (* caller's window handle               *)
   hDC            : HDC;           (* printer DC/IC or NULL                *)
   lpLogFont      : PLOGFONTW;     (* ptr. to a LOGFONT struct             *)
   iPointSize     : INTEGER;       (* 10 * size in points of selected font *)
   Flags          : CF_SET;        (* enum. type flags                     *)
   rgbColors      : COLORREF;      (* returned text color                  *)
   lCustData      : LPARAM;        (* data passed to hook fn.              *)
   lpfnHook       : CFHOOKPROC;    (* ptr. to hook function                *)
   lpTemplateName : RESOURCESTRW;  (* custom template name                 *)
   hInstance      : HINSTANCE;     (* instance handle of.EXE that
                                      contains cust. dlg. template         *)
   lpszStyle      : PWSTR;         (* return the style field here
                                      must be LF_FACESIZE or bigger        *)
   nFontType      : WORD;          (* same value reported to the EnumFonts
                                        call back with the extra FONTTYPE_
                                        bits added                         *)
   ___MISSING_ALIGNMENT__ : WORD;
   nSizeMin       : INTEGER;       (* minimum pt size allowed &            *)
   nSizeMax       : INTEGER;       (* max pt size allowed if
                                        CF_LIMITSIZE is used               *)
END;


<* IF DEFINED (UNICODE) THEN *>
      TYPE CHOOSEFONT = CHOOSEFONTW;
<* ELSE  *>
      TYPE CHOOSEFONT = CHOOSEFONTA;
<* END *>

PROCEDURE ChooseFontA (VAR ChooseFontStruct : CHOOSEFONTA) : BOOL;
PROCEDURE ChooseFontW (VAR ChooseFontStruct : CHOOSEFONTW) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ChooseFont = ChooseFontW;
<* ELSE  *>
      CONST ChooseFont = ChooseFontA;
<* END *>

CONST WM_CHOOSEFONT_GETLOGFONT = WM_USER + 1;
      WM_CHOOSEFONT_SETLOGFONT = WM_USER + 101;
      WM_CHOOSEFONT_SETFLAGS   = WM_USER + 102;

(* ----------------------------------------------------------------------- *)

(* strings used to obtain unique window message for communication
   between dialog and caller
*)

CONST LBSELCHSTRINGA  = "commdlg_LBSelChangedNotify";
      SHAREVISTRINGA  = "commdlg_ShareViolation";
      FILEOKSTRINGA   = "commdlg_FileNameOK";
      COLOROKSTRINGA  = "commdlg_ColorOK";
      SETRGBSTRINGA   = "commdlg_SetRGBColor";
      HELPMSGSTRINGA  = "commdlg_help";
      FINDMSGSTRINGA  = "commdlg_FindReplace";

      TYPE WARR_LBSELCHSTRING  = ARRAY [0..LEN (LBSELCHSTRINGA)-1] OF WCHAR;
      TYPE WARR_SHAREVISTRING  = ARRAY [0..LEN (SHAREVISTRINGA)-1] OF WCHAR;
      TYPE WARR_FILEOKSTRING   = ARRAY [0..LEN (FILEOKSTRINGA )-1] OF WCHAR;
      TYPE WARR_COLOROKSTRING  = ARRAY [0..LEN (COLOROKSTRINGA)-1] OF WCHAR;
      TYPE WARR_SETRGBSTRING   = ARRAY [0..LEN (SETRGBSTRINGA )-1] OF WCHAR;
      TYPE WARR_HELPMSGSTRING  = ARRAY [0..LEN (HELPMSGSTRINGA)-1] OF WCHAR;
      TYPE WARR_FINDMSGSTRING  = ARRAY [0..LEN (FINDMSGSTRINGA)-1] OF WCHAR;

CONST LBSELCHSTRINGW  = WARR_LBSELCHSTRING {ORD('c'),ORD('o'),ORD('m'),ORD('m'),
                                            ORD('d'),ORD('l'),ORD('g'),ORD('_'),
                                            ORD('L'),ORD('B'),ORD('S'),ORD('e'),
                                            ORD('l'),ORD('C'),ORD('h'),ORD('a'),
                                            ORD('n'),ORD('g'),ORD('e'),ORD('d'),
                                            ORD('N'),ORD('o'),ORD('t'),ORD('i'),
                                            ORD('f'),ORD('y'),0};
      SHAREVISTRINGW  = WARR_SHAREVISTRING {ORD('c'),ORD('o'),ORD('m'),ORD('m'),
                                            ORD('d'),ORD('l'),ORD('g'),ORD('_'),
                                            ORD('S'),ORD('h'),ORD('a'),ORD('r'),
                                            ORD('e'),ORD('V'),ORD('i'),ORD('o'),
                                            ORD('l'),ORD('a'),ORD('t'),ORD('i'),
                                            ORD('o'),ORD('n'),0};
      FILEOKSTRINGW   = WARR_FILEOKSTRING  {ORD('c'),ORD('o'),ORD('m'),ORD('m'),
                                            ORD('d'),ORD('l'),ORD('g'),ORD('_'),
                                            ORD('F'),ORD('i'),ORD('l'),ORD('e'),
                                            ORD('N'),ORD('a'),ORD('m'),ORD('e'),
                                            ORD('O'),ORD('K'),0};
      COLOROKSTRINGW  = WARR_COLOROKSTRING {ORD('c'),ORD('o'),ORD('m'),ORD('m'),
                                            ORD('d'),ORD('l'),ORD('g'),ORD('_'),
                                            ORD('C'),ORD('o'),ORD('l'),ORD('o'),
                                            ORD('r'),ORD('O'),ORD('K'),0};
      SETRGBSTRINGW   = WARR_SETRGBSTRING  {ORD('c'),ORD('o'),ORD('m'),ORD('m'),
                                            ORD('d'),ORD('l'),ORD('g'),ORD('_'),
                                            ORD('S'),ORD('e'),ORD('t'),ORD('R'),
                                            ORD('G'),ORD('B'),ORD('C'),ORD('o'),
                                            ORD('l'),ORD('o'),ORD('r'),0};
      HELPMSGSTRINGW  = WARR_HELPMSGSTRING {ORD('c'),ORD('o'),ORD('m'),ORD('m'),
                                            ORD('d'),ORD('l'),ORD('g'),ORD('_'),
                                            ORD('h'),ORD('e'),ORD('l'),ORD('p'),0};
      FINDMSGSTRINGW  = WARR_FINDMSGSTRING {ORD('c'),ORD('o'),ORD('m'),ORD('m'),
                                            ORD('d'),ORD('l'),ORD('g'),ORD('_'),
                                            ORD('F'),ORD('i'),ORD('n'),ORD('d'),
                                            ORD('R'),ORD('e'),ORD('p'),ORD('l'),
                                            ORD('a'),ORD('c'),ORD('e'),0};

<* IF DEFINED (UNICODE) THEN *>
      CONST LBSELCHSTRING = LBSELCHSTRINGW;
            SHAREVISTRING = SHAREVISTRINGW;
            FILEOKSTRING  = FILEOKSTRINGW;
            COLOROKSTRING = COLOROKSTRINGW;
            SETRGBSTRING  = SETRGBSTRINGW;
            HELPMSGSTRING = HELPMSGSTRINGW;
            FINDMSGSTRING = FINDMSGSTRINGW;
<* ELSE *>
      CONST LBSELCHSTRING = LBSELCHSTRINGA;
            SHAREVISTRING = SHAREVISTRINGA;
            FILEOKSTRING  = FILEOKSTRINGA;
            COLOROKSTRING = COLOROKSTRINGA;
            SETRGBSTRING  = SETRGBSTRINGA;
            HELPMSGSTRING = HELPMSGSTRINGA;
            FINDMSGSTRING = FINDMSGSTRINGA;
<* END *>

(* ----------------------------------------------------------------------- *)

(* HIWORD values for lParam of commdlg_LBSelChangeNotify message *)

CONST CD_LBSELNOITEMS = -1;
      CD_LBSELCHANGE  =  0;
      CD_LBSELSUB     =  1;
      CD_LBSELADD     =  2;


(* ----------------- Print dialog box ------------------------------------ *)

TYPE PRINTHOOKPROC = PROCEDURE (HWND, UINT, WPARAM, LPARAM) : UINT;
TYPE SETUPHOOKPROC = PROCEDURE (HWND, UINT, WPARAM, LPARAM) : UINT;

TYPE PD_ENUM = (PD__SELECTION,                  (*  0 *)
                PD__PAGENUMS,                   (*  1 *)
                PD__NOSELECTION,                (*  2 *)
                PD__NOPAGENUMS,                 (*  3 *)
                PD__COLLATE,                    (*  4 *)
                PD__PRINTTOFILE,                (*  5 *)
                PD__PRINTSETUP,                 (*  6 *)
                PD__NOWARNING,                  (*  7 *)
                PD__RETURNDC,                   (*  8 *)
                PD__RETURNIC,                   (*  9 *)
                PD__RETURNDEFAULT,              (* 10 *)
                PD__SHOWHELP,                   (* 11 *)
                PD__ENABLEPRINTHOOK,            (* 12 *)
                PD__ENABLESETUPHOOK,            (* 13 *)
                PD__ENABLEPRINTTEMPLATE,        (* 14 *)
                PD__ENABLESETUPTEMPLATE,        (* 15 *)
                PD__ENABLEPRINTTEMPLATEHANDLE,  (* 16 *)
                PD__ENABLESETUPTEMPLATEHANDLE,  (* 17 *)
                PD__USEDEVMODECOPIES,           (* 18 *)
                PD__DISABLEPRINTTOFILE,         (* 19 *)
                PD__HIDEPRINTTOFILE,            (* 20 *)
                PD__NONETWORKBUTTON);           (* 21 *)
      PD_SET = SET OF PD_ENUM;
CONST
 PD_ALLPAGES                  = PD_SET {};                              (* 0x00000000 *)
 PD_SELECTION                 = PD_SET {PD__SELECTION};                 (* 0x00000001 *)
 PD_PAGENUMS                  = PD_SET {PD__PAGENUMS};                  (* 0x00000002 *)
 PD_NOSELECTION               = PD_SET {PD__NOSELECTION};               (* 0x00000004 *)
 PD_NOPAGENUMS                = PD_SET {PD__NOPAGENUMS};                (* 0x00000008 *)
 PD_COLLATE                   = PD_SET {PD__COLLATE};                   (* 0x00000010 *)
 PD_PRINTTOFILE               = PD_SET {PD__PRINTTOFILE};               (* 0x00000020 *)
 PD_PRINTSETUP                = PD_SET {PD__PRINTSETUP};                (* 0x00000040 *)
 PD_NOWARNING                 = PD_SET {PD__NOWARNING};                 (* 0x00000080 *)
 PD_RETURNDC                  = PD_SET {PD__RETURNDC};                  (* 0x00000100 *)
 PD_RETURNIC                  = PD_SET {PD__RETURNIC};                  (* 0x00000200 *)
 PD_RETURNDEFAULT             = PD_SET {PD__RETURNDEFAULT};             (* 0x00000400 *)
 PD_SHOWHELP                  = PD_SET {PD__SHOWHELP};                  (* 0x00000800 *)
 PD_ENABLEPRINTHOOK           = PD_SET {PD__ENABLEPRINTHOOK};           (* 0x00001000 *)
 PD_ENABLESETUPHOOK           = PD_SET {PD__ENABLESETUPHOOK};           (* 0x00002000 *)
 PD_ENABLEPRINTTEMPLATE       = PD_SET {PD__ENABLEPRINTTEMPLATE};       (* 0x00004000 *)
 PD_ENABLESETUPTEMPLATE       = PD_SET {PD__ENABLESETUPTEMPLATE};       (* 0x00008000 *)
 PD_ENABLEPRINTTEMPLATEHANDLE = PD_SET {PD__ENABLEPRINTTEMPLATEHANDLE}; (* 0x00010000 *)
 PD_ENABLESETUPTEMPLATEHANDLE = PD_SET {PD__ENABLESETUPTEMPLATEHANDLE}; (* 0x00020000 *)
 PD_USEDEVMODECOPIES          = PD_SET {PD__USEDEVMODECOPIES};          (* 0x00040000 *)
 PD_USEDEVMODECOPIESANDCOLLATE= PD_USEDEVMODECOPIES;                    (* 0x00040000 *)
 PD_DISABLEPRINTTOFILE        = PD_SET {PD__DISABLEPRINTTOFILE};        (* 0x00080000 *)
 PD_HIDEPRINTTOFILE           = PD_SET {PD__HIDEPRINTTOFILE};           (* 0x00100000 *)
 PD_NONETWORKBUTTON           = PD_SET {PD__NONETWORKBUTTON};           (* 0x00200000 *)

TYPE PRINTDLGA = RECORD
                        lStructSize         : DWORD;
                        hwndOwner           : HWND;
                        hDevMode            : HGLOBAL;
                        hDevNames           : HGLOBAL;
                        hDC                 : HDC;
                        Flags               : PD_SET;
                        nFromPage           : WORD;
                        nToPage             : WORD;
                        nMinPage            : WORD;
                        nMaxPage            : WORD;
                        nCopies             : WORD;
                        hInstance           : HINSTANCE;
                        lCustData           : LPARAM;
                        lpfnPrintHook       : PRINTHOOKPROC;
                        lpfnSetupHook       : SETUPHOOKPROC;
                        lpPrintTemplateName : RESOURCESTRA;
                        lpSetupTemplateName : RESOURCESTRA;
                        hPrintTemplate      : HGLOBAL;
                        hSetupTemplate      : HGLOBAL;
                 END;
    PPRINTDLGA = POINTER TO PRINTDLGA;

TYPE PRINTDLGW = RECORD
                        lStructSize         : DWORD;
                        hwndOwner           : HWND;
                        hDevMode            : HGLOBAL;
                        hDevNames           : HGLOBAL;
                        hDC                 : HDC;
                        Flags               : PD_SET;
                        nFromPage           : WORD;
                        nToPage             : WORD;
                        nMinPage            : WORD;
                        nMaxPage            : WORD;
                        nCopies             : WORD;
                        hInstance           : HINSTANCE;
                        lCustData           : LPARAM;
                        lpfnPrintHook       : PRINTHOOKPROC;
                        lpfnSetupHook       : SETUPHOOKPROC;
                        lpPrintTemplateName : RESOURCESTRW;
                        lpSetupTemplateName : RESOURCESTRW;
                        hPrintTemplate      : HGLOBAL;
                        hSetupTemplate      : HGLOBAL;
                 END;
    PPRINTDLGW = POINTER TO PRINTDLGW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  PRINTDLG =  PRINTDLGW;
      TYPE PPRINTDLG = PPRINTDLGW;
<* ELSE *>
      TYPE  PRINTDLG =  PRINTDLGA;
      TYPE PPRINTDLG = PPRINTDLGA;
<* END *>

PROCEDURE PrintDlgA (VAR PrintStruct : PRINTDLGA) : BOOL;
PROCEDURE PrintDlgW (VAR PrintStruct : PRINTDLGW) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST PrintDlg = PrintDlgW;
<* ELSE *>
      CONST PrintDlg = PrintDlgA;
<* END *>

TYPE DEVNAMES = RECORD
                       wDriverOffset : WORD;
                       wDeviceOffset : WORD;
                       wOutputOffset : WORD;
                       wDefault      : WORD;
                END;
     PDEVNAMES = POINTER TO DEVNAMES;

CONST DN_DEFAULTPRN = 1;

(* ----------------------------------------------------------------------- *)

PROCEDURE CommDlgExtendedError () : DWORD;

(* ----------------- Page setup dialog box ------------------------------- *)

TYPE PSD_ENUM = (PSD__MINMARGINS,                    (*  0 - use caller's *)
                 PSD__MARGINS,                       (*  1 - use caller's *)
                 PSD__INTHOUSANDTHSOFINCHES,         (*  2 - 2nd of 4 possible *)
                 PSD__INHUNDREDTHSOFMILLIMETERS,     (*  3 - 3rd of 4 possible *)
                 PSD__DISABLEMARGINS,                (*  4 *)
                 PSD__DISABLEPRINTER,                (*  5 *)
                 PSD__6,

                 PSD__NOWARNING,                     (*  7 - must be same as PD_* *)
                 PSD__DISABLEORIENTATION,            (*  8 *)
                 PSD__DISABLEPAPER,                  (*  9 *)
                 PSD__RETURNDEFAULT,                 (* 10 - must be same as PD_* *)
                 PSD__SHOWHELP,                      (* 11 - must be same as PD_* *)
                 PSD__12,
                 PSD__ENABLEPAGESETUPHOOK,           (* 13 - must be same as PD_* *)
                 PSD__14,
                 PSD__ENABLEPAGESETUPTEMPLATE,       (* 15 - must be same as PD_* *)
                 PSD__16,
                 PSD__ENABLEPAGESETUPTEMPLATEHANDLE, (* 17 - must be same as PD_* *)
                 PSD__ENABLEPAGEPAINTHOOK,           (* 18 *)
                 PSD__DISABLEPAGEPAINTING);          (* 19 *)

     PSD_SET = SET OF PSD_ENUM;

CONST PSD_DEFAULTMINMARGINS             = PSD_SET {}; (* 0x00000000 - default (printer's) *)
      PSD_INWININIINTLMEASURE           = PSD_SET {}; (* 0x00000000 - 1st of 4 possible *)

      PSD_MINMARGINS                    = PSD_SET {PSD__MINMARGINS                    }; (* 0x00000001 - use caller's *)
      PSD_MARGINS                       = PSD_SET {PSD__MARGINS                       }; (* 0x00000002 - use caller's *)
      PSD_INTHOUSANDTHSOFINCHES         = PSD_SET {PSD__INTHOUSANDTHSOFINCHES         }; (* 0x00000004 - 2nd of 4 possible *)
      PSD_INHUNDREDTHSOFMILLIMETERS     = PSD_SET {PSD__INHUNDREDTHSOFMILLIMETERS     }; (* 0x00000008 - 3rd of 4 possible *)
      PSD_DISABLEMARGINS                = PSD_SET {PSD__DISABLEMARGINS                }; (* 0x00000010 *)
      PSD_DISABLEPRINTER                = PSD_SET {PSD__DISABLEPRINTER                }; (* 0x00000020 *)
      PSD_NOWARNING                     = PSD_SET {PSD__NOWARNING                     }; (* 0x00000080 - must be same as PD_* *)
      PSD_DISABLEORIENTATION            = PSD_SET {PSD__DISABLEORIENTATION            }; (* 0x00000100 *)
      PSD_RETURNDEFAULT                 = PSD_SET {PSD__RETURNDEFAULT                 }; (* 0x00000400 - must be same as PD_* *)
      PSD_DISABLEPAPER                  = PSD_SET {PSD__DISABLEPAPER                  }; (* 0x00000200 *)
      PSD_SHOWHELP                      = PSD_SET {PSD__SHOWHELP                      }; (* 0x00000800 - must be same as PD_* *)
      PSD_ENABLEPAGESETUPHOOK           = PSD_SET {PSD__ENABLEPAGESETUPHOOK           }; (* 0x00002000 - must be same as PD_* *)
      PSD_ENABLEPAGESETUPTEMPLATE       = PSD_SET {PSD__ENABLEPAGESETUPTEMPLATE       }; (* 0x00008000 - must be same as PD_* *)
      PSD_ENABLEPAGESETUPTEMPLATEHANDLE = PSD_SET {PSD__ENABLEPAGESETUPTEMPLATEHANDLE }; (* 0x00020000 - must be same as PD_* *)
      PSD_ENABLEPAGEPAINTHOOK           = PSD_SET {PSD__ENABLEPAGEPAINTHOOK           }; (* 0x00040000 *)
      PSD_DISABLEPAGEPAINTING           = PSD_SET {PSD__DISABLEPAGEPAINTING           }; (* 0x00080000 *)

CONST WM_PSD_PAGESETUPDLG   = WM_USER;
      WM_PSD_FULLPAGERECT   = WM_USER+1;
      WM_PSD_MINMARGINRECT  = WM_USER+2;
      WM_PSD_MARGINRECT     = WM_USER+3;
      WM_PSD_GREEKTEXTRECT  = WM_USER+4;
      WM_PSD_ENVSTAMPRECT   = WM_USER+5;
      WM_PSD_YAFULLPAGERECT = WM_USER+6;

TYPE PAGEPAINTHOOK = PROCEDURE (HWND, UINT, WPARAM, LPARAM) : UINT;
TYPE PAGESETUPHOOK = PROCEDURE (HWND, UINT, WPARAM, LPARAM) : UINT;

TYPE PAGESETUPDLGA = RECORD
                            lStructSize             : DWORD;
                            hwndOwner               : HWND;
                            hDevMode                : HGLOBAL;
                            hDevNames               : HGLOBAL;
                            Flags                   : PSD_SET;
                            ptPaperSize             : POINT;
                            rtMinMargin             : RECT;
                            rtMargin                : RECT;
                            hInstance               : HINSTANCE;
                            lCustData               : LPARAM;
                            lpfnPageSetupHook       : PAGESETUPHOOK;
                            lpfnPagePaintHook       : PAGEPAINTHOOK;
                            lpPageSetupTemplateName : PCSTR;
                            hPageSetupTemplate      : HGLOBAL;
                     END;
    PPAGESETUPDLGA = POINTER TO PAGESETUPDLGA;

TYPE PAGESETUPDLGW = RECORD
                            lStructSize             : DWORD;
                            hwndOwner               : HWND;
                            hDevMode                : HGLOBAL;
                            hDevNames               : HGLOBAL;
                            Flags                   : PSD_SET;
                            ptPaperSize             : POINT;
                            rtMinMargin             : RECT;
                            rtMargin                : RECT;
                            hInstance               : HINSTANCE;
                            lCustData               : LPARAM;
                            lpfnPageSetupHook       : PAGESETUPHOOK;
                            lpfnPagePaintHook       : PAGEPAINTHOOK;
                            lpPageSetupTemplateName : PCSTR;
                            hPageSetupTemplate      : HGLOBAL;
                     END;
    PPAGESETUPDLGW = POINTER TO PAGESETUPDLGW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  PAGESETUPDLG =  PAGESETUPDLGW;
      TYPE PPAGESETUPDLG = PPAGESETUPDLGW;
<* ELSE *>
      TYPE  PAGESETUPDLG =  PAGESETUPDLGA;
      TYPE PPAGESETUPDLG = PPAGESETUPDLGA;
<* END *>

PROCEDURE PageSetupDlgA (VAR d : PAGESETUPDLGA) : BOOL;
PROCEDURE PageSetupDlgW (VAR d : PAGESETUPDLGW) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST PageSetupDlg = PageSetupDlgW;
<* ELSE *>
      CONST PageSetupDlg = PageSetupDlgA;
<* END *>

<* POP *> (* back to alignment 8 *)


(* WinSpool.def

    Definition file for Print APIs

*)




TYPE PRINTER_ENUM_ENUM = (PRINTER_ENUM__DEFAULT,     (* 0 *)
                          PRINTER_ENUM__LOCAL,       (* 1 *)
                          PRINTER_ENUM__CONNECTIONS, (* 2 *)
                          PRINTER_ENUM__NAME,        (* 3 *)
                          PRINTER_ENUM__REMOTE,      (* 4 *)
                          PRINTER_ENUM__SHARED,      (* 5 *)
                          PRINTER_ENUM__NETWORK,     (* 6 *)
                          PRINTER_ENUM__7,
                          PRINTER_ENUM__8,
                          PRINTER_ENUM__9,
                          PRINTER_ENUM__10,
                          PRINTER_ENUM__11,
                          PRINTER_ENUM__12,
                          PRINTER_ENUM__13,
                          PRINTER_ENUM__EXPAND,      (* 14*)
                          PRINTER_ENUM__CONTAINER,   (* 15*)

                          PRINTER_ENUM__ICON1,       (* 16*)
                          PRINTER_ENUM__ICON2,       (* 17*)
                          PRINTER_ENUM__ICON3,       (* 18*)
                          PRINTER_ENUM__ICON4,       (* 19*)
                          PRINTER_ENUM__ICON5,       (* 20*)
                          PRINTER_ENUM__ICON6,       (* 21*)
                          PRINTER_ENUM__ICON7,       (* 22*)
                          PRINTER_ENUM__ICON8);      (* 21*)

CONST PRINTER_ENUM__FAVORITE = PRINTER_ENUM__CONNECTIONS;

TYPE PRINTER_ENUM_SET = SET OF PRINTER_ENUM_ENUM;

CONST PRINTER_ENUM_DEFAULT     = PRINTER_ENUM_SET {PRINTER_ENUM__DEFAULT    }; (* 0x00000001 *)
      PRINTER_ENUM_LOCAL       = PRINTER_ENUM_SET {PRINTER_ENUM__LOCAL      }; (* 0x00000002 *)
      PRINTER_ENUM_CONNECTIONS = PRINTER_ENUM_SET {PRINTER_ENUM__CONNECTIONS}; (* 0x00000004 *)
      PRINTER_ENUM_FAVORITE    = PRINTER_ENUM_SET {PRINTER_ENUM__FAVORITE   }; (* 0x00000004 *)
      PRINTER_ENUM_NAME        = PRINTER_ENUM_SET {PRINTER_ENUM__NAME       }; (* 0x00000008 *)
      PRINTER_ENUM_REMOTE      = PRINTER_ENUM_SET {PRINTER_ENUM__REMOTE     }; (* 0x00000010 *)
      PRINTER_ENUM_SHARED      = PRINTER_ENUM_SET {PRINTER_ENUM__SHARED     }; (* 0x00000020 *)
      PRINTER_ENUM_NETWORK     = PRINTER_ENUM_SET {PRINTER_ENUM__NETWORK    }; (* 0x00000040 *)

      PRINTER_ENUM_EXPAND      = PRINTER_ENUM_SET {PRINTER_ENUM__EXPAND     }; (* 0x00004000 *)
      PRINTER_ENUM_CONTAINER   = PRINTER_ENUM_SET {PRINTER_ENUM__CONTAINER  }; (* 0x00008000 *)

      PRINTER_ENUM_ICONMASK    = PRINTER_ENUM_SET {PRINTER_ENUM__ICON1..
                                                   PRINTER_ENUM__ICON8      }; (* 0x00ff0000 *)
      PRINTER_ENUM_ICON1       = PRINTER_ENUM_SET {PRINTER_ENUM__ICON1      }; (* 0x00010000 *)
      PRINTER_ENUM_ICON2       = PRINTER_ENUM_SET {PRINTER_ENUM__ICON2      }; (* 0x00020000 *)
      PRINTER_ENUM_ICON3       = PRINTER_ENUM_SET {PRINTER_ENUM__ICON3      }; (* 0x00040000 *)
      PRINTER_ENUM_ICON4       = PRINTER_ENUM_SET {PRINTER_ENUM__ICON4      }; (* 0x00080000 *)
      PRINTER_ENUM_ICON5       = PRINTER_ENUM_SET {PRINTER_ENUM__ICON5      }; (* 0x00100000 *)
      PRINTER_ENUM_ICON6       = PRINTER_ENUM_SET {PRINTER_ENUM__ICON6      }; (* 0x00200000 *)
      PRINTER_ENUM_ICON7       = PRINTER_ENUM_SET {PRINTER_ENUM__ICON7      }; (* 0x00400000 *)
      PRINTER_ENUM_ICON8       = PRINTER_ENUM_SET {PRINTER_ENUM__ICON8      }; (* 0x00800000 *)


TYPE PRINTER_INFO_1A = RECORD
                              Flags        : PRINTER_ENUM_SET;
                              pDescription : PSTR;
                              pName        : PSTR;
                              pComment     : PSTR;
                       END;
     PPRINTER_INFO_1A = POINTER TO PRINTER_INFO_1A;

TYPE PRINTER_INFO_1W = RECORD
                              Flags        : PRINTER_ENUM_SET;
                              pDescription : PWSTR;
                              pName        : PWSTR;
                              pComment     : PWSTR;
                       END;
     PPRINTER_INFO_1W = POINTER TO PRINTER_INFO_1W;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  PRINTER_INFO_1 =  PRINTER_INFO_1W;
      TYPE PPRINTER_INFO_1 = PPRINTER_INFO_1W;
<* ELSE *>
      TYPE  PRINTER_INFO_1 =  PRINTER_INFO_1A;
      TYPE PPRINTER_INFO_1 = PPRINTER_INFO_1A;
<* END *>

(* Status field values for PRINTER_INFO_2 *)

TYPE PRINTER_STATUS_ENUM = (PRINTER_STATUS__PAUSED,            (* 0 *)
                            PRINTER_STATUS__ERROR,             (* 1 *)
                            PRINTER_STATUS__PENDING_DELETION,  (* 2 *)
                            PRINTER_STATUS__PAPER_JAM,         (* 3 *)
                            PRINTER_STATUS__PAPER_OUT,         (* 4 *)
                            PRINTER_STATUS__MANUAL_FEED,       (* 5 *)
                            PRINTER_STATUS__PAPER_PROBLEM,     (* 6 *)
                            PRINTER_STATUS__OFFLINE,           (* 7 *)
                            PRINTER_STATUS__IO_ACTIVE,         (* 8 *)
                            PRINTER_STATUS__BUSY,              (* 9 *)
                            PRINTER_STATUS__PRINTING,          (* 10 *)
                            PRINTER_STATUS__OUTPUT_BIN_FULL,   (* 11 *)
                            PRINTER_STATUS__NOT_AVAILABLE,     (* 12 *)
                            PRINTER_STATUS__WAITING,           (* 13 *)
                            PRINTER_STATUS__PROCESSING,        (* 14 *)
                            PRINTER_STATUS__INITIALIZING,      (* 15 *)
                            PRINTER_STATUS__WARMING_UP,        (* 16 *)
                            PRINTER_STATUS__TONER_LOW,         (* 17 *)
                            PRINTER_STATUS__NO_TONER,          (* 18 *)
                            PRINTER_STATUS__PAGE_PUNT,         (* 19 *)
                            PRINTER_STATUS__USER_INTERVENTION, (* 20 *)
                            PRINTER_STATUS__OUT_OF_MEMORY,     (* 21 *)
                            PRINTER_STATUS__DOOR_OPEN,         (* 22 *)
                            PRINTER_STATUS__SERVER_UNKNOWN,    (* 23 *)
                            PRINTER_STATUS__POWER_SAVE);       (* 24 *)
     PRINTER_STATUS_SET = SET OF PRINTER_STATUS_ENUM;

CONST PRINTER_STATUS_PAUSED            = PRINTER_STATUS_SET {PRINTER_STATUS__PAUSED           }; (* 0x00000001 *)
      PRINTER_STATUS_ERROR             = PRINTER_STATUS_SET {PRINTER_STATUS__ERROR            }; (* 0x00000002 *)
      PRINTER_STATUS_PENDING_DELETION  = PRINTER_STATUS_SET {PRINTER_STATUS__PENDING_DELETION }; (* 0x00000004 *)
      PRINTER_STATUS_PAPER_JAM         = PRINTER_STATUS_SET {PRINTER_STATUS__PAPER_JAM        }; (* 0x00000008 *)
      PRINTER_STATUS_PAPER_OUT         = PRINTER_STATUS_SET {PRINTER_STATUS__PAPER_OUT        }; (* 0x00000010 *)
      PRINTER_STATUS_MANUAL_FEED       = PRINTER_STATUS_SET {PRINTER_STATUS__MANUAL_FEED      }; (* 0x00000020 *)
      PRINTER_STATUS_PAPER_PROBLEM     = PRINTER_STATUS_SET {PRINTER_STATUS__PAPER_PROBLEM    }; (* 0x00000040 *)
      PRINTER_STATUS_OFFLINE           = PRINTER_STATUS_SET {PRINTER_STATUS__OFFLINE          }; (* 0x00000080 *)
      PRINTER_STATUS_IO_ACTIVE         = PRINTER_STATUS_SET {PRINTER_STATUS__IO_ACTIVE        }; (* 0x00000100 *)
      PRINTER_STATUS_BUSY              = PRINTER_STATUS_SET {PRINTER_STATUS__BUSY             }; (* 0x00000200 *)
      PRINTER_STATUS_PRINTING          = PRINTER_STATUS_SET {PRINTER_STATUS__PRINTING         }; (* 0x00000400 *)
      PRINTER_STATUS_OUTPUT_BIN_FULL   = PRINTER_STATUS_SET {PRINTER_STATUS__OUTPUT_BIN_FULL  }; (* 0x00000800 *)
      PRINTER_STATUS_NOT_AVAILABLE     = PRINTER_STATUS_SET {PRINTER_STATUS__NOT_AVAILABLE    }; (* 0x00001000 *)
      PRINTER_STATUS_WAITING           = PRINTER_STATUS_SET {PRINTER_STATUS__WAITING          }; (* 0x00002000 *)
      PRINTER_STATUS_PROCESSING        = PRINTER_STATUS_SET {PRINTER_STATUS__PROCESSING       }; (* 0x00004000 *)
      PRINTER_STATUS_INITIALIZING      = PRINTER_STATUS_SET {PRINTER_STATUS__INITIALIZING     }; (* 0x00008000 *)
      PRINTER_STATUS_WARMING_UP        = PRINTER_STATUS_SET {PRINTER_STATUS__WARMING_UP       }; (* 0x00010000 *)
      PRINTER_STATUS_TONER_LOW         = PRINTER_STATUS_SET {PRINTER_STATUS__TONER_LOW        }; (* 0x00020000 *)
      PRINTER_STATUS_NO_TONER          = PRINTER_STATUS_SET {PRINTER_STATUS__NO_TONER         }; (* 0x00040000 *)
      PRINTER_STATUS_PAGE_PUNT         = PRINTER_STATUS_SET {PRINTER_STATUS__PAGE_PUNT        }; (* 0x00080000 *)
      PRINTER_STATUS_USER_INTERVENTION = PRINTER_STATUS_SET {PRINTER_STATUS__USER_INTERVENTION}; (* 0x00100000 *)
      PRINTER_STATUS_OUT_OF_MEMORY     = PRINTER_STATUS_SET {PRINTER_STATUS__OUT_OF_MEMORY    }; (* 0x00200000 *)
      PRINTER_STATUS_DOOR_OPEN         = PRINTER_STATUS_SET {PRINTER_STATUS__DOOR_OPEN        }; (* 0x00400000 *)
      PRINTER_STATUS_SERVER_UNKNOWN    = PRINTER_STATUS_SET {PRINTER_STATUS__SERVER_UNKNOWN   }; (* 0x00800000 *)
      PRINTER_STATUS_POWER_SAVE        = PRINTER_STATUS_SET {PRINTER_STATUS__POWER_SAVE       }; (* 0x01000000 *)

(* Attributes field for PRINTER_INFO_2 *)

TYPE PRINTER_ATTRIBUTE_ENUM = (PRINTER_ATTRIBUTE__QUEUED,            (* 0 *)
                               PRINTER_ATTRIBUTE__DIRECT,            (* 1 *)
                               PRINTER_ATTRIBUTE__DEFAULT,           (* 2 *)
                               PRINTER_ATTRIBUTE__SHARED,            (* 3 *)
                               PRINTER_ATTRIBUTE__NETWORK,           (* 4 *)
                               PRINTER_ATTRIBUTE__HIDDEN,            (* 5 *)
                               PRINTER_ATTRIBUTE__LOCAL,             (* 6 *)
                               PRINTER_ATTRIBUTE__ENABLE_DEVQ,       (* 7 *)
                               PRINTER_ATTRIBUTE__KEEPPRINTEDJOBS,   (* 8 *)
                               PRINTER_ATTRIBUTE__DO_COMPLETE_FIRST, (* 9 *)
                               PRINTER_ATTRIBUTE__WORK_OFFLINE,      (* 10 *)
                               PRINTER_ATTRIBUTE__ENABLE_BIDI);      (* 11 *)
     PRINTER_ATTRIBUTE_SET = SET OF PRINTER_ATTRIBUTE_ENUM;

CONST PRINTER_ATTRIBUTE_QUEUED         = PRINTER_ATTRIBUTE_SET {PRINTER_ATTRIBUTE__QUEUED }; (* 0x00000001 *)
      PRINTER_ATTRIBUTE_DIRECT         = PRINTER_ATTRIBUTE_SET {PRINTER_ATTRIBUTE__DIRECT }; (* 0x00000002 *)
      PRINTER_ATTRIBUTE_DEFAULT        = PRINTER_ATTRIBUTE_SET {PRINTER_ATTRIBUTE__DEFAULT}; (* 0x00000004 *)
      PRINTER_ATTRIBUTE_SHARED         = PRINTER_ATTRIBUTE_SET {PRINTER_ATTRIBUTE__SHARED }; (* 0x00000008 *)
      PRINTER_ATTRIBUTE_NETWORK        = PRINTER_ATTRIBUTE_SET {PRINTER_ATTRIBUTE__NETWORK}; (* 0x00000010 *)
      PRINTER_ATTRIBUTE_HIDDEN         = PRINTER_ATTRIBUTE_SET {PRINTER_ATTRIBUTE__HIDDEN }; (* 0x00000020 *)
      PRINTER_ATTRIBUTE_LOCAL          = PRINTER_ATTRIBUTE_SET {PRINTER_ATTRIBUTE__LOCAL  }; (* 0x00000040 *)

      PRINTER_ATTRIBUTE_ENABLE_DEVQ       = PRINTER_ATTRIBUTE_SET {PRINTER_ATTRIBUTE__ENABLE_DEVQ      }; (* 0x00000080 *)
      PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS   = PRINTER_ATTRIBUTE_SET {PRINTER_ATTRIBUTE__KEEPPRINTEDJOBS  }; (* 0x00000100 *)
      PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST = PRINTER_ATTRIBUTE_SET {PRINTER_ATTRIBUTE__DO_COMPLETE_FIRST}; (* 0x00000200 *)

      PRINTER_ATTRIBUTE_WORK_OFFLINE   = PRINTER_ATTRIBUTE_SET {PRINTER_ATTRIBUTE__WORK_OFFLINE}; (* 0x00000400 *)
      PRINTER_ATTRIBUTE_ENABLE_BIDI    = PRINTER_ATTRIBUTE_SET {PRINTER_ATTRIBUTE__ENABLE_BIDI }; (* 0x00000800 *)


TYPE PRINTER_INFO_2A = RECORD
                              pServerName         : PSTR;
                              pPrinterName        : PSTR;
                              pShareName          : PSTR;
                              pPortName           : PSTR;
                              pDriverName         : PSTR;
                              pComment            : PSTR;
                              pLocation           : PSTR;
                              pDevMode            : PDEVMODEA;
                              pSepFile            : PSTR;
                              pPrintProcessor     : PSTR;
                              pDatatype           : PSTR;
                              pParameters         : PSTR;
                              pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                              Attributes          : PRINTER_ATTRIBUTE_SET;
                              Priority            : DWORD;
                              DefaultPriority     : DWORD;
                              StartTime           : DWORD;
                              UntilTime           : DWORD;
                              Status              : PRINTER_STATUS_SET;
                              cJobs               : DWORD;
                              AveragePPM          : DWORD;
                       END;
    PPRINTER_INFO_2A = POINTER TO PRINTER_INFO_2A;

TYPE PRINTER_INFO_2W = RECORD
                              pServerName         : PWSTR;
                              pPrinterName        : PWSTR;
                              pShareName          : PWSTR;
                              pPortName           : PWSTR;
                              pDriverName         : PWSTR;
                              pComment            : PWSTR;
                              pLocation           : PWSTR;
                              pDevMode            : PDEVMODEW;
                              pSepFile            : PWSTR;
                              pPrintProcessor     : PWSTR;
                              pDatatype           : PWSTR;
                              pParameters         : PWSTR;
                              pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                              Attributes          : PRINTER_ATTRIBUTE_SET;
                              Priority            : DWORD;
                              DefaultPriority     : DWORD;
                              StartTime           : DWORD;
                              UntilTime           : DWORD;
                              Status              : PRINTER_STATUS_SET;
                              cJobs               : DWORD;
                              AveragePPM          : DWORD;
                       END;
    PPRINTER_INFO_2W = POINTER TO PRINTER_INFO_2W;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  PRINTER_INFO_2 =  PRINTER_INFO_2W;
      TYPE PPRINTER_INFO_2 = PPRINTER_INFO_2W;
<* ELSE *>
      TYPE  PRINTER_INFO_2 =  PRINTER_INFO_2A;
      TYPE PPRINTER_INFO_2 = PPRINTER_INFO_2A;
<* END *>

TYPE PRINTER_INFO_3 = RECORD
                             pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                      END;

    PPRINTER_INFO_3 = POINTER TO PRINTER_INFO_3;

TYPE PRINTER_INFO_4A = RECORD
                              pPrinterName : PSTR;
                              pServerName  : PSTR;
                              Attributes   : PRINTER_ATTRIBUTE_SET;
                       END;
    PPRINTER_INFO_4A = POINTER TO PRINTER_INFO_4A;

TYPE PRINTER_INFO_4W = RECORD
                              pPrinterName : PWSTR;
                              pServerName  : PWSTR;
                              Attributes   : PRINTER_ATTRIBUTE_SET;
                       END;
    PPRINTER_INFO_4W = POINTER TO PRINTER_INFO_4W;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  PRINTER_INFO_4 =  PRINTER_INFO_4W;
      TYPE PPRINTER_INFO_4 = PPRINTER_INFO_4W;
<* ELSE *>
      TYPE  PRINTER_INFO_4 =  PRINTER_INFO_4A;
      TYPE PPRINTER_INFO_4 = PPRINTER_INFO_4A;
<* END *>

TYPE PRINTER_INFO_5A = RECORD
                              pPrinterName             : PSTR;
                              pPortName                : PSTR;
                              Attributes               : PRINTER_ATTRIBUTE_SET;
                              DeviceNotSelectedTimeout : DWORD;
                              TransmissionRetryTimeout : DWORD;
                       END;
    PPRINTER_INFO_5A = POINTER TO PRINTER_INFO_5A;

TYPE PRINTER_INFO_5W = RECORD
                              pPrinterName             : PWSTR;
                              pPortName                : PWSTR;
                              Attributes               : PRINTER_ATTRIBUTE_SET;
                              DeviceNotSelectedTimeout : DWORD;
                              TransmissionRetryTimeout : DWORD;
                       END;
    PPRINTER_INFO_5W = POINTER TO PRINTER_INFO_5W;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  PRINTER_INFO_5 =  PRINTER_INFO_5W;
      TYPE PPRINTER_INFO_5 = PPRINTER_INFO_5W;
<* ELSE *>
      TYPE  PRINTER_INFO_5 =  PRINTER_INFO_5A;
      TYPE PPRINTER_INFO_5 = PPRINTER_INFO_5A;
<* END *>

TYPE PRINTER_CONTROL_ENUM = (PRINTER_CONTROL_0,
                             PRINTER_CONTROL_PAUSE,        (* 1 *)
                             PRINTER_CONTROL_RESUME,       (* 2 *)
                             PRINTER_CONTROL_PURGE,        (* 3 *)
                             PRINTER_CONTROL_SET_STATUS);  (* 4 *)

CONST  NO_PRIORITY  =  0;
      MAX_PRIORITY  = 99;
      MIN_PRIORITY  =  1;
      DEF_PRIORITY  =  1;

(* Values for Priority field of JOB_STATUS structure *)

TYPE JOB_STATUS_ENUM = (JOB_STATUS__PAUSED,             (* 0 *)
                        JOB_STATUS__ERROR,              (* 1 *)
                        JOB_STATUS__DELETING,           (* 2 *)
                        JOB_STATUS__SPOOLING,           (* 3 *)
                        JOB_STATUS__PRINTING,           (* 4 *)
                        JOB_STATUS__OFFLINE,            (* 5 *)
                        JOB_STATUS__PAPEROUT,           (* 6 *)
                        JOB_STATUS__PRINTED,            (* 7 *)
                        JOB_STATUS__DELETED,            (* 8 *)
                        JOB_STATUS__BLOCKED_DEVQ,       (* 9 *)
                        JOB_STATUS__USER_INTERVENTION); (*10 *)

     JOB_STATUS_SET = SET OF JOB_STATUS_ENUM;

CONST JOB_STATUS_PAUSED              = JOB_STATUS_SET {JOB_STATUS__PAUSED       };     (* 0x00000001 *)
      JOB_STATUS_ERROR               = JOB_STATUS_SET {JOB_STATUS__ERROR        };     (* 0x00000002 *)
      JOB_STATUS_DELETING            = JOB_STATUS_SET {JOB_STATUS__DELETING     };     (* 0x00000004 *)
      JOB_STATUS_SPOOLING            = JOB_STATUS_SET {JOB_STATUS__SPOOLING     };     (* 0x00000008 *)
      JOB_STATUS_PRINTING            = JOB_STATUS_SET {JOB_STATUS__PRINTING     };     (* 0x00000010 *)
      JOB_STATUS_OFFLINE             = JOB_STATUS_SET {JOB_STATUS__OFFLINE      };     (* 0x00000020 *)
      JOB_STATUS_PAPEROUT            = JOB_STATUS_SET {JOB_STATUS__PAPEROUT     };     (* 0x00000040 *)
      JOB_STATUS_PRINTED             = JOB_STATUS_SET {JOB_STATUS__PRINTED      };     (* 0x00000080 *)
      JOB_STATUS_DELETED             = JOB_STATUS_SET {JOB_STATUS__DELETED      };     (* 0x00000100 *)
      JOB_STATUS_BLOCKED_DEVQ        = JOB_STATUS_SET {JOB_STATUS__BLOCKED_DEVQ };     (* 0x00000200 *)
      JOB_STATUS_USER_INTERVENTION   = JOB_STATUS_SET {JOB_STATUS__USER_INTERVENTION}; (* 0x00000400 *)


TYPE JOB_INFO_1A = RECORD
                          JobId        : DWORD;
                          pPrinterName : PSTR;
                          pMachineName : PSTR;
                          pUserName    : PSTR;
                          pDocument    : PSTR;
                          pDatatype    : PSTR;
                          pStatus      : PSTR;
                          Status       : JOB_STATUS_SET;
                          Priority     : DWORD;
                          Position     : DWORD;
                          TotalPages   : DWORD;
                          PagesPrinted : DWORD;
                          Submitted    : SYSTEMTIME;
                   END;
    PJOB_INFO_1A = POINTER TO JOB_INFO_1A;

TYPE JOB_INFO_1W = RECORD
                          JobId        : DWORD;
                          pPrinterName : PWSTR;
                          pMachineName : PWSTR;
                          pUserName    : PWSTR;
                          pDocument    : PWSTR;
                          pDatatype    : PWSTR;
                          pStatus      : PWSTR;
                          Status       : JOB_STATUS_SET;
                          Priority     : DWORD;
                          Position     : DWORD;
                          TotalPages   : DWORD;
                          PagesPrinted : DWORD;
                          Submitted    : SYSTEMTIME;
                   END;
    PJOB_INFO_1W = POINTER TO JOB_INFO_1W;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  JOB_INFO_1 =  JOB_INFO_1W;
      TYPE PJOB_INFO_1 = PJOB_INFO_1W;
<* ELSE *>
      TYPE  JOB_INFO_1 =  JOB_INFO_1A;
      TYPE PJOB_INFO_1 = PJOB_INFO_1A;
<* END *>

TYPE JOB_INFO_2A = RECORD
                          JobId               : DWORD;
                          pPrinterName        : PSTR;
                          pMachineName        : PSTR;
                          pUserName           : PSTR;
                          pDocument           : PSTR;
                          pNotifyName         : PSTR;
                          pDatatype           : PSTR;
                          pPrintProcessor     : PSTR;
                          pParameters         : PSTR;
                          pDriverName         : PSTR;
                          pDevMode            : PDEVMODEA;
                          pStatus             : PSTR;
                          pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                          Status              : JOB_STATUS_SET;
                          Priority            : DWORD;
                          Position            : DWORD;
                          StartTime           : DWORD;
                          UntilTime           : DWORD;
                          TotalPages          : DWORD;
                          Size                : DWORD;
                          Submitted           : SYSTEMTIME;      (* Time the job was spooled *)
                          Time                : DWORD;           (* How many seconds the job has been printing *)
                          PagesPrinted        : DWORD;
                   END;
    PJOB_INFO_2A = POINTER TO JOB_INFO_2A;

TYPE JOB_INFO_2W = RECORD
                          JobId               : DWORD;
                          pPrinterName        : PWSTR;
                          pMachineName        : PWSTR;
                          pUserName           : PWSTR;
                          pDocument           : PWSTR;
                          pNotifyName         : PWSTR;
                          pDatatype           : PWSTR;
                          pPrintProcessor     : PWSTR;
                          pParameters         : PWSTR;
                          pDriverName         : PWSTR;
                          pDevMode            : PDEVMODEW;
                          pStatus             : PWSTR;
                          pSecurityDescriptor : PSECURITY_DESCRIPTOR;
                          Status              : JOB_STATUS_SET;
                          Priority            : DWORD;
                          Position            : DWORD;
                          StartTime           : DWORD;
                          UntilTime           : DWORD;
                          TotalPages          : DWORD;
                          Size                : DWORD;
                          Submitted           : SYSTEMTIME; (* Time the job was spooled *)
                          Time                : DWORD;      (* How many seconds the job has been printing *)
                          PagesPrinted        : DWORD;
                   END;
    PJOB_INFO_2W = POINTER TO JOB_INFO_2W;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  JOB_INFO_2 =  JOB_INFO_2W;
      TYPE PJOB_INFO_2 = PJOB_INFO_2W;
<* ELSE *>
      TYPE  JOB_INFO_2 =  JOB_INFO_2A;
      TYPE PJOB_INFO_2 = PJOB_INFO_2A;
<* END *>

TYPE JOB_CONTROL_ENUM = (JOB_CONTROL_0,
                         JOB_CONTROL_PAUSE,    (* 1 *)
                         JOB_CONTROL_RESUME,   (* 2 *)
                         JOB_CONTROL_CANCEL,   (* 3 *)
                         JOB_CONTROL_RESTART,  (* 4 *)
                         JOB_CONTROL_DELETE);  (* 5 *)

CONST JOB_POSITION_UNSPECIFIED = 0;

TYPE ADDJOB_INFO_1A = RECORD
                             Path  : PSTR;
                             JobId : DWORD;
                      END;
    PADDJOB_INFO_1A = POINTER TO ADDJOB_INFO_1A;

TYPE ADDJOB_INFO_1W = RECORD
                             Path  : PWSTR;
                             JobId : DWORD;
                      END;
    PADDJOB_INFO_1W = POINTER TO ADDJOB_INFO_1W;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  ADDJOB_INFO_1 =  ADDJOB_INFO_1W;
      TYPE PADDJOB_INFO_1 = PADDJOB_INFO_1W;
<* ELSE *>
      TYPE  ADDJOB_INFO_1 =  ADDJOB_INFO_1A;
      TYPE PADDJOB_INFO_1 = PADDJOB_INFO_1A;
<* END *>

TYPE DRIVER_INFO_1A  = RECORD
                              pName : PSTR;              (* QMS 810 *)
                       END;
     PDRIVER_INFO_1A = POINTER TO DRIVER_INFO_1A;

TYPE DRIVER_INFO_1W  = RECORD
                              pName : PWSTR;            (* QMS 810 *)
                       END;
     PDRIVER_INFO_1W = POINTER TO DRIVER_INFO_1W;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  DRIVER_INFO_1 =  DRIVER_INFO_1W;
      TYPE PDRIVER_INFO_1 = PDRIVER_INFO_1W;
<* ELSE *>
      TYPE  DRIVER_INFO_1 =  DRIVER_INFO_1A;
      TYPE PDRIVER_INFO_1 = PDRIVER_INFO_1A;
<* END *>


TYPE DRIVER_INFO_2A  = RECORD
                              cVersion     : DWORD;
                              pName        : PSTR;  (* QMS 810 *)
                              pEnvironment : PSTR;  (* Win32 x86 *)
                              pDriverPath  : PSTR;  (* c:\drivers\pscript.dll *)
                              pDataFile    : PSTR;  (* c:\drivers\QMS810.PPD *)
                              pConfigFile  : PSTR;  (* c:\drivers\PSCRPTUI.DLL *)
                       END;
     PDRIVER_INFO_2A = POINTER TO DRIVER_INFO_2A;

TYPE DRIVER_INFO_2W  = RECORD
                              cVersion     : DWORD;
                              pName        : PWSTR;  (* QMS 810 *)
                              pEnvironment : PWSTR;  (* Win32 x86 *)
                              pDriverPath  : PWSTR;  (* c:\drivers\pscript.dll *)
                              pDataFile    : PWSTR;  (* c:\drivers\QMS810.PPD *)
                              pConfigFile  : PWSTR;  (* c:\drivers\PSCRPTUI.DLL *)
                      END;
    PDRIVER_INFO_2W = POINTER TO DRIVER_INFO_2W;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  DRIVER_INFO_2 =  DRIVER_INFO_2W;
      TYPE PDRIVER_INFO_2 = PDRIVER_INFO_2W;
<* ELSE *>
      TYPE  DRIVER_INFO_2 =  DRIVER_INFO_2A;
      TYPE PDRIVER_INFO_2 = PDRIVER_INFO_2A;
<* END *>

TYPE DRIVER_INFO_3A  = RECORD
                              cVersion         : DWORD;
                              pName            : PSTR;   (* QMS 810 *)
                              pEnvironment     : PSTR;   (* Win32 x86 *)
                              pDriverPath      : PSTR;   (* c:\drivers\pscript.dll *)
                              pDataFile        : PSTR;   (* c:\drivers\QMS810.PPD *)
                              pConfigFile      : PSTR;   (* c:\drivers\PSCRPTUI.DLL *)
                              pHelpFile        : PSTR;   (* c:\drivers\PSCRPTUI.HLP *)
                              pDependentFiles  : PSTR;   (* PSCRIPT.DLL\0QMS810.PPD\0PSCRIPTUI.DLL\0PSCRIPTUI.HLP\0PSTEST.TXT\0\0 *)
                              pMonitorName     : PSTR;   (* "PJL monitor" *)
                              pDefaultDataType : PSTR;   (* "EMF" *)
                       END;
     PDRIVER_INFO_3A = POINTER TO DRIVER_INFO_3A;

TYPE DRIVER_INFO_3W  = RECORD
                              cVersion         : DWORD;
                              pName            : PWSTR;   (* QMS 810 *)
                              pEnvironment     : PWSTR;   (* Win32 x86 *)
                              pDriverPath      : PWSTR;   (* c:\drivers\pscript.dll *)
                              pDataFile        : PWSTR;   (* c:\drivers\QMS810.PPD *)
                              pConfigFile      : PWSTR;   (* c:\drivers\PSCRPTUI.DLL *)
                              pHelpFile        : PWSTR;   (* c:\drivers\PSCRPTUI.HLP *)
                              pDependentFiles  : PWSTR;   (* PSCRIPT.DLL\0QMS810.PPD\0PSCRIPTUI.DLL\0PSCRIPTUI.HLP\0PSTEST.TXT\0\0 *)
                              pMonitorName     : PWSTR;   (* "PJL monitor" *)
                              pDefaultDataType : PWSTR;   (* "EMF" *)
                       END;
     PDRIVER_INFO_3W = POINTER TO DRIVER_INFO_3W;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  DRIVER_INFO_3 =  DRIVER_INFO_3W;
      TYPE PDRIVER_INFO_3 = PDRIVER_INFO_3W;
<* ELSE *>
      TYPE  DRIVER_INFO_3 =  DRIVER_INFO_3A;
      TYPE PDRIVER_INFO_3 = PDRIVER_INFO_3A;
<* END *>

TYPE DOC_INFO_1A  = RECORD
                           pDocName    : PSTR;
                           pOutputFile : PSTR;
                           pDatatype   : PSTR;
                    END;
     PDOC_INFO_1A = POINTER TO DOC_INFO_1A;

TYPE DOC_INFO_1W  = RECORD
                           pDocName    : PWSTR;
                           pOutputFile : PWSTR;
                           pDatatype   : PWSTR;
                    END;
     PDOC_INFO_1W = POINTER TO DOC_INFO_1W;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  DOC_INFO_1 =  DOC_INFO_1W;
      TYPE PDOC_INFO_1 = PDOC_INFO_1W;
<* ELSE *>
      TYPE  DOC_INFO_1 =  DOC_INFO_1A;
      TYPE PDOC_INFO_1 = PDOC_INFO_1A;
<* END *>

TYPE FORM_FLAGS_ENUM = (FORM__BUILTIN); (* 0 *)
     FORM_FLAGS_SET = SET OF FORM_FLAGS_ENUM;

CONST FORM_BUILTIN = FORM_FLAGS_SET {FORM__BUILTIN}; (* 0x00000001 *)

TYPE FORM_INFO_1A  = RECORD
                             Flags         : FORM_FLAGS_SET;
                             pName         : PSTR;
                             Size          : SIZEL;
                             ImageableArea : RECTL;
                     END;
     PFORM_INFO_1A = POINTER TO FORM_INFO_1A;

TYPE FORM_INFO_1W  = RECORD
                             Flags         : FORM_FLAGS_SET;
                             pName         : PWSTR;
                             Size          : SIZEL;
                             ImageableArea : RECTL;
                     END;
     PFORM_INFO_1W = POINTER TO FORM_INFO_1W;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  FORM_INFO_1 =  FORM_INFO_1W;
      TYPE PFORM_INFO_1 = PFORM_INFO_1W;
<* ELSE *>
      TYPE  FORM_INFO_1 =  FORM_INFO_1A;
      TYPE PFORM_INFO_1 = PFORM_INFO_1A;
<* END *>

TYPE _DI_ENUM = (DI_0,
                 DI_CHANNEL,         (* 1 - start direct read/write channel, *)
                 DI_CHANNEL_WRITE,   (* 2 - Direct write only - background read thread ok *)
                 DI_READ_SPOOL_JOB); (* 3 *)

TYPE DOC_INFO_2A  = RECORD
                           pDocName    : PSTR;
                           pOutputFile : PSTR;
                           pDatatype   : PSTR;
                           dwMode      : _DI_ENUM;
                           JobId       : DWORD;
                    END;
     PDOC_INFO_2A = POINTER TO DOC_INFO_2A;

TYPE DOC_INFO_2W  = RECORD
                           pDocName    : PWSTR;
                           pOutputFile : PWSTR;
                           pDatatype   : PWSTR;
                           dwMode      : _DI_ENUM;
                           JobId       : DWORD;
                    END;
     PDOC_INFO_2W = POINTER TO DOC_INFO_2W;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  DOC_INFO_2 =  DOC_INFO_2W;
      TYPE PDOC_INFO_2 = PDOC_INFO_2W;
<* ELSE *>
      TYPE  DOC_INFO_2 =  DOC_INFO_2A;
      TYPE PDOC_INFO_2 = PDOC_INFO_2A;
<* END *>

TYPE PRINTPROCESSOR_INFO_1A  = RECORD
                                      pName : PSTR;
                               END;
     PPRINTPROCESSOR_INFO_1A = POINTER TO PRINTPROCESSOR_INFO_1A;

TYPE PRINTPROCESSOR_INFO_1W  = RECORD
                                      pName : PWSTR;
                               END;
     PPRINTPROCESSOR_INFO_1W = POINTER TO PRINTPROCESSOR_INFO_1W;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  PRINTPROCESSOR_INFO_1 =  PRINTPROCESSOR_INFO_1W;
      TYPE PPRINTPROCESSOR_INFO_1 = PPRINTPROCESSOR_INFO_1W;
<* ELSE *>
      TYPE  PRINTPROCESSOR_INFO_1 =  PRINTPROCESSOR_INFO_1A;
      TYPE PPRINTPROCESSOR_INFO_1 = PPRINTPROCESSOR_INFO_1A;
<* END *>

TYPE PORT_INFO_1A  = RECORD
                            pName : PSTR;
                     END;
     PPORT_INFO_1A = POINTER TO PORT_INFO_1A;

TYPE PORT_INFO_1W  = RECORD
                            pName : PWSTR;
                     END;
     PPORT_INFO_1W = POINTER TO PORT_INFO_1W;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  PORT_INFO_1 =  PORT_INFO_1W;
      TYPE PPORT_INFO_1 = PPORT_INFO_1W;
<* ELSE *>
      TYPE  PORT_INFO_1 =  PORT_INFO_1A;
      TYPE PPORT_INFO_1 = PPORT_INFO_1A;
<* END *>

(* fPortType values for PORT_INFO_2 *)

TYPE PORT_TYPE_ENUM = (PORT_TYPE__WRITE,         (* 0 *)
                       PORT_TYPE__READ,          (* 1 *)
                       PORT_TYPE__REDIRECTED,    (* 2 *)
                       PORT_TYPE__NET_ATTACHED); (* 3 *)

     PORT_TYPE_SET = SET OF PORT_TYPE_ENUM;

CONST PORT_TYPE_WRITE         = PORT_TYPE_SET {PORT_TYPE__WRITE       }; (* 0x0001 *)
      PORT_TYPE_READ          = PORT_TYPE_SET {PORT_TYPE__READ        }; (* 0x0002 *)
      PORT_TYPE_REDIRECTED    = PORT_TYPE_SET {PORT_TYPE__REDIRECTED  }; (* 0x0004 *)
      PORT_TYPE_NET_ATTACHED  = PORT_TYPE_SET {PORT_TYPE__NET_ATTACHED}; (* 0x0008 *)

TYPE PORT_INFO_2A  = RECORD
                            pPortName    : PSTR;
                            pMonitorName : PSTR;
                            pDescription : PSTR;
                            fPortType    : PORT_TYPE_SET;
                            Reserved     : DWORD;
                     END;
     PPORT_INFO_2A = POINTER TO PORT_INFO_2A;

TYPE PORT_INFO_2W  = RECORD
                            pPortName    : PWSTR;
                            pMonitorName : PWSTR;
                            pDescription : PWSTR;
                            fPortType    : PORT_TYPE_SET;
                            Reserved     : DWORD;
                     END;
     PPORT_INFO_2W = POINTER TO PORT_INFO_2W;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  PORT_INFO_2 = PORT_INFO_2W;
      TYPE PPORT_INFO_2 = PPORT_INFO_2W;
<* ELSE *>
      TYPE  PORT_INFO_2 =  PORT_INFO_2A;
      TYPE PPORT_INFO_2 = PPORT_INFO_2A;
<* END *>

TYPE MONITOR_INFO_1A = RECORD
                              pName : PSTR;
                       END;
    PMONITOR_INFO_1A = POINTER TO MONITOR_INFO_1A;

TYPE MONITOR_INFO_1W = RECORD
                              pName : PWSTR;
                       END;
    PMONITOR_INFO_1W = POINTER TO MONITOR_INFO_1W;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  MONITOR_INFO_1 =  MONITOR_INFO_1W;
      TYPE PMONITOR_INFO_1 = PMONITOR_INFO_1W;
<* ELSE *>
      TYPE  MONITOR_INFO_1 =  MONITOR_INFO_1A;
      TYPE PMONITOR_INFO_1 = PMONITOR_INFO_1A;
<* END *>

TYPE MONITOR_INFO_2A = RECORD
                              pName        : PSTR;
                              pEnvironment : PSTR;
                              pDLLName     : PSTR;
                       END;
    PMONITOR_INFO_2A = POINTER TO MONITOR_INFO_2A;

TYPE MONITOR_INFO_2W = RECORD
                              pName        : PWSTR;
                              pEnvironment : PWSTR;
                              pDLLName     : PWSTR;
                       END;
    PMONITOR_INFO_2W = POINTER TO MONITOR_INFO_2W;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  MONITOR_INFO_2 =  MONITOR_INFO_2W;
      TYPE PMONITOR_INFO_2 = PMONITOR_INFO_2W;
<* ELSE *>
      TYPE  MONITOR_INFO_2 =  MONITOR_INFO_2A;
      TYPE PMONITOR_INFO_2 = PMONITOR_INFO_2A;
<* END *>

TYPE DATATYPES_INFO_1A = RECORD
                                pName : PSTR;
                         END;
    PDATATYPES_INFO_1A = POINTER TO DATATYPES_INFO_1A;

TYPE DATATYPES_INFO_1W = RECORD
                                pName : PWSTR;
                         END;
    PDATATYPES_INFO_1W = POINTER TO DATATYPES_INFO_1W;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  DATATYPES_INFO_1 =  DATATYPES_INFO_1W;
      TYPE PDATATYPES_INFO_1 = PDATATYPES_INFO_1W;
<* ELSE *>
      TYPE  DATATYPES_INFO_1 =  DATATYPES_INFO_1A;
      TYPE PDATATYPES_INFO_1 = PDATATYPES_INFO_1A;
<* END *>

TYPE PRINTER_DEFAULTSA = RECORD
                                pDatatype     : PSTR;
                                pDevMode      : PDEVMODEA;
                                DesiredAccess : ACCESS_MASK;
                         END;
    PPRINTER_DEFAULTSA = POINTER TO PRINTER_DEFAULTSA;

TYPE PRINTER_DEFAULTSW = RECORD
                                pDatatype     : PWSTR;
                                pDevMode      : PDEVMODEW;
                                DesiredAccess : ACCESS_MASK;
                         END;
    PPRINTER_DEFAULTSW = POINTER TO PRINTER_DEFAULTSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  PRINTER_DEFAULTS =  PRINTER_DEFAULTSW;
      TYPE PPRINTER_DEFAULTS = PPRINTER_DEFAULTSW;
<* ELSE *>
      TYPE  PRINTER_DEFAULTS =  PRINTER_DEFAULTSA;
      TYPE PPRINTER_DEFAULTS = PPRINTER_DEFAULTSA;
<* END *>

PROCEDURE EnumPrintersA (Flags          : PRINTER_ENUM_SET;
                         Name           : PSTR;
                         Level          : DWORD;
                         pPrinterEnum   : PBYTE;
                         cbBuf          : DWORD;
                         VAR pcbNeeded  : DWORD;
                         VAR pcReturned : DWORD) : BOOL;

PROCEDURE EnumPrintersW (Flags          : PRINTER_ENUM_SET;
                         Name           : PWSTR;
                         Level          : DWORD;
                         pPrinterEnum   : PBYTE;
                         cbBuf          : DWORD;
                         VAR pcbNeeded  : DWORD;
                         VAR pcReturned : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumPrinters = EnumPrintersW;
<* ELSE *>
      CONST EnumPrinters = EnumPrintersA;
<* END *>

PROCEDURE OpenPrinterA (pPrinterName      : PSTR;
                        VAR hPrinter      : HANDLE;
                        VAR [NIL] Default : PRINTER_DEFAULTSA) : BOOL;

PROCEDURE OpenPrinterW (pPrinterName      : PWSTR;
                        VAR hPrinter      : HANDLE;
                        VAR [NIL] Default : PRINTER_DEFAULTSW) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST OpenPrinter = OpenPrinterW;
<* ELSE *>
      CONST OpenPrinter = OpenPrinterA;
<* END *>

<* IF BACKEND # "C" THEN *>
PROCEDURE ResetPrinterA (hPrinter : HANDLE;
                         Default  : PRINTER_DEFAULTSA) : BOOL;
<* ELSE *>
PROCEDURE ResetPrinterA (hPrinter : HANDLE;
                         Default  : PPRINTER_DEFAULTSA) : BOOL;
<* END *>

PROCEDURE ResetPrinterW (hPrinter : HANDLE;
                         Default  : PPRINTER_DEFAULTSW) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ResetPrinter = ResetPrinterW;
<* ELSE *>
      CONST ResetPrinter = ResetPrinterA;
<* END *>

PROCEDURE SetJobA (hPrinter : HANDLE;
                   JobId    : DWORD;
                   Level    : DWORD;
                   pJob     : PBYTE;
                   Command  : JOB_CONTROL_ENUM) : BOOL;

PROCEDURE SetJobW (hPrinter : HANDLE;
                   JobId    : DWORD;
                   Level    : DWORD;
                   pJob     : PBYTE;
                   Command  : JOB_CONTROL_ENUM) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetJob = SetJobW;
<* ELSE *>
      CONST SetJob = SetJobA;
<* END *>

PROCEDURE GetJobA (hPrinter     : HANDLE;
                   JobId        : DWORD;
                   Level        : DWORD;
                   pJob         : PBYTE;
                   cbBuf        : DWORD;
                   VAR cbNeeded : DWORD) : BOOL;

PROCEDURE GetJobW (hPrinter     : HANDLE;
                   JobId        : DWORD;
                   Level        : DWORD;
                   pJob         : PBYTE;
                   cbBuf        : DWORD;
                   VAR cbNeeded : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetJob = GetJobW;
<* ELSE *>
      CONST GetJob = GetJobA;
<* END *>


PROCEDURE EnumJobsA (hPrinter      : HANDLE;
                     FirstJob      : DWORD;
                     NoJobs        : DWORD;
                     Level         : DWORD;
                     pJob          : PBYTE;
                     cbBuf         : DWORD;
                     VAR cbNeeded  : DWORD;
                     VAR cReturned : DWORD) : BOOL;

PROCEDURE EnumJobsW (hPrinter      : HANDLE;
                     FirstJob      : DWORD;
                     NoJobs        : DWORD;
                     Level         : DWORD;
                     pJob          : PBYTE;
                     cbBuf         : DWORD;
                     VAR cbNeeded  : DWORD;
                     VAR cReturned : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumJobs = EnumJobsW;
<* ELSE *>
      CONST EnumJobs = EnumJobsA;
<* END *>

PROCEDURE AddPrinterA (pName    : PSTR;
                       Level    : DWORD;
                       pPrinter : PBYTE) : HANDLE;

PROCEDURE AddPrinterW (pName    : PWSTR;
                       Level    : DWORD;
                       pPrinter : PBYTE) : HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST AddPrinter = AddPrinterW;
<* ELSE *>
      CONST AddPrinter = AddPrinterA;
<* END *>


PROCEDURE DeletePrinter (hPrinter : HANDLE) : BOOL;

PROCEDURE SetPrinterA (hPrinter : HANDLE;
                       Level    : DWORD;
                       pPrinter : PBYTE;
                       Command  : PRINTER_CONTROL_ENUM) : BOOL;

PROCEDURE SetPrinterW (hPrinter : HANDLE;
                       Level    : DWORD;
                       pPrinter : PBYTE;
                       Command  : PRINTER_CONTROL_ENUM) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetPrinter = SetPrinterW;
<* ELSE *>
      CONST SetPrinter = SetPrinterA;
<* END *>

PROCEDURE GetPrinterA (hPrinter     : HANDLE;
                       Level        : DWORD;
                       pPrinter     : PBYTE;
                       cbBuf        : DWORD;
                       VAR cbNeeded : DWORD) : BOOL;

PROCEDURE GetPrinterW (hPrinter     : HANDLE;
                       Level        : DWORD;
                       pPrinter     : PBYTE;
                       cbBuf        : DWORD;
                       VAR cbNeeded : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetPrinter = GetPrinterW;
<* ELSE *>
      CONST GetPrinter = GetPrinterA;
<* END *>

PROCEDURE AddPrinterDriverA (pName       : PSTR;
                             Level       : DWORD;
                             pDriverInfo : PBYTE) : BOOL;

PROCEDURE AddPrinterDriverW (pName       : PWSTR;
                             Level       : DWORD;
                             pDriverInfo : PBYTE) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST AddPrinterDriver = AddPrinterDriverW;
<* ELSE *>
      CONST AddPrinterDriver = AddPrinterDriverA;
<* END *>


PROCEDURE EnumPrinterDriversA (pName         : PSTR;
                               pEnvironment  : PSTR;
                               Level         : DWORD;
                               pDriverInfo   : PBYTE;
                               cbBuf         : DWORD;
                               VAR cbNeeded  : DWORD;
                               VAR cReturned : DWORD) : BOOL;

PROCEDURE EnumPrinterDriversW (pName         : PWSTR;
                               pEnvironment  : PWSTR;
                               Level         : DWORD;
                               pDriverInfo   : PBYTE;
                               cbBuf         : DWORD;
                               VAR cbNeeded  : DWORD;
                               VAR cReturned : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumPrinterDrivers = EnumPrinterDriversW;
<* ELSE *>
      CONST EnumPrinterDrivers = EnumPrinterDriversA;
<* END *>


PROCEDURE GetPrinterDriverA (hPrinter     : HANDLE;
                             pEnvironment : PSTR;
                             Level        : DWORD;
                             pDriverInfo  : PBYTE;
                             cbBuf        : DWORD;
                             VAR cbNeeded : DWORD) : BOOL;

PROCEDURE GetPrinterDriverW (hPrinter     : HANDLE;
                             pEnvironment : PWSTR;
                             Level        : DWORD;
                             pDriverInfo  : PBYTE;
                             cbBuf        : DWORD;
                             VAR cbNeeded : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetPrinterDriver = GetPrinterDriverW;
<* ELSE *>
      CONST GetPrinterDriver = GetPrinterDriverA;
<* END *>

PROCEDURE GetPrinterDriverDirectoryA (pName            : PSTR;
                                      pEnvironment     : PSTR;
                                      Level            : DWORD;
                                      pDriverDirectory : PBYTE;
                                      cbBuf            : DWORD;
                                      VAR cbNeeded     : DWORD) : BOOL;

PROCEDURE GetPrinterDriverDirectoryW (pName            : PWSTR;
                                      pEnvironment     : PWSTR;
                                      Level            : DWORD;
                                      pDriverDirectory : PBYTE;
                                      cbBuf            : DWORD;
                                      VAR cbNeeded     : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetPrinterDriverDirectory = GetPrinterDriverDirectoryW;
<* ELSE *>
      CONST GetPrinterDriverDirectory = GetPrinterDriverDirectoryA;
<* END *>

PROCEDURE DeletePrinterDriverA (pName        : PSTR;
                                pEnvironment : PSTR;
                                pDriverName  : PSTR) : BOOL;

PROCEDURE DeletePrinterDriverW (pName        : PWSTR;
                                pEnvironment : PWSTR;
                                pDriverName  : PWSTR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST DeletePrinterDriver = DeletePrinterDriverW;
<* ELSE *>
      CONST DeletePrinterDriver = DeletePrinterDriverA;
<* END *>

PROCEDURE AddPrintProcessorA (pName               : PSTR;
                              pEnvironment        : PSTR;
                              pPathName           : PSTR;
                              pPrintProcessorName : PSTR) : BOOL;

PROCEDURE AddPrintProcessorW (pName               : PWSTR;
                              pEnvironment        : PWSTR;
                              pPathName           : PWSTR;
                              pPrintProcessorName : PWSTR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST AddPrintProcessor = AddPrintProcessorW;
<* ELSE *>
      CONST AddPrintProcessor = AddPrintProcessorA;
<* END *>

PROCEDURE EnumPrintProcessorsA (pName               : PSTR;
                                pEnvironment        : PSTR;
                                Level               : DWORD;
                                pPrintProcessorInfo : PBYTE;
                                cbBuf               : DWORD;
                                VAR cbNeeded        : DWORD;
                                VAR cReturned       : DWORD) : BOOL;

PROCEDURE EnumPrintProcessorsW (pName               : PWSTR;
                                pEnvironment        : PWSTR;
                                Level               : DWORD;
                                pPrintProcessorInfo : PBYTE;
                                cbBuf               : DWORD;
                                VAR cbNeeded        : DWORD;
                                VAR cReturned       : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumPrintProcessors = EnumPrintProcessorsW;
<* ELSE *>
      CONST EnumPrintProcessors = EnumPrintProcessorsA;
<* END *>


PROCEDURE GetPrintProcessorDirectoryA (pName               : PSTR;
                                       pEnvironment        : PSTR;
                                       Level               : DWORD;
                                       pPrintProcessorInfo : PBYTE;
                                       cbBuf               : DWORD;
                                       VAR cbNeeded        : DWORD) : BOOL;

PROCEDURE GetPrintProcessorDirectoryW (pName               : PWSTR;
                                       pEnvironment        : PWSTR;
                                       Level               : DWORD;
                                       pPrintProcessorInfo : PBYTE;
                                       cbBuf               : DWORD;
                                       VAR cbNeeded        : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetPrintProcessorDirectory = GetPrintProcessorDirectoryW;
<* ELSE *>
      CONST GetPrintProcessorDirectory = GetPrintProcessorDirectoryA;
<* END *>

PROCEDURE EnumPrintProcessorDatatypesA (pName               : PSTR;
                                        pPrintProcessorName : PSTR;
                                        Level               : DWORD;
                                        pDatatypes          : PBYTE;
                                        cbBuf               : DWORD;
                                        VAR cbNeeded        : DWORD;
                                        VAR cReturned       : DWORD) : BOOL;

PROCEDURE EnumPrintProcessorDatatypesW (pName               : PWSTR;
                                        pPrintProcessorName : PWSTR;
                                        Level               : DWORD;
                                        pDatatypes          : PBYTE;
                                        cbBuf               : DWORD;
                                        VAR cbNeeded        : DWORD;
                                        VAR cReturned       : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumPrintProcessorDatatypes = EnumPrintProcessorDatatypesW;
<* ELSE *>
      CONST EnumPrintProcessorDatatypes = EnumPrintProcessorDatatypesA;
<* END *>

PROCEDURE DeletePrintProcessorA (pName               : PSTR;
                                 pEnvironment        : PSTR;
                                 pPrintProcessorName : PSTR) : BOOL;

PROCEDURE DeletePrintProcessorW (pName               : PWSTR;
                                 pEnvironment        : PWSTR;
                                 pPrintProcessorName : PWSTR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST DeletePrintProcessor = DeletePrintProcessorW;
<* ELSE *>
      CONST DeletePrintProcessor = DeletePrintProcessorA;
<* END *>

PROCEDURE StartDocPrinterA (hPrinter : HANDLE;
                            Level    : DWORD;
                            pDocInfo : PBYTE) : DWORD;

PROCEDURE StartDocPrinterW (hPrinter : HANDLE;
                            Level    : DWORD;
                            pDocInfo : PBYTE) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST StartDocPrinter = StartDocPrinterW;
<* ELSE *>
      CONST StartDocPrinter = StartDocPrinterA;
<* END *>

PROCEDURE StartPagePrinter (hPrinter : HANDLE) : BOOL;

PROCEDURE WritePrinter (hPrinter     : HANDLE;
                        pBuf         : PVOID;
                        cbBuf        : DWORD;
                        VAR cWritten : DWORD) : BOOL;

PROCEDURE EndPagePrinter (hPrinter : HANDLE) : BOOL;

PROCEDURE AbortPrinter (hPrinter : HANDLE) : BOOL;

PROCEDURE ReadPrinter (hPrinter        : HANDLE;
                       pBuf            : PVOID;
                       cbBuf           : DWORD;
                       VAR NoBytesRead : DWORD) : BOOL;

PROCEDURE EndDocPrinter (hPrinter : HANDLE) : BOOL;

PROCEDURE AddJobA (hPrinter    : HANDLE;
                  Level        : DWORD;
                  pData        : PBYTE;
                  cbBuf        : DWORD;
                  VAR cbNeeded : DWORD) : BOOL;

PROCEDURE AddJobW (hPrinter     : HANDLE;
                   Level        : DWORD;
                   pData        : PBYTE;
                   cbBuf        : DWORD;
                   VAR cbNeeded : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST AddJob = AddJobW;
<* ELSE *>
      CONST AddJob = AddJobA;
<* END *>

PROCEDURE ScheduleJob (hPrinter : HANDLE;
                       JobId    : DWORD) : BOOL;

PROCEDURE PrinterProperties (hWnd     : HWND;
                             hPrinter : HANDLE) : BOOL;


PROCEDURE DocumentPropertiesA (hWnd              : HWND;
                               hPrinter          : HANDLE;
                               pDeviceName       : PSTR;
                               VAR DevModeOutput : DEVMODEA;
                               VAR DevModeInput  : DEVMODEA;
                               fMode             : _DM_SET) : LONG;

PROCEDURE DocumentPropertiesW (hWnd              : HWND;
                               hPrinter          : HANDLE;
                               pDeviceName       : PWSTR;
                               VAR DevModeOutput : DEVMODEW;
                               VAR DevModeInput  : DEVMODEW;
                               fMode             : _DM_SET) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST DocumentProperties = DocumentPropertiesW;
<* ELSE *>
      CONST DocumentProperties = DocumentPropertiesA;
<* END *>

PROCEDURE AdvancedDocumentPropertiesA (hWnd              : HWND;
                                       hPrinter          : HANDLE;
                                       pDeviceName       : PSTR;
                                       VAR DevModeOutput : PDEVMODEA;
                                       VAR DevModeInput  : PDEVMODEA) : LONG;

PROCEDURE AdvancedDocumentPropertiesW (hWnd              : HWND;
                                       hPrinter          : HANDLE;
                                       pDeviceName       : PWSTR;
                                       VAR DevModeOutput : PDEVMODEW;
                                       VAR DevModeInput  : PDEVMODEW) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST AdvancedDocumentProperties = AdvancedDocumentPropertiesW;
<* ELSE *>
      CONST AdvancedDocumentProperties = AdvancedDocumentPropertiesA;
<* END *>

PROCEDURE GetPrinterDataA (hPrinter     : HANDLE;
                           pValueName   : PSTR;
                           VAR Type     : REG_TYPE;
                           pData        : PBYTE;
                           nSize        : DWORD;
                           VAR cbNeeded : DWORD) : DWORD;

PROCEDURE GetPrinterDataW (hPrinter     : HANDLE;
                           pValueName   : PWSTR;
                           VAR Type     : REG_TYPE;
                           pData        : PBYTE;
                           nSize        : DWORD;
                           VAR cbNeeded : DWORD) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetPrinterData = GetPrinterDataW;
<* ELSE *>
      CONST GetPrinterData = GetPrinterDataA;
<* END *>

PROCEDURE SetPrinterDataA (hPrinter   : HANDLE;
                           pValueName : PSTR;
                           Type       : REG_TYPE;
                           pData      : PBYTE;
                           cbData     : DWORD) : DWORD;

PROCEDURE SetPrinterDataW (hPrinter   : HANDLE;
                           pValueName : PWSTR;
                           Type       : REG_TYPE;
                           pData      : PBYTE;
                           cbData     : DWORD) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetPrinterData = SetPrinterDataW;
<* ELSE *>
      CONST SetPrinterData = SetPrinterDataA;
<* END *>

TYPE NOTIFY_TYPE_ENUM = WORD;

CONST  PRINTER_NOTIFY_TYPE = VAL (NOTIFY_TYPE_ENUM, 0);
       JOB_NOTIFY_TYPE     = VAL (NOTIFY_TYPE_ENUM, 1);

TYPE NOTIFY_FIELD  = WORD;
     PNOTIFY_FIELD = POINTER TO NOTIFY_FIELD;

CONST PRINTER_NOTIFY_FIELD_SERVER_NAME           = VAL (NOTIFY_FIELD, 00h);
      PRINTER_NOTIFY_FIELD_PRINTER_NAME          = VAL (NOTIFY_FIELD, 01h);
      PRINTER_NOTIFY_FIELD_SHARE_NAME            = VAL (NOTIFY_FIELD, 02h);
      PRINTER_NOTIFY_FIELD_PORT_NAME             = VAL (NOTIFY_FIELD, 03h);
      PRINTER_NOTIFY_FIELD_DRIVER_NAME           = VAL (NOTIFY_FIELD, 04h);
      PRINTER_NOTIFY_FIELD_COMMENT               = VAL (NOTIFY_FIELD, 05h);
      PRINTER_NOTIFY_FIELD_LOCATION              = VAL (NOTIFY_FIELD, 06h);
      PRINTER_NOTIFY_FIELD_DEVMODE               = VAL (NOTIFY_FIELD, 07h);
      PRINTER_NOTIFY_FIELD_SEPFILE               = VAL (NOTIFY_FIELD, 08h);
      PRINTER_NOTIFY_FIELD_PRINT_PROCESSOR       = VAL (NOTIFY_FIELD, 09h);
      PRINTER_NOTIFY_FIELD_PARAMETERS            = VAL (NOTIFY_FIELD, 0Ah);
      PRINTER_NOTIFY_FIELD_DATATYPE              = VAL (NOTIFY_FIELD, 0Bh);
      PRINTER_NOTIFY_FIELD_SECURITY_DESCRIPTOR   = VAL (NOTIFY_FIELD, 0Ch);
      PRINTER_NOTIFY_FIELD_ATTRIBUTES            = VAL (NOTIFY_FIELD, 0Dh);
      PRINTER_NOTIFY_FIELD_PRIORITY              = VAL (NOTIFY_FIELD, 0Eh);
      PRINTER_NOTIFY_FIELD_DEFAULT_PRIORITY      = VAL (NOTIFY_FIELD, 0Fh);
      PRINTER_NOTIFY_FIELD_START_TIME            = VAL (NOTIFY_FIELD, 10h);
      PRINTER_NOTIFY_FIELD_UNTIL_TIME            = VAL (NOTIFY_FIELD, 11h);
      PRINTER_NOTIFY_FIELD_STATUS                = VAL (NOTIFY_FIELD, 12h);
      PRINTER_NOTIFY_FIELD_STATUS_STRING         = VAL (NOTIFY_FIELD, 13h);
      PRINTER_NOTIFY_FIELD_CJOBS                 = VAL (NOTIFY_FIELD, 14h);
      PRINTER_NOTIFY_FIELD_AVERAGE_PPM           = VAL (NOTIFY_FIELD, 15h);
      PRINTER_NOTIFY_FIELD_TOTAL_PAGES           = VAL (NOTIFY_FIELD, 16h);
      PRINTER_NOTIFY_FIELD_PAGES_PRINTED         = VAL (NOTIFY_FIELD, 17h);
      PRINTER_NOTIFY_FIELD_TOTAL_BYTES           = VAL (NOTIFY_FIELD, 18h);
      PRINTER_NOTIFY_FIELD_BYTES_PRINTED         = VAL (NOTIFY_FIELD, 19h);

      JOB_NOTIFY_FIELD_PRINTER_NAME              = VAL (NOTIFY_FIELD, 00h);
      JOB_NOTIFY_FIELD_MACHINE_NAME              = VAL (NOTIFY_FIELD, 01h);
      JOB_NOTIFY_FIELD_PORT_NAME                 = VAL (NOTIFY_FIELD, 02h);
      JOB_NOTIFY_FIELD_USER_NAME                 = VAL (NOTIFY_FIELD, 03h);
      JOB_NOTIFY_FIELD_NOTIFY_NAME               = VAL (NOTIFY_FIELD, 04h);
      JOB_NOTIFY_FIELD_DATATYPE                  = VAL (NOTIFY_FIELD, 05h);
      JOB_NOTIFY_FIELD_PRINT_PROCESSOR           = VAL (NOTIFY_FIELD, 06h);
      JOB_NOTIFY_FIELD_PARAMETERS                = VAL (NOTIFY_FIELD, 07h);
      JOB_NOTIFY_FIELD_DRIVER_NAME               = VAL (NOTIFY_FIELD, 08h);
      JOB_NOTIFY_FIELD_DEVMODE                   = VAL (NOTIFY_FIELD, 09h);
      JOB_NOTIFY_FIELD_STATUS                    = VAL (NOTIFY_FIELD, 0Ah);
      JOB_NOTIFY_FIELD_STATUS_STRING             = VAL (NOTIFY_FIELD, 0Bh);
      JOB_NOTIFY_FIELD_SECURITY_DESCRIPTOR       = VAL (NOTIFY_FIELD, 0Ch);
      JOB_NOTIFY_FIELD_DOCUMENT                  = VAL (NOTIFY_FIELD, 0Dh);
      JOB_NOTIFY_FIELD_PRIORITY                  = VAL (NOTIFY_FIELD, 0Eh);
      JOB_NOTIFY_FIELD_POSITION                  = VAL (NOTIFY_FIELD, 0Fh);
      JOB_NOTIFY_FIELD_SUBMITTED                 = VAL (NOTIFY_FIELD, 10h);
      JOB_NOTIFY_FIELD_START_TIME                = VAL (NOTIFY_FIELD, 11h);
      JOB_NOTIFY_FIELD_UNTIL_TIME                = VAL (NOTIFY_FIELD, 12h);
      JOB_NOTIFY_FIELD_TIME                      = VAL (NOTIFY_FIELD, 13h);
      JOB_NOTIFY_FIELD_TOTAL_PAGES               = VAL (NOTIFY_FIELD, 14h);
      JOB_NOTIFY_FIELD_PAGES_PRINTED             = VAL (NOTIFY_FIELD, 15h);
      JOB_NOTIFY_FIELD_TOTAL_BYTES               = VAL (NOTIFY_FIELD, 16h);
      JOB_NOTIFY_FIELD_BYTES_PRINTED             = VAL (NOTIFY_FIELD, 17h);


TYPE PRINTER_NOTIFY_OPTIONS_TYPE  = RECORD
                                           Type      : NOTIFY_TYPE_ENUM;
                                           Reserved0 : WORD;
                                           Reserved1 : DWORD;
                                           Reserved2 : DWORD;
                                           Count     : DWORD;
                                           pFields   : PNOTIFY_FIELD;
     END;
     PPRINTER_NOTIFY_OPTIONS_TYPE = POINTER TO PRINTER_NOTIFY_OPTIONS_TYPE;

CONST PRINTER_NOTIFY_OPTIONS_REFRESH  = 1;

TYPE PRINTER_NOTIFY_OPTIONS  = RECORD
                                      Version : DWORD;
                                      Flags   : DWORD;
                                      Count   : DWORD;
                                      pTypes  : PPRINTER_NOTIFY_OPTIONS_TYPE;
                              END;
    PPRINTER_NOTIFY_OPTIONS = POINTER TO PRINTER_NOTIFY_OPTIONS;


CONST PRINTER_NOTIFY_INFO_DISCARDED = 1;

TYPE PRINTER_NOTIFY_INFO_DATA =
     RECORD
            Type     : NOTIFY_TYPE_ENUM;
            Field    : NOTIFY_FIELD;
            Reserved : DWORD;
            Id       : DWORD;
            CASE : BOOLEAN OF
            | TRUE  : adwData : ARRAY [0..1] OF DWORD;
            | FALSE : cbBuf   : DWORD;
                      pBuf    : PVOID;
            END;
     END;
     PPRINTER_NOTIFY_INFO_DATA = POINTER TO PRINTER_NOTIFY_INFO_DATA;

TYPE PRINTER_NOTIFY_INFO =
     RECORD
            Version : DWORD;
            Flags   : DWORD;
            Count   : DWORD;
            aData   : ARRAY [0..0] OF PRINTER_NOTIFY_INFO_DATA;
     END;
     PPRINTER_NOTIFY_INFO = POINTER TO PRINTER_NOTIFY_INFO;


TYPE PRINTER_CHANGE_ENUM = (PRINTER_CHANGE__ADD_PRINTER,              (*  0 *)
                            PRINTER_CHANGE__SET_PRINTER,              (*  1 *)
                            PRINTER_CHANGE__DELETE_PRINTER,           (*  2 *)
                            PRINTER_CHANGE__FAILED_CONNECTION_PRINTER,(*  3 *)

                            PRINTER_CHANGE__4,
                            PRINTER_CHANGE__5,
                            PRINTER_CHANGE__6,
                            PRINTER_CHANGE__7,

                            PRINTER_CHANGE__ADD_JOB,                  (*  8 *)
                            PRINTER_CHANGE__SET_JOB,                  (*  9 *)
                            PRINTER_CHANGE__DELETE_JOB,               (* 10 *)
                            PRINTER_CHANGE__WRITE_JOB,                (* 11 *)

                            PRINTER_CHANGE__12,
                            PRINTER_CHANGE__13,
                            PRINTER_CHANGE__14,
                            PRINTER_CHANGE__15,

                            PRINTER_CHANGE__ADD_FORM,                 (* 16 *)
                            PRINTER_CHANGE__SET_FORM,                 (* 17 *)
                            PRINTER_CHANGE__DELETE_FORM,              (* 18 *)

                            PRINTER_CHANGE__19,

                            PRINTER_CHANGE__ADD_PORT,                 (* 20 *)
                            PRINTER_CHANGE__CONFIGURE_PORT,           (* 21 *)
                            PRINTER_CHANGE__DELETE_PORT,              (* 22 *)

                            PRINTER_CHANGE__23,

                            PRINTER_CHANGE__ADD_PRINT_PROCESSOR,      (* 24 *)
                            PRINTER_CHANGE__25,
                            PRINTER_CHANGE__DELETE_PRINT_PROCESSOR,   (* 26 *)

                            PRINTER_CHANGE__27,

                            PRINTER_CHANGE__ADD_PRINTER_DRIVER,       (* 28 *)
                            PRINTER_CHANGE__SET_PRINTER_DRIVER,       (* 29 *)
                            PRINTER_CHANGE__DELETE_PRINTER_DRIVER,    (* 30 *)
                            PRINTER_CHANGE__TIMEOUT);                 (* 31 *)

      PRINTER_CHANGE_SET = SET OF PRINTER_CHANGE_ENUM;

CONST PRINTER_CHANGE_ADD_PRINTER              = PRINTER_CHANGE_SET {PRINTER_CHANGE__ADD_PRINTER              }; (* 0x00000001 *)
      PRINTER_CHANGE_SET_PRINTER              = PRINTER_CHANGE_SET {PRINTER_CHANGE__SET_PRINTER              }; (* 0x00000002 *)
      PRINTER_CHANGE_DELETE_PRINTER           = PRINTER_CHANGE_SET {PRINTER_CHANGE__DELETE_PRINTER           }; (* 0x00000004 *)
      PRINTER_CHANGE_FAILED_CONNECTION_PRINTER= PRINTER_CHANGE_SET {PRINTER_CHANGE__FAILED_CONNECTION_PRINTER}; (* 0x00000008 *)
      PRINTER_CHANGE_PRINTER                  = PRINTER_CHANGE_SET {PRINTER_CHANGE__ADD_PRINTER..
                                                                    PRINTER_CHANGE__7                        }; (* 0x000000FF *)

      PRINTER_CHANGE_ADD_JOB                  = PRINTER_CHANGE_SET {PRINTER_CHANGE__ADD_JOB                  }; (* 0x00000100 *)
      PRINTER_CHANGE_SET_JOB                  = PRINTER_CHANGE_SET {PRINTER_CHANGE__SET_JOB                  }; (* 0x00000200 *)
      PRINTER_CHANGE_DELETE_JOB               = PRINTER_CHANGE_SET {PRINTER_CHANGE__DELETE_JOB               }; (* 0x00000400 *)
      PRINTER_CHANGE_WRITE_JOB                = PRINTER_CHANGE_SET {PRINTER_CHANGE__WRITE_JOB                }; (* 0x00000800 *)
      PRINTER_CHANGE_JOB                      = PRINTER_CHANGE_SET {PRINTER_CHANGE__ADD_JOB,
                                                                    PRINTER_CHANGE__15                       }; (* 0x0000FF00 *)

      PRINTER_CHANGE_ADD_FORM                 = PRINTER_CHANGE_SET {PRINTER_CHANGE__ADD_FORM                 }; (* 0x00010000 *)
      PRINTER_CHANGE_SET_FORM                 = PRINTER_CHANGE_SET {PRINTER_CHANGE__SET_FORM                 }; (* 0x00020000 *)
      PRINTER_CHANGE_DELETE_FORM              = PRINTER_CHANGE_SET {PRINTER_CHANGE__DELETE_FORM              }; (* 0x00040000 *)
      PRINTER_CHANGE_FORM                     = PRINTER_CHANGE_SET {PRINTER_CHANGE__ADD_FORM..
                                                                    PRINTER_CHANGE__DELETE_FORM              }; (* 0x00070000 *)

      PRINTER_CHANGE_ADD_PORT                 = PRINTER_CHANGE_SET {PRINTER_CHANGE__ADD_PORT                 }; (* 0x00100000 *)
      PRINTER_CHANGE_CONFIGURE_PORT           = PRINTER_CHANGE_SET {PRINTER_CHANGE__CONFIGURE_PORT           }; (* 0x00200000 *)
      PRINTER_CHANGE_DELETE_PORT              = PRINTER_CHANGE_SET {PRINTER_CHANGE__DELETE_PORT              }; (* 0x00400000 *)
      PRINTER_CHANGE_PORT                     = PRINTER_CHANGE_SET {PRINTER_CHANGE__ADD_PORT..
                                                                    PRINTER_CHANGE__DELETE_PORT              }; (* 0x00700000 *)

      PRINTER_CHANGE_ADD_PRINT_PROCESSOR      = PRINTER_CHANGE_SET {PRINTER_CHANGE__ADD_PRINT_PROCESSOR      }; (* 0x01000000 *)
      PRINTER_CHANGE_DELETE_PRINT_PROCESSOR   = PRINTER_CHANGE_SET {PRINTER_CHANGE__DELETE_PRINT_PROCESSOR   }; (* 0x04000000 *)
      PRINTER_CHANGE_PRINT_PROCESSOR          = PRINTER_CHANGE_SET {PRINTER_CHANGE__ADD_PRINT_PROCESSOR..
                                                                    PRINTER_CHANGE__DELETE_PRINT_PROCESSOR   }; (* 0x07000000 *)

      PRINTER_CHANGE_ADD_PRINTER_DRIVER       = PRINTER_CHANGE_SET {PRINTER_CHANGE__ADD_PRINTER_DRIVER       }; (* 0x10000000 *)
      PRINTER_CHANGE_SET_PRINTER_DRIVER       = PRINTER_CHANGE_SET {PRINTER_CHANGE__SET_PRINTER_DRIVER       }; (* 0x20000000 *)
      PRINTER_CHANGE_DELETE_PRINTER_DRIVER    = PRINTER_CHANGE_SET {PRINTER_CHANGE__DELETE_PRINTER_DRIVER    }; (* 0x40000000 *)
      PRINTER_CHANGE_PRINTER_DRIVER           = PRINTER_CHANGE_SET {PRINTER_CHANGE__ADD_PRINTER_DRIVER..
                                                                    PRINTER_CHANGE__DELETE_PRINTER_DRIVER    }; (* 0x70000000 *)

      PRINTER_CHANGE_TIMEOUT                  = PRINTER_CHANGE_SET {PRINTER_CHANGE__TIMEOUT                  }; (* 0x80000000 *)

      PRINTER_CHANGE_ALL                      = PRINTER_CHANGE_PRINTER +
                                                PRINTER_CHANGE_JOB +
                                                PRINTER_CHANGE_FORM +
                                                PRINTER_CHANGE_PORT +
                                                PRINTER_CHANGE_PRINT_PROCESSOR +
                                                PRINTER_CHANGE_PRINTER_DRIVER;

PROCEDURE FindFirstPrinterChangeNotification (hPrinter   : HANDLE;
                                              fdwFlags   : PRINTER_CHANGE_SET;
                                              fdwOptions : DWORD;
                                              pPrinterNotifyOptions : PVOID) : HANDLE;

PROCEDURE FindNextPrinterChangeNotification (hChange      : HANDLE;
                                             VAR dwChange : PRINTER_CHANGE_SET;
                                             pvReserved   : PVOID;
                                             VAR [NIL] PrinterNotifyInfo : PVOID
                                   ) : BOOL;

PROCEDURE FreePrinterNotifyInfo (pPrinterNotifyInfo : PPRINTER_NOTIFY_INFO) : BOOL;

PROCEDURE FindClosePrinterChangeNotification (hChange : HANDLE) : BOOL;

PROCEDURE PrinterMessageBoxA (hPrinter : HANDLE;
                              Error    : DWORD;
                              hWnd     : HWND;
                              pText    : PSTR;
                              pCaption : PSTR;
                              dwType   : DWORD) : DWORD;

PROCEDURE PrinterMessageBoxW (hPrinter : HANDLE;
                              Error    : DWORD;
                              hWnd     : HWND;
                              pText    : PWSTR;
                              pCaption : PWSTR;
                              dwType   : DWORD) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST PrinterMessageBox = PrinterMessageBoxW;
<* ELSE *>
      CONST PrinterMessageBox = PrinterMessageBoxA;
<* END *>


CONST PRINTER_ERROR_INFORMATION = 80000000h;
      PRINTER_ERROR_WARNING     = 40000000h;
      PRINTER_ERROR_SEVERE      = 20000000h;

      PRINTER_ERROR_OUTOFPAPER  = 00000001h;
      PRINTER_ERROR_JAM         = 00000002h;
      PRINTER_ERROR_OUTOFTONER  = 00000004h;

PROCEDURE ClosePrinter (hPrinter : HANDLE) : BOOL;

PROCEDURE AddFormA (hPrinter : HANDLE;
                    Level    : DWORD;
                    pForm    : PBYTE) : BOOL;

PROCEDURE AddFormW (hPrinter : HANDLE;
                    Level    : DWORD;
                    pForm    : PBYTE) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST AddForm = AddFormW;
<* ELSE *>
      CONST AddForm = AddFormA;
<* END *>

PROCEDURE DeleteFormA (hPrinter  : HANDLE;
                       pFormName : PSTR) : BOOL;

PROCEDURE DeleteFormW (hPrinter  : HANDLE;
                       pFormName : PWSTR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST DeleteForm = DeleteFormW;
<* ELSE *>
      CONST DeleteForm = DeleteFormA;
<* END *>

PROCEDURE GetFormA (hPrinter     : HANDLE;
                    pFormName    : PSTR;
                    Level        : DWORD;
                    pForm        : PBYTE;
                    cbBuf        : DWORD;
                    VAR cbNeeded : DWORD) : BOOL;

PROCEDURE GetFormW (hPrinter     : HANDLE;
                    pFormName    : PWSTR;
                    Level        : DWORD;
                    pForm        : PBYTE;
                    cbBuf        : DWORD;
                    VAR cbNeeded : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetForm = GetFormW;
<* ELSE *>
      CONST GetForm = GetFormA;
<* END *>

PROCEDURE SetFormA (hPrinter  : HANDLE;
                    pFormName : PSTR;
                    Level     : DWORD;
                    pForm     : PBYTE) : BOOL;

PROCEDURE SetFormW (hPrinter  : HANDLE;
                    pFormName : PWSTR;
                    Level     : DWORD;
                    pForm     : PBYTE) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST SetForm = SetFormW;
<* ELSE *>
      CONST SetForm = SetFormA;
<* END *>

PROCEDURE EnumFormsA (hPrinter      : HANDLE;
                      Level         : DWORD;
                      pForm         : PBYTE;
                      cbBuf         : DWORD;
                      VAR cbNeeded  : DWORD;
                      VAR cReturned : DWORD) : BOOL;

PROCEDURE EnumFormsW (hPrinter      : HANDLE;
                      Level         : DWORD;
                      pForm         : PBYTE;
                      cbBuf         : DWORD;
                      VAR cbNeeded  : DWORD;
                      VAR cReturned : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumForms = EnumFormsW;
<* ELSE *>
      CONST EnumForms = EnumFormsA;
<* END *>

PROCEDURE EnumMonitorsA (pName         : PSTR;
                         Level         : DWORD;
                         pMonitors     : PBYTE;
                         cbBuf         : DWORD;
                         VAR cbNeeded  : DWORD;
                         VAR cReturned : DWORD) : BOOL;

PROCEDURE EnumMonitorsW (pName         : PWSTR;
                         Level         : DWORD;
                         pMonitors     : PBYTE;
                         cbBuf         : DWORD;
                         VAR cbNeeded  : DWORD;
                         VAR cReturned : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumMonitors = EnumMonitorsW;
<* ELSE *>
      CONST EnumMonitors = EnumMonitorsA;
<* END *>

PROCEDURE AddMonitorA (pName     : PSTR;
                       Level     : DWORD;
                       pMonitors : PBYTE) : BOOL;

PROCEDURE AddMonitorW (pName     : PWSTR;
                       Level     : DWORD;
                       pMonitors : PBYTE) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST AddMonitor = AddMonitorW;
<* ELSE *>
      CONST AddMonitor = AddMonitorA;
<* END *>

PROCEDURE DeleteMonitorA (pName        : PSTR;
                          pEnvironment : PSTR;
                          pMonitorName : PSTR) : BOOL;

PROCEDURE DeleteMonitorW (pName        : PWSTR;
                          pEnvironment : PWSTR;
                          pMonitorName : PWSTR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST DeleteMonitor = DeleteMonitorW;
<* ELSE *>
      CONST DeleteMonitor = DeleteMonitorA;
<* END *>

PROCEDURE EnumPortsA (pName         : PSTR;
                      Level         : DWORD;
                      pPorts        : PBYTE;
                      cbBuf         : DWORD;
                      VAR cbNeeded  : DWORD;
                      VAR cReturned : DWORD) : BOOL;

PROCEDURE EnumPortsW (pName         : PWSTR;
                      Level         : DWORD;
                      pPorts        : PBYTE;
                      cbBuf         : DWORD;
                      VAR cbNeeded  : DWORD;
                      VAR cReturned : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumPorts = EnumPortsW;
<* ELSE *>
      CONST EnumPorts = EnumPortsA;
<* END *>

PROCEDURE AddPortA (pName        : PSTR;
                    hWnd         : HWND;
                    pMonitorName : PSTR) : BOOL;

PROCEDURE AddPortW (pName        : PWSTR;
                    hWnd         : HWND;
                    pMonitorName : PWSTR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST AddPort = AddPortW;
<* ELSE *>
      CONST AddPort = AddPortA;
<* END *>

PROCEDURE ConfigurePortA (pName     : PSTR;
                          hWnd      : HWND;
                          pPortName : PSTR) : BOOL;

PROCEDURE ConfigurePortW (pName     : PSTR;
                          hWnd      : HWND;
                          pPortName : PSTR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ConfigurePort = ConfigurePortW;
<* ELSE *>
      CONST ConfigurePort = ConfigurePortA;
<* END *>

PROCEDURE DeletePortA (pName     : PSTR;
                       hWnd      : HWND;
                       pPortName : PSTR) : BOOL;

PROCEDURE DeletePortW (pName     : PWSTR;
                       hWnd      : HWND;
                       pPortName : PWSTR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST DeletePort = DeletePortW;
<* ELSE *>
      CONST DeletePort = DeletePortA;
<* END *>

PROCEDURE AddPrinterConnectionA (pName : PSTR)  : BOOL;
PROCEDURE AddPrinterConnectionW (pName : PWSTR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST AddPrinterConnection = AddPrinterConnectionW;
<* ELSE *>
      CONST AddPrinterConnection = AddPrinterConnectionA;
<* END *>

PROCEDURE DeletePrinterConnectionA (pName : PSTR)  : BOOL;
PROCEDURE DeletePrinterConnectionW (pName : PWSTR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST DeletePrinterConnection = DeletePrinterConnectionW;
<* ELSE *>
      CONST DeletePrinterConnection = DeletePrinterConnectionA;
<* END *>

PROCEDURE ConnectToPrinterDlg (hwnd  : HWND;
                               Flags : DWORD) : HANDLE;

TYPE PROVIDOR_INFO_1A = RECORD
                               pName        : PSTR;
                               pEnvironment : PSTR;
                               pDLLName     : PSTR;
                        END;
    PPROVIDOR_INFO_1A = POINTER TO PROVIDOR_INFO_1A;

TYPE PROVIDOR_INFO_1W = RECORD
                               pName        : PWSTR;
                               pEnvironment : PWSTR;
                               pDLLName     : PWSTR;
                        END;
    PPROVIDOR_INFO_1W = POINTER TO PROVIDOR_INFO_1W;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  PROVIDOR_INFO_1 =  PROVIDOR_INFO_1W;
      TYPE PPROVIDOR_INFO_1 = PPROVIDOR_INFO_1W;
<* ELSE *>
      TYPE  PROVIDOR_INFO_1 =  PROVIDOR_INFO_1A;
      TYPE PPROVIDOR_INFO_1 = PPROVIDOR_INFO_1A;
<* END *>

PROCEDURE AddPrintProvidorA (pName         : PSTR;
                             level         : DWORD;
                             pProvidorInfo : PBYTE) : BOOL;

PROCEDURE AddPrintProvidorW (pName         : PWSTR;
                             level         : DWORD;
                             pProvidorInfo : PBYTE) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST AddPrintProvidor = AddPrintProvidorW;
<* ELSE *>
      CONST AddPrintProvidor = AddPrintProvidorA;
<* END *>


PROCEDURE DeletePrintProvidorA (pName              : PSTR;
                                pEnvironment       : PSTR;
                                pPrintProvidorName : PSTR) : BOOL;

PROCEDURE DeletePrintProvidorW (pName              : PWSTR;
                                pEnvironment       : PWSTR;
                                pPrintProvidorName : PWSTR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST DeletePrintProvidor = DeletePrintProvidorW;
<* ELSE *>
      CONST DeletePrintProvidor = DeletePrintProvidorA;
<* END *>


CONST SERVER_ACCESS_ADMINISTER    = ACCESS_MASK {ACCESS_0}; (* 0x00000001 *)
      SERVER_ACCESS_ENUMERATE     = ACCESS_MASK {ACCESS_1}; (* 0x00000002 *)

      PRINTER_ACCESS_ADMINISTER   = ACCESS_MASK {ACCESS_2}; (* 0x00000004 *)
      PRINTER_ACCESS_USE          = ACCESS_MASK {ACCESS_3}; (* 0x00000008 *)

      JOB_ACCESS_ADMINISTER       = ACCESS_MASK {ACCESS_4}; (* 0x00000010 *)

(*
 * Access rights for print servers
 *)

CONST SERVER_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED +
                          SERVER_ACCESS_ADMINISTER +
                          SERVER_ACCESS_ENUMERATE;

      SERVER_READ       = STANDARD_RIGHTS_READ +
                          SERVER_ACCESS_ENUMERATE;

      SERVER_WRITE      = STANDARD_RIGHTS_WRITE +
                          SERVER_ACCESS_ADMINISTER +
                          SERVER_ACCESS_ENUMERATE;

      SERVER_EXECUTE    = STANDARD_RIGHTS_EXECUTE +
                          SERVER_ACCESS_ENUMERATE;

(*
 * Access rights for printers
 *)

CONST PRINTER_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED +
                           PRINTER_ACCESS_ADMINISTER +
                           PRINTER_ACCESS_USE;

      PRINTER_READ       = STANDARD_RIGHTS_READ +
                           PRINTER_ACCESS_USE;

      PRINTER_WRITE      = STANDARD_RIGHTS_WRITE +
                           PRINTER_ACCESS_USE;

      PRINTER_EXECUTE    = STANDARD_RIGHTS_EXECUTE +
                           PRINTER_ACCESS_USE;

(*
 * Access rights for jobs
 *)

CONST JOB_ALL_ACCESS     = STANDARD_RIGHTS_REQUIRED +
                           JOB_ACCESS_ADMINISTER;

      JOB_READ           = STANDARD_RIGHTS_READ +
                           JOB_ACCESS_ADMINISTER;

      JOB_WRITE          = STANDARD_RIGHTS_WRITE +
                           JOB_ACCESS_ADMINISTER;

      JOB_EXECUTE        = STANDARD_RIGHTS_EXECUTE +
                           JOB_ACCESS_ADMINISTER;



(*****************************************************************************\
*                                                                             *
* OLE.def -     Object Linking and Embedding functions, types, and definitions*
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
\*****************************************************************************)



(* Object types *)

TYPE OT_TYPE = (OT_0,
                OT_LINK,       (* 1 *)
                OT_EMBEDDED,   (* 2 *)
                OT_STATIC);    (* 3 *)

(* activate verbs *)

CONST OLEVERB_PRIMARY    = 0;

(* target device info structure *)

TYPE OLETARGETDEVICE = RECORD
                              otdDeviceNameOffset  : USHORT;
                              otdDriverNameOffset  : USHORT;
                              otdPortNameOffset    : USHORT;
                              otdExtDevmodeOffset  : USHORT;
                              otdExtDevmodeSize    : USHORT;
                              otdEnvironmentOffset : USHORT;
                              otdEnvironmentSize   : USHORT;
                              otdData              : ARRAY [0..0] OF BYTE;
                       END;
    POLETARGETDEVICE = POINTER TO OLETARGETDEVICE;

(* flags used in some methods *)

TYPE OF_FLAGS_ENUM = (OF__SET,      (* 0 *)
                      OF__GET,      (* 1 *)
                      OF__HANDLER); (* 2 *)

     OF_FLAGS_SET = SET OF OF_FLAGS_ENUM;

CONST OF_SET     = OF_FLAGS_SET {OF__SET};     (* 0x0001 *)
      OF_GET     = OF_FLAGS_SET {OF__GET};     (* 0x0002 *)
      OF_HANDLER = OF_FLAGS_SET {OF__HANDLER}; (* 0x0004 *)


(* return codes for OLE functions *)

TYPE OLESTATUS = (
    OLE_OK,                     (* 0   Function operated correctly             *)

    OLE_WAIT_FOR_RELEASE,       (* 1   Command has been initiated, client      *)
                                (*     must wait for release. keep dispatching *)
                                (*     messages till OLE_RELESE in callback    *)

    OLE_BUSY,                   (* 2   Tried to execute a method while another *)
                                (*     method is in progress.                  *)

    OLE_ERROR_PROTECT_ONLY,     (* 3   Ole APIs are called in real mode        *)
    OLE_ERROR_MEMORY,           (* 4   Could not alloc or lock memory          *)
    OLE_ERROR_STREAM,           (* 5  (OLESTREAM) stream error                 *)
    OLE_ERROR_STATIC,           (* 6   Non static object expected              *)
    OLE_ERROR_BLANK,            (* 7   Critical data missing                   *)
    OLE_ERROR_DRAW,             (* 8   Error while drawing                     *)
    OLE_ERROR_METAFILE,         (* 9   Invalid metafile                        *)
    OLE_ERROR_ABORT,            (* 10  Client chose to abort metafile drawing  *)
    OLE_ERROR_CLIPBOARD,        (* 11  Failed to get/set clipboard data        *)
    OLE_ERROR_FORMAT,           (* 12  Requested format is not available       *)
    OLE_ERROR_OBJECT,           (* 13  Not a valid object                      *)
    OLE_ERROR_OPTION,           (* 14  Invalid option(link update / render)    *)
    OLE_ERROR_PROTOCOL,         (* 15  Invalid protocol                        *)
    OLE_ERROR_ADDRESS,          (* 16  One of the pointers is invalid          *)
    OLE_ERROR_NOT_EQUAL,        (* 17  Objects are not equal                   *)
    OLE_ERROR_HANDLE,           (* 18  Invalid handle encountered              *)
    OLE_ERROR_GENERIC,          (* 19  Some general error                      *)
    OLE_ERROR_CLASS,            (* 20  Invalid class                           *)
    OLE_ERROR_SYNTAX,           (* 21  Command syntax is invalid               *)
    OLE_ERROR_DATATYPE,         (* 22  Data format is not supported            *)
    OLE_ERROR_PALETTE,          (* 23  Invalid color palette                   *)
    OLE_ERROR_NOT_LINK,         (* 24  Not a linked object                     *)
    OLE_ERROR_NOT_EMPTY,        (* 25  Client doc contains objects.            *)
    OLE_ERROR_SIZE,             (* 26  Incorrect buffer size passed to the api *)
                                (*     that places some string in caller's     *)
                                (*     buffer                                  *)

    OLE_ERROR_DRIVE,            (* 27  Drive letter in doc name is invalid     *)
    OLE_ERROR_NETWORK,          (* 28  Failed to establish connection to a     *)
                                (*     network share on which the document     *)
                                (*     is located                              *)

    OLE_ERROR_NAME,             (* 29  Invalid name(doc name, object name),    *)
                                (*     etc.. passed to the APIs                *)

    OLE_ERROR_TEMPLATE,         (* 30  Server failed to load template          *)
    OLE_ERROR_NEW,              (* 31  Server failed to create new doc         *)
    OLE_ERROR_EDIT,             (* 32  Server failed to create embedded        *)
                                (*     instance                                *)
    OLE_ERROR_OPEN,             (* 33  Server failed to open document,         *)
                                (*     possible invalid link                   *)

    OLE_ERROR_NOT_OPEN,         (* 34  Object is not open for editing          *)
    OLE_ERROR_LAUNCH,           (* 35  Failed to launch server                 *)
    OLE_ERROR_COMM,             (* 36  Failed to communicate with server       *)
    OLE_ERROR_TERMINATE,        (* 37  Error in termination                    *)
    OLE_ERROR_COMMAND,          (* 38  Error in execute                        *)
    OLE_ERROR_SHOW,             (* 39  Error in show                           *)
    OLE_ERROR_DOVERB,           (* 40  Error in sending do verb, or invalid    *)
                                (*     verb                                    *)
    OLE_ERROR_ADVISE_NATIVE,    (* 41  Item could be missing                   *)
    OLE_ERROR_ADVISE_PICT,      (* 42  Item could be missing or server doesn't *)
                                (*     this format.                            *)

    OLE_ERROR_ADVISE_RENAME,    (* 43  Server doesn't support rename           *)
    OLE_ERROR_POKE_NATIVE,      (* 44  Failure of poking native data to server *)
    OLE_ERROR_REQUEST_NATIVE,   (* 45  Server failed to render native data     *)
    OLE_ERROR_REQUEST_PICT,     (* 46  Server failed to render presentation    *)
                                (*     data                                    *)
    OLE_ERROR_SERVER_BLOCKED,   (* 47  Trying to block a blocked server or     *)
                                (*     trying to revoke a blocked server       *)
                                (*     or document                             *)

    OLE_ERROR_REGISTRATION,     (* 48  Server is not registered in regestation *)
                                (*     data base                               *)
    OLE_ERROR_ALREADY_REGISTERED,(*49  Trying to register same doc multiple    *)
                                 (*    times                                   *)
    OLE_ERROR_TASK,             (* 50  Server or client task is invalid        *)
    OLE_ERROR_OUTOFDATE,        (* 51  Object is out of date                   *)
    OLE_ERROR_CANT_UPDATE_CLIENT,(* 52 Embed doc's client doesn't accept       *)
                                (*     updates                                 *)
    OLE_ERROR_UPDATE,           (* 53  erorr while trying to update            *)
    OLE_ERROR_SETDATA_FORMAT,   (* 54  Server app doesn't understand the       *)
                                (*     format given to its SetData method      *)
    OLE_ERROR_STATIC_FROM_OTHER_OS,(* 55 trying to load a static object created *)
                                   (*    on another Operating System           *)
    OLE_ERROR_FILE_VER);

(*  Following are warnings *)

CONST OLE_WARN_DELETE_DATA = SYSTEM.CAST (OLESTATUS, VAL (LONG, 1000));
    (*     Caller must delete the data when he is  *)
    (*     done with it.                           *)


(* Codes for CallBack events *)

TYPE OLE_NOTIFICATION =
  ( OLE_CHANGED,            (* 0                                             *)
    OLE_SAVED,              (* 1                                             *)
    OLE_CLOSED,             (* 2                                             *)
    OLE_RENAMED,            (* 3                                             *)
    OLE_QUERY_PAINT,        (* 4  Interruptible paint support                *)
    OLE_RELEASE,            (* 5  Object is released(asynchronous operation  *)
                            (*    is completed)                              *)
    OLE_QUERY_RETRY         (* 6  Query for retry when server sends busy ACK *)
  );

TYPE OLE_RELEASE_METHOD =
  ( OLE_NONE,               (* 0  no method active                           *)
    OLE_DELETE,             (* 1  object delete                              *)
    OLE_LNKPASTE,           (* 2  PasteLink(auto reconnect)                  *)
    OLE_EMBPASTE,           (* 3  paste(and update)                          *)
    OLE_SHOW,               (* 4  Show                                       *)
    OLE_RUN,                (* 5  Run                                        *)
    OLE_ACTIVATE,           (* 6  Activate                                   *)
    OLE_UPDATE,             (* 7  Update                                     *)
    OLE_CLOSE,              (* 8  Close                                      *)
    OLE_RECONNECT,          (* 9  Reconnect                                  *)
    OLE_SETUPDATEOPTIONS,   (* 10 setting update options                     *)
    OLE_SERVERUNLAUNCH,     (* 11 server is being unlaunched                 *)
    OLE_LOADFROMSTREAM,     (* 12 LoadFromStream(auto reconnect)             *)
    OLE_SETDATA,            (* 13 OleSetData                                 *)
    OLE_REQUESTDATA,        (* 14 OleRequestData                             *)
    OLE_OTHER,              (* 15 other misc async operations                *)
    OLE_CREATE,             (* 16 create                                     *)
    OLE_CREATEFROMTEMPLATE, (* 17 CreatefromTemplate                         *)
    OLE_CREATELINKFROMFILE, (* 18 CreateLinkFromFile                         *)
    OLE_COPYFROMLNK,        (* 19 CopyFromLink(auto reconnect)               *)
    OLE_CREATEFROMFILE,     (* 20 CreateFromFile                             *)
    OLE_CREATEINVISIBLE     (* 21 CreateInvisible                            *)
  );

(* rendering options *)

TYPE  OLEOPT_RENDER = (olerender_none,
                       olerender_draw,
                       olerender_format);

(* standard clipboard format type *)

TYPE OLECLIPFORMAT = WORD;


(* Link update options *)
TYPE OLEOPT_UPDATE = (oleupdate_always,
                      oleupdate_onsave,
                      oleupdate_oncall,
                      oleupdate_onclose);

TYPE HOBJECT     = HANDLE;
TYPE LHSERVER    = LONG;
TYPE LHCLIENTDOC = LONG;
TYPE LHSERVERDOC = LONG;

TYPE POLEOBJECT = POINTER TO OLEOBJECT;
TYPE POLESTREAM = POINTER TO OLESTREAM;
TYPE POLECLIENT = POINTER TO OLECLIENT;

(* object method table definitions. *)

<* IF BACKEND # "C" THEN *>

TYPE OLEOBJECTVTBL =
     RECORD
     QueryProtocol        : PROCEDURE (POLEOBJECT, PCSTR) : PVOID;
     Release              : PROCEDURE (POLEOBJECT) : OLESTATUS;
     Show                 : PROCEDURE (POLEOBJECT, BOOL) : OLESTATUS;
     DoVerb               : PROCEDURE (POLEOBJECT, UINT, BOOL, BOOL) : OLESTATUS;
     GetData              : PROCEDURE (POLEOBJECT, OLECLIPFORMAT, VAR HANDLE) : OLESTATUS;
     SetData              : PROCEDURE (POLEOBJECT, OLECLIPFORMAT, HANDLE) : OLESTATUS;
     SetTargetDevice      : PROCEDURE (POLEOBJECT, HGLOBAL) : OLESTATUS;
     SetBounds            : PROCEDURE (POLEOBJECT, RECT) : OLESTATUS;
     EnumFormats          : PROCEDURE (POLEOBJECT, OLECLIPFORMAT) : OLECLIPFORMAT;
     SetColorScheme       : PROCEDURE (POLEOBJECT, LOGPALETTE) : OLESTATUS;

     (* Server has to implement only the above methods. *)

     (* Extra methods required for client. *)

     Delete               : PROCEDURE (POLEOBJECT) : OLESTATUS;
     SetHostNames         : PROCEDURE (POLEOBJECT, PCSTR, PCSTR) : OLESTATUS;
     SaveToStream         : PROCEDURE (POLEOBJECT, POLESTREAM) : OLESTATUS;
     Clone                : PROCEDURE (POLEOBJECT, POLECLIENT, LHCLIENTDOC, PCSTR, VAR POLEOBJECT) : OLESTATUS;
     CopyFromLink         : PROCEDURE (POLEOBJECT, POLECLIENT, LHCLIENTDOC, PCSTR, VAR POLEOBJECT) : OLESTATUS;
     Equal                : PROCEDURE (POLEOBJECT, POLEOBJECT) : OLESTATUS;
     CopyToClipboard      : PROCEDURE (POLEOBJECT) : OLESTATUS;
     Draw                 : PROCEDURE (POLEOBJECT, HDC, RECT, RECT, HDC) : OLESTATUS;
     Activate             : PROCEDURE (POLEOBJECT, UINT, BOOL, BOOL, HWND, RECT) : OLESTATUS;
     Execute              : PROCEDURE (POLEOBJECT, HGLOBAL, UINT) : OLESTATUS;
     Close                : PROCEDURE (POLEOBJECT) : OLESTATUS;
     Update               : PROCEDURE (POLEOBJECT) : OLESTATUS;
     Reconnect            : PROCEDURE (POLEOBJECT) : OLESTATUS;

     ObjectConvert        : PROCEDURE (POLEOBJECT, PCSTR, POLECLIENT, LHCLIENTDOC, PCSTR, VAR POLEOBJECT) : OLESTATUS;
     GetLinkUpdateOptions : PROCEDURE (POLEOBJECT, VAR OLEOPT_UPDATE) : OLESTATUS;
     SetLinkUpdateOptions : PROCEDURE (POLEOBJECT, OLEOPT_UPDATE) : OLESTATUS;

     Rename               : PROCEDURE (POLEOBJECT, PCSTR) : OLESTATUS;
     QueryName            : PROCEDURE (POLEOBJECT, PSTR, VAR UINT) : OLESTATUS;

     QueryType            : PROCEDURE (POLEOBJECT, VAR LONG) : OLESTATUS;
     QueryBounds          : PROCEDURE (POLEOBJECT, VAR RECT) : OLESTATUS;
     QuerySize            : PROCEDURE (POLEOBJECT, VAR DWORD) : OLESTATUS;
     QueryOpen            : PROCEDURE (POLEOBJECT) : OLESTATUS;
     QueryOutOfDate       : PROCEDURE (POLEOBJECT) : OLESTATUS;

     QueryReleaseStatus   : PROCEDURE (POLEOBJECT) : OLESTATUS;
     QueryReleaseError    : PROCEDURE (POLEOBJECT) : OLESTATUS;
     QueryReleaseMethod   : PROCEDURE (POLEOBJECT) : OLE_RELEASE_METHOD;

     RequestData          : PROCEDURE (POLEOBJECT, OLECLIPFORMAT) : OLESTATUS;
     ObjectLong           : PROCEDURE (POLEOBJECT, UINT, VAR LONG) : OLESTATUS;

     (* This method is internal only *)

     ChangeData           : PROCEDURE (POLEOBJECT, HANDLE, POLECLIENT, BOOL) : OLESTATUS;
     END;
     POLEOBJECTVTBL = POINTER TO OLEOBJECTVTBL;

<* ELSE *>

TYPE OLEOBJECTVTBL =
     RECORD
     QueryProtocol        : PROCEDURE (POLEOBJECT, PCSTR) : PVOID;
     Release              : PROCEDURE (POLEOBJECT) : OLESTATUS;
     Show                 : PROCEDURE (POLEOBJECT, BOOL) : OLESTATUS;
     DoVerb               : PROCEDURE (POLEOBJECT, UINT, BOOL, BOOL) : OLESTATUS;
     GetData              : PROCEDURE (POLEOBJECT, OLECLIPFORMAT, VAR HANDLE) : OLESTATUS;
     SetData              : PROCEDURE (POLEOBJECT, OLECLIPFORMAT, HANDLE) : OLESTATUS;
     SetTargetDevice      : PROCEDURE (POLEOBJECT, HGLOBAL) : OLESTATUS;
     SetBounds            : PROCEDURE (POLEOBJECT, PRECT) : OLESTATUS;
     EnumFormats          : PROCEDURE (POLEOBJECT, OLECLIPFORMAT) : OLECLIPFORMAT;
     SetColorScheme       : PROCEDURE (POLEOBJECT, PLOGPALETTE) : OLESTATUS;

     (* Server has to implement only the above methods. *)

     (* Extra methods required for client. *)

     Delete               : PROCEDURE (POLEOBJECT) : OLESTATUS;
     SetHostNames         : PROCEDURE (POLEOBJECT, PCSTR, PCSTR) : OLESTATUS;
     SaveToStream         : PROCEDURE (POLEOBJECT, POLESTREAM) : OLESTATUS;
     Clone                : PROCEDURE (POLEOBJECT, POLECLIENT, LHCLIENTDOC, PCSTR, VAR POLEOBJECT) : OLESTATUS;
     CopyFromLink         : PROCEDURE (POLEOBJECT, POLECLIENT, LHCLIENTDOC, PCSTR, VAR POLEOBJECT) : OLESTATUS;
     Equal                : PROCEDURE (POLEOBJECT, POLEOBJECT) : OLESTATUS;
     CopyToClipboard      : PROCEDURE (POLEOBJECT) : OLESTATUS;
     Draw                 : PROCEDURE (POLEOBJECT, HDC, PRECT, PRECT, HDC) : OLESTATUS;
     Activate             : PROCEDURE (POLEOBJECT, UINT, BOOL, BOOL, HWND, PRECT) : OLESTATUS;
     Execute              : PROCEDURE (POLEOBJECT, HGLOBAL, UINT) : OLESTATUS;
     Close                : PROCEDURE (POLEOBJECT) : OLESTATUS;
     Update               : PROCEDURE (POLEOBJECT) : OLESTATUS;
     Reconnect            : PROCEDURE (POLEOBJECT) : OLESTATUS;

     ObjectConvert        : PROCEDURE (POLEOBJECT, PCSTR, POLECLIENT, LHCLIENTDOC, PCSTR, VAR POLEOBJECT) : OLESTATUS;
     GetLinkUpdateOptions : PROCEDURE (POLEOBJECT, VAR OLEOPT_UPDATE) : OLESTATUS;
     SetLinkUpdateOptions : PROCEDURE (POLEOBJECT, OLEOPT_UPDATE) : OLESTATUS;

     Rename               : PROCEDURE (POLEOBJECT, PCSTR) : OLESTATUS;
     QueryName            : PROCEDURE (POLEOBJECT, PSTR, VAR UINT) : OLESTATUS;

     QueryType            : PROCEDURE (POLEOBJECT, VAR LONG) : OLESTATUS;
     QueryBounds          : PROCEDURE (POLEOBJECT, VAR RECT) : OLESTATUS;
     QuerySize            : PROCEDURE (POLEOBJECT, VAR DWORD) : OLESTATUS;
     QueryOpen            : PROCEDURE (POLEOBJECT) : OLESTATUS;
     QueryOutOfDate       : PROCEDURE (POLEOBJECT) : OLESTATUS;

     QueryReleaseStatus   : PROCEDURE (POLEOBJECT) : OLESTATUS;
     QueryReleaseError    : PROCEDURE (POLEOBJECT) : OLESTATUS;
     QueryReleaseMethod   : PROCEDURE (POLEOBJECT) : OLE_RELEASE_METHOD;

     RequestData          : PROCEDURE (POLEOBJECT, OLECLIPFORMAT) : OLESTATUS;
     ObjectLong           : PROCEDURE (POLEOBJECT, UINT, VAR LONG) : OLESTATUS;

     (* This method is internal only *)

     ChangeData           : PROCEDURE (POLEOBJECT, HANDLE, POLECLIENT, BOOL) : OLESTATUS;
     END;
     POLEOBJECTVTBL = POINTER TO OLEOBJECTVTBL;

<* END *>

TYPE OLEOBJECT = RECORD pvtbl : POLEOBJECTVTBL; END;

TYPE OLECLIENTVTBL =
     RECORD
          CallBack : PROCEDURE (POLECLIENT, OLE_NOTIFICATION, POLEOBJECT) : INTEGER;
     END;
     POLECLIENTVTBL = POINTER TO OLECLIENTVTBL;

TYPE OLECLIENT = RECORD pvtbl : POLECLIENTVTBL; END;

(* Stream definitions *)
TYPE OLESTREAMVTBL =
     RECORD
           Get : PROCEDURE (POLESTREAM,  PVOID, DWORD) : DWORD;
           Put : PROCEDURE (POLESTREAM, LPCVOID, DWORD) : DWORD;
     END;
     POLESTREAMVTBL = POINTER TO OLESTREAMVTBL;

TYPE OLESTREAM = RECORD pstbl : POLESTREAMVTBL; END;


(* Public Function Prototypes *)

PROCEDURE OleDelete               (Obj : POLEOBJECT) : OLESTATUS;
PROCEDURE OleRelease              (Obj : POLEOBJECT) : OLESTATUS;
PROCEDURE OleSaveToStream         (Obj : POLEOBJECT; Stream : POLESTREAM) : OLESTATUS;
PROCEDURE OleEqual                (Obj : POLEOBJECT; Obj2 : POLEOBJECT) : OLESTATUS;
PROCEDURE OleCopyToClipboard      (Obj : POLEOBJECT) : OLESTATUS;
PROCEDURE OleSetHostNames         (Obj : POLEOBJECT; Client : PCSTR; ClientObj : PCSTR) : OLESTATUS;
PROCEDURE OleSetTargetDevice      (Obj : POLEOBJECT; hotd : HGLOBAL) : OLESTATUS;
<* IF BACKEND # "C" THEN *>
PROCEDURE OleSetBounds            (Obj : POLEOBJECT; rect : RECT) : OLESTATUS;
<* ELSE *>
PROCEDURE OleSetBounds            (Obj : POLEOBJECT; rect : PRECT) : OLESTATUS;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE OleSetColorScheme       (Obj : POLEOBJECT; palette : LOGPALETTE) : OLESTATUS;
<* ELSE *>
PROCEDURE OleSetColorScheme       (Obj : POLEOBJECT; palette : PLOGPALETTE) : OLESTATUS;
<* END *>
PROCEDURE OleQueryBounds          (Obj : POLEOBJECT; VAR bounds : RECT) : OLESTATUS;
PROCEDURE OleQuerySize            (Obj : POLEOBJECT; VAR size : DWORD) : OLESTATUS;
<* IF BACKEND # "C" THEN *>
PROCEDURE OleDraw                 (Obj : POLEOBJECT; hdc : HDC; Bounds : RECT; WBounds : RECT; hdcFormat : HDC) : OLESTATUS;
<* ELSE *>
PROCEDURE OleDraw                 (Obj : POLEOBJECT; hdc : HDC; Bounds : PRECT; WBounds : PRECT; hdcFormat : HDC) : OLESTATUS;
<* END *>
PROCEDURE OleQueryOpen            (Obj : POLEOBJECT) : OLESTATUS;
<* IF BACKEND # "C" THEN *>
PROCEDURE OleActivate             (Obj : POLEOBJECT; verb : UINT; fShow : BOOL; fTakeFocus : BOOL; hwnd : HWND; bound : RECT) : OLESTATUS;
<* ELSE *>
PROCEDURE OleActivate             (Obj : POLEOBJECT; verb : UINT; fShow : BOOL; fTakeFocus : BOOL; hwnd : HWND; bound : PRECT) : OLESTATUS;
<* END *>
PROCEDURE OleExecute              (Obj : POLEOBJECT; cmds : HGLOBAL; reserved : UINT) : OLESTATUS;
PROCEDURE OleClose                (Obj : POLEOBJECT) : OLESTATUS;
PROCEDURE OleUpdate               (Obj : POLEOBJECT) : OLESTATUS;
PROCEDURE OleReconnect            (Obj : POLEOBJECT) : OLESTATUS;
PROCEDURE OleGetLinkUpdateOptions (Obj : POLEOBJECT; VAR UpdateOpt : OLEOPT_UPDATE) : OLESTATUS;
PROCEDURE OleSetLinkUpdateOptions (Obj : POLEOBJECT; UpdateOpt : OLEOPT_UPDATE) : OLESTATUS;
PROCEDURE OleQueryProtocol        (Obj : POLEOBJECT; pszProtocol : PCSTR) : PVOID;

(* Routines related to asynchronous operations. *)

PROCEDURE OleQueryReleaseStatus (Obj : POLEOBJECT) : OLESTATUS;
PROCEDURE OleQueryReleaseError  (Obj : POLEOBJECT) : OLESTATUS;
PROCEDURE OleQueryReleaseMethod (Obj : POLEOBJECT) : OLE_RELEASE_METHOD;

PROCEDURE OleQueryType (Obj : POLEOBJECT; VAR Type : OT_TYPE) : OLESTATUS;

(* LOWORD is major version, HIWORD is minor version *)

PROCEDURE OleQueryClientVersion () : DWORD;
PROCEDURE OleQueryServerVersion () : DWORD;

(* Converting to format (as in clipboard): *)

PROCEDURE OleEnumFormats    (Obj : POLEOBJECT; fmt : OLECLIPFORMAT) : OLECLIPFORMAT;
PROCEDURE OleGetData        (Obj : POLEOBJECT; fmt : OLECLIPFORMAT; VAR hData : HANDLE) : OLESTATUS;
PROCEDURE OleSetData        (Obj : POLEOBJECT; fmt : OLECLIPFORMAT; hdata : HANDLE) : OLESTATUS;
<* IF BACKEND # "C" THEN *>
PROCEDURE OleQueryOutOfDate (Obj : OLEOBJECT) : OLESTATUS;
<* ELSE *>
PROCEDURE OleQueryOutOfDate (Obj : POLEOBJECT) : OLESTATUS;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE OleRequestData    (Obj : OLEOBJECT; fmt : OLECLIPFORMAT) : OLESTATUS;
<* ELSE *>
PROCEDURE OleRequestData    (Obj : POLEOBJECT; fmt : OLECLIPFORMAT) : OLESTATUS;
<* END *>

(* Query apis for creation from clipboard *)

PROCEDURE OleQueryLinkFromClip   (protocol : PCSTR; renderopt : OLEOPT_RENDER; fmt : OLECLIPFORMAT) : OLESTATUS;
PROCEDURE OleQueryCreateFromClip (protocol : PCSTR; renderopt : OLEOPT_RENDER; fmt : OLECLIPFORMAT) : OLESTATUS;

(* Object creation functions *)

PROCEDURE OleCreateFromClip (protocol : PCSTR; client : POLECLIENT;
                             clientdoc : LHCLIENTDOC; ObjName : PCSTR;
                             VAR Obj : POLEOBJECT; renderopt : OLEOPT_RENDER;
                             fmt : OLECLIPFORMAT) : OLESTATUS;
PROCEDURE OleCreateLinkFromClip (protocol : PCSTR; client : POLECLIENT;
                                 clientdoc : LHCLIENTDOC; ObjName : PCSTR;
                                 VAR Obj : POLEOBJECT; renderopt : OLEOPT_RENDER;
                                 fmt : OLECLIPFORMAT) : OLESTATUS;
PROCEDURE OleCreateFromFile (protocol : PCSTR; client : POLECLIENT;
                             Class : PCSTR; File : PCSTR;
                             clientdoc : LHCLIENTDOC;
                             objname : PCSTR;
                             VAR Obj : POLEOBJECT;
                             renderopt : OLEOPT_RENDER;
                             fmt : OLECLIPFORMAT) : OLESTATUS;
PROCEDURE OleCreateLinkFromFile (protocol : PCSTR; client : POLECLIENT;
                                 Class : PCSTR; File : PCSTR; Item : PCSTR;
                                 clientdoc : LHCLIENTDOC;
                                 objname : PCSTR;
                                 VAR Obj : POLEOBJECT;
                                 renderopt : OLEOPT_RENDER;
                                 fmt : OLECLIPFORMAT) : OLESTATUS;
PROCEDURE OleLoadFromStream (Stream : POLESTREAM; protocol : PCSTR;
                             Client : POLECLIENT; ClientDoc : LHCLIENTDOC;
                             ObjName : PCSTR; VAR Obj : POLEOBJECT) : OLESTATUS;
PROCEDURE OleCreate (protocol : PCSTR; Client : POLECLIENT;
                     Class : PCSTR; ClientDoc : LHCLIENTDOC;
                     ObjName : PCSTR; VAR Obj : POLEOBJECT;
                     render : OLEOPT_RENDER; fmt : OLECLIPFORMAT) : OLESTATUS;
PROCEDURE OleCreateInvisible (protocol : PCSTR; Client : POLECLIENT;
                              Class : PCSTR; ClientDoc : LHCLIENTDOC;
                              ObjName : PCSTR; VAR Obj : POLEOBJECT;
                              render : OLEOPT_RENDER; fmt : OLECLIPFORMAT;
                              fActivate : BOOL) : OLESTATUS;
PROCEDURE OleCreateFromTemplate (protocol : PCSTR; Client : POLECLIENT;
                     Template : PCSTR; ClientDoc : LHCLIENTDOC;
                     ObjName : PCSTR; VAR Obj : POLEOBJECT;
                     render : OLEOPT_RENDER; fmt : OLECLIPFORMAT) : OLESTATUS;
PROCEDURE OleClone (Obj : POLEOBJECT; CLient : POLECLIENT;
                    ClientDoc : LHCLIENTDOC;
                    ObjName : PCSTR; VAR NewObj : POLEOBJECT) : OLESTATUS;
PROCEDURE OleCopyFromLink (Obj : POLEOBJECT; Protocol : PCSTR;
                           Client : POLECLIENT; ClientDoc : LHCLIENTDOC;
                           ObjName : PCSTR; VAR NewObj : POLEOBJECT) : OLESTATUS;
PROCEDURE OleObjectConvert (Obj : POLEOBJECT; Protocol : PCSTR;
                            CLient : POLECLIENT; ClientDoc : LHCLIENTDOC;
                            ObjName : PCSTR; VAR NewObj : POLEOBJECT) : OLESTATUS;
PROCEDURE OleRename (Obj : POLEOBJECT; NewName : PCSTR) : OLESTATUS;
PROCEDURE OleQueryName (Obj : POLEOBJECT; name : PSTR; VAR Size : UINT) : OLESTATUS;
PROCEDURE OleRevokeObject (Client : POLECLIENT) : OLESTATUS;
PROCEDURE OleIsDcMeta (hdc : HDC) : BOOL;

(* client document API *)
PROCEDURE OleRegisterClientDoc (Class : PCSTR; Doc : PCSTR;
                                reserved : LONG;
                                VAR ClientDoc : LHCLIENTDOC) : OLESTATUS;
PROCEDURE OleRevokeClientDoc (ClientDoc : LHCLIENTDOC) : OLESTATUS;
PROCEDURE OleRenameClientDoc (ClientDoc : LHCLIENTDOC; newname : PCSTR) : OLESTATUS;
PROCEDURE OleRevertClientDoc (ClientDoc : LHCLIENTDOC) : OLESTATUS;
PROCEDURE OleSavedClientDoc  (ClientDoc : LHCLIENTDOC) : OLESTATUS;
PROCEDURE OleEnumObjects     (ClientDoc : LHCLIENTDOC; VAR Obj : POLEOBJECT) : OLESTATUS;

(* server usage definitions *)

TYPE OLE_SERVER_USE = (
    OLE_SERVER_MULTI,           (* multiple instances *)
    OLE_SERVER_SINGLE           (* single instance(multiple document) *)
   );

(* Server API *)
TYPE POLESERVER = POINTER TO OLESERVER;

PROCEDURE OleRegisterServer (Class : PCSTR; Server : POLESERVER;
                             VAR hServer : LHSERVER; hinst : HINSTANCE;
                             srvuse : OLE_SERVER_USE) : OLESTATUS;
PROCEDURE OleRevokeServer  (hsrv : LHSERVER) : OLESTATUS;
PROCEDURE OleBlockServer   (hsrv : LHSERVER) : OLESTATUS;
PROCEDURE OleUnblockServer (hsrv : LHSERVER; VAR Request : BOOL) : OLESTATUS;

(* APIs to keep server open *)

PROCEDURE OleLockServer   (Obj : POLEOBJECT; VAR hServer : LHSERVER) : OLESTATUS;
PROCEDURE OleUnlockServer (hsrv : LHSERVER) : OLESTATUS;

(* Server document API *)

TYPE POLESERVERDOC = POINTER TO OLESERVERDOC;

PROCEDURE OleRegisterServerDoc (hServer : LHSERVER;docname : PCSTR;
                                Doc : POLESERVERDOC;
                                VAR ServerDoc : LHSERVERDOC) : OLESTATUS;
PROCEDURE OleRevokeServerDoc   (ServerDoc : LHSERVERDOC) : OLESTATUS;
PROCEDURE OleRenameServerDoc   (ServerDoc : LHSERVERDOC; newname : PCSTR) : OLESTATUS;
PROCEDURE OleRevertServerDoc   (ServerDoc : LHSERVERDOC) : OLESTATUS;
PROCEDURE OleSavedServerDoc    (ServerDoc : LHSERVERDOC) : OLESTATUS;

TYPE OLESERVERVTBL =
     RECORD
     Open : PROCEDURE (POLESERVER, LHSERVERDOC, PCSTR, VAR POLESERVERDOC) : OLESTATUS;
                                   (* long handle to doc(privtate to DLL)  *)
                                   (* lp to OLESERVER                      *)
                                   (* document name                        *)
                                   (* place holder for returning oledoc.   *)

     Create : PROCEDURE (POLESERVER, LHSERVERDOC, PCSTR, PCSTR, VAR POLESERVERDOC) : OLESTATUS;
                                   (* long handle to doc(privtate to DLL)  *)
                                   (* lp to OLESERVER                      *)
                                   (* lp class name                        *)
                                   (* lp doc name                          *)
                                   (* place holder for returning oledoc.   *)

     CreateFromTemplate : PROCEDURE (POLESERVER, LHSERVERDOC, PCSTR, PCSTR, PCSTR, VAR POLESERVERDOC) : OLESTATUS;
                                   (* long handle to doc(privtate to DLL)  *)
                                   (* lp to OLESERVER                      *)
                                   (* lp class name                        *)
                                   (* lp doc name                          *)
                                   (* lp template name                     *)
                                   (* place holder for returning oledoc.   *)

     Edit : PROCEDURE (POLESERVER, LHSERVERDOC, PCSTR, PCSTR, VAR POLESERVERDOC) : OLESTATUS;
                                   (* long handle to doc(privtate to DLL)  *)
                                   (* lp to OLESERVER                      *)
                                   (* lp class name                        *)
                                   (* lp doc name                          *)
                                   (* place holder for returning oledoc.   *)

     Exit : PROCEDURE (POLESERVER) : OLESTATUS;
                                   (* lp OLESERVER                         *)

     Release : PROCEDURE (POLESERVER) : OLESTATUS;
                                   (* lp OLESERVER                         *)

     Execute : PROCEDURE (POLESERVER, HGLOBAL) : OLESTATUS;
                                   (* lp OLESERVER                         *)
                                   (* handle to command strings            *)
     END;
     POLESERVERVTBL = POINTER TO OLESERVERVTBL;

TYPE OLESERVER = RECORD pvtbl : POLESERVERVTBL; END;

<* IF BACKEND # "C" THEN *>

TYPE OLESERVERDOCVTBL =
     RECORD
     Save             : PROCEDURE (POLESERVERDOC) : OLESTATUS;
     Close            : PROCEDURE (POLESERVERDOC) : OLESTATUS;
     SetHostNames     : PROCEDURE (POLESERVERDOC, PCSTR, PCSTR) : OLESTATUS;
     SetDocDimensions : PROCEDURE (POLESERVERDOC, RECT) : OLESTATUS;
     GetObject        : PROCEDURE (POLESERVERDOC, PCSTR, VAR POLEOBJECT, POLECLIENT) : OLESTATUS;
     Release          : PROCEDURE (POLESERVERDOC) : OLESTATUS;
     SetColorScheme   : PROCEDURE (POLESERVERDOC, LOGPALETTE) : OLESTATUS;
     Execute          : PROCEDURE (POLESERVERDOC, HGLOBAL) : OLESTATUS;
     END;
     POLESERVERDOCVTBL = POINTER TO OLESERVERDOCVTBL;

<* ELSE *>

TYPE OLESERVERDOCVTBL =
     RECORD
     Save             : PROCEDURE (POLESERVERDOC) : OLESTATUS;
     Close            : PROCEDURE (POLESERVERDOC) : OLESTATUS;
     SetHostNames     : PROCEDURE (POLESERVERDOC, PCSTR, PCSTR) : OLESTATUS;
     SetDocDimensions : PROCEDURE (POLESERVERDOC, PRECT) : OLESTATUS;
     GetObject        : PROCEDURE (POLESERVERDOC, PCSTR, VAR POLEOBJECT, POLECLIENT) : OLESTATUS;
     Release          : PROCEDURE (POLESERVERDOC) : OLESTATUS;
     SetColorScheme   : PROCEDURE (POLESERVERDOC, PLOGPALETTE) : OLESTATUS;
     Execute          : PROCEDURE (POLESERVERDOC, HGLOBAL) : OLESTATUS;
     END;
     POLESERVERDOCVTBL = POINTER TO OLESERVERDOCVTBL;

<* END *>

TYPE OLESERVERDOC = RECORD pltbl : POLESERVERDOCVTBL; END;



(*  WinSvc.def

    Definition module for the Service Control Manager

*)

(*
** Constants
*)

(*
** Service database names
*)

TYPE WCHARARRAY15 = ARRAY [0..14] OF WCHAR;

CONST SERVICES_ACTIVE_DATABASEW =
         WCHARARRAY15 {ORD('S'),ORD('e'),ORD('r'),ORD('v'),ORD('i'),ORD('c'),
                       ORD('e'),ORD('s'),ORD('A'),ORD('c'),ORD('t'),ORD('i'),
                       ORD('v'),ORD('e'),0};
      SERVICES_FAILED_DATABASEW =
         WCHARARRAY15 {ORD('S'),ORD('e'),ORD('r'),ORD('v'),ORD('i'),ORD('c'),
                       ORD('e'),ORD('s'),ORD('F'),ORD('a'),ORD('i'),ORD('l'),
                       ORD('e'),ORD('d'),0};

CONST SERVICES_ACTIVE_DATABASEA = "ServicesActive";
      SERVICES_FAILED_DATABASEA = "ServicesFailed";

(*
** Character to designate that a name is a group
*)

CONST SC_GROUP_IDENTIFIERW = VAL (WCHAR, '+');
CONST SC_GROUP_IDENTIFIERA = '+';

<* IF DEFINED (UNICODE) THEN *>

      CONST SERVICES_ACTIVE_DATABASE = SERVICES_ACTIVE_DATABASEW;
            SERVICES_FAILED_DATABASE = SERVICES_FAILED_DATABASEW;

            SC_GROUP_IDENTIFIER      = SC_GROUP_IDENTIFIERW;

<* ELSE *>

      CONST SERVICES_ACTIVE_DATABASE = SERVICES_ACTIVE_DATABASEA;
            SERVICES_FAILED_DATABASE = SERVICES_FAILED_DATABASEA;

            SC_GROUP_IDENTIFIER      = SC_GROUP_IDENTIFIERA;
<* END *>


(*
** Value to indicate no change to an optional parameter
*)

CONST SERVICE_NO_CHANGE =  0ffffffffh;

(*
** Service State -- for Enum Requests (Bit Mask)
*)

TYPE SERVICE_STATE_ENUM = (SERVICE__ACTIVE,     (* 0x00000001 *)
                           SERVICE__INACTIVE);  (* 0x00000002 *)

     SERVICE_STATE_SET = SET OF SERVICE_STATE_ENUM;

CONST SERVICE_ACTIVE    = SERVICE_STATE_SET {SERVICE__ACTIVE};   (* 0x00000001 *)
      SERVICE_INACTIVE  = SERVICE_STATE_SET {SERVICE__INACTIVE}; (* 0x00000002 *)
      SERVICE_STATE_ALL = SERVICE_ACTIVE + SERVICE_INACTIVE;

(*
** Controls
*)

TYPE SERVICE_CONTROL_ENUM = (SERVICE_CONTROL_0,
                             SERVICE_CONTROL_STOP,        (* 0x00000001 *)
                             SERVICE_CONTROL_PAUSE,       (* 0x00000002 *)
                             SERVICE_CONTROL_CONTINUE,    (* 0x00000003 *)
                             SERVICE_CONTROL_INTERROGATE, (* 0x00000004 *)
                             SERVICE_CONTROL_SHUTDOWN);    (* 0x00000005 *)

(*
** Service State -- for CurrentState
*)

TYPE SERVICE_CUR_STATE_ENUM = (SERVICE_CUR_STATE_0,
                               SERVICE_STOPPED,          (* 0x00000001 *)
                               SERVICE_START_PENDING,    (* 0x00000002 *)
                               SERVICE_STOP_PENDING,     (* 0x00000003 *)
                               SERVICE_RUNNING,          (* 0x00000004 *)
                               SERVICE_CONTINUE_PENDING, (* 0x00000005 *)
                               SERVICE_PAUSE_PENDING,    (* 0x00000006 *)
                               SERVICE_PAUSED);          (* 0x00000007 *)

(*
** Controls Accepted  (Bit Mask)
*)

TYPE SERVICE_ACCEPT_ENUM = (SERVICE_ACCEPT__STOP,           (* 0 *)
                            SERVICE_ACCEPT__PAUSE_CONTINUE, (* 1 *)
                            SERVICE_ACCEPT__SHUTDOWN);      (* 2 *)

     SERVICE_ACCEPT_SET = SET OF SERVICE_ACCEPT_ENUM;

CONST SERVICE_ACCEPT_STOP           = SERVICE_ACCEPT_SET {SERVICE_ACCEPT__STOP};           (* 0x00000001 *)
      SERVICE_ACCEPT_PAUSE_CONTINUE = SERVICE_ACCEPT_SET {SERVICE_ACCEPT__PAUSE_CONTINUE}; (* 0x00000002 *)
      SERVICE_ACCEPT_SHUTDOWN       = SERVICE_ACCEPT_SET {SERVICE_ACCEPT__SHUTDOWN};       (* 0x00000004 *)

(*
** Service Control Manager object specific access types
*)

CONST SC_MANAGER_CONNECT            = ACCESS_MASK {ACCESS_0}; (* 0x0001 *)
      SC_MANAGER_CREATE_SERVICE     = ACCESS_MASK {ACCESS_1}; (* 0x0002 *)
      SC_MANAGER_ENUMERATE_SERVICE  = ACCESS_MASK {ACCESS_2}; (* 0x0004 *)
      SC_MANAGER_LOCK               = ACCESS_MASK {ACCESS_3}; (* 0x0008 *)
      SC_MANAGER_QUERY_LOCK_STATUS  = ACCESS_MASK {ACCESS_4}; (* 0x0010 *)
      SC_MANAGER_MODIFY_BOOT_CONFIG = ACCESS_MASK {ACCESS_5}; (* 0x0020 *)

      SC_MANAGER_ALL_ACCESS         = STANDARD_RIGHTS_REQUIRED      +
                                      SC_MANAGER_CONNECT            +
                                      SC_MANAGER_CREATE_SERVICE     +
                                      SC_MANAGER_ENUMERATE_SERVICE  +
                                      SC_MANAGER_LOCK               +
                                      SC_MANAGER_QUERY_LOCK_STATUS  +
                                      SC_MANAGER_MODIFY_BOOT_CONFIG;

(*
** Service object specific access type
*)

CONST SERVICE_QUERY_CONFIG         = ACCESS_MASK {ACCESS_0}; (* 0x0001 *)
      SERVICE_CHANGE_CONFIG        = ACCESS_MASK {ACCESS_1}; (* 0x0002 *)
      SERVICE_QUERY_STATUS         = ACCESS_MASK {ACCESS_2}; (* 0x0004 *)
      SERVICE_ENUMERATE_DEPENDENTS = ACCESS_MASK {ACCESS_3}; (* 0x0008 *)
      SERVICE_START                = ACCESS_MASK {ACCESS_4}; (* 0x0010 *)
      SERVICE_STOP                 = ACCESS_MASK {ACCESS_5}; (* 0x0020 *)
      SERVICE_PAUSE_CONTINUE       = ACCESS_MASK {ACCESS_6}; (* 0x0040 *)
      SERVICE_INTERROGATE          = ACCESS_MASK {ACCESS_7}; (* 0x0080 *)
      SERVICE_USER_DEFINED_CONTROL = ACCESS_MASK {ACCESS_8}; (* 0x0100 *)

      SERVICE_ALL_ACCESS           = STANDARD_RIGHTS_REQUIRED     +
                                     SERVICE_QUERY_CONFIG         +
                                     SERVICE_CHANGE_CONFIG        +
                                     SERVICE_QUERY_STATUS         +
                                     SERVICE_ENUMERATE_DEPENDENTS +
                                     SERVICE_START                +
                                     SERVICE_STOP                 +
                                     SERVICE_PAUSE_CONTINUE       +
                                     SERVICE_INTERROGATE          +
                                     SERVICE_USER_DEFINED_CONTROL;

(*
** Handle Types
*)

TYPE SC_HANDLE  = HANDLE;
TYPE PSC_HANDLE = POINTER TO SC_HANDLE;

TYPE SERVICE_STATUS_HANDLE = DWORD;


(*
** Service Status Structure
*)

TYPE SERVICE_STATUS = RECORD
                             dwServiceType             : SERVICE_NODE_TYPE;
                             dwCurrentState            : SERVICE_CUR_STATE_ENUM;
                             dwControlsAccepted        : SERVICE_ACCEPT_SET;
                             dwWin32ExitCode           : DWORD;
                             dwServiceSpecificExitCode : DWORD;
                             dwCheckPoint              : DWORD;
                             dwWaitHint                : DWORD;
                      END;
    PSERVICE_STATUS = POINTER TO SERVICE_STATUS;

(*
** Service Status Enumeration Structure
*)

TYPE ENUM_SERVICE_STATUSA = RECORD
                                   lpServiceName : PSTR;
                                   lpDisplayName : PSTR;
                                   ServiceStatus : SERVICE_STATUS;
                            END;
    PENUM_SERVICE_STATUSA = POINTER TO ENUM_SERVICE_STATUSA;

TYPE ENUM_SERVICE_STATUSW = RECORD
                                   lpServiceName : PWSTR;
                                   lpDisplayName : PWSTR;
                                   ServiceStatus : SERVICE_STATUS;
                            END;
    PENUM_SERVICE_STATUSW = POINTER TO ENUM_SERVICE_STATUSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  ENUM_SERVICE_STATUS =  ENUM_SERVICE_STATUSW;
      TYPE PENUM_SERVICE_STATUS = PENUM_SERVICE_STATUSW;
<* ELSE *>
      TYPE  ENUM_SERVICE_STATUS =  ENUM_SERVICE_STATUSA;
      TYPE PENUM_SERVICE_STATUS = PENUM_SERVICE_STATUSA;
<* END *>


(*
** Structures for the Lock API functions
*)

TYPE SC_LOCK = PVOID;

TYPE QUERY_SERVICE_LOCK_STATUSA = RECORD
                                         fIsLocked      : DWORD;
                                         lpLockOwner    : PSTR;
                                         dwLockDuration : DWORD;
                                  END;
     PQUERY_SERVICE_LOCK_STATUSA = POINTER TO QUERY_SERVICE_LOCK_STATUSA;

TYPE QUERY_SERVICE_LOCK_STATUSW = RECORD
                                         fIsLocked      : DWORD;
                                         lpLockOwner    : PWSTR;
                                         dwLockDuration : DWORD;
                                  END;
     PQUERY_SERVICE_LOCK_STATUSW = POINTER TO QUERY_SERVICE_LOCK_STATUSW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  QUERY_SERVICE_LOCK_STATUS =  QUERY_SERVICE_LOCK_STATUSW;
      TYPE PQUERY_SERVICE_LOCK_STATUS = PQUERY_SERVICE_LOCK_STATUSW;
<* ELSE *>
      TYPE  QUERY_SERVICE_LOCK_STATUS =  QUERY_SERVICE_LOCK_STATUSA;
      TYPE PQUERY_SERVICE_LOCK_STATUS = PQUERY_SERVICE_LOCK_STATUSA;
<* END *>

(*
** Query Service Configuration Structure
*)

TYPE QUERY_SERVICE_CONFIGA = RECORD
                                    dwServiceType      : SERVICE_NODE_TYPE;
                                    dwStartType        : SERVICE_LOAD_TYPE;
                                    dwErrorControl     : SERVICE_ERROR_TYPE;
                                    lpBinaryPathName   : PSTR;
                                    lpLoadOrderGroup   : PSTR;
                                    dwTagId            : DWORD;
                                    lpDependencies     : PSTR;
                                    lpServiceStartName : PSTR;
                                    lpDisplayName      : PSTR;
                             END;
    PQUERY_SERVICE_CONFIGA = POINTER TO QUERY_SERVICE_CONFIGA;

TYPE QUERY_SERVICE_CONFIGW = RECORD
                                    dwServiceType      : SERVICE_NODE_TYPE;
                                    dwStartType        : SERVICE_LOAD_TYPE;
                                    dwErrorControl     : SERVICE_ERROR_TYPE;
                                    lpBinaryPathName   : PWSTR;
                                    lpLoadOrderGroup   : PWSTR;
                                    dwTagId            : DWORD;
                                    lpDependencies     : PWSTR;
                                    lpServiceStartName : PWSTR;
                                    lpDisplayName      : PWSTR;
                             END;
    PQUERY_SERVICE_CONFIGW = POINTER TO QUERY_SERVICE_CONFIGW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  QUERY_SERVICE_CONFIG =  QUERY_SERVICE_CONFIGW;
      TYPE PQUERY_SERVICE_CONFIG = PQUERY_SERVICE_CONFIGW;
<* ELSE *>
      TYPE  QUERY_SERVICE_CONFIG =  QUERY_SERVICE_CONFIGA;
      TYPE PQUERY_SERVICE_CONFIG = PQUERY_SERVICE_CONFIGA;
<* END *>

(*
** Function Prototype for the Service Main Function
*)

TYPE SERVICE_MAIN_FUNCTIONW = PROCEDURE (    (* dwNumServicesArgs   : *) DWORD,
                                         VAR (* lpServiceArgVectors : *) ARRAY OF PWSTR);


TYPE SERVICE_MAIN_FUNCTIONA = PROCEDURE (    (* dwNumServicesArgs   : *) DWORD,
                                         VAR (* lpServiceArgVectors : *) ARRAY OF PSTR);


<* IF DEFINED (UNICODE) THEN *>
      TYPE SERVICE_MAIN_FUNCTION = SERVICE_MAIN_FUNCTIONW;
<* ELSE *>
      TYPE SERVICE_MAIN_FUNCTION = SERVICE_MAIN_FUNCTIONA;
<* END *>

(*
** Service Start Table
*)

TYPE SERVICE_TABLE_ENTRYA = RECORD
                                   lpServiceName : PSTR;
                                   lpServiceProc : SERVICE_MAIN_FUNCTIONA;
                            END;
    PSERVICE_TABLE_ENTRYA = POINTER TO SERVICE_TABLE_ENTRYA;

TYPE SERVICE_TABLE_ENTRYW = RECORD
                                   lpServiceName : PWSTR;
                                   lpServiceProc : SERVICE_MAIN_FUNCTIONW;
                            END;
    PSERVICE_TABLE_ENTRYW = POINTER TO SERVICE_TABLE_ENTRYW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  SERVICE_TABLE_ENTRY =  SERVICE_TABLE_ENTRYW;
      TYPE PSERVICE_TABLE_ENTRY = PSERVICE_TABLE_ENTRYW;
<* ELSE *>
      TYPE  SERVICE_TABLE_ENTRY =  SERVICE_TABLE_ENTRYA;
      TYPE PSERVICE_TABLE_ENTRY = PSERVICE_TABLE_ENTRYA;
<* END *>


(*
** Prototype for the Service Control Handler Function
*)

TYPE HANDLER_FUNCTION = PROCEDURE ((* dwControl : *) SERVICE_CONTROL_ENUM);


(*************************************************************************
** API Function Prototypes
**************************************************************************)


PROCEDURE ChangeServiceConfigA (hService           : SC_HANDLE;
                                dwServiceType      : SERVICE_NODE_TYPE;
                                dwStartType        : SERVICE_LOAD_TYPE;
                                dwErrorControl     : SERVICE_ERROR_TYPE;
                                lpBinaryPathName   : PCSTR; (* NIL *)
                                lpLoadOrderGroup   : PCSTR; (* NIL *)
                                VAR [NIL] dwTagId  : DWORD;
                                lpDependencies     : PCSTR; (* NIL *)
                                lpServiceStartName : PCSTR; (* NIL *)
                                lpPassword         : PCSTR; (* NIL *)
                                lpDisplayName      : PCSTR  (* NIL *)) : BOOL;

PROCEDURE ChangeServiceConfigW (hService           : SC_HANDLE;
                                dwServiceType      : SERVICE_NODE_TYPE;
                                dwStartType        : SERVICE_LOAD_TYPE;
                                dwErrorControl     : SERVICE_ERROR_TYPE;
                                lpBinaryPathName   : PCWSTR; (* NIL *)
                                lpLoadOrderGroup   : PCWSTR; (* NIL *)
                                VAR [NIL] dwTagId  : DWORD;
                                lpDependencies     : PCWSTR; (* NIL *)
                                lpServiceStartName : PCWSTR; (* NIL *)
                                lpPassword         : PCWSTR; (* NIL *)
                                lpDisplayName      : PCWSTR  (* NIL *)) : BOOL;


<* IF DEFINED (UNICODE) THEN*>
      CONST ChangeServiceConfig = ChangeServiceConfigW;
<* ELSE *>
      CONST ChangeServiceConfig = ChangeServiceConfigA;
<* END *>


PROCEDURE CloseServiceHandle (hSCObject : SC_HANDLE) : BOOL;


PROCEDURE ControlService (hService                : SC_HANDLE;
                          dwControl               : SERVICE_CONTROL_ENUM;
                          VAR [NIL] ServiceStatus : SERVICE_STATUS) : BOOL;


PROCEDURE CreateServiceA (hSCManager         : SC_HANDLE;
                          lpServiceName      : ARRAY OF CHAR;
                          lpDisplayName      : ARRAY OF CHAR;
                          dwDesiredAccess    : ACCESS_MASK;
                          dwServiceType      : SERVICE_NODE_TYPE;
                          dwStartType        : SERVICE_LOAD_TYPE;
                          dwErrorControl     : SERVICE_ERROR_TYPE;
                          lpBinaryPathName   : ARRAY OF CHAR;
                          lpLoadOrderGroup   : PCSTR; (* NIL *)
                          VAR [NIL] dwTagId  : DWORD;
                          lpDependencies     : PCSTR; (* NIL *)
                          lpServiceStartName : PCSTR; (* NIL *)
                          lpPassword         : PCSTR  (* NIL *)) : SC_HANDLE;

PROCEDURE CreateServiceW (hSCManager         : SC_HANDLE;
                          lpServiceName      : ARRAY OF WCHAR;
                          lpDisplayName      : ARRAY OF WCHAR;
                          dwDesiredAccess    : ACCESS_MASK;
                          dwServiceType      : SERVICE_NODE_TYPE;
                          dwStartType        : SERVICE_LOAD_TYPE;
                          dwErrorControl     : SERVICE_ERROR_TYPE;
                          lpBinaryPathName   : ARRAY OF WCHAR;
                          lpLoadOrderGroup   : PCWSTR; (* NIL *)
                          VAR [NIL] dwTagId  : DWORD;
                          lpDependencies     : PCWSTR; (* NIL *)
                          lpServiceStartName : PCWSTR; (* NIL *)
                          lpPassword         : PCWSTR  (* NIL *)) : SC_HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST CreateService = CreateServiceW;
<* ELSE *>
      CONST CreateService = CreateServiceA;
<* END *>

PROCEDURE DeleteService (hService : SC_HANDLE) : BOOL;

PROCEDURE EnumDependentServicesA (hService             : SC_HANDLE;
                                  dwServiceState       : SERVICE_STATE_SET;
                                  VAR Services         : ARRAY OF ENUM_SERVICE_STATUSA;
                                  cbBufSize            : DWORD;
                                  VAR cbBytesNeeded    : DWORD;
                                  VAR ServicesReturned : DWORD) : BOOL;

PROCEDURE EnumDependentServicesW (hService             : SC_HANDLE;
                                  dwServiceState       : SERVICE_STATE_SET;
                                  VAR Services         : ARRAY OF ENUM_SERVICE_STATUSW;
                                  cbBufSize            : DWORD;
                                  VAR cbBytesNeeded    : DWORD;
                                  VAR ServicesReturned : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumDependentServices = EnumDependentServicesW;
<* ELSE *>
      CONST EnumDependentServices = EnumDependentServicesA;
<* END *>


PROCEDURE EnumServicesStatusA (hSCManager           : SC_HANDLE;
                               dwServiceType        : SERVICE_NODE_TYPE;
                               dwServiceState       : SERVICE_STATE_SET;
                               VAR Services         : ARRAY OF ENUM_SERVICE_STATUSA;
                               cbBufSize            : DWORD;
                               VAR cbBytesNeeded    : DWORD;
                               VAR ServicesReturned : DWORD;
                               VAR ResumeHandle     : DWORD) : BOOL;

PROCEDURE EnumServicesStatusW (hSCManager           : SC_HANDLE;
                               dwServiceType        : SERVICE_NODE_TYPE;
                               dwServiceState       : SERVICE_STATE_SET;
                               VAR Services         : ARRAY OF ENUM_SERVICE_STATUSW;
                               cbBufSize            : DWORD;
                               VAR cbBytesNeeded    : DWORD;
                               VAR ServicesReturned : DWORD;
                               VAR ResumeHandle     : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST EnumServicesStatus = EnumServicesStatusW;
<* ELSE *>
      CONST EnumServicesStatus = EnumServicesStatusA;
<* END *>


PROCEDURE GetServiceKeyNameA (hSCManager      : SC_HANDLE;
                              DisplayName     : ARRAY OF CHAR;
                              VAR ServiceName : ARRAY OF CHAR;
                              VAR cchBuffer   : DWORD) : BOOL;

PROCEDURE GetServiceKeyNameW (hSCManager      : SC_HANDLE;
                              DisplayName     : ARRAY OF WCHAR;
                              VAR ServiceName : ARRAY OF WCHAR;
                              VAR cchBuffer   : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetServiceKeyName = GetServiceKeyNameW;
<* ELSE *>
      CONST GetServiceKeyName = GetServiceKeyNameA;
<* END *>


PROCEDURE GetServiceDisplayNameA (hSCManager      : SC_HANDLE;
                                  ServiceName     : ARRAY OF CHAR;
                                  VAR DisplayName : ARRAY OF CHAR;
                                  VAR cchBuffer   : DWORD) : BOOL;

PROCEDURE GetServiceDisplayNameW (hSCManager      : SC_HANDLE;
                                  ServiceName     : ARRAY OF WCHAR;
                                  VAR DisplayName : ARRAY OF WCHAR;
                                  VAR cchBuffer   : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST GetServiceDisplayName = GetServiceDisplayNameW;
<* ELSE *>
      CONST GetServiceDisplayName = GetServiceDisplayNameA;
<* END *>


PROCEDURE LockServiceDatabase (hSCManager : SC_HANDLE) : SC_LOCK;

PROCEDURE NotifyBootConfigStatus (BootAcceptable : BOOL) : BOOL;

PROCEDURE OpenSCManagerA (lpMachineName   : PCSTR; (* NIL *)
                          lpDatabaseName  : PCSTR; (* NIL *)
                          dwDesiredAccess : ACCESS_MASK) : SC_HANDLE;

PROCEDURE OpenSCManagerW (lpMachineName   : PCWSTR; (* NIL *)
                          lpDatabaseName  : PCWSTR; (* NIL *)
                          dwDesiredAccess : ACCESS_MASK) : SC_HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST OpenSCManager = OpenSCManagerW;
<* ELSE *>
      CONST OpenSCManager = OpenSCManagerA;
<* END *>


PROCEDURE OpenServiceA (hSCManager      : SC_HANDLE;
                        lpServiceName   : ARRAY OF CHAR;
                        dwDesiredAccess : ACCESS_MASK) : SC_HANDLE;

PROCEDURE OpenServiceW (hSCManager      : SC_HANDLE;
                        lpServiceName   : ARRAY OF WCHAR;
                        dwDesiredAccess : ACCESS_MASK) : SC_HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST OpenService = OpenServiceW;
<* ELSE *>
      CONST OpenService = OpenServiceA;
<* END *>

PROCEDURE QueryServiceConfigA (hService          : SC_HANDLE;
                               VAR ServiceConfig : QUERY_SERVICE_CONFIGA;
                               cbBufSize         : DWORD;
                               VAR cbBytesNeeded : DWORD) : BOOL;

PROCEDURE QueryServiceConfigW (hService          : SC_HANDLE;
                               VAR ServiceConfig : QUERY_SERVICE_CONFIGW;
                               cbBufSize         : DWORD;
                               VAR cbBytesNeeded : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST QueryServiceConfig = QueryServiceConfigW;
<* ELSE *>
      CONST QueryServiceConfig = QueryServiceConfigA;
<* END *>


PROCEDURE QueryServiceLockStatusA (hSCManager        : SC_HANDLE;
                                   VAR LockStatus    : QUERY_SERVICE_LOCK_STATUSA;
                                   cbBufSize         : DWORD;
                                   VAR cbBytesNeeded : DWORD) : BOOL;

PROCEDURE QueryServiceLockStatusW (hSCManager        : SC_HANDLE;
                                   VAR LockStatus    : QUERY_SERVICE_LOCK_STATUSW;
                                   cbBufSize         : DWORD;
                                   VAR cbBytesNeeded : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST QueryServiceLockStatus = QueryServiceLockStatusW;
<* ELSE *>
      CONST QueryServiceLockStatus = QueryServiceLockStatusA;
<* END *>

PROCEDURE QueryServiceObjectSecurity (hService              : SC_HANDLE;
                                      dwSecurityInformation : SECURITY_INFORMATION;
                                      lpSecurityDescriptor  : PSECURITY_DESCRIPTOR;
                                      cbBufSize             : DWORD;
                                      VAR cbBytesNeeded     : DWORD) : BOOL;

PROCEDURE QueryServiceStatus (hService          : SC_HANDLE;
                              VAR ServiceStatus : SERVICE_STATUS) : BOOL;


PROCEDURE RegisterServiceCtrlHandlerA (ServiceName : ARRAY OF CHAR;
                                       lpHandlerProc : HANDLER_FUNCTION
          ) : SERVICE_STATUS_HANDLE;

PROCEDURE RegisterServiceCtrlHandlerW (lpServiceName : ARRAY OF WCHAR;
                                       lpHandlerProc : HANDLER_FUNCTION
          ) : SERVICE_STATUS_HANDLE;

<* IF DEFINED (UNICODE) THEN *>
      CONST RegisterServiceCtrlHandler = RegisterServiceCtrlHandlerW;
<* ELSE *>
      CONST RegisterServiceCtrlHandler = RegisterServiceCtrlHandlerA;
<* END *>


PROCEDURE SetServiceObjectSecurity (hService              : SC_HANDLE;
                                    dwSecurityInformation : SECURITY_INFORMATION;
                                    lpSecurityDescriptor  : PSECURITY_DESCRIPTOR) : BOOL;

PROCEDURE SetServiceStatus (hServiceStatus    : SERVICE_STATUS_HANDLE;
                            VAR ServiceStatus : SERVICE_STATUS
                                                               ) : BOOL;

PROCEDURE StartServiceCtrlDispatcherA (
                VAR ServiceStartTable : ARRAY OF SERVICE_TABLE_ENTRYA
          ) : BOOL;

PROCEDURE StartServiceCtrlDispatcherW (
                VAR ServiceStartTable : ARRAY OF SERVICE_TABLE_ENTRYW
          ) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST StartServiceCtrlDispatcher = StartServiceCtrlDispatcherW;
<* ELSE *>
      CONST StartServiceCtrlDispatcher = StartServiceCtrlDispatcherA;
<* END *>


PROCEDURE StartServiceA (hService              : SC_HANDLE;
                         dwNumServiceArgs      : DWORD;
                         VAR [NIL] ServiceArgVectors : ARRAY OF PCSTR) : BOOL;

PROCEDURE StartServiceW (hService              : SC_HANDLE;
                         dwNumServiceArgs      : DWORD;
                         VAR [NIL] ServiceArgVectors : ARRAY OF PCWSTR) : BOOL;


PROCEDURE UnlockServiceDatabase (ScLock : SC_LOCK) : BOOL;


(************************************************************************
*                                                                       *
*   MCX.def -- This module defines the 32-Bit Windows MCX APIs          *
*                                                                       *
************************************************************************)


(* Dial Options *)

TYPE DIALOPTION_ENUM = (DIALOPTION__0, DIALOPTION__1,
                        DIALOPTION__2, DIALOPTION__3,
                        DIALOPTION__4, DIALOPTION__5,
                        DIALOPTION__BILLING,           (* 6 - Supports wait for bong "$" *)
                        DIALOPTION__QUIET,             (* 7 - Supports wait for quiet "@" *)
                        DIALOPTION__DIALTONE);         (* 8 - Supports wait for dial tone "W" *)

     DIALOPTION_SET = SET OF DIALOPTION_ENUM;

CONST DIALOPTION_BILLING  = DIALOPTION_SET {DIALOPTION__BILLING }; (* 0x00000040 *)
      DIALOPTION_QUIET    = DIALOPTION_SET {DIALOPTION__QUIET   }; (* 0x00000080 *)
      DIALOPTION_DIALTONE = DIALOPTION_SET {DIALOPTION__DIALTONE}; (* 0x00000100 *)

(* SpeakerVolume for MODEMDEVCAPS *)

TYPE MDMVOLFLAG_ENUM = (MDMVOLFLAG__LOW,    (* 0 *)
                        MDMVOLFLAG__MEDIUM, (* 1 *)
                        MDMVOLFLAG__HIGH);  (* 2 *)

     MDMVOLFLAG_SET = SET OF MDMVOLFLAG_ENUM;

CONST MDMVOLFLAG_LOW      = MDMVOLFLAG_SET {MDMVOLFLAG__LOW   }; (* 0x00000001 *)
      MDMVOLFLAG_MEDIUM   = MDMVOLFLAG_SET {MDMVOLFLAG__MEDIUM}; (* 0x00000002 *)
      MDMVOLFLAG_HIGH     = MDMVOLFLAG_SET {MDMVOLFLAG__HIGH  }; (* 0x00000004 *)

(* SpeakerMode for MODEMDEVCAPS *)

TYPE MDMSPKRFLAG_ENUM = (MDMSPKRFLAG__OFF,        (* 0 *)
                         MDMSPKRFLAG__DIAL,       (* 1 *)
                         MDMSPKRFLAG__ON,         (* 2 *)
                         MDMSPKRFLAG__CALLSETUP); (* 3 *)

     MDMSPKRFLAG_SET = SET OF MDMSPKRFLAG_ENUM;

CONST MDMSPKRFLAG_OFF       = MDMSPKRFLAG_SET {MDMSPKRFLAG__OFF      }; (* 0x00000001 *)
      MDMSPKRFLAG_DIAL      = MDMSPKRFLAG_SET {MDMSPKRFLAG__DIAL     }; (* 0x00000002 *)
      MDMSPKRFLAG_ON        = MDMSPKRFLAG_SET {MDMSPKRFLAG__ON       }; (* 0x00000004 *)
      MDMSPKRFLAG_CALLSETUP = MDMSPKRFLAG_SET {MDMSPKRFLAG__CALLSETUP}; (* 0x00000008 *)

(* Modem Options *)

TYPE MDM_ENUM = (MDM__COMPRESSION,      (*  0 *)
                 MDM__ERROR_CONTROL,    (*  1 *)
                 MDM__FORCED_EC,        (*  2 *)
                 MDM__CELLULAR,         (*  3 *)
                 MDM__FLOWCONTROL_HARD, (*  4 *)
                 MDM__FLOWCONTROL_SOFT, (*  5 *)
                 MDM__CCITT_OVERRIDE,   (*  6 *)
                 MDM__SPEED_ADJUST,     (*  7 *)
                 MDM__TONE_DIAL,        (*  8 *)
                 MDM__BLIND_DIAL,       (*  9 *)
                 MDM__V23_OVERRIDE);    (* 10 *)

     MDM_SET = SET OF MDM_ENUM;

CONST MDM_COMPRESSION      = MDM_SET {MDM__COMPRESSION      }; (* 0x00000001 *)
      MDM_ERROR_CONTROL    = MDM_SET {MDM__ERROR_CONTROL    }; (* 0x00000002 *)
      MDM_FORCED_EC        = MDM_SET {MDM__FORCED_EC        }; (* 0x00000004 *)
      MDM_CELLULAR         = MDM_SET {MDM__CELLULAR         }; (* 0x00000008 *)
      MDM_FLOWCONTROL_HARD = MDM_SET {MDM__FLOWCONTROL_HARD }; (* 0x00000010 *)
      MDM_FLOWCONTROL_SOFT = MDM_SET {MDM__FLOWCONTROL_SOFT }; (* 0x00000020 *)
      MDM_CCITT_OVERRIDE   = MDM_SET {MDM__CCITT_OVERRIDE   }; (* 0x00000040 *)
      MDM_SPEED_ADJUST     = MDM_SET {MDM__SPEED_ADJUST     }; (* 0x00000080 *)
      MDM_TONE_DIAL        = MDM_SET {MDM__TONE_DIAL        }; (* 0x00000100 *)
      MDM_BLIND_DIAL       = MDM_SET {MDM__BLIND_DIAL       }; (* 0x00000200 *)
      MDM_V23_OVERRIDE     = MDM_SET {MDM__V23_OVERRIDE     }; (* 0x00000400 *)


TYPE MODEMDEVCAPS =
     RECORD
            dwActualSize              : DWORD;  (* size of returned data, in bytes *)
            dwRequiredSize            : DWORD;  (* total size of structure         *)
            dwDevSpecificOffset       : DWORD;  (* offset of provider-defined data *)
            dwDevSpecificSize         : DWORD;  (* size of provider-defined data   *)

           (* product and version identification *)

            dwModemProviderVersion    : DWORD;  (* provider version number *)
            dwModemManufacturerOffset : DWORD;  (* offset of manufacturer name *)
            dwModemManufacturerSize   : DWORD;  (* length of manufacturer name *)
            dwModemModelOffset        : DWORD;  (* offset of model name *)
            dwModemModelSize          : DWORD;  (* length of model name *)
            dwModemVersionOffset      : DWORD;  (* offset of version name *)
            dwModemVersionSize        : DWORD;  (* length of version name *)

           (* local option capabilities *)

            dwDialOptions             : DIALOPTION_SET;  (* bitmap of supported values *)
            dwCallSetupFailTimer      : DWORD;           (* maximum in seconds *)
            dwInactivityTimeout       : DWORD;           (* maximum in seconds *)
            dwSpeakerVolume           : MDMVOLFLAG_SET;  (* bitmap of supported values *)
            dwSpeakerMode             : MDMSPKRFLAG_SET; (* bitmap of supported values *)
            dwModemOptions            : MDM_SET;         (* bitmap of supported values *)
            dwMaxDTERate              : DWORD;           (* maximum value in bit/s *)
            dwMaxDCERate              : DWORD;           (* maximum value in bit/s *)

           (* Variable portion for proprietary expansion *)

            abVariablePortion : ARRAY [0..0] OF BYTE;
     END;
     PMODEMDEVCAPS = POINTER TO MODEMDEVCAPS;

(* SpeakerMode for MODEMSETTINGS *)

TYPE MDMSPKR_ENUM = (MDMSPKR_OFF,        (* 0 *)
                     MDMSPKR_DIAL,       (* 1 *)
                     MDMSPKR_ON,         (* 2 *)
                     MDMSPKR_CALLSETUP); (* 3 *)

(* SpeakerVolume for MODEMSETTINGS *)

TYPE MDMVOL_ENUM = (MDMVOL_LOW,    (* 0 *)
                    MDMVOL_MEDIUM, (* 1 *)
                    MDMVOL_HIGH);  (* 2 *)


TYPE MODEMSETTINGS =
     RECORD
            dwActualSize             : DWORD;         (* size of returned data, in bytes *)
            dwRequiredSize           : DWORD;         (* total size of structure *)
            dwDevSpecificOffset      : DWORD;         (* offset of provider-defined data *)
            dwDevSpecificSize        : DWORD;         (* size of provider-defined data *)

      (* Static local options (read/write) *)

            dwCallSetupFailTimer     : DWORD;         (* call setup timeout, in seconds *)
            dwInactivityTimeout      : DWORD;         (* inactivity timeout, in tenths of seconds *)
            dwSpeakerVolume          : MDMVOL_ENUM;   (* speaker volume level *)
            dwSpeakerMode            : MDMSPKR_ENUM;  (* speaker mode *)
            dwPreferredModemOptions  : MDM_SET;       (* bitmap specifying preferred options *)

      (* negotiated options (read only) for current or last call *)

            dwNegotiatedModemOptions : MDM_SET;      (* bitmap specifying actual options *)
            dwNegotiatedDCERate      : DWORD;        (* DCE rate, in bits per second *)

      (* Variable portion for proprietary expansion *)

            abVariablePortion        : ARRAY [0..0] OF BYTE; (* variable-length data *)

     END;
     PMODEMSETTINGS = POINTER TO MODEMSETTINGS;



(**********************************************************************)
(*                                                                    *)
(*      IMM.def - Input Method Manager definitions                    *)
(*                                                                    *)
(**********************************************************************)


TYPE HIMC  = DWORD;
     HIMCC = DWORD;

     PHKL = POINTER TO HKL;

(* bit field for IMC_SETCOMPOSITIONWINDOW, IMC_SETCANDIDATEWINDOW *)

TYPE CFS_ENUM = (CFS__RECT,            (* 0 *)
                 CFS__POINT,           (* 1 *)
                 CFS__SCREEN,          (* 2 *)
                 CFS__3, CFS__4,
                 CFS__FORCE_POSITION,  (* 5 *)
                 CFS__CANDIDATEPOS,    (* 6 *)
                 CFS__EXCLUDE);        (* 7 *)

TYPE CFS_SET = SET OF CFS_ENUM;

CONST CFS_DEFAULT        = CFS_SET {};                    (* 0000h *)
      CFS_RECT           = CFS_SET {CFS__RECT};           (* 0001h *)
      CFS_POINT          = CFS_SET {CFS__POINT};          (* 0002h *)
      CFS_SCREEN         = CFS_SET {CFS__SCREEN};         (* 0004h *)
      CFS_FORCE_POSITION = CFS_SET {CFS__FORCE_POSITION}; (* 0020h *)
      CFS_CANDIDATEPOS   = CFS_SET {CFS__CANDIDATEPOS};   (* 0040h *)
      CFS_EXCLUDE        = CFS_SET {CFS__EXCLUDE};        (* 0080h *)

TYPE COMPOSITIONFORM = RECORD
                              dwStyle      : CFS_SET;
                              ptCurrentPos : POINT;
                              rcArea       : RECT;
                       END;
    PCOMPOSITIONFORM = POINTER TO COMPOSITIONFORM;

TYPE CANDIDATEFORM = RECORD
                            dwIndex      : DWORD;
                            dwStyle      : CFS_SET;
                            ptCurrentPos : POINT;
                            rcArea       : RECT;
                     END;
    PCANDIDATEFORM = POINTER TO CANDIDATEFORM;

(* style of candidate *)

TYPE IME_CAND_ENUM = (IME_CAND_UNKNOWN,  (* 0000h *)
                      IME_CAND_READ,     (* 0001h *)
                      IME_CAND_CODE,     (* 0002h *)
                      IME_CAND_MEANING,  (* 0003h *)
                      IME_CAND_RADICAL,  (* 0004h *)
                      IME_CAND_STROKE);  (* 0005h *)

TYPE CANDIDATELIST = RECORD
                            dwSize      : DWORD;
                            dwStyle     : IME_CAND_ENUM;
                            dwCount     : DWORD;
                            dwSelection : DWORD;
                            dwPageStart : DWORD;
                            dwPageSize  : DWORD;
                            dwOffset    : ARRAY [0..0] OF DWORD;
                     END;
    PCANDIDATELIST = POINTER TO CANDIDATELIST;

TYPE REGISTERWORDA = RECORD
                            lpReading : PSTR;
                            lpWord    : PSTR;
                     END;
    PREGISTERWORDA = POINTER TO REGISTERWORDA;

TYPE REGISTERWORDW = RECORD
                            lpReading : PWSTR;
                            lpWord    : PWSTR;
                     END;
    PREGISTERWORDW = POINTER TO REGISTERWORDW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  REGISTERWORD =  REGISTERWORDW;
      TYPE PREGISTERWORD = PREGISTERWORDW;
<* ELSE *>
      TYPE  REGISTERWORD =  REGISTERWORDA;
      TYPE PREGISTERWORD = PREGISTERWORDA;
<* END *>

(* style of word registration *)

TYPE IME_REGWORD_STYLE_TYPE = DWORD;

CONST IME_REGWORD_STYLE_EUDC          = VAL (IME_REGWORD_STYLE_TYPE, 00000001h);
      IME_REGWORD_STYLE_USER_FIRST    = VAL (IME_REGWORD_STYLE_TYPE, 80000000h);
      IME_REGWORD_STYLE_USER_LAST     = VAL (IME_REGWORD_STYLE_TYPE, 0FFFFFFFFh);

CONST STYLE_DESCRIPTION_SIZE = 32;

TYPE STYLEBUFA = RECORD
                        dwStyle       : IME_REGWORD_STYLE_TYPE;
                        szDescription : ARRAY [0..STYLE_DESCRIPTION_SIZE-1] OF CHAR;
                 END;
    PSTYLEBUFA = POINTER TO STYLEBUFA;

TYPE STYLEBUFW = RECORD
                        dwStyle       : IME_REGWORD_STYLE_TYPE;
                        szDescription : ARRAY [0..STYLE_DESCRIPTION_SIZE-1] OF WCHAR;
                 END;
    PSTYLEBUFW = POINTER TO STYLEBUFW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE  STYLEBUF =  STYLEBUFW;
      TYPE PSTYLEBUF = PSTYLEBUFW;
<* ELSE *>
      TYPE  STYLEBUF =  STYLEBUFA;
      TYPE PSTYLEBUF = PSTYLEBUFA;
<* END *>

(* prototype of IMM API *)

PROCEDURE ImmInstallIMEA (IMEFileName : ARRAY OF CHAR;  lpszLayoutText : ARRAY OF CHAR)  : HKL;
PROCEDURE ImmInstallIMEW (IMEFileName : ARRAY OF WCHAR; lpszLayoutText : ARRAY OF WCHAR) : HKL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ImmInstallIME = ImmInstallIMEW;
<* ELSE *>
      CONST ImmInstallIME = ImmInstallIMEA;
<* END *>

PROCEDURE ImmGetDefaultIMEWnd (hwnd : HWND) : HWND;

PROCEDURE ImmGetDescriptionA (hkl : HKL; VAR descr : ARRAY OF CHAR;  uBufLen : UINT) : UINT;
PROCEDURE ImmGetDescriptionW (hkl : HKL; VAR descr : ARRAY OF WCHAR; uBufLen : UINT) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST ImmGetDescription = ImmGetDescriptionW;
<* ELSE *>
      CONST ImmGetDescription = ImmGetDescriptionA;
<* END *>

PROCEDURE ImmGetIMEFileNameA (hkl : HKL; VAR name : ARRAY OF CHAR;  uBufLen : UINT) : UINT;
PROCEDURE ImmGetIMEFileNameW (hkl : HKL; VAR name : ARRAY OF WCHAR; uBufLen : UINT) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST ImmGetIMEFileName = ImmGetIMEFileNameW;
<* ELSE *>
      CONST ImmGetIMEFileName = ImmGetIMEFileNameA;
<* END *>

(* ID for dwIndex of ImmGetProperty *)

TYPE IGP_TYPE = LONG;

CONST IGP_GETIMEVERSION               = VAL (IGP_TYPE, -4);
      IGP_PROPERTY                    = VAL (IGP_TYPE, 00000004h);
      IGP_CONVERSION                  = VAL (IGP_TYPE, 00000008h);
      IGP_SENTENCE                    = VAL (IGP_TYPE, 0000000ch);
      IGP_UI                          = VAL (IGP_TYPE, 00000010h);
      IGP_SETCOMPSTR                  = VAL (IGP_TYPE, 00000014h);
      IGP_SELECT                      = VAL (IGP_TYPE, 00000018h);

PROCEDURE ImmGetProperty (hkl : HKL; index : IGP_TYPE) : DWORD;

PROCEDURE ImmIsIME (hkl : HKL) : BOOL;

PROCEDURE ImmSimulateHotKey (hwnd : HWND; HotKeyId : DWORD) : BOOL;

PROCEDURE ImmCreateContext    () : HIMC;
PROCEDURE ImmDestroyContext   (himc : HIMC) : BOOL;
PROCEDURE ImmGetContext       (hwnd : HWND) : HIMC;
PROCEDURE ImmReleaseContext   (hwnd : HWND; himc : HIMC) : BOOL;
PROCEDURE ImmAssociateContext (hwnd : HWND; himc : HIMC) : HIMC;

(* parameter of ImmGetCompositionString *)

TYPE GCS_TYPE = DWORD;

CONST GCS_COMPREADSTR                 = VAL (GCS_TYPE, 0001h);
      GCS_COMPREADATTR                = VAL (GCS_TYPE, 0002h);
      GCS_COMPREADCLAUSE              = VAL (GCS_TYPE, 0004h);
      GCS_COMPSTR                     = VAL (GCS_TYPE, 0008h);
      GCS_COMPATTR                    = VAL (GCS_TYPE, 0010h);
      GCS_COMPCLAUSE                  = VAL (GCS_TYPE, 0020h);
      GCS_CURSORPOS                   = VAL (GCS_TYPE, 0080h);
      GCS_DELTASTART                  = VAL (GCS_TYPE, 0100h);
      GCS_RESULTREADSTR               = VAL (GCS_TYPE, 0200h);
      GCS_RESULTREADCLAUSE            = VAL (GCS_TYPE, 0400h);
      GCS_RESULTSTR                   = VAL (GCS_TYPE, 0800h);
      GCS_RESULTCLAUSE                = VAL (GCS_TYPE, 1000h);


PROCEDURE ImmGetCompositionStringA (himc : HIMC; index : GCS_TYPE; buf : PVOID; buflen : DWORD) : LONG;
PROCEDURE ImmGetCompositionStringW (himc : HIMC; index : GCS_TYPE; buf : PVOID; buflen : DWORD) : LONG;

<* IF DEFINED (UNICODE) THEN *>
      CONST ImmGetCompositionString = ImmGetCompositionStringW;
<* ELSE *>
      CONST ImmGetCompositionString = ImmGetCompositionStringA;
<* END *>

(* dwIndex for ImmSetCompositionString API *)

CONST SCS_SETSTR                       = GCS_COMPREADSTR    + GCS_COMPSTR;
      SCS_CHANGEATTR                   = GCS_COMPREADATTR   + GCS_COMPATTR;
      SCS_CHANGECLAUSE                 = GCS_COMPREADCLAUSE + GCS_COMPCLAUSE;

PROCEDURE ImmSetCompositionStringA (himc : HIMC; Index : GCS_TYPE; Comp : LPCVOID;
                                    CompLen : DWORD; Read : LPCVOID; ReadLen : DWORD) : BOOL;
PROCEDURE ImmSetCompositionStringW (himc : HIMC; Index : GCS_TYPE; Comp : LPCVOID;
                                    CompLen : DWORD; Read : LPCVOID; ReadLen : DWORD) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ImmSetCompositionString = ImmSetCompositionStringW;
<* ELSE *>
      CONST ImmSetCompositionString = ImmSetCompositionStringA;
<* END *>

PROCEDURE ImmGetCandidateListCountA (himc : HIMC; VAR ListCount : DWORD) : DWORD;
PROCEDURE ImmGetCandidateListCountW (himc : HIMC; VAR ListCount : DWORD) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST ImmGetCandidateListCount = ImmGetCandidateListCountW;
<* ELSE *>
      CONST ImmGetCandidateListCount = ImmGetCandidateListCountA;
<* END *>

PROCEDURE ImmGetCandidateListA (himc : HIMC; Index : DWORD; VAR List : CANDIDATELIST; BufLen : DWORD) : DWORD;
PROCEDURE ImmGetCandidateListW (himc : HIMC; Index : DWORD; VAR List : CANDIDATELIST; BufLen : DWORD) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST ImmGetCandidateList = ImmGetCandidateListW;
<* ELSE *>
      CONST ImmGetCandidateList = ImmGetCandidateListA;
<* END *>

(* ID for deIndex of ImmGetGuideLine *)

TYPE GGL_ENUM = (GGL_0,
                 GGL_LEVEL,     (* 00000001h *)
                 GGL_INDEX,     (* 00000002h *)
                 GGL_STRING,    (* 00000003h *)
                 GGL_PRIVATE);  (* 00000004h *)

PROCEDURE ImmGetGuideLineA (himc : HIMC;
                            dwIndex : GGL_ENUM;
                            VAR [NIL] Buf : ARRAY OF CHAR;
                            BufLen : DWORD) : DWORD;
PROCEDURE ImmGetGuideLineW (himc : HIMC;
                            dwIndex : GGL_ENUM;
                            VAR [NIL] Buf : ARRAY OF WCHAR;
                            BufLen : DWORD) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST ImmGetGuideLine = ImmGetGuideLineW;
<* ELSE *>
      CONST ImmGetGuideLine = ImmGetGuideLineA;
<* END *>

(* bit field for conversion mode *)

TYPE IME_CMODE_ENUM = (IME_CMODE__NATIVE,       (* 0 *)
                       IME_CMODE__KATAKANA,     (* 1 *)
                       IME_CMODE__FULLSHAPE,    (* 3 *)
                       IME_CMODE__ROMAN,        (* 4 *)
                       IME_CMODE__CHARCODE,     (* 5 *)
                       IME_CMODE__HANJACONVERT, (* 6 *)
                       IME_CMODE__SOFTKBD,      (* 7 *)
                       IME_CMODE__NOCONVERSION, (* 8 *)
                       IME_CMODE__EUDC,         (* 9 *)
                       IME_CMODE__SYMBOL);      (* 10 *)

TYPE IME_CMODE_SET = SET OF IME_CMODE_ENUM;

CONST IME_CMODE_ALPHANUMERIC = IME_CMODE_SET {};                         (* 0000h *)
      IME_CMODE_NATIVE       = IME_CMODE_SET {IME_CMODE__NATIVE};        (* 0001h *)
      IME_CMODE_CHINESE      = IME_CMODE_NATIVE;
      IME_CMODE_HANGEUL      = IME_CMODE_NATIVE;
      IME_CMODE_JAPANESE     = IME_CMODE_NATIVE;
      IME_CMODE_KATAKANA     = IME_CMODE_SET {IME_CMODE__KATAKANA};       (* 0002h only effect under IME_CMODE_NATIVE *)
      IME_CMODE_LANGUAGE     = IME_CMODE_NATIVE + IME_CMODE_KATAKANA;    (* 0003h *)
      IME_CMODE_FULLSHAPE    = IME_CMODE_SET {IME_CMODE__FULLSHAPE};     (* 0008h *)
      IME_CMODE_ROMAN        = IME_CMODE_SET {IME_CMODE__ROMAN};         (* 0010h *)
      IME_CMODE_CHARCODE     = IME_CMODE_SET {IME_CMODE__CHARCODE};      (* 0020h *)
      IME_CMODE_HANJACONVERT = IME_CMODE_SET {IME_CMODE__HANJACONVERT};  (* 0040h *)
      IME_CMODE_SOFTKBD      = IME_CMODE_SET {IME_CMODE__SOFTKBD};       (* 0080h *)
      IME_CMODE_NOCONVERSION = IME_CMODE_SET {IME_CMODE__NOCONVERSION};  (* 0100h *)
      IME_CMODE_EUDC         = IME_CMODE_SET {IME_CMODE__EUDC};          (* 0200h *)
      IME_CMODE_SYMBOL       = IME_CMODE_SET {IME_CMODE__SYMBOL};        (* 0400h *)

(* bit field for sentnence mode *)

TYPE IME_SMODE_ENUM = (IME_SMODE__PLAURALCLAUSE,  (* 0 *)
                       IME_SMODE__SINGLECONVERT,  (* 1 *)
                       IME_SMODE__AUTOMATIC,      (* 2 *)
                       IME_SMODE__PHRASEPREDICT); (* 3 *)

     IME_SMODE_SET = SET OF IME_SMODE_ENUM;

CONST IME_SMODE_PLAURALCLAUSE = IME_SMODE_SET {IME_SMODE__PLAURALCLAUSE}; (* 0001h *)
      IME_SMODE_SINGLECONVERT = IME_SMODE_SET {IME_SMODE__SINGLECONVERT}; (* 0002h *)
      IME_SMODE_AUTOMATIC     = IME_SMODE_SET {IME_SMODE__AUTOMATIC};     (* 0004h *)
      IME_SMODE_PHRASEPREDICT = IME_SMODE_SET {IME_SMODE__PHRASEPREDICT}; (* 0008h *)

PROCEDURE ImmGetConversionStatus (himc : HIMC;
                                  VAR ConVersion : IME_CMODE_SET;
                                  VAR Sentence : IME_SMODE_SET) : BOOL;

PROCEDURE ImmSetConversionStatus (himc : HIMC;
                                  ConVersion : IME_CMODE_SET;
                                  Sentence : IME_SMODE_SET) : BOOL;

PROCEDURE ImmGetOpenStatus (himc : HIMC) : BOOL;
PROCEDURE ImmSetOpenStatus (himc : HIMC; Open : BOOL) : BOOL;

PROCEDURE ImmGetCompositionFontA (himc : HIMC; VAR font : LOGFONTA) : BOOL;
PROCEDURE ImmGetCompositionFontW (himc : HIMC; VAR font : LOGFONTW) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ImmGetCompositionFont = ImmGetCompositionFontW;
<* ELSE *>
      CONST ImmGetCompositionFont = ImmGetCompositionFontA;
<* END *>


<* IF BACKEND # "C" THEN *>
PROCEDURE ImmSetCompositionFontA (himc : HIMC; font : LOGFONTA (*!*)) : BOOL;
<* ELSE *>
PROCEDURE ImmSetCompositionFontA (himc : HIMC; font : PLOGFONTA (*!*)) : BOOL;
<* END *>
<* IF BACKEND # "C" THEN *>
PROCEDURE ImmSetCompositionFontW (himc : HIMC; font : LOGFONTW (*!*)) : BOOL;
<* ELSE *>
PROCEDURE ImmSetCompositionFontW (himc : HIMC; font : PLOGFONTW (*!*)) : BOOL;
<* END *>

<* IF DEFINED (UNICODE) THEN *>
      CONST ImmSetCompositionFont = ImmSetCompositionFontW;
<* ELSE *>
      CONST ImmSetCompositionFont = ImmSetCompositionFontA;
<* END *>

(* dialog mode of ImmConfigureIME *)

TYPE IME_CONFIG_ENUM = (IME_CONFIG_0,
                        IME_CONFIG_GENERAL,           (* 1 *)
                        IME_CONFIG_REGISTERWORD,      (* 2 *)
                        IME_CONFIG_SELECTDICTIONARY); (* 3 *)

PROCEDURE ImmConfigureIMEA (hkl : HKL; hwnd : HWND; mode : IME_CONFIG_ENUM; pdata : PVOID) : BOOL;
PROCEDURE ImmConfigureIMEW (hkl : HKL; hwnd : HWND; mode : IME_CONFIG_ENUM; pdata : PVOID) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ImmConfigureIME = ImmConfigureIMEW;
<* ELSE *>
      CONST ImmConfigureIME = ImmConfigureIMEA;
<* END *>

(* dialog mode of ImmEscape *)

TYPE IME_ESC_TYPE = UINT;

CONST IME_ESC_QUERY_SUPPORT           = VAL (IME_ESC_TYPE, 0003h);
      IME_ESC_RESERVED_FIRST          = VAL (IME_ESC_TYPE, 0004h);
      IME_ESC_RESERVED_LAST           = VAL (IME_ESC_TYPE, 07FFh);
      IME_ESC_PRIVATE_FIRST           = VAL (IME_ESC_TYPE, 0800h);
      IME_ESC_PRIVATE_LAST            = VAL (IME_ESC_TYPE, 0FFFh);
      IME_ESC_SEQUENCE_TO_INTERNAL    = VAL (IME_ESC_TYPE, 1001h);
      IME_ESC_GET_EUDC_DICTIONARY     = VAL (IME_ESC_TYPE, 1003h);
      IME_ESC_SET_EUDC_DICTIONARY     = VAL (IME_ESC_TYPE, 1004h);
      IME_ESC_MAX_KEY                 = VAL (IME_ESC_TYPE, 1005h);
      IME_ESC_IME_NAME                = VAL (IME_ESC_TYPE, 1006h);
      IME_ESC_SYNC_HOTKEY             = VAL (IME_ESC_TYPE, 1007h);
      IME_ESC_HANJA_MODE              = VAL (IME_ESC_TYPE, 1008h);
      IME_ESC_AUTOMATA                = VAL (IME_ESC_TYPE, 1009h);
      IME_ESC_PRIVATE_HOTKEY          = VAL (IME_ESC_TYPE, 100Ah);

PROCEDURE ImmEscapeA (hkl : HKL; himc : HIMC; escape : IME_ESC_TYPE; data : PVOID) : LRESULT;
PROCEDURE ImmEscapeW (hkl : HKL; himc : HIMC; escape : IME_ESC_TYPE; data : PVOID) : LRESULT;

<* IF DEFINED (UNICODE) THEN *>
      CONST ImmEscape = ImmEscapeW;
<* ELSE *>
      CONST ImmEscape = ImmEscapeA;
<* END *>

(* conversion direction for ImmGetConversionList *)

TYPE GCL_ENUM = (GCL_0,
                 GCL_CONVERSION,        (* 1 *)
                 GCL_REVERSECONVERSION, (* 2 *)
                 GCL_REVERSE_LENGTH);   (* 3 *)

PROCEDURE ImmGetConversionListA (hkl : HKL; himc : HIMC; src : ARRAY OF CHAR;
                                 VAR [NIL] dest : CANDIDATELIST; BufLen : DWORD;
                                 uFlag : GCL_ENUM) : DWORD;

PROCEDURE ImmGetConversionListW (hkl : HKL; himc : HIMC; src : ARRAY OF WCHAR;
                                 VAR [NIL] dest : CANDIDATELIST; BufLen : DWORD;
                                 uFlag : GCL_ENUM) : DWORD;

<* IF DEFINED (UNICODE) THEN *>
      CONST ImmGetConversionList = ImmGetConversionListW;
<* ELSE *>
      CONST ImmGetConversionList = ImmGetConversionListA;
<* END *>

(* wParam for WM_IME_CONTROL to the soft keyboard *)
(* dwAction for ImmNotifyIME *)

TYPE NI_TYPE = DWORD;

CONST NI_OPENCANDIDATE                = VAL (NI_TYPE, 0010h);
      NI_CLOSECANDIDATE               = VAL (NI_TYPE, 0011h);
      NI_SELECTCANDIDATESTR           = VAL (NI_TYPE, 0012h);
      NI_CHANGECANDIDATELIST          = VAL (NI_TYPE, 0013h);
      NI_FINALIZECONVERSIONRESULT     = VAL (NI_TYPE, 0014h);
      NI_COMPOSITIONSTR               = VAL (NI_TYPE, 0015h);
      NI_SETCANDIDATE_PAGESTART       = VAL (NI_TYPE, 0016h);
      NI_SETCANDIDATE_PAGESIZE        = VAL (NI_TYPE, 0017h);

(* dwIndex for ImmNotifyIME/NI_COMPOSITIONSTR *)

CONST CPS_COMPLETE                    = 0001h;
      CPS_CONVERT                     = 0002h;
      CPS_REVERT                      = 0003h;
      CPS_CANCEL                      = 0004h;

PROCEDURE ImmNotifyIME (himc : HIMC; Action : NI_TYPE; Index : DWORD; Value : DWORD) : BOOL;

PROCEDURE ImmGetStatusWindowPos (himc : HIMC; VAR pt : POINT) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE ImmSetStatusWindowPos (himc : HIMC; pt : POINT (*!*)) : BOOL;
<* ELSE *>
PROCEDURE ImmSetStatusWindowPos (himc : HIMC; pt : PPOINT (*!*)) : BOOL;
<* END *>
PROCEDURE ImmGetCompositionWindow (himc : HIMC; VAR CompForm : COMPOSITIONFORM) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE ImmSetCompositionWindow (himc : HIMC;     CompForm : COMPOSITIONFORM (*!*)) : BOOL;
<* ELSE *>
PROCEDURE ImmSetCompositionWindow (himc : HIMC;     CompForm : PCOMPOSITIONFORM (*!*)) : BOOL;
<* END *>
PROCEDURE ImmGetCandidateWindow (himc : HIMC; BufLen : DWORD; VAR Candidate : CANDIDATEFORM) : BOOL;
<* IF BACKEND # "C" THEN *>
PROCEDURE ImmSetCandidateWindow (himc : HIMC; Candidate : CANDIDATEFORM (*!*)) : BOOL;
<* ELSE *>
PROCEDURE ImmSetCandidateWindow (himc : HIMC; Candidate : PCANDIDATEFORM (*!*)) : BOOL;
<* END *>

PROCEDURE ImmIsUIMessageA (hwnd : HWND; msg : UINT; wparam : WPARAM; lparam : LPARAM) : BOOL;
PROCEDURE ImmIsUIMessageW (hwnd : HWND; msg : UINT; wparam : WPARAM; lparam : LPARAM) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ImmIsUIMessage = ImmIsUIMessageW;
<* ELSE *>
      CONST ImmIsUIMessage = ImmIsUIMessageA;
<* END *>

PROCEDURE ImmGetVirtualKey (hwnd : HWND) : UINT;

TYPE REGISTERWORDENUMPROCA = PROCEDURE (ARRAY OF CHAR,  DWORD, ARRAY OF CHAR,  PVOID) : INTEGER;
TYPE REGISTERWORDENUMPROCW = PROCEDURE (ARRAY OF WCHAR, DWORD, ARRAY OF WCHAR, PVOID) : INTEGER;

<* IF DEFINED (UNICODE) THEN *>
      TYPE REGISTERWORDENUMPROC = REGISTERWORDENUMPROCW;
<* ELSE *>
      TYPE REGISTERWORDENUMPROC = REGISTERWORDENUMPROCA;
<* END *>

PROCEDURE ImmRegisterWordA (hkl : HKL; Reading : ARRAY OF CHAR;
                            Style : IME_REGWORD_STYLE_TYPE;
                            Register : ARRAY OF CHAR) : BOOL;
PROCEDURE ImmRegisterWordW (hkl : HKL; Reading : ARRAY OF WCHAR;
                            Style : IME_REGWORD_STYLE_TYPE;
                            Register : ARRAY OF WCHAR): BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ImmRegisterWord = ImmRegisterWordW;
<* ELSE *>
      CONST ImmRegisterWord = ImmRegisterWordA;
<* END *>

PROCEDURE ImmUnregisterWordA (hkl : HKL; Reading : ARRAY OF CHAR;
                              Style : IME_REGWORD_STYLE_TYPE;
                              Unregister : ARRAY OF CHAR) : BOOL;
PROCEDURE ImmUnregisterWordW (hkl : HKL; Reading : ARRAY OF WCHAR;
                              Style : IME_REGWORD_STYLE_TYPE;
                              Unregister : ARRAY OF WCHAR) : BOOL;

<* IF DEFINED (UNICODE) THEN *>
      CONST ImmUnregisterWord = ImmUnregisterWordW;
<* ELSE *>
      CONST ImmUnregisterWord = ImmUnregisterWordA;
<* END *>

PROCEDURE ImmGetRegisterWordStyleA (hkl : HKL; nItem : UINT; VAR StyleBuf : STYLEBUFA) : UINT;
PROCEDURE ImmGetRegisterWordStyleW (hkl : HKL; nItem : UINT; VAR StyleBuf : STYLEBUFW) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST ImmGetRegisterWordStyle = ImmGetRegisterWordStyleW;
<* ELSE *>
      CONST ImmGetRegisterWordStyle = ImmGetRegisterWordStyleA;
<* END *>

PROCEDURE ImmEnumRegisterWordA (hkl : HKL;
                                EnumProc : REGISTERWORDENUMPROCA;
                                Reading : PCSTR; (* NIL *)
                                Style : IME_REGWORD_STYLE_TYPE;
                                Register : PCSTR; (* NIL *)
                                pData : PVOID) : UINT;

PROCEDURE ImmEnumRegisterWorWA (hkl : HKL;
                                EnumProc : REGISTERWORDENUMPROCW;
                                Reading  : PCWSTR; (* NIL *)
                                Style : IME_REGWORD_STYLE_TYPE;
                                Register : PCWSTR; (* NIL *)
                                pData : PVOID) : UINT;

<* IF DEFINED (UNICODE) THEN *>
      CONST ImmEnumRegisterWord = ImmEnumRegisterWordW;
<* ELSE *>
      CONST ImmEnumRegisterWord = ImmEnumRegisterWordA;
<* END *>

(* wParam for WM_IME_CONTROL *)

CONST IMC_GETCANDIDATEPOS      = 0007h;
      IMC_SETCANDIDATEPOS      = 0008h;
      IMC_GETCOMPOSITIONFONT   = 0009h;
      IMC_SETCOMPOSITIONFONT   = 000Ah;
      IMC_GETCOMPOSITIONWINDOW = 000Bh;
      IMC_SETCOMPOSITIONWINDOW = 000Ch;
      IMC_GETSTATUSWINDOWPOS   = 000Fh;
      IMC_SETSTATUSWINDOWPOS   = 0010h;
      IMC_CLOSESTATUSWINDOW    = 0021h;
      IMC_OPENSTATUSWINDOW     = 0022h;


(* lParam for WM_IME_SETCONTEXT *)

CONST ISC_SHOWUICANDIDATEWINDOW       = 00000001h;
      ISC_SHOWUICOMPOSITIONWINDOW     = 80000000h;
      ISC_SHOWUIGUIDELINE             = 40000000h;
      ISC_SHOWUIALLCANDIDATEWINDOW    = 0000000Fh;
      ISC_SHOWUIALL                   = 0C000000Fh;

(* the modifiers of hot key were here but moved to WinUser.def *)

(* Windows for Simplified Chinese Edition hot key ID from 0x10 - 0x2F *)

CONST IME_CHOTKEY_IME_NONIME_TOGGLE           = 10h;
      IME_CHOTKEY_SHAPE_TOGGLE                = 11h;
      IME_CHOTKEY_SYMBOL_TOGGLE               = 12h;

(* Windows for Japanese Edition hot key ID from 0x30 - 0x4F *)

CONST IME_JHOTKEY_CLOSE_OPEN                  = 30h;

(* Windows for Korean Edition hot key ID from 0x50 - 0x6F *)

CONST IME_KHOTKEY_SHAPE_TOGGLE                = 50h;
      IME_KHOTKEY_HANJACONVERT                = 51h;
      IME_KHOTKEY_ENGLISH                     = 52h;

(* Windows for Tranditional Chinese Edition hot key ID from 0x70 - 0x8F *)

CONST IME_THOTKEY_IME_NONIME_TOGGLE           = 70;
      IME_THOTKEY_SHAPE_TOGGLE                = 71h;
      IME_THOTKEY_SYMBOL_TOGGLE               = 72h;

(* direct switch hot key ID from 0x100 - 0x11F *)

CONST IME_HOTKEY_DSWITCH_FIRST                = 100h;
      IME_HOTKEY_DSWITCH_LAST                 = 11Fh;

(* IME private hot key from 0x200 - 0x21F *)

CONST IME_HOTKEY_PRIVATE_FIRST                = 200h;
      IME_ITHOTKEY_RESEND_RESULTSTR           = 200h;
      IME_ITHOTKEY_PREVIOUS_COMPOSITION       = 201h;
      IME_ITHOTKEY_UISTYLE_TOGGLE             = 202h;
      IME_HOTKEY_PRIVATE_LAST                 = 21Fh;

(* style bit flags for WM_IME_COMPOSITION *)

CONST CS_INSERTCHAR                   = 2000h;
      CS_NOMOVECARET                  = 4000h;

(* bits of fdwInit of INPUTCONTEXT *)
(* IME version constants *)

CONST IMEVER_0310                     = 0003000Ah;
      IMEVER_0400                     = 00040000h;

(* IME property bits *)

CONST IME_PROP_AT_CARET               = 00010000h;
      IME_PROP_SPECIAL_UI             = 00020000h;
      IME_PROP_CANDLIST_START_FROM_1  = 00040000h;
      IME_PROP_UNICODE                = 00080000h;

(* IME UICapability bits *)

CONST UI_CAP_2700                     = 00000001h;
      UI_CAP_ROT90                    = 00000002h;
      UI_CAP_ROTANY                   = 00000004h;

(* ImmSetCompositionString Capability bits *)

CONST SCS_CAP_COMPSTR                 = 00000001h;
      SCS_CAP_MAKEREAD                = 00000002h;

(* IME WM_IME_SELECT inheritance Capability bits *)
CONST SELECT_CAP_CONVERSION           = 00000001h;
      SELECT_CAP_SENTENCE             = 00000002h;

(* ID for dwLevel of GUIDELINE Structure *)

CONST GL_LEVEL_NOGUIDELINE            = 00000000h;
      GL_LEVEL_FATAL                  = 00000001h;
      GL_LEVEL_ERROR                  = 00000002h;
      GL_LEVEL_WARNING                = 00000003h;
      GL_LEVEL_INFORMATION            = 00000004h;

(* ID for dwIndex of GUIDELINE Structure *)

CONST GL_ID_UNKNOWN                   = 00000000h;
      GL_ID_NOMODULE                  = 00000001h;
      GL_ID_NODICTIONARY              = 00000010h;
      GL_ID_CANNOTSAVE                = 00000011h;
      GL_ID_NOCONVERT                 = 00000020h;
      GL_ID_TYPINGERROR               = 00000021h;
      GL_ID_TOOMANYSTROKE             = 00000022h;
      GL_ID_READINGCONFLICT           = 00000023h;
      GL_ID_INPUTREADING              = 00000024h;
      GL_ID_INPUTRADICAL              = 00000025h;
      GL_ID_INPUTCODE                 = 00000026h;
      GL_ID_INPUTSYMBOL               = 00000027h;
      GL_ID_CHOOSECANDIDATE           = 00000028h;
      GL_ID_REVERSECONVERSION         = 00000029h;
      GL_ID_PRIVATE_FIRST             = 00008000h;
      GL_ID_PRIVATE_LAST              = 0000FFFFh;

(* attribute for COMPOSITIONSTRING Structure *)

CONST ATTR_INPUT                      = 00h;
      ATTR_TARGET_CONVERTED           = 01h;
      ATTR_CONVERTED                  = 02h;
      ATTR_TARGET_NOTCONVERTED        = 03h;
      ATTR_INPUT_ERROR                = 04h;

(* wParam of report message WM_IME_NOTIFY *)

CONST IMN_CLOSESTATUSWINDOW    = 0001h;
      IMN_OPENSTATUSWINDOW     = 0002h;
      IMN_CHANGECANDIDATE      = 0003h;
      IMN_CLOSECANDIDATE       = 0004h;
      IMN_OPENCANDIDATE        = 0005h;
      IMN_SETCONVERSIONMODE    = 0006h;
      IMN_SETSENTENCEMODE      = 0007h;
      IMN_SETOPENSTATUS        = 0008h;
      IMN_SETCANDIDATEPOS      = 0009h;
      IMN_SETCOMPOSITIONFONT   = 000Ah;
      IMN_SETCOMPOSITIONWINDOW = 000Bh;
      IMN_SETSTATUSWINDOWPOS   = 000Ch;
      IMN_GUIDELINE            = 000Dh;
      IMN_PRIVATE              = 000Eh;

(* error code of ImmGetCompositionString *)

CONST IMM_ERROR_NODATA                = SYSTEM.CAST (DWORD, VAL (LONG, -1));
      IMM_ERROR_GENERAL               = SYSTEM.CAST (DWORD, VAL (LONG, -2));

(* type of soft keyboard *)
(* for Windows Tranditional Chinese Edition *)

CONST SOFTKEYBOARD_TYPE_T1            = 0001h;

(* for Windows Simplified Chinese Edition *)

CONST SOFTKEYBOARD_TYPE_C1            = 0002h;



END Windows.
