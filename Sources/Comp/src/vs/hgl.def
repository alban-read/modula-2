(* h2d_hgl3.def  Jun 2  16:14:12  1999 *)
(* Generated by H2D v1.31.0 from hgl3.h. *)
<*+ M2ADDTYPES *>
<*+ M2EXTENSIONS *>
<*+ NOHEADER *> 
<* IF NOT DEFINED(GENTYPEDEF) THEN *> <* NEW GENTYPEDEF+ *> <* END *>
<* IF BACKEND#"C" THEN *>
--  <* +gendll       *>
--  <* +usedll       *>
--  <* +dllexport    *>
--  <* NEW dllname="hgl" *>
<* END *>

(* Merged headers: hgl3.h, Windows.h, _win386.h, stddef.h, win16.h *)

DEFINITION MODULE ["C"] hgl;

IMPORT SYSTEM;


CONST
    ObjVertex   = 0;
    ObjFragment = 1;
    ObjEdge     = 2;

(*VAR Vertices: POINTER TO RECORD
                           num: LONGINT;
                         END;
  *)

TYPE
  tagRECT = RECORD
    left  : SYSTEM.int;
    top   : SYSTEM.int;
    right : SYSTEM.int;
    bottom: SYSTEM.int;
  END;

  RECT = tagRECT;

(* H2D:  Required IMPORT clause: 
IMPORT h2d_hgl3;
*)

(*  HGL 3.0 header *)
(* #define __near *)
(* #define __far *)
(* #define __pascal *)
(* #define __cdecl *)
(* #define _huge *)
(*   ***************************************************************************  *)
(*  *                                                                             *)
(*  *  WINDOWS.H -                                                                *)
(*  *                                                                               *)
(*  *   Include file for Windows 3.0 applications                                   *)
(*  *                                                                             *)
(*  *  Copyright by WATCOM International Corp. 1988-1995.  All rights reserved.   *)
(*  *                                                                             *)
(*  ***************************************************************************   *)
(*                                                                               *)
(*  *  Copyright by WATCOM International Corp. 1988-1995.  All rights reserved.  *)
(*                                                                               *)
(*    Special include for 32-bit Windows 3.x                                     *)
(*                                                                               *)
(*                                                                               *)
(* #define ___WIN386_INCLUDED__ *)
(*                                                                               *)
(*  *  stddef.h    Standard definitions                                          *)
(*  *                                                                            *)
(*  *  Copyright by WATCOM International Corp. 1988-1995.  All rights reserved.  *)
(*                                                                               *)
(*  macros for MS compatibility  *)
(*  #define _CRTAPI1 *)
(*  #define _CRTAPI2 *)
(*  #define _CRTIMP *)
(* #define _SIZE_T_DEFINED_ *)


(*  Dinamic data structures *)
(*   template <class T>                                *)
(* class DinArr                                        *)
(* {                                                   *)
(*     public:                                         *)
(*                                                     *)
(*     DinArr() { num = 0; };                          *)
(*     ~DinArr();                                      *)
(*     int Add(T x);                                   *)
(*     int Delete(int n);                              *)
(*     T* Acc(int n) { return &(tab[n>>8][n&255]); };  *)
(*                                                     *)
(*     int num;                                        *)
(*     T* tab[128];                                    *)
(* };                                                  *)
(*                                                     *)
(* struct Stack                                        *)
(* {                                                   *)
(*     int* data;                                      *)
(*     int top;                                        *)
(*                                                     *)
(*     public:                                         *)
(*                                                     *)
(*     Stack() { data = new int[4096]; top = 0; };     *)
(*     ~Stack() { delete[](data); };                   *)
(*     void Push(int i) { data[top++] = i; };          *)
(*     void Pop(int& i) { i = data[--top]; };          *)
(*     int num() { return top; };                      *)
(* };                                                  *)
(*                                                     *)
<* PUSH *> <* ENUMSIZE = "1" *>

TYPE QUALITY_ENUM = (DEFAULT_QUALITY,        (* 0 *)
                     DRAFT_QUALITY,          (* 1 *)
                     PROOF_QUALITY,          (* 2 *)
                     NONANTIALIASED_QUALITY, (* 3 *)
                     ANTIALIASED_QUALITY);   (* 4 *)

<* POP *>

     LONG   = SYSTEM.INT32;
TYPE FW_TYPE = LONG;
     BOOL8  = SYSTEM.BOOL8;
     BYTE   = SYSTEM.CARD8;
TYPE CHARSET_TYPE = BYTE;
TYPE CLIP_PRECIS_ENUM = (CLIP__0, CLIP__1, CLIP__2, CLIP__3,
                         CLIP__4, CLIP__5, CLIP__6, CLIP__7);

<* PUSH *> <* SETSIZE = "1" *>

TYPE CLIP_PRECIS_SET = SET OF CLIP_PRECIS_ENUM;

 <* POP *>
TYPE OUT_PRECIS_ENUM = (OUT_DEFAULT_PRECIS,         (* 0 *)
                        OUT_STRING_PRECIS,          (* 1 *)
                        OUT_CHARACTER_PRECIS,       (* 2 *)
                        OUT_STROKE_PRECIS,          (* 3 *)
                        OUT_TT_PRECIS,              (* 4 *)
                        OUT_DEVICE_PRECIS,          (* 5 *)
                        OUT_RASTER_PRECIS,          (* 6 *)
                        OUT_TT_ONLY_PRECIS,         (* 7 *)
                        OUT_OUTLINE_PRECIS,         (* 8 *)
                        OUT_SCREEN_OUTLINE_PRECIS); (* 9 *)
TYPE PITCH_AND_FAMILY_ENUM = (PF__0, PF__1, PF__2, PF__3, PF__4, PF__5, PF__6, PF__7);

<* PUSH *> <* SETSIZE = "1" *>

TYPE PITCH_AND_FAMILY_SET = SET OF PITCH_AND_FAMILY_ENUM;

<* POP *>

     WCHAR   = SYSTEM.CARD16;
CONST LF_FACESIZE     = 32;
TYPE LOGFONTA = RECORD
                       lfHeight          : LONG;
                       lfWidth           : LONG;
                       lfEscapement      : LONG;
                       lfOrientation     : LONG;
                       lfWeight          : FW_TYPE;
                       lfItalic          : BOOL8;
                       lfUnderline       : BOOL8;
                       lfStrikeOut       : BOOL8;
                       lfCharSet         : CHARSET_TYPE;
                       lfOutputPrecision : OUT_PRECIS_ENUM;
                       lfClipPrecision   : CLIP_PRECIS_SET;
                       lfQuality         : QUALITY_ENUM;
                       lfPitchAndFamily  : PITCH_AND_FAMILY_SET;
                       lfFaceName        : ARRAY [0..LF_FACESIZE-1] OF CHAR;
                END;
     PLOGFONTA = POINTER TO LOGFONTA;

     LOGFONTW = RECORD
                       lfHeight          : LONG;
                       lfWidth           : LONG;
                       lfEscapement      : LONG;
                       lfOrientation     : LONG;
                       lfWeight          : FW_TYPE;
                       lfItalic          : BOOL8;
                       lfUnderline       : BOOL8;
                       lfStrikeOut       : BOOL8;
                       lfCharSet         : CHARSET_TYPE;
                       lfOutputPrecision : OUT_PRECIS_ENUM;
                       lfClipPrecision   : CLIP_PRECIS_SET;
                       lfQuality         : QUALITY_ENUM;
                       lfPitchAndFamily  : PITCH_AND_FAMILY_SET;
                       lfFaceName        : ARRAY [0..LF_FACESIZE-1] OF WCHAR;
                END;
     PLOGFONTW = POINTER TO LOGFONTW;

<* IF DEFINED (UNICODE) THEN *>
      TYPE LOGFONT  = LOGFONTW;
          PLOGFONT = PLOGFONTW;
<* ELSE *>
      TYPE LOGFONT  = LOGFONTA;
          PLOGFONT = PLOGFONTA;
<* END *>

  TYPE
  LKEY = SYSTEM.unsigned;

  q = RECORD
    CASE : INTEGER OF
       0: end: LKEY;
      |1: n  : SYSTEM.int;
    END;
  END;

  ListIt = RECORD
    next: LKEY;
  END;

(*                                                                                   *)
(* class ListBox                                                                     *)
(* {                                                                                 *)
(*     unsigned int fbound; // First clear element in data array.                    *)
(*     unsigned int cur_el; // Current element in data array.                        *)
(*     int empty_sign;                                                               *)
(*     ListIt* data[256];                                                            *)
(*     unsigned int dbn;    // Number of 256-bytes data blocks used.                 *)
(*     Stack* cstack;       // Stack for current elements                            *)
(*                                                                                   *)
(*     public:                                                                       *)
(*                                                                                   *)
(*     ListBox();                                                                    *)
(*     ~ListBox();                                                                   *)
(*     int Get(LKEY key);   // Open the list with this key. Returns zero if          *)
(*                         // this list is empty.                                    *)
(*     int Next();          // Get next value in opened list. If the list is at the  *)
(*                         // end returns empty_sign.                                *)
(*     void SetEmptySign(int sign);                                                  *)
(*     int NoEnd() { return cur_el; }; // Returns non-zero value if opened list is   *)
(*                         // not at the end, otherwise returns zero.                *)
(*     LKEY NewList();      // Creates new empty list.                               *)
(*     void DestList(LKEY key); // Deletes list.                                     *)
(*     void AddFirst(LKEY key, int n); // Adds n to the beginning of list.           *)
(*     void AddLast(LKEY key, int n);  // Adds n to the end of list.                 *)
(*     int AddFirstX(LKEY key, int n); // Adds n if it was not in list and returns   *)
(*                                     // 1, otherwise returns 0.                    *)
(*     int AddLastX(LKEY key, int n);                                                *)
(*     int Delete(LKEY key, int n);                                                  *)
(*     int DeleteFirst(LKEY key);                                                    *)
(*     int Search(LKEY key, int n); // Returns how many times n present in list.     *)
(*     void Insert(LKEY key, int prev_num, int n);                                   *)
(*     void Change(LKEY key, int num, int n);                                        *)
(*     void DeleteByNum(LKEY key, int num);                                          *)
(*     int GetLast(LKEY key);                                                        *)
(*     void PushCur() { cstack->Push((int)cur_el); };                                *)
(*     void PopCur() { int x; cstack->Pop(x); cur_el = x; };                         *)
(* };                                                                                *)
(*                                                                                   *)

  SKEY = SYSTEM.unsigned;

<* IF  __GEN_C__ THEN *>

VAR 
  SB_LEN -: SYSTEM.unsigned;
<* END *>

TYPE
  DAdr = RECORD
    a_n: SYSTEM.int;
    adr: SYSTEM.unsigned;
  END;

(*                                                               *)
(* class StringBox                                               *)
(* {                                                             *)
(*     char* arr[128];  // Addresses of character arrays         *)
(*     unsigned int arr_num; // Number of arrays currently used  *)
(*     DAdr* d_adr[128];                                         *)
(*     unsigned int d_adr_num;                                   *)
(*                                                               *)
(*     unsigned int cur_arr;                                     *)
(*     unsigned int cur_adr;                                     *)
(*     SKEY ek; // empty key                                     *)
(*                                                               *)
(*     char null;                                                *)
(*                                                               *)
(*     public:                                                   *)
(*                                                               *)
(*     StringBox();                                              *)
(*     ~StringBox();                                             *)
(*     SKEY Put(const char* str);                                *)
(*     char* Get(SKEY key);                                      *)
(*     void Delete(SKEY key);                                    *)
(*     char* FindPlaceInCurrenArray(int len);                    *)
(* };                                                            *)
(*                                                               *)
(*  Basic structures *)

  Vertex = RECORD
    type : SYSTEM.int;
    x    : SYSTEM.int;
    y    : SYSTEM.int;
    w    : SYSTEM.int;
    h    : SYSTEM.int;
    fr   : SYSTEM.int;       (*  Number of fragment this vertex belongs to. *)
    tn   : SYSTEM.int;       (*  Number of this vertex in type numeration. *)
    dx   : SYSTEM.int;       (*  Anchor point of external labels text *)
    dy   : SYSTEM.int;
    flags: SYSTEM.unsigned;  (*  BIT 1 -- Used in multigraph checking. *)
    in   : LKEY;             (*  Key of list of incoming edges. *)
    out  : LKEY;             (*  Key of list of outgoing edges. *)
  END;
  PVertex= POINTER TO Vertex;

  Fragment = RECORD
    type    : SYSTEM.int;
    x       : SYSTEM.int;
    y       : SYSTEM.int;
    w       : SYSTEM.int;
    h       : SYSTEM.int;
    scroll_x: SYSTEM.int;
    scroll_y: SYSTEM.int;
    WinRect : RECT;
    scale   : SYSTEM.int;
    fr      : SYSTEM.int;       (*  Number of external fragment. *)
    tn      : SYSTEM.int;       (*  Number of this fragment in type numeration. *)
    kind    : SYSTEM.int;       (*  0 - closed, 1 - open. *)
    level   : SYSTEM.int;
    dx      : SYSTEM.int;       (*  Anchor point of labels text when open *)
    dy      : SYSTEM.int;
    ID      : LONGINT;
    flags   : SYSTEM.unsigned;  (*  Used somewhere *)
    draw    : SYSTEM.int;       (*  Used in drawing process. *)
    title   : SKEY;             (*  (In general stringbox). *)
    ptw     : SYSTEM.ADDRESS;
  END;

  Edge = RECORD
    type  : SYSTEM.int;
    from  : SYSTEM.int;
    to    : SYSTEM.int;
    tn    : SYSTEM.int;
    dx1   : SYSTEM.int;
    dy1   : SYSTEM.int;
    dx2   : SYSTEM.int;
    dy2   : SYSTEM.int;       (*  Anchor points vector coordinates. *)
    lpt   : SYSTEM.int;       (*  Label stick point parameter. *)
    ort   : SYSTEM.int;       (*  BIT 0 - orthogonalization at starting vertex *)
    (*  BIT 1 - orthogonalization at end vertex *)
    flags : SYSTEM.unsigned;  (*  Currently not used. *)
    xbends: LKEY;             (*  List of x-coordinates of trace points. *)
    ybends: LKEY;             (*  List of y-coordinates of trace points. *)
  END;
  PEdge= POINTER TO Edge;

(*                                                                                        *)
(* struct Label                                                                           *)
(* {                                                                                      *)
(*     void GetValString(int n, char* str);                                               *)
(*     void GetDefValString(char* str);                                                   *)
(*     int SetVal(int n, char* str);                                                      *)
(*     int SetDefVal(char* str);                                                          *)
(*     void SetValFromDef(int n);                                                         *)
(*                                                                                        *)
(*     int data_type; // 1 - integer, 3 - float, 4 - text;                                *)
(*     int i_defval;                                                                      *)
(*     double f_defval;                                                                   *)
(*     int par;       // BIT 0 - Left allign.                                             *)
(*     int width;                                                                         *)
(*     int prec;                                                                          *)
(*     SKEY t_defval; // In General StringBox.                                            *)
(*     SKEY name;     // In General StringBox.                                            *)
(*     DinArr<int>* i_val;                                                                *)
(*     DinArr<double>* f_val;                                                             *)
(*     StringBox* text;                                                                   *)
(* };                                                                                     *)
(*                                                                                        *)
(* struct Type                                                                            *)
(* {                                                                                      *)
(*     int AddTObject();                                                                  *)
(*     int DeleteTObject(int m);                                                          *)
(*     void AddLabel(int t);                                                              *)
(*     void DeleteLabel(int ln);                                                          *)
(*                                                                                        *)
(*     int SetVisCode(char* str, int is_x);                                               *)
(*     void GetVisCode(char* str, int is_x);                                              *)
(*     void DestVisCode(int is_x);                                                        *)
(*                                                                                        *)
(*     int object;   // 0 - vertex, 1 - fragment, 2 - edge.                               *)
(*     int shape;    // For vertices:                                                     *)
(*                 // 0 - rectangle, 1 - rounded rectangle,                               *)
(*                 // 2 - ellipse, 3 - rhombus.                                           *)
(*                 // For edges:                                                          *)
(*                 // 0 - polyline,                                                       *)
(*                 // 2 - rounded.                                                        *)
(*                                                                                        *)
(*     int b_style;  // Border style (vert.) or line style (edge):                        *)
(*                 // Border styles:                                                      *)
(*                 // 0 - solid                                                           *)
(*                 // 1 - bold                                                            *)
(*                 // 2 - extra bold                                                      *)
(*                 // 3 - dotted                                                          *)
(*                 // 4 - double solid                                                    *)
(*                 // 5 - bold & solid                                                    *)
(*                 // Only cases 0, 1, 2, 3 are available for line style                  *)
(*                                                                                        *)
(*     long b_color; // Border color (v) or line color (e) or interior color (o.f.).      *)
(*     long i_color; // Color of the interior of vertex or closed fragment.               *)
(*     int defwidth, defheight; // Only for vertices.                                     *)
(*     int def_ort; // Only for edges                                                     *)
(*                                                                                        *)
(*     int num;      // Number of objects of this type.                                   *)
(*                                                                                        *)
(*     LOGFONT lf;   // Font to print labels text of edges,                               *)
(*                 // internal l.t. of vertices, or                                       *)
(*                 // closed l.t. of fragments.                                           *)
(*     LOGFONT lfx;  // Font to print external l.t. of vertices                           *)
(*                 // or open l.t. of fragments.                                          *)
(*                                                                                        *)
(*     int lv_par;   // BIT 0 - Use back color (for edges and external vertex labels),    *)
(*                 // BIT 1 - Allign center (lf),                                         *)
(*                 // BIT 2 - Allign top left (lf),                                       *)
(*                 // BIT 3 - Skip empty lines (lf),                                      *)
(*                 // BIT 4 - Allign center (lfx),                                        *)
(*                 // BIT 5 - Allign top left (lfx),                                      *)
(*                 // BIT 6 - Skip empty lines (lfx).                                     *)
(*                 // BIT 7 - Auto adjust sizes (vert.)                                   *)
(*                 // BIT 8 - Reduce only to defaults (vert.)                             *)
(*                                                                                        *)
(*     long l_col;   // Labels text color (lf).                                           *)
(*     long l_colx;  // Labels text color (lfx).                                          *)
(*                                                                                        *)
(*     int Lab_Dist; // Distance between the vertex border and the external labels text   *)
(*                 // or distance between the open fragment border and lab. text          *)
(*                 // or distance between the stick point and the labels text             *)
(*                                                                                        *)
(*     int Arrow_wid; // width par. of arrow (for edges)                                  *)
(*     int Arrow_len;                                                                     *)
(*     int ArrSScale; // 1 if arrow sizes depend on scale, 0 - otherwise                  *)
(*     int ArrShape;  // 0 - simple, 1 - triangle, 2 - special                            *)
(*                                                                                        *)
(*     LKEY vis_cd;  // First (lf) visualization code. (In GenLists)                      *)
(*     LKEY vis_cdx; // Second (lfx) visualization code. (In GenLists)                    *)
(*                                                                                        *)
(*     // Drawing tools:                                                                  *)
(*                                                                                        *)
(*     HFONT font;   // lf                                                                *)
(*     HFONT fontx;  // lfx                                                               *)
(*     HPEN pen;     // Pen for border of vertices, lines of edges and                    *)
(*                 // top left border of fragments                                        *)
(*                 // Created according to b_style and b_color (for v. & e.)              *)
(*                 // i_color (for fr.)                                                   *)
(*     HPEN penx;    // Pen for bottom right fragment border or                           *)
(*                 // pen for drawing edge arrows (if needed) or                          *)
(*                 // pen for drawing the internal part of 'double' styled vertex border  *)
(*     HBRUSH brush; // Brush for interial of vertices and fragments                      *)
(*                 // or arrows of edge (if needed)                                       *)
(*                                                                                        *)
(*     HBRUSH brushy; // Created only for fragments (open)                                *)
(*     HPEN peny;                                                                         *)
(*     HPEN penxy;                                                                        *)
(*     //---------------                                                                  *)
(*                                                                                        *)
(*     SKEY name;    // (In general stringbox).                                           *)
(*     DinArr<Label>* Labels;                                                             *)
(*     int ToolsCreated; // 1 if drawing tools are currently created                      *)
(*                     // 0 -- otherwise                                                  *)
(*     int CurFontScale; // Current font scale (the scale last time                       *)
(*                     // passed to CreateDTools function).                               *)
(* };                                                                                     *)
(*                                                                                        *)

  PARAMINFO = RECORD
    d_type: SYSTEM.int;
    name  : SKEY;
    p     : SYSTEM.ADDRESS;
  END;

(*  Variables *)

VAR 
  GrType: SYSTEM.int;   (*  Bit 0 - (set - not oriented, reset - oriented) *)

(*  Bit 1 - graph / multigraph *)
(*  Bit 2 - alt fr / random fr *)
  GGenOpt: SYSTEM.unsigned;   (*  Bits: *)

(*  0 - 2  Hanging edges par. *)
(*  3      --- *)
(*  4      Rounded rect. roundness depend on size. *)
(*  5      --- *)
(*  6      --- *)
(*  7      --- *)
(*  8      Border width depends on scale. *)
(*  9      --- *)
(*  10     Self fragment par.: 0 -- hide, *)
(*  11     1 -- show border, 2 -- full show *)
(*  12     --- *)
(*  13     --- *)
(*  14     Allow line breaks in labels *)
  Grid_w: SYSTEM.int;
  Grid_h: SYSTEM.int;
  Grid_x: SYSTEM.int;
  Grid_y: SYSTEM.int;
  Ex: SYSTEM.int;

(*                                                                        *)
(* extern DinArr<Vertex>* Vertices;                                       *)
(* extern DinArr<Fragment>* Fragments;                                    *)
(* extern DinArr<Edge>* Edges;                                            *)
(* extern Type* type;                                                     *)
(* extern int typ_num;      // Number of types of all objects.            *)
(* extern Stack* EUStack;                                                 *)
(* extern int EUSwitch;                                                   *)
(* extern int EUNum;                                                      *)
(* extern ListBox* InEdges;  // ListBox of incoming edges for all nodes.  *)
(* extern ListBox* OutEdges;                                              *)
(* extern ListBox* GenLists; // General lists.                            *)
(* extern ListBox* GenX;     // General lists of coordinates              *)
(* extern ListBox* GenY;                                                  *)
(* extern StringBox* GenStrings;                                          *)
(* extern ListBox* XBends;  // Edges bends lists.                         *)
(* extern ListBox* YBends;                                                *)
(* extern int RRPar;    // Rounded rectangles parameter.                  *)
(* extern LOGFONT DefLogFont;                                             *)
(* extern long Next_F_ID;                                                 *)
(* extern PARAMINFO* param;                                               *)
(* extern int par_num;                                                    *)
(* extern int UseDefaultOptions;                                          *)
(*                                                                        *)
(*  Functions *)
(*  1. Add/delete vertex/edge *)

PROCEDURE GetVertex ( vertex: SYSTEM.int ): PVertex;
PROCEDURE GetEdge   ( edge: SYSTEM.int ):   PEdge;
PROCEDURE SetTypeShape   ( typenum, newShape: SYSTEM.int );
PROCEDURE SetTypeLV_PAR ( typenum, newLV_PAR: SYSTEM.int );

PROCEDURE AddVertex ( t: SYSTEM.int; fr: SYSTEM.int; x: SYSTEM.int; y: SYSTEM.int );

(*  t -- number of type *)
(*  fr -- number of fragment to which the new vertex will belong. *)

PROCEDURE DeleteVertex ( n: SYSTEM.int );

PROCEDURE AddEdge ( t: SYSTEM.int; from: SYSTEM.int; to: SYSTEM.int );

PROCEDURE DeleteEdge ( n: SYSTEM.int );

(*  2. Fragment hierarchy functions *)

PROCEDURE CreateFragment ( t: SYSTEM.int; fr: SYSTEM.int; x: SYSTEM.int;
                           y: SYSTEM.int; w: SYSTEM.int; h: SYSTEM.int );

PROCEDURE Unfold ( fr: SYSTEM.int );

PROCEDURE MoveVertexToFragment ( v: SYSTEM.int; fr: SYSTEM.int );

PROCEDURE OptimizeFrLoc ( fr: SYSTEM.int; (* = 4  *) BB_Dist: SYSTEM.int );

(*  3. Types *)

TYPE
  H2D_PtrSChar = POINTER TO CHAR;

PROCEDURE AddType ( object: SYSTEM.int; name: H2D_PtrSChar ): SYSTEM.int;

(*  Parameters: *)
(*  object -- the kind of objects of the new type (vertex, fragment, edge) *)
(*  name -- name of the new type *)
(*  Returns: *)
(*  0        -- type with this name is already exist *)
(*  type_num -- succes *)

PROCEDURE DeleteType ( tn: SYSTEM.int; (* = 0  *) par: SYSTEM.int ): SYSTEM.int;

(*  Parameters: *)
(*  tn -- number of type to delete *)
(*  if par != 0 then this type will be deleted even if it is the last *)
(*  vertex (fragment, edge) type *)
(*  Returns: *)
(*  0 -- succes *)
(*  1 -- this is the last node type *)
(*  2 -- last fragment type *)
(*  3 -- last edge type *)
(*  4 -- objects of this type are present in the graph *)

PROCEDURE RenameType ( tn: SYSTEM.int; name: H2D_PtrSChar ): SYSTEM.int;

(*  Returns: *)
(*  1 -- there is another type with this name *)
(*  0 -- succes *)
(*  4. Start/End *)

PROCEDURE BeginWork ( SEQ arg0: SYSTEM.BYTE );

PROCEDURE CreateNewGraph ( t: SYSTEM.int );

(*  Parameters: *)
(*  t -- number of fragment type for the main fragment of the new graph *)

PROCEDURE DestroyGraph ( SEQ arg0: SYSTEM.BYTE );

PROCEDURE EndWork ( SEQ arg0: SYSTEM.BYTE );

(*  5. In/Out *)

PROCEDURE LoadGraph ( filename: H2D_PtrSChar ): SYSTEM.int;

PROCEDURE SaveGraph ( filename: H2D_PtrSChar ): SYSTEM.int;

(*  6. Labels *)

PROCEDURE AddLabel_Ex ( t: SYSTEM.int; d: SYSTEM.int ): SYSTEM.int;

(*  Parameters: *)
(*  t -- type to which the label will be added *)
(*  d -- data type of this label (1 - int, 3 - float, 4 - string) *)
(*  Returns: *)
(*  Number of added label *)

PROCEDURE DeleteLabel ( t: SYSTEM.int; ln: SYSTEM.int );

(*  Parameters: *)
(*  t -- type which label will be removed *)
(*  ln -- number of label which will be removed *)

PROCEDURE SetVisCode_Ex ( t: SYSTEM.int; str: H2D_PtrSChar;
                       is_x: SYSTEM.int ): SYSTEM.int;

(*  Parameters: *)
(*  t -- number of type *)
(*  str -- string with vis. code *)
(*  is_x -- not zero to set extended vis code *)
(*  Returns: *)
(*  0 -- succes *)
(*  1 -- wrong vis. code *)

PROCEDURE GetVisCode ( t: SYSTEM.int; str: H2D_PtrSChar; is_x: SYSTEM.int );

(*  Parameters: *)
(*  t -- number of type *)
(*  str -- string to receive the vis. code *)
(*  is_x -- not zero to get extended vis code *)

PROCEDURE GetLabVal ( obj: SYSTEM.int; n: SYSTEM.int; ln: SYSTEM.int;
                      str: H2D_PtrSChar ): SYSTEM.int;

(*  Parameters: *)
(*  obj -- kind of object which label is to be retreived  *)
(*  n -- number of object *)
(*  ln -- number of label to retrieve *)
(*  str -- string to receive the label value  *)
(*  Returns: *)
(*  0 -- success *)
(*  1 -- there is no label with this number *)

PROCEDURE GetLabDefVal ( t: SYSTEM.int; ln: SYSTEM.int;
                         str: H2D_PtrSChar ): SYSTEM.int;

(*  Parameters: *)
(*  t -- number of type *)
(*  ln -- number of label *)
(*  str -- string to receive the default label value *)
(*  Returns: *)
(*  0 -- success *)
(*  1 -- there is no label with this number *)

PROCEDURE SetLabVal ( obj: SYSTEM.int; n: SYSTEM.int; ln: SYSTEM.int;
                      str: H2D_PtrSChar ): SYSTEM.int;

(*  Parameters: *)
(*  obj -- kind of object which label is to be set  *)
(*  n -- number of object *)
(*  ln -- number of label to set *)
(*  str -- string with the label value *)
(*  Returns: *)
(*  0 -- success *)
(*  1 -- there is no label with this number *)

PROCEDURE SetLabDefVal ( t: SYSTEM.int; ln: SYSTEM.int;
                         str: H2D_PtrSChar ): SYSTEM.int;

(*  Parameters: *)
(*  t -- number of type *)
(*  ln -- number of label *)
(*  str -- string with the default label value *)
(*  Returns:                        *)
(*  0 -- success *)
(*  1 -- there is no label with this number *)

PROCEDURE ResetLabVal ( obj: SYSTEM.int; n: SYSTEM.int; ln: SYSTEM.int ): SYSTEM.int;

(*  Parameters: *)
(*  obj -- kind of object which label is to be reset (set to default) *)
(*  n -- number of object *)
(*  ln -- number of label to reset *)
(*  Returns: *)
(*  0 -- success *)
(*  1 -- there is no label with this number *)
(* int SetLabVal(int obj, int n, int ln, int val); *)
(*  Parameters: *)
(*  obj -- kind of object which label is to be set  *)
(*  n -- number of object *)
(*  ln -- number of label to set *)
(*  val -- value of label  *)
(*  Returns: *)
(*  0 -- success *)
(*  1 -- there is no label with this number *)
(* int SetLabVal(int obj, int n, int ln, double val); *)
(* int GetLabVal(int obj, int n, int ln, int& val); *)
(*  Parameters: *)
(*  obj -- kind of object which label is to be retreived  *)
(*  n -- number of object *)
(*  ln -- number of label to retrieve *)
(*  val -- label value *)
(*  Returns: *)
(*  0 -- success *)
(*  1 -- there is no label with this number *)
(*  2 -- label datatype not compatible with integer *)
(* int GetLabVal(int obj, int n, int ln, double& val); *)
(* int SetLabDefVal(int t, int ln, int val); *)
(*  Parameters: *)
(*  t -- number of type *)
(*  ln -- number of label *)
(*  val -- default label value *)
(*  Returns: *)
(*  0 -- success *)
(*  1 -- there is no label with this number *)
(* int SetLabDefVal(int t, int ln, double val); *)
(* int GetLabDefVal(int t, int ln, int& val); *)
(*  Parameters: *)
(*  t -- number of type *)
(*  ln -- number of label *)
(*  val -- default label value *)
(*  0 -- success *)
(*  1 -- there is no label with this number *)
(*  2 -- label datatype is not compatible with integer *)
(* int GetLabDefVal(int t, int ln, double& val); *)
(*  7. Bends *)

PROCEDURE DeleteAllBends ( n: SYSTEM.int );

(*  Parameters: *)
(*  n -- number of edge which bends must be removed *)

PROCEDURE AddBendFirst ( n: SYSTEM.int; x: SYSTEM.int; y: SYSTEM.int );

(*  Parameters: *)
(*  n -- number of edge to which the new bend must be added *)
(*  x -- x-coordinate of the bend point *)
(*  y -- y-coordinate of the bend point *)

PROCEDURE AddBendLast ( n: SYSTEM.int; x: SYSTEM.int; y: SYSTEM.int );

(*  Parameters: *)
(*  n -- number of edge to which the new bend must be added *)
(*  x -- x-coordinate of the bend point *)
(*  y -- y-coordinate of the bend point *)

PROCEDURE InsertBend ( n: SYSTEM.int; bn: SYSTEM.int; x: SYSTEM.int; y: SYSTEM.int );

(*  Parameters: *)
(*  n -- number of edge to which the new bend must be inserted *)
(*  bn -- number of bend after which the new one will be placed *)
(*        (anchor point at the starting vertex is considered to be *)
(*         the bend number zero) *)
(*  x -- x-coordinate of the bend point *)
(*  y -- y-coordinate of the bend point *)

PROCEDURE DeleteBend ( n: SYSTEM.int; bn: SYSTEM.int );

(*  Parameters: *)
(*  n -- number of edge *)
(*  bn -- number of bend to delete (numeration starts from 1) *)

PROCEDURE DeleteFirstBend ( n: SYSTEM.int );

(*  Parameters: *)
(*  n -- number of edge *)
(*  8. Access functions *)

PROCEDURE GetOutEdges ( n: SYSTEM.int );

(*  Parameters: *)
(*  n -- number of vertex which outgoing edges must be accessed *)

TYPE
  H2D_PtrSInt = POINTER TO SYSTEM.int;

PROCEDURE NextOutEdge ( e: H2D_PtrSInt ): SYSTEM.int;

(*  Parameters: *)
(*  e -- number of the next edge *)
(*  Returns: *)
(*  0 -- no more edges (e is invalid) *)
(*  1 -- other case *)

PROCEDURE GetInEdges ( n: SYSTEM.int );

(*  Parameters: *)
(*  n -- number of vertex which incoming edges must be accessed *)

PROCEDURE NextInEdge ( e: H2D_PtrSInt ): SYSTEM.int;

(*  Parameters: *)
(*  e -- number of the next edge *)
(*  Returns: *)
(*  0 -- no more edges (e is invalid) *)
(*  1 -- other case *)
(*  For undirected graphs *)

PROCEDURE GetEdges ( n: SYSTEM.int );

PROCEDURE NextEdge ( e: H2D_PtrSInt ): SYSTEM.int;

(*  Push/Pop functions for recursive use of edge lists *)

PROCEDURE PushOutEdge ( SEQ arg0: SYSTEM.BYTE );

PROCEDURE PushInEdge ( SEQ arg0: SYSTEM.BYTE );

PROCEDURE PushEdge ( SEQ arg0: SYSTEM.BYTE );

PROCEDURE PopOutEdge ( SEQ arg0: SYSTEM.BYTE );

PROCEDURE PopInEdge ( SEQ arg0: SYSTEM.BYTE );

PROCEDURE PopEdge ( SEQ arg0: SYSTEM.BYTE );

PROCEDURE GetBends ( n: SYSTEM.int );

(*  Parameters: *)
(*  n -- number of edge which bends must be accessed *)

PROCEDURE NextBend ( x: H2D_PtrSInt; y: H2D_PtrSInt ): SYSTEM.int;

(*  Parameters: *)
(*  x -- x-coordinate of the bend point  *)
(*  y -- y-coordinate of the bend point *)
(*  Returns: *)
(*  0 -- no more bends (x and y are invalid) *)
(*  1 -- other case *)
(*  9. Other functions *)

PROCEDURE SetFrTitle ( fr: SYSTEM.int; str: H2D_PtrSChar );

(*  Parameters: *)
(*  fr -- number of fragment which title must be changed *)
(*  str -- string with the new title *)

PROCEDURE GetFrTitle ( fr: SYSTEM.int ): H2D_PtrSChar;

PROCEDURE SetLabelName ( t: SYSTEM.int; ln: SYSTEM.int; str: H2D_PtrSChar );

(*  Parameters: *)
(*  t -- number of type which label must be renamed *)
(*  ln -- number of label that must be renamed *)
(*  str -- string with the new name *)

PROCEDURE GetLabelName ( t: SYSTEM.int; ln: SYSTEM.int ): H2D_PtrSChar;

PROCEDURE SetTypeName ( t: SYSTEM.int; str: H2D_PtrSChar ): SYSTEM.int;

(*  Parameters: *)
(*  t -- number of type that must be renamed *)
(*  str -- string with the new name *)
(*  Returns: *)
(*  0 -- succes *)
(*  1 -- type with the given name is already exist *)

PROCEDURE GetTypeName ( t: SYSTEM.int ): H2D_PtrSChar;

PROCEDURE GetLabelNumber ( t: SYSTEM.int; str: H2D_PtrSChar ): SYSTEM.int;

(*  Parameters: *)
(*  t -- number of type which label number must be retrieved *)
(*  str -- string with the label name *)
(*  Returns: *)
(*  -1 -- there is no label with given name *)
(*  number of label that has the specified name *)

PROCEDURE ChangeVertexType ( n: SYSTEM.int; new_type: SYSTEM.int );

(*  Parameters: *)
(*  n - number of vertex *)
(*  new_type - new type of this object *)

PROCEDURE ChangeFragmentType ( n: SYSTEM.int; new_type: SYSTEM.int );

PROCEDURE ChangeEdgeType ( n: SYSTEM.int; new_type: SYSTEM.int );

PROCEDURE SimplifyGraph ( SEQ arg0: SYSTEM.BYTE );

(*  Removes all but one vertex types from the graph and *)
(*  makes all vertices belong to one type (number 0). *)
(*  Performs the same thing with fragments (type number 1) *)
(*  and edges (type number 2). *)
(*  Type parameters have initial values. *)
(*  Doesn't change coordinates and sizes as well as edge bends.   *)

PROCEDURE UnfoldAll ( SEQ arg0: SYSTEM.BYTE );

PROCEDURE RemoveAllBends ( (* = 0 *) par: SYSTEM.int );

(*  Parameters: *)
(*  par - if not zero, bends from loop edges are not removed  *)

PROCEDURE RenumV ( v1: SYSTEM.int; v2: SYSTEM.int );

PROCEDURE RenumF ( f1: SYSTEM.int; f2: SYSTEM.int );

PROCEDURE RenumE ( e1: SYSTEM.int; e2: SYSTEM.int );

PROCEDURE NormalizeGraph ( (* = 1 *) red: SYSTEM.int );

(*  Reduces sizes of fragments if red *)
(*  10. Connection functions *)

PROCEDURE RegisterParameter ( name: H2D_PtrSChar; p: H2D_PtrSInt );

(* void RegisterParameter(char* name, double* p); *)
(* void RegisterParameter(char* name, char* p); *)

PROCEDURE StartAlg ( lpCmdLine: H2D_PtrSChar ): SYSTEM.int;

(*  Returns: *)
(*  0 - success *)
(*  1 - users break *)
(*  2 - wrong number of parameters *)
(*  3 - wrong parameter *)
(*  4 - can't open first sample *)
(*  5 - can't load first sample *)

PROCEDURE EndStep ( SEQ arg0: SYSTEM.BYTE ): SYSTEM.int;

(*  Returns 1 if system wants e.p. to close immediately *)
(*  otherwise returns 0 *)

PROCEDURE EndAlg ( SEQ arg0: SYSTEM.BYTE );

PROCEDURE SendMesLog ( mes: H2D_PtrSChar );

PROCEDURE AskUserYN ( mes: H2D_PtrSChar ): SYSTEM.int;

PROCEDURE AskUserOC ( mes: H2D_PtrSChar ): SYSTEM.int;

PROCEDURE MesUser ( mes: H2D_PtrSChar; (* = 0 *) mes_type: SYSTEM.int );

(*  mes_type : *)
(*  0 - information *)
(*  1 - warning *)
(*  2 - error *)

PROCEDURE AskUser ( mes: H2D_PtrSChar; i: H2D_PtrSInt );

(* void AskUser(const char* mes, double& f); *)
(* void AskUser(const char* mes, char* buf, int len /*= 256*/); *)

PROCEDURE AskVertexNumber ( mes: H2D_PtrSChar ): SYSTEM.int;

PROCEDURE AskFragmentNumber ( mes: H2D_PtrSChar ): SYSTEM.int;

PROCEDURE AskEdgeNumber ( mes: H2D_PtrSChar ): SYSTEM.int;

(*  11. Drawing interface functions *)

PROCEDURE StartDrawMethod ( lpCmdLine: H2D_PtrSChar ): SYSTEM.int;

PROCEDURE EndDrawMethod ( (* = 1 *) is_success: SYSTEM.int ): SYSTEM.int;

PROCEDURE SetDrawCountPC ( pc: SYSTEM.int );

(*  12. String functions *)

PROCEDURE StrEq ( s1: H2D_PtrSChar; s2: H2D_PtrSChar ): SYSTEM.int;

PROCEDURE StrCopy ( sfr: H2D_PtrSChar; sto: H2D_PtrSChar );

PROCEDURE StrLen ( str: H2D_PtrSChar ): SYSTEM.int;

PROCEDURE StrConcat ( beg: H2D_PtrSChar; end: H2D_PtrSChar );

(* -------------------- *)

<* IF  __GEN_C__ THEN *>

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE vertex ( n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE fragment ( n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE edge ( n: ARRAY OF SYSTEM.BYTE );

(* H2D: this procedure corresponds to a macro. *)
PROCEDURE label ( n: ARRAY OF SYSTEM.BYTE );
<* END *>

END hgl.
